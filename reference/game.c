void _init(void)

{
    call_gmon_start();
    frame_dummy();
    __do_global_ctors_aux();
    return;
}



void FUN_0804a82c(void)

{
    (*(code *)(undefined *)0x0)();
    return;
}



// std::filebuf::~filebuf()

void __thiscall std::filebuf::~filebuf(filebuf *this)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// std::istream::peek()

void std::istream::peek(void)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pthread_cond_wait(pthread_cond_t *__cond,pthread_mutex_t *__mutex)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pthread_detach(pthread_t __th)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pthread_attr_init(pthread_attr_t *__attr)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int sigfillset(sigset_t *__set)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int usleep(__useconds_t __useconds)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



void __divdi3(void)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



void __cxa_allocate_exception(void)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int rename(char *__old,char *__new)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int sigaction(int __sig,sigaction *__act,sigaction *__oact)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strchr(char *__s,int __c)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// std::istream::get()

void std::istream::get(void)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int ungetc(int __c,FILE *__stream)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



void __cxa_pure_virtual(void)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// std::filebuf::filebuf()

void __thiscall std::filebuf::filebuf(filebuf *this)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__pid_t getpid(void)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// std::string::_Rep::_M_dispose(std::allocator<char> const&)

void std::string::_Rep::_M_dispose(allocator *param_1)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pthread_attr_setstacksize(pthread_attr_t *__attr,size_t __stacksize)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// std::ios_base::~ios_base()

void __thiscall std::ios_base::~ios_base(ios_base *this)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int isprint(int param_1)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// std::ostream::TEMPNAMEPLACEHOLDERVALUE(long)

void __thiscall std::ostream::operator<<(ostream *this,long param_1)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t write(int __fd,void *__buf,size_t __n)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int poll(pollfd *__fds,nfds_t __nfds,int __timeout)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

tm * localtime(time_t *__timer)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int strcmp(char *__s1,char *__s2)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int close(int __fd)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// std::istream::~istream()

void __thiscall std::istream::~istream(istream *this)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fprintf(FILE *__stream,char *__format,...)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__pid_t fork(void)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * getenv(char *__name)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__mode_t umask(__mode_t __mask)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pthread_create(pthread_t *__newthread,pthread_attr_t *__attr,__start_routine *__start_routine,
                  void *__arg)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int unlink(char *__name)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int sigblock(int __mask)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// std::terminate()

void std::terminate(void)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int vsnprintf(char *__s,size_t __maxlen,char *__format,__gnuc_va_list __arg)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strerror(int __errnum)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pthread_cancel(pthread_t __th)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



void __cxa_call_unexpected(void)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// std::ios::clear(std::_Ios_Iostate)

void std::ios::clear(void)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



void __cxa_atexit(void)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// operator delete(void*)

void operator_delete(void *param_1)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int * __errno_location(void)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long ftell(FILE *__stream)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int accept(int __fd,sockaddr *__addr,socklen_t *__addr_len)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pthread_attr_setstack(pthread_attr_t *__attr,void *__stackaddr,size_t __stacksize)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * inet_ntoa(in_addr __in)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// std::ios_base::ios_base()

void __thiscall std::ios_base::ios_base(ios_base *this)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int puts(char *__s)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int listen(int __fd,int __n)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// std::istream::TEMPNAMEPLACEHOLDERVALUE(int&)

void __thiscall std::istream::operator>>(istream *this,int *param_1)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * malloc(size_t __size)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int sched_yield(void)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__pid_t setsid(void)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pthread_mutex_init(pthread_mutex_t *__mutex,pthread_mutexattr_t *__mutexattr)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t strftime(char *__s,size_t __maxsize,char *__format,tm *__tp)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pthread_mutex_destroy(pthread_mutex_t *__mutex)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pipe(int *__pipedes)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memmove(void *__dest,void *__src,size_t __n)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int setitimer(__itimer_which_t __which,itimerval *__new,itimerval *__old)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// std::ostream::~ostream()

void __thiscall std::ostream::~ostream(ostream *this)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



void __cxa_rethrow(void)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// std::__basic_file<char>::~__basic_file()

void __thiscall std::__basic_file<char>::~__basic_file(__basic_file<char> *this)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int shmget(key_t __key,size_t __size,int __shmflg)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void abort(void)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



void __cxa_throw(void)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// std::filebuf::open(char const*, std::_Ios_Openmode)

int std::filebuf::open(char *__file,int __oflag,...)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int __xstat(int __ver,char *__filename,stat *__stat_buf)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int setsockopt(int __fd,int __level,int __optname,void *__optval,socklen_t __optlen)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long sysconf(int __name)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int execv(char *__path,char **__argv)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int getpeername(int __fd,sockaddr *__addr,socklen_t *__len)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fseek(FILE *__stream,long __off,int __whence)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__pid_t waitpid(__pid_t __pid,int *__stat_loc,int __options)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t time(time_t *__timer)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int __sigpause(int __sig_or_mask,int __is_sig)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pthread_mutex_lock(pthread_mutex_t *__mutex)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int execlp(char *__file,char *__arg,...)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// std::streambuf::~streambuf()

void __thiscall std::streambuf::~streambuf(streambuf *this)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int chdir(char *__path)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// std::locale::~locale()

void __thiscall std::locale::~locale(locale *this)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// std::filebuf::close()

int std::filebuf::close(int __fd)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strstr(char *__haystack,char *__needle)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t strlen(char *__s)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

uint sleep(uint __seconds)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



void __cxa_end_catch(void)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



void __strtol_internal(void)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int rand_r(uint *__seed)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// std::__throw_logic_error(char const*)

void std::__throw_logic_error(char *param_1)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pthread_cond_signal(pthread_cond_t *__cond)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// std::ios::~ios()

void __thiscall std::ios::~ios(ios *this)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// std::bad_alloc::~bad_alloc()

void __thiscall std::bad_alloc::~bad_alloc(bad_alloc *this)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int sigprocmask(int __how,sigset_t *__set,sigset_t *__oset)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

in_addr_t inet_addr(char *__cp)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



void __gxx_personality_v0(void)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pthread_cond_init(pthread_cond_t *__cond,pthread_condattr_t *__cond_attr)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int shmdt(void *__shmaddr)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// std::string::_Rep::_S_create(unsigned int, std::allocator<char> const&)

void std::string::_Rep::_S_create(uint param_1,allocator *param_2)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int putc(int __c,FILE *__stream)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



void __libc_start_main(void)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// std::string::reserve(unsigned int)

void std::string::reserve(uint param_1)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// std::istream::istream(std::streambuf*)

void __thiscall std::istream::istream(istream *this,streambuf *param_1)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int dup2(int __fd,int __fd2)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strcat(char *__dest,char *__src)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pthread_attr_destroy(pthread_attr_t *__attr)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int printf(char *__format,...)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int bind(int __fd,sockaddr *__addr,socklen_t __len)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fcntl(int __fd,int __cmd,...)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memcpy(void *__dest,void *__src,size_t __n)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// std::__throw_length_error(char const*)

void std::__throw_length_error(char *param_1)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fclose(FILE *__stream)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * ctime(time_t *__timer)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int gethostbyname_r(char *__name,hostent *__result_buf,char *__buf,size_t __buflen,
                   hostent **__result,int *__h_errnop)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int shmctl(int __shmid,int __cmd,shmid_ds *__buf)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// std::ostream::TEMPNAMEPLACEHOLDERVALUE(unsigned long)

void __thiscall std::ostream::operator<<(ostream *this,ulong param_1)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int closedir(DIR *__dirp)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void srand(uint __seed)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

DIR * opendir(char *__name)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int snprintf(char *__s,size_t __maxlen,char *__format,...)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int sigemptyset(sigset_t *__set)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// std::stringbuf::stringbuf(std::string const&, std::_Ios_Openmode)

void __thiscall std::stringbuf::stringbuf(void)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pthread_join(pthread_t __th,void **__thread_return)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void pthread_exit(void *__retval)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void exit(int __status)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int sscanf(char *__s,char *__format,...)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void free(void *__ptr)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



void __cxa_begin_catch(void)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memset(void *__s,int __c,size_t __n)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int connect(int __fd,sockaddr *__addr,socklen_t __len)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pthread_cond_destroy(pthread_cond_t *__cond)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strncpy(char *__dest,char *__src,size_t __n)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// std::__default_alloc_template<true, 0>::deallocate(void*, unsigned int)

void std::__default_alloc_template<true,0>::deallocate(void *param_1,uint param_2)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * fopen(char *__filename,char *__modes)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int sigwait(sigset_t *__set,int *__sig)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



void _Unwind_Resume(void)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// std::istream::get(char*, int, char)

void std::istream::get(char *param_1,int param_2,char param_3)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pthread_mutex_unlock(pthread_mutex_t *__mutex)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// operator new[](unsigned int)

void * operator_new__(uint param_1)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int kill(__pid_t __pid,int __sig)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int getc(FILE *__stream)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// operator delete[](void*)

void operator_delete__(void *param_1)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int sprintf(char *__s,char *__format,...)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// std::ios::init(std::streambuf*)

int std::ios::init(EVP_PKEY_CTX *ctx)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// std::ostream::ostream(std::streambuf*)

void __thiscall std::ostream::ostream(ostream *this,streambuf *param_1)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int socket(int __domain,int __type,int __protocol)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

dirent * readdir(DIR *__dirp)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// std::string::_M_mutate(unsigned int, unsigned int, unsigned int)

void std::string::_M_mutate(uint param_1,uint param_2,uint param_3)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int rand(void)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t read(int __fd,void *__buf,size_t __nbytes)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// operator new(unsigned int)

void * operator_new(uint param_1)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

uint alarm(uint __seconds)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * shmat(int __shmid,void *__shmaddr,int __shmflg)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strcpy(char *__dest,char *__src)

{
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



void processEntry _start(undefined4 param_1,undefined4 param_2)

{
    undefined1 auStack_4 [4];
    
    __libc_start_main(main,param_2,&stack0x00000004,__libc_csu_init,__libc_csu_fini,param_1,
                      auStack_4);
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
}



void call_gmon_start(void)

{
    __gmon_start__();
    return;
}



void __do_global_dtors_aux(void)

{
    code *pcVar1;
    
    if (completed_1 == '\0') {
        completed_1 = 0;
        pcVar1 = *(code **)p_0;
        while (pcVar1 != (code *)0x0) {
            p_0 = p_0 + 4;
            (*pcVar1)();
            pcVar1 = *(code **)p_0;
        }
        completed_1 = '\x01';
    }
    return;
}



// WARNING: Removing unreachable block (ram,0x0804b29c)

void frame_dummy(void)

{
    return;
}



void __static_initialization_and_destruction_0(int __initialize_p,int __priority)

{
    if ((__priority == 0xffff) && (__initialize_p == 1)) {
        NONE.ObjectID = 0;
    }
    return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__I_BeADaemon(void)

{
    __static_initialization_and_destruction_0(1,0xffff);
    return;
}

void SetPrintFunction(TPrintFunction *Function)

{
    PrintFunction = Function;
    return;
}



void SetErrorFunction(TErrorFunction *Function)

{
    ErrorFunction = Function;
    return;
}



void SilentHandler(int param_1,char *param_2)

{
    return;
}



void SilentHandler(char *param_1)

{
    return;
}



void LogfileHandler(int param_1,char *Text)

{
    FILE *__stream;
    int iVar1;
    FILE *f;
    
    if (StandardLogfile[0] != '\0') {
        __stream = fopen(StandardLogfile,"at");
        if (__stream != (FILE *)0x0) {
            fprintf(__stream,"%s",Text);
            iVar1 = fclose(__stream);
            if (iVar1 != 0) {
                __errno_location();
                error(&DAT_080eeb60);
                return;
            }
        }
    }
    return;
}



void LogfileHandler(char *Text)

{
    FILE *__stream;
    int iVar1;
    int *piVar2;
    FILE *f;
    
    if (StandardLogfile[0] != '\0') {
        __stream = fopen(StandardLogfile,"at");
        if (__stream != (FILE *)0x0) {
            fprintf(__stream,"%s",Text);
            iVar1 = fclose(__stream);
            if (iVar1 != 0) {
                piVar2 = __errno_location();
                error(&DAT_080eeb60,*piVar2);
            }
        }
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void print(void)

{
    int in_stack_00000004;
    char *in_stack_00000008;
    char local_40c [4];
    char s [1024];
    
    vsnprintf(local_40c,0x400,in_stack_00000008,&stack0x0000000c);
    if (PrintFunction == (TPrintFunction *)0x0) {
        printf("%s",local_40c);
    }
    else {
        (*PrintFunction)(in_stack_00000004,local_40c);
    }
    return;
}

int val(char c)

{
    int iVar1;
    
    if ((byte)(c - 0x30U) < 10) {
        iVar1 = c + -0x30;
    }
    else if ((byte)(c + 0xbfU) < 6) {
        iVar1 = c + -0x37;
    }
    else if ((byte)(c + 0x9fU) < 6) {
        iVar1 = c + -0x57;
    }
    else {
        iVar1 = 0;
    }
    return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long random(void)

{
    int iVar1;
    int iVar2;
    int range;
    int in_stack_00000004;
    int in_stack_00000008;
    
    iVar1 = (in_stack_00000008 - in_stack_00000004) + 1;
    if (0 < iVar1) {
        iVar2 = rand();
        in_stack_00000004 = iVar2 % iVar1 + in_stack_00000004;
    }
    return in_stack_00000004;
}



bool FileExists(char *FileName)

{
    int *piVar1;
    int iVar2;
    bool bVar3;
    undefined1 local_6c [4];
    stat Buffer;
    
    piVar1 = __errno_location();
    *piVar1 = 0;
    iVar2 = __xstat(3,FileName,(stat *)local_6c);
    bVar3 = true;
    if (iVar2 != 0) {
        if (*piVar1 != 2) {
            error("FileExists: Unerwarteter Fehlercode %d.\n",*piVar1);
        }
        bVar3 = false;
    }
    return bVar3;
}



void TreatAllFiles(char *Directory,char *Extension,TFileHandlerFunction *Function)

{
    uint *__dest;
    dirent *DirectoryEntry;
    DIR *__dirp;
    dirent *pdVar1;
    char *pcVar2;
    size_t sVar3;
    int iVar4;
    uint uVar5;
    uint uVar6;
    uint *puVar7;
    uint *puVar8;
    DIR *WorkingDirectory;
    bool bVar9;
    char local_105c [4];
    char Name [64];
    char FileName [4096];
    
    __dirp = opendir(Directory);
    if (__dirp != (DIR *)0x0) {
        while (pdVar1 = readdir(__dirp), pdVar1 != (dirent *)0x0) {
            __dest = (uint *)(Name + 0x3c);
            strcpy((char *)__dest,pdVar1->d_name);
            puVar8 = __dest;
            do {
                puVar7 = puVar8;
                uVar5 = *puVar7 + 0xfefefeff & ~*puVar7;
                uVar6 = uVar5 & 0x80808080;
                puVar8 = puVar7 + 1;
            } while (uVar6 == 0);
            bVar9 = (uVar5 & 0x8080) == 0;
            if (bVar9) {
                uVar6 = uVar6 >> 0x10;
            }
            if (bVar9) {
                puVar8 = (uint *)((int)puVar7 + 6);
            }
            pcVar2 = (char *)strlen(Extension);
            puVar7 = __dest;
            if (pcVar2 < (char *)((int)puVar8 +
                                 ((-3 - (uint)CARRY1((byte)uVar6,(byte)uVar6)) - (int)__dest))) {
                do {
                    puVar8 = puVar7;
                    uVar5 = *puVar8 + 0xfefefeff & ~*puVar8;
                    uVar6 = uVar5 & 0x80808080;
                    puVar7 = puVar8 + 1;
                } while (uVar6 == 0);
                bVar9 = (uVar5 & 0x8080) == 0;
                if (bVar9) {
                    uVar6 = uVar6 >> 0x10;
                }
                puVar7 = (uint *)((int)puVar8 + 6);
                if (!bVar9) {
                    puVar7 = puVar8 + 1;
                }
                sVar3 = strlen(Extension);
                iVar4 = strcmp((char *)((int)puVar7 +
                                       ((-3 - (uint)CARRY1((byte)uVar6,(byte)uVar6)) - sVar3)),
                               Extension);
                if (iVar4 == 0) {
                    local_105c[0] = '\0';
                    local_105c[1] = '\0';
                    local_105c[2] = '\0';
                    local_105c[3] = '\0';
                    Name[0] = '\0';
                    Name[1] = '\0';
                    Name[2] = '\0';
                    Name[3] = '\0';
                    Name[4] = '\0';
                    Name[5] = '\0';
                    Name[6] = '\0';
                    Name[7] = '\0';
                    Name[0xc] = '\0';
                    Name[0xd] = '\0';
                    Name[0xe] = '\0';
                    Name[0xf] = '\0';
                    Name[0x10] = '\0';
                    Name[0x11] = '\0';
                    Name[0x12] = '\0';
                    Name[0x13] = '\0';
                    Name[0x14] = '\0';
                    Name[0x15] = '\0';
                    Name[0x16] = '\0';
                    Name[0x17] = '\0';
                    Name[0x18] = '\0';
                    Name[0x19] = '\0';
                    Name[0x1a] = '\0';
                    Name[0x1b] = '\0';
                    Name[0x1c] = '\0';
                    Name[0x1d] = '\0';
                    Name[0x1e] = '\0';
                    Name[0x1f] = '\0';
                    Name[8] = '\0';
                    Name[9] = '\0';
                    Name[10] = '\0';
                    Name[0xb] = '\0';
                    Name[0x20] = '\0';
                    Name[0x21] = '\0';
                    Name[0x22] = '\0';
                    Name[0x23] = '\0';
                    Name[0x24] = '\0';
                    Name[0x25] = '\0';
                    Name[0x26] = '\0';
                    Name[0x27] = '\0';
                    Name[0x28] = '\0';
                    Name[0x29] = '\0';
                    Name[0x2a] = '\0';
                    Name[0x2b] = '\0';
                    Name[0x30] = '\0';
                    Name[0x31] = '\0';
                    Name[0x32] = '\0';
                    Name[0x33] = '\0';
                    Name[0x34] = '\0';
                    Name[0x35] = '\0';
                    Name[0x36] = '\0';
                    Name[0x37] = '\0';
                    Name[0x2c] = '\0';
                    Name[0x2d] = '\0';
                    Name[0x2e] = '\0';
                    Name[0x2f] = '\0';
                    Name[0x38] = '\0';
                    Name[0x39] = '\0';
                    Name[0x3a] = '\0';
                    Name[0x3b] = '\0';
                    puVar8 = __dest;
                    do {
                        puVar7 = puVar8;
                        uVar5 = *puVar7 + 0xfefefeff & ~*puVar7;
                        uVar6 = uVar5 & 0x80808080;
                        puVar8 = puVar7 + 1;
                    } while (uVar6 == 0);
                    bVar9 = (uVar5 & 0x8080) == 0;
                    if (bVar9) {
                        uVar6 = uVar6 >> 0x10;
                    }
                    if (bVar9) {
                        puVar8 = (uint *)((int)puVar7 + 6);
                    }
                    sVar3 = strlen(Extension);
                    strncpy(local_105c,(char *)__dest,
                            (size_t)((int)puVar8 +
                                    (((-3 - (uint)CARRY1((byte)uVar6,(byte)uVar6)) - (int)__dest) -
                                    sVar3)));
                    (*Function)(Directory,local_105c,Extension);
                }
            }
        }
        closedir(__dirp);
    }
    return;
}



void SendMail(char *Address,char *Subject,char *Text)

{
    uint *puVar1;
    int iVar2;
    size_t sVar3;
    int iVar4;
    __pid_t _Var5;
    int *piVar6;
    uint *puVar7;
    uint *puVar8;
    uint uVar9;
    uint uVar10;
    char_0_ *Content;
    bool bVar11;
    int iStack_b0;
    uint auStack_94 [4];
    undefined4 local_84;
    int inode [2];
    stat StatBuffer;
    
    iStack_b0 = 0x804e4b9;
    sVar3 = strlen(Text);
    iVar2 = -(sVar3 + 0x7df & 0xfffffff0);
    *(undefined1 *)((int)auStack_94 + iVar2) = 0;
    puVar1 = (uint *)((int)auStack_94 + iVar2);
    puVar8 = puVar1;
    do {
        puVar7 = puVar8;
        uVar9 = *puVar7 + 0xfefefeff & ~*puVar7;
        uVar10 = uVar9 & 0x80808080;
        puVar8 = puVar7 + 1;
    } while (uVar10 == 0);
    bVar11 = (uVar9 & 0x8080) == 0;
    if (bVar11) {
        uVar10 = uVar10 >> 0x10;
    }
    if (bVar11) {
        puVar8 = (uint *)((int)puVar7 + 6);
    }
    *(char **)(&stack0xffffff58 + iVar2) = "From: %s\n";
    *(uint *)((int)auStack_94 + iVar2 + -0x18) =
         (int)puVar8 + (-3 - (uint)CARRY1((byte)uVar10,(byte)uVar10));
    *(char **)(&stack0xffffff5c + iVar2) = SendMail::sender;
    *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e519;
    sprintf(*(char **)((int)auStack_94 + iVar2 + -0x18),*(char **)(&stack0xffffff58 + iVar2));
    puVar8 = puVar1;
    do {
        puVar7 = puVar8;
        uVar9 = *puVar7 + 0xfefefeff & ~*puVar7;
        uVar10 = uVar9 & 0x80808080;
        puVar8 = puVar7 + 1;
    } while (uVar10 == 0);
    bVar11 = (uVar9 & 0x8080) == 0;
    if (bVar11) {
        uVar10 = uVar10 >> 0x10;
    }
    if (bVar11) {
        puVar8 = (uint *)((int)puVar7 + 6);
    }
    *(char **)(&stack0xffffff58 + iVar2) = "To: %s\n";
    *(uint *)((int)auStack_94 + iVar2 + -0x18) =
         (int)puVar8 + (-3 - (uint)CARRY1((byte)uVar10,(byte)uVar10));
    *(char **)(&stack0xffffff5c + iVar2) = Address;
    *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e567;
    sprintf(*(char **)((int)auStack_94 + iVar2 + -0x18),*(char **)(&stack0xffffff58 + iVar2));
    puVar8 = puVar1;
    do {
        puVar7 = puVar8;
        uVar9 = *puVar7 + 0xfefefeff & ~*puVar7;
        uVar10 = uVar9 & 0x80808080;
        puVar8 = puVar7 + 1;
    } while (uVar10 == 0);
    bVar11 = (uVar9 & 0x8080) == 0;
    if (bVar11) {
        uVar10 = uVar10 >> 0x10;
    }
    if (bVar11) {
        puVar8 = (uint *)((int)puVar7 + 6);
    }
    *(char **)(&stack0xffffff58 + iVar2) = "Subject: %s\n";
    *(uint *)((int)auStack_94 + iVar2 + -0x18) =
         (int)puVar8 + (-3 - (uint)CARRY1((byte)uVar10,(byte)uVar10));
    *(char **)(&stack0xffffff5c + iVar2) = Subject;
    *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e5b7;
    sprintf(*(char **)((int)auStack_94 + iVar2 + -0x18),*(char **)(&stack0xffffff58 + iVar2));
    puVar8 = puVar1;
    do {
        puVar7 = puVar8;
        uVar9 = *puVar7 + 0xfefefeff & ~*puVar7;
        uVar10 = uVar9 & 0x80808080;
        puVar8 = puVar7 + 1;
    } while (uVar10 == 0);
    bVar11 = (uVar9 & 0x8080) == 0;
    if (bVar11) {
        uVar10 = uVar10 >> 0x10;
    }
    if (bVar11) {
        puVar8 = (uint *)((int)puVar7 + 6);
    }
    *(char **)(&stack0xffffff58 + iVar2) = "Reply-To: %s\n";
    *(uint *)((int)auStack_94 + iVar2 + -0x18) =
         (int)puVar8 + (-3 - (uint)CARRY1((byte)uVar10,(byte)uVar10));
    *(char **)(&stack0xffffff5c + iVar2) = SendMail::replyto;
    *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e609;
    sprintf(*(char **)((int)auStack_94 + iVar2 + -0x18),*(char **)(&stack0xffffff58 + iVar2));
    puVar8 = puVar1;
    do {
        puVar7 = puVar8;
        uVar9 = *puVar7 + 0xfefefeff & ~*puVar7;
        uVar10 = uVar9 & 0x80808080;
        puVar8 = puVar7 + 1;
    } while (uVar10 == 0);
    bVar11 = (uVar9 & 0x8080) == 0;
    if (bVar11) {
        uVar10 = uVar10 >> 0x10;
    }
    if (bVar11) {
        puVar8 = (uint *)((int)puVar7 + 6);
    }
    *(char **)(&stack0xffffff58 + iVar2) = "X-Mailer: %s\n";
    *(uint *)((int)auStack_94 + iVar2 + -0x18) =
         (int)puVar8 + (-3 - (uint)CARRY1((byte)uVar10,(byte)uVar10));
    *(char **)(&stack0xffffff5c + iVar2) = SendMail::xmailer;
    *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e659;
    sprintf(*(char **)((int)auStack_94 + iVar2 + -0x18),*(char **)(&stack0xffffff58 + iVar2));
    puVar8 = puVar1;
    do {
        puVar7 = puVar8;
        uVar9 = *puVar7 + 0xfefefeff & ~*puVar7;
        uVar10 = uVar9 & 0x80808080;
        puVar8 = puVar7 + 1;
    } while (uVar10 == 0);
    *(char **)(&stack0xffffff58 + iVar2) = "Content-Type: text/plain; charset=\"iso-8859-1\"\n";
    bVar11 = (uVar9 & 0x8080) == 0;
    if (bVar11) {
        uVar10 = uVar10 >> 0x10;
    }
    if (bVar11) {
        puVar8 = (uint *)((int)puVar7 + 6);
    }
    *(uint *)((int)auStack_94 + iVar2 + -0x18) =
         (int)puVar8 + (-3 - (uint)CARRY1((byte)uVar10,(byte)uVar10));
    *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e6a0;
    sprintf(*(char **)((int)auStack_94 + iVar2 + -0x18),*(char **)(&stack0xffffff58 + iVar2));
    puVar8 = puVar1;
    do {
        puVar7 = puVar8;
        uVar9 = *puVar7 + 0xfefefeff & ~*puVar7;
        uVar10 = uVar9 & 0x80808080;
        puVar8 = puVar7 + 1;
    } while (uVar10 == 0);
    *(char **)(&stack0xffffff58 + iVar2) = "\n";
    bVar11 = (uVar9 & 0x8080) == 0;
    if (bVar11) {
        uVar10 = uVar10 >> 0x10;
    }
    if (bVar11) {
        puVar8 = (uint *)((int)puVar7 + 6);
    }
    *(uint *)((int)auStack_94 + iVar2 + -0x18) =
         (int)puVar8 + (-3 - (uint)CARRY1((byte)uVar10,(byte)uVar10));
    *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e6f0;
    sprintf(*(char **)((int)auStack_94 + iVar2 + -0x18),*(char **)(&stack0xffffff58 + iVar2));
    puVar8 = puVar1;
    do {
        puVar7 = puVar8;
        uVar9 = *puVar7 + 0xfefefeff & ~*puVar7;
        uVar10 = uVar9 & 0x80808080;
        puVar8 = puVar7 + 1;
    } while (uVar10 == 0);
    *(char **)(&stack0xffffff5c + iVar2) = Text;
    *(char **)(&stack0xffffff58 + iVar2) = "%s\n";
    bVar11 = (uVar9 & 0x8080) == 0;
    if (bVar11) {
        uVar10 = uVar10 >> 0x10;
    }
    if (bVar11) {
        puVar8 = (uint *)((int)puVar7 + 6);
    }
    *(uint *)((int)auStack_94 + iVar2 + -0x18) =
         (int)puVar8 + (-3 - (uint)CARRY1((byte)uVar10,(byte)uVar10));
    *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e744;
    sprintf(*(char **)((int)auStack_94 + iVar2 + -0x18),*(char **)(&stack0xffffff58 + iVar2));
    *(undefined4 *)((int)auStack_94 + iVar2 + -0x18) = 3;
    *(int **)(&stack0xffffff5c + iVar2) = inode + 1;
    *(char **)(&stack0xffffff58 + iVar2) = SendMail::mailer;
    *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e761;
    iVar4 = __xstat(*(int *)((int)auStack_94 + iVar2 + -0x18),*(char **)(&stack0xffffff58 + iVar2),
                    *(stat **)(&stack0xffffff5c + iVar2));
    if (iVar4 == 0) {
        *(undefined4 **)((int)auStack_94 + iVar2 + -0x18) = &local_84;
        *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e78f;
        iVar4 = pipe(*(int **)((int)auStack_94 + iVar2 + -0x18));
        if (iVar4 == 0) {
            *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e7a6;
            _Var5 = fork();
            if (-1 < _Var5) {
                puVar8 = puVar1;
                if (_Var5 == 0) {
                    *(undefined4 *)(&stack0xffffff58 + iVar2) = 0;
                    *(undefined4 *)((int)auStack_94 + iVar2 + -0x18) = local_84;
                    *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e86a;
                    dup2(*(int *)((int)auStack_94 + iVar2 + -0x18),
                         *(int *)(&stack0xffffff58 + iVar2));
                    *(undefined4 *)((int)auStack_94 + iVar2 + -0x18) = local_84;
                    *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e875;
                    iVar4 = close(*(int *)((int)auStack_94 + iVar2 + -0x18));
                    if (iVar4 < 0) {
                        *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e8e8;
                        piVar6 = __errno_location();
                        iVar4 = *piVar6;
                        *(undefined **)((int)auStack_94 + iVar2 + -0x18) = &DAT_080eefa0;
                        *(int *)(&stack0xffffff58 + iVar2) = iVar4;
                        *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e8fa;
                        error(*(char **)((int)auStack_94 + iVar2 + -0x18));
                    }
                    *(int *)((int)auStack_94 + iVar2 + -0x18) = inode[0];
                    *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e884;
                    iVar4 = close(*(int *)((int)auStack_94 + iVar2 + -0x18));
                    if (iVar4 < 0) {
                        *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e8cf;
                        piVar6 = __errno_location();
                        iVar4 = *piVar6;
                        *(undefined **)((int)auStack_94 + iVar2 + -0x18) = &DAT_080eef60;
                        *(int *)(&stack0xffffff58 + iVar2) = iVar4;
                        *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e8e1;
                        error(*(char **)((int)auStack_94 + iVar2 + -0x18));
                    }
                    *(undefined4 *)(&stack0xffffff68 + iVar2) = 0;
                    *(char **)(&stack0xffffff64 + iVar2) = Address;
                    *(undefined **)(&stack0xffffff5c + iVar2) = &DAT_080eeb56;
                    *(char **)(&stack0xffffff60 + iVar2) = SendMail::envelope;
                    *(char **)(&stack0xffffff58 + iVar2) = SendMail::mailer;
                    *(char **)((int)auStack_94 + iVar2 + -0x18) = SendMail::mailer;
                    *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e8be;
                    execlp(*(char **)((int)auStack_94 + iVar2 + -0x18),
                           *(char **)(&stack0xffffff58 + iVar2));
                    *(undefined4 *)((int)auStack_94 + iVar2 + -0x18) = 0;
                    // WARNING: Subroutine does not return
                    *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e8ca;
                    exit(*(int *)((int)auStack_94 + iVar2 + -0x18));
                }
                do {
                    puVar7 = puVar8;
                    uVar9 = *puVar7 + 0xfefefeff & ~*puVar7;
                    uVar10 = uVar9 & 0x80808080;
                    puVar8 = puVar7 + 1;
                } while (uVar10 == 0);
                *(uint **)(&stack0xffffff58 + iVar2) = puVar1;
                bVar11 = (uVar9 & 0x8080) == 0;
                if (bVar11) {
                    uVar10 = uVar10 >> 0x10;
                }
                if (bVar11) {
                    puVar8 = (uint *)((int)puVar7 + 6);
                }
                *(uint *)(&stack0xffffff5c + iVar2) =
                     (int)puVar8 + ((-3 - (uint)CARRY1((byte)uVar10,(byte)uVar10)) - (int)puVar1);
                *(int *)((int)auStack_94 + iVar2 + -0x18) = inode[0];
                *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e805;
                write(*(int *)((int)auStack_94 + iVar2 + -0x18),*(void **)(&stack0xffffff58 + iVar2)
                      ,*(size_t *)(&stack0xffffff5c + iVar2));
                *(undefined4 *)((int)auStack_94 + iVar2 + -0x18) = local_84;
                *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e810;
                iVar4 = close(*(int *)((int)auStack_94 + iVar2 + -0x18));
                if (iVar4 < 0) {
                    *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e843;
                    piVar6 = __errno_location();
                    iVar4 = *piVar6;
                    *(undefined **)((int)auStack_94 + iVar2 + -0x18) = &DAT_080eef20;
                    *(int *)(&stack0xffffff58 + iVar2) = iVar4;
                    *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e855;
                    error(*(char **)((int)auStack_94 + iVar2 + -0x18));
                }
                *(int *)((int)auStack_94 + iVar2 + -0x18) = inode[0];
                *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e81f;
                iVar4 = close(*(int *)((int)auStack_94 + iVar2 + -0x18));
                if (-1 < iVar4) {
                    return;
                }
                *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e82c;
                piVar6 = __errno_location();
                iVar4 = *piVar6;
                *(undefined **)((int)auStack_94 + iVar2 + -0x18) = &DAT_080eeee0;
                *(int *)(&stack0xffffff58 + iVar2) = iVar4;
                goto LAB_0804e775;
            }
            *(undefined **)((int)auStack_94 + iVar2 + -0x18) = &DAT_080eefe0;
        }
        else {
            *(char **)((int)auStack_94 + iVar2 + -0x18) = "SendMail: Kann Pipe nicht anlegen.\n";
        }
        *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e79f;
        error(*(char **)((int)auStack_94 + iVar2 + -0x18));
    }
    else {
        *(undefined **)((int)auStack_94 + iVar2 + -0x18) = &DAT_080eee60;
        *(char **)(&stack0xffffff58 + iVar2) = SendMail::mailer;
LAB_0804e775:
        *(undefined4 *)((int)&iStack_b0 + iVar2) = 0x804e77a;
        error(*(char **)((int)auStack_94 + iVar2 + -0x18));
    }
    return;
}



// WARNING: Variable defined which should be unmapped: status
// WARNING: Unknown calling convention -- yet parameter storage is locked

void RemoveZombie(void)

{
    int local_8;
    int status;
    
    waitpid(-1,&local_8,3);
    return;
}



ulong PackAbsoluteCoordinate(int x,int y,int z)

{
    return (x + -0x6000) * 0x40000 + (y + -0x6000) * 0x10 + z;
}



ulong PackRelativeCoordinate(int dx,int dy,int dz)

{
    return (dx + 0x2000) * 0x40000 + (dy + 0x2000) * 0x10 + dz + 8;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void UnpackAbsoluteCoordinate(void)

{
    uint in_stack_00000004;
    int *in_stack_00000008;
    int *in_stack_0000000c;
    uint *in_stack_00000010;
    
    *in_stack_00000008 = (in_stack_00000004 >> 0x12) + 0x6000;
    *in_stack_0000000c = (in_stack_00000004 >> 4 & 0x3fff) + 0x6000;
    *in_stack_00000010 = in_stack_00000004 & 0xf;
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void UnpackRelativeCoordinate(void)

{
    uint in_stack_00000004;
    int *in_stack_00000008;
    int *in_stack_0000000c;
    int *in_stack_00000010;
    
    *in_stack_00000008 = (in_stack_00000004 >> 0x12) - 0x2000;
    *in_stack_0000000c = (in_stack_00000004 >> 4 & 0x3fff) - 0x2000;
    *in_stack_00000010 = (in_stack_00000004 & 0xf) - 8;
    return;
}

void __static_initialization_and_destruction_0(int __initialize_p,int __priority)

{
    if ((__priority == 0xffff) && (__initialize_p == 1)) {
        StaticStringTable.firstNode = (listnode<> *)0x0;
        StaticStringTable.lastNode = (listnode<> *)0x0;
        __cxa_atexit(__tcf_0,0,&__dso_handle);
        DynamicStringTable.firstNode = (listnode<> *)0x0;
        DynamicStringTable.lastNode = (listnode<> *)0x0;
        __cxa_atexit(__tcf_1,0,&__dso_handle);
    }
    return;
}

void __tcf_0(void *param_1)

{
    listnode<> *plVar1;
    listnode<> *plVar2;
    listnode<> *plVar3;
    
    if (StaticStringTable.firstNode != (listnode<> *)0x0) {
        do {
            plVar2 = StaticStringTable.firstNode;
            if (StaticStringTable.firstNode == (listnode<> *)0x0) {
                error("list::remove: node ist NULL.\n");
            }
            else {
                plVar3 = (StaticStringTable.firstNode)->prev;
                if (plVar3 == (listnode<> *)0x0) {
                    plVar3 = (StaticStringTable.firstNode)->prev;
                    StaticStringTable.firstNode = (StaticStringTable.firstNode)->next;
                }
                else {
                    plVar3->next = (StaticStringTable.firstNode)->next;
                }
                plVar1 = plVar2->next;
                if (plVar1 != (listnode<> *)0x0) {
                    plVar1->prev = plVar3;
                    plVar3 = StaticStringTable.lastNode;
                }
                StaticStringTable.lastNode = plVar3;
                operator_delete(plVar2);
            }
        } while (StaticStringTable.firstNode != (listnode<> *)0x0);
    }
    return;
}



void __tcf_1(void *param_1)

{
    listnode<> *plVar1;
    listnode<> *plVar2;
    listnode<> *plVar3;
    
    if (DynamicStringTable.firstNode != (listnode<> *)0x0) {
        do {
            plVar2 = DynamicStringTable.firstNode;
            if (DynamicStringTable.firstNode == (listnode<> *)0x0) {
                error("list::remove: node ist NULL.\n");
            }
            else {
                plVar3 = (DynamicStringTable.firstNode)->prev;
                if (plVar3 == (listnode<> *)0x0) {
                    plVar3 = (DynamicStringTable.firstNode)->prev;
                    DynamicStringTable.firstNode = (DynamicStringTable.firstNode)->next;
                }
                else {
                    plVar3->next = (DynamicStringTable.firstNode)->next;
                }
                plVar1 = plVar2->next;
                if (plVar1 != (listnode<> *)0x0) {
                    plVar1->prev = plVar3;
                    plVar3 = DynamicStringTable.lastNode;
                }
                DynamicStringTable.lastNode = plVar3;
                operator_delete(plVar2);
            }
        } while (DynamicStringTable.firstNode != (listnode<> *)0x0);
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__I_StaticStringTable(void)

{
    __static_initialization_and_destruction_0(1,0xffff);
    return;
}

void __static_initialization_and_destruction_0(int __initialize_p,int __priority)

{
    bool bVar1;
    
    if ((__priority == 0xffff) && (__initialize_p == 1)) {
        ObjectTypes.initialized = false;
        ObjectTypes.max = 5000;
        ObjectTypes.space = 0x1389;
        ObjectTypes.min = 0;
        ObjectTypes.start = 0;
        ObjectTypes.block = 1000;
        ObjectTypes.entry = (TObjectType *)operator_new__(0x19f1f4);
        __cxa_atexit(__tcf_0,0,&__dso_handle);
        bVar1 = false;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[0].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[1].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[2].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[3].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[4].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        SpecialObjects[5].TypeID = 0;
        bVar1 = false;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[6].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[7].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        SpecialObjects[8].TypeID = 0;
        bVar1 = false;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[9].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        SpecialObjects[10].TypeID = 0;
        bVar1 = false;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[0xb].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        SpecialObjects[0xc].TypeID = 0;
        bVar1 = false;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[0xd].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[0xe].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[0xf].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        SpecialObjects[0x10].TypeID = 0;
        bVar1 = false;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[0x11].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        SpecialObjects[0x12].TypeID = 0;
        bVar1 = false;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[0x13].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        SpecialObjects[0x14].TypeID = 0;
        bVar1 = false;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[0x15].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[0x16].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[0x17].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        SpecialObjects[0x18].TypeID = 0;
        bVar1 = false;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[0x19].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        SpecialObjects[0x1a].TypeID = 0;
        bVar1 = false;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[0x1b].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        SpecialObjects[0x1c].TypeID = 0;
        bVar1 = false;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[0x1d].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[0x1e].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[0x1f].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        SpecialObjects[0x20].TypeID = 0;
        bVar1 = false;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[0x21].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        SpecialObjects[0x22].TypeID = 0;
        bVar1 = false;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[0x23].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        SpecialObjects[0x24].TypeID = 0;
        bVar1 = false;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[0x25].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[0x26].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[0x27].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        SpecialObjects[0x28].TypeID = 0;
        bVar1 = false;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[0x29].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        SpecialObjects[0x2a].TypeID = 0;
        bVar1 = false;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[0x2b].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        SpecialObjects[0x2c].TypeID = 0;
        bVar1 = false;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[0x2d].TypeID = 0;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        SpecialObjects[0x2e].TypeID = 0;
        bVar1 = false;
        if ((ObjectTypes.min < 1) && ((uint)ObjectTypes.max < 0x80000000)) {
            bVar1 = true;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        bVar1 = false;
        SpecialObjects[0x2f].TypeID = 0;
        if ((ObjectTypes.min < 1) && (bVar1 = true, ObjectTypes.max < 0)) {
            bVar1 = false;
        }
        if (!bVar1) {
            error(&DAT_080f0a80,0);
        }
        SpecialObjects[0x30].TypeID = 0;
    }
    return;
}

void __tcf_0(void *param_1)

{
    if (ObjectTypes.entry == (TObjectType *)0x0) {
        return;
    }
    operator_delete__(ObjectTypes.entry);
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__I_FlagNames(void)

{
    __static_initialization_and_destruction_0(1,0xffff);
    return;
}


void __static_initialization_and_destruction_0(int __initialize_p,int __priority)

{
    if ((__priority == 0xffff) && (__initialize_p == 1)) {
        NONE.ObjectID = 0;
        Semaphore::Semaphore(&LogfileMutex,1);
        __cxa_atexit(__tcf_0,0,&__dso_handle);
    }
    return;
}

void __tcf_0(void *param_1)

{
    int in_stack_00000008;
    
    Semaphore::~Semaphore(&LogfileMutex,in_stack_00000008);
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__I_IsGameServer(void)

{
    __static_initialization_and_destruction_0(1,0xffff);
    return;
}



void __static_initialization_and_destruction_0(int __initialize_p,int __priority)

{
    TCronEntry *pTVar1;
    int iVar2;
    
    if (__priority == 0xffff) {
        if (__initialize_p == 1) {
            NONE.ObjectID = 0;
            CronEntry.initialized = false;
            CronEntry.init.Obj.ObjectID = 0;
            CronEntry.min = 0;
            CronEntry.max = 0x100;
            CronEntry.start = 0;
            CronEntry.space = 0x101;
            CronEntry.block = 0x100;
            CronEntry.entry = (TCronEntry *)operator_new__(0x1010);
            iVar2 = 0x100;
            pTVar1 = CronEntry.entry;
            do {
                (pTVar1->Obj).ObjectID = 0;
                iVar2 = iVar2 + -1;
                pTVar1 = pTVar1 + 1;
            } while (iVar2 != -1);
            __cxa_atexit(__tcf_0,0,&__dso_handle);
        }
        if (__initialize_p == 1) {
            DepotInfo.initialized = false;
            DepotInfo.max = 4;
            DepotInfo.space = 5;
            DepotInfo.min = 0;
            DepotInfo.start = 0;
            DepotInfo.block = 5;
            DepotInfo.entry = (TDepotInfo *)operator_new__(0x78);
            __cxa_atexit(__tcf_1,0,&__dso_handle);
            Mark.initialized = false;
            Mark.space = 5;
            Mark.min = 0;
            Mark.max = 4;
            Mark.start = 0;
            Mark.block = 5;
            Mark.entry = (TMark *)operator_new__(0xa0);
            __cxa_atexit(__tcf_2,0,&__dso_handle);
            TDynamicWriteBuffer::TDynamicWriteBuffer(&HelpBuffer,0x10000);
            __cxa_atexit(__tcf_3,0,&__dso_handle);
        }
    }
    return;
}

void __tcf_0(void *param_1)

{
    if (CronEntry.entry == (TCronEntry *)0x0) {
        return;
    }
    operator_delete__(CronEntry.entry);
    return;
}



void __tcf_1(void *param_1)

{
    if (DepotInfo.entry == (TDepotInfo *)0x0) {
        return;
    }
    operator_delete__(DepotInfo.entry);
    return;
}



void __tcf_2(void *param_1)

{
    if (Mark.entry == (TMark *)0x0) {
        return;
    }
    operator_delete__(Mark.entry);
    return;
}



void __tcf_3(void *param_1)

{
    int in_stack_00000008;
    
    TDynamicWriteBuffer::~TDynamicWriteBuffer(&HelpBuffer,in_stack_00000008);
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__I_InstanceAttributeNames(void)

{
    __static_initialization_and_destruction_0(1,0xffff);
    return;
}

void __static_initialization_and_destruction_0(int __initialize_p,int __priority)

{
    THelpDepot *pTVar1;
    undefined4 *puVar2;
    int iVar3;
    int local_20;
    THouse *local_1c;
    
    if (__priority == 0xffff) {
        if (__initialize_p == 1) {
            NONE.ObjectID = 0;
            HouseArea.initialized = false;
            HouseArea.max = 99;
            HouseArea.min = 0;
            HouseArea.start = 0;
            HouseArea.space = 100;
            HouseArea.block = 0x32;
            HouseArea.entry = (THouseArea *)operator_new__(0x4b0);
            __cxa_atexit(__tcf_0,0,&__dso_handle);
            vector<>::vector(&House.init.Subowner,0,4,5);
                    // try { // try from 08060b2c to 08060b30 has its CatchHandler @ 08060c98
            vector<>::vector(&House.init.Guest,0,9,10);
            House.initialized = false;
            House.min = 0;
            House.max = 99;
            House.space = 100;
            House.start = 0;
            House.block = 100;
                    // try { // try from 08060b78 to 08060b7c has its CatchHandler @ 08060d52
            puVar2 = (undefined4 *)operator_new__(0x141e4);
            *puVar2 = 100;
            local_20 = 99;
            local_1c = (THouse *)(puVar2 + 1);
            do {
                    // try { // try from 08060bb7 to 08060bbb has its CatchHandler @ 08060d4a
                vector<>::vector(&local_1c->Subowner,0,4,5);
                    // try { // try from 08060bdf to 08060be3 has its CatchHandler @ 08060cb7
                vector<>::vector(&local_1c->Guest,0,9,10);
                local_20 = local_20 + -1;
                local_1c = local_1c + 1;
            } while (local_20 != -1);
            House.entry = (THouse *)(puVar2 + 1);
            __cxa_atexit(__tcf_1,0,&__dso_handle);
        }
        if (__initialize_p == 1) {
            HelpDepot.initialized = false;
            HelpDepot.start = 1;
            HelpDepot.init.Box.ObjectID = 0;
            HelpDepot.max = 10;
            HelpDepot.min = 1;
            HelpDepot.space = 10;
            HelpDepot.block = 10;
            HelpDepot.entry = (THelpDepot *)operator_new__(0x78);
            iVar3 = 9;
            pTVar1 = HelpDepot.entry;
            do {
                (pTVar1->Box).ObjectID = 0;
                iVar3 = iVar3 + -1;
                pTVar1 = pTVar1 + 1;
            } while (iVar3 != -1);
            __cxa_atexit(__tcf_2,0,&__dso_handle);
        }
    }
    return;
}



THouseArea * GetHouseArea(ushort ID)

{
    THouseArea *pTVar1;
    int i;
    int i_00;
    
    i_00 = 0;
    if (0 < HouseAreas) {
        do {
            pTVar1 = vector<THouseArea>::operator()(&HouseArea,i_00);
            if (pTVar1->ID == ID) {
                pTVar1 = vector<THouseArea>::operator()(&HouseArea,i_00);
                return pTVar1;
            }
            i_00 = i_00 + 1;
        } while (i_00 < HouseAreas);
    }
    error("GetHouseArea: Gebiet mit ID %d nicht gefunden.\n",(uint)ID);
    return (THouseArea *)0x0;
}



int CheckAccessRight(char *Rule,TPlayer *pl)

{
    char cVar1;
    bool bVar2;
    char *pcVar3;
    bool local_ec;
    bool PositiveRule;
    char local_dc [4];
    char Pattern [200];
    
    if (Rule == (char *)0x0) {
        pcVar3 = "CheckAccessRight: Regel ist NULL.\n";
    }
    else {
        if (pl != (TPlayer *)0x0) {
            cVar1 = *Rule;
            if (cVar1 == '!') {
                Rule = Rule + 1;
            }
            local_ec = cVar1 != '!';
            pcVar3 = strchr(Rule,0x40);
            if (pcVar3 == (char *)0x0) {
                pcVar3 = (pl->super_TCreature).Name;
            }
            else {
                if (pl->Guild[0] == '\0') {
                    return 0;
                }
                if (pl->Rank[0] == '\0') {
                    snprintf(local_dc,200,"@%s",pl->Guild);
                }
                else {
                    snprintf(local_dc,200,"%s@%s",pl->Rank,pl->Guild);
                }
                pcVar3 = local_dc;
            }
            bVar2 = MatchString(Rule,pcVar3);
            if (!bVar2) {
                return 0;
            }
            return (uint)local_ec * 2 + -1;
        }
        pcVar3 = "CheckAccessRight: pl ist NULL.\n";
    }
    error(pcVar3);
    return 0;
}



// WARNING: Variable defined which should be unmapped: low

THouse * GetHouse(ushort ID)

{
    THouse *pTVar1;
    int iVar2;
    int test;
    int i;
    int high;
    int iVar3;
    int local_14;
    int low;
    
    local_14 = 0;
    iVar3 = Houses + -1;
    if (-1 < iVar3) {
        do {
            i = (local_14 + iVar3) / 2;
            pTVar1 = vector<THouse>::operator()(&House,i);
            if (pTVar1->ID == ID) {
                pTVar1 = vector<THouse>::operator()(&House,i);
                return pTVar1;
            }
            pTVar1 = vector<THouse>::operator()(&House,i);
            iVar2 = i + 1;
            if (ID <= pTVar1->ID) {
                iVar2 = local_14;
            }
            pTVar1 = vector<THouse>::operator()(&House,i);
            if (ID < pTVar1->ID) {
                iVar3 = i + -1;
            }
            local_14 = iVar2;
        } while (iVar2 <= iVar3);
    }
    error("GetHouse: Haus mit ID %d nicht gefunden.\n",(uint)ID);
    return (THouse *)0x0;
}



bool IsOwner(ushort HouseID,TPlayer *pl)

{
    THouse *pTVar1;
    THouse *house;
    
    pTVar1 = GetHouse(HouseID);
    if (pTVar1 == (THouse *)0x0) {
        error("IsOwner: Haus mit ID %d existiert nicht.\n",(uint)HouseID);
    }
    else {
        if (pl != (TPlayer *)0x0) {
            return pTVar1->OwnerID == (pl->super_TCreature).ID;
        }
        error("IsOwner: pl ist NULL.\n");
    }
    return false;
}



bool IsSubowner(ushort HouseID,TPlayer *pl,int TimeStamp)

{
    THouse *pTVar1;
    THouseGuest *Rule;
    int iVar2;
    THouse *house;
    int i;
    
    pTVar1 = GetHouse(HouseID);
    if (pTVar1 == (THouse *)0x0) {
        error("IsSubowner: Haus mit ID %d existiert nicht.\n",(uint)HouseID);
    }
    else if (pl == (TPlayer *)0x0) {
        error("IsSubowner: pl ist NULL.\n");
    }
    else if ((pTVar1->LastTransition <= TimeStamp) && (i = 0, 0 < pTVar1->Subowners)) {
        do {
            Rule = vector<>::operator()(&pTVar1->Subowner,i);
            iVar2 = CheckAccessRight(Rule->Name,pl);
            if (iVar2 == -1) {
                return false;
            }
            if (iVar2 == 1) {
                return true;
            }
            i = i + 1;
        } while (i < pTVar1->Subowners);
    }
    return false;
}



bool IsGuest(ushort HouseID,TPlayer *pl,int TimeStamp)

{
    THouse *pTVar1;
    THouseGuest *Rule;
    int iVar2;
    THouse *house;
    int i;
    
    pTVar1 = GetHouse(HouseID);
    if (pTVar1 == (THouse *)0x0) {
        error("IsGuest: Haus mit ID %d existiert nicht.\n",(uint)HouseID);
    }
    else if (pl == (TPlayer *)0x0) {
        error("IsGuest: pl ist NULL.\n");
    }
    else if ((pTVar1->LastTransition <= TimeStamp) && (i = 0, 0 < pTVar1->Guests)) {
        do {
            Rule = vector<>::operator()(&pTVar1->Guest,i);
            iVar2 = CheckAccessRight(Rule->Name,pl);
            if (iVar2 == -1) {
                return false;
            }
            if (iVar2 == 1) {
                return true;
            }
            i = i + 1;
        } while (i < pTVar1->Guests);
    }
    return false;
}



bool IsInvited(ushort HouseID,TPlayer *pl,int TimeStamp)

{
    bool bVar1;
    THouse *pTVar2;
    THouse *house;
    bool bVar3;
    
    if (pl == (TPlayer *)0x0) {
        error("IsInvited: pl ist NULL.\n");
        bVar1 = false;
    }
    else {
        bVar1 = false;
        pTVar2 = GetHouse(HouseID);
        if (pTVar2 == (THouse *)0x0) {
            error("IsOwner: Haus mit ID %d existiert nicht.\n",(uint)HouseID);
            bVar3 = false;
        }
        else {
            bVar3 = pTVar2->OwnerID == (pl->super_TCreature).ID;
        }
        if (((bVar3) || (bVar3 = IsSubowner(HouseID,pl,TimeStamp), bVar3)) ||
           (bVar3 = IsGuest(HouseID,pl,TimeStamp), bVar3)) {
            bVar1 = true;
        }
    }
    return bVar1;
}



char * GetHouseName(ushort HouseID)

{
    THouse *house;
    THouse *pTVar1;
    char *pcVar2;
    
    pTVar1 = GetHouse(HouseID);
    if (pTVar1 == (THouse *)0x0) {
        error("GetHouseName: Haus mit ID %d existiert nicht.\n",(uint)HouseID);
        pcVar2 = (char *)0x0;
    }
    else {
        pcVar2 = pTVar1->Name;
    }
    return pcVar2;
}



char * GetHouseOwner(ushort HouseID)

{
    THouse *house;
    THouse *pTVar1;
    char *pcVar2;
    
    pTVar1 = GetHouse(HouseID);
    if (pTVar1 == (THouse *)0x0) {
        error("GetHouseOwner: Haus mit ID %d existiert nicht.\n",(uint)HouseID);
        pcVar2 = (char *)0x0;
    }
    else {
        pcVar2 = pTVar1->OwnerName;
    }
    return pcVar2;
}



void ShowSubownerList(ushort HouseID,TPlayer *pl,char *Buffer)

{
    THouse *pTVar1;
    THouse *pTVar2;
    THouseGuest *__src;
    undefined4 *puVar3;
    THouse *house_1;
    int i;
    THouse *house;
    bool bVar4;
    char *Text;
    
                    // try { // try from 08061299 to 080613e6 has its CatchHandler @ 080613f0
    pTVar1 = GetHouse(HouseID);
    if (pTVar1 == (THouse *)0x0) {
        error("ShowSubownerList: Haus mit ID %d existiert nicht.\n",(uint)HouseID);
    }
    else {
        if (pl == (TPlayer *)0x0) {
            Text = "ShowSubownerList: pl ist NULL.\n";
        }
        else {
            if (Buffer != (char *)0x0) {
                pTVar2 = GetHouse(HouseID);
                if (pTVar2 == (THouse *)0x0) {
                    error("IsOwner: Haus mit ID %d existiert nicht.\n",(uint)HouseID);
                    bVar4 = false;
                }
                else {
                    bVar4 = pTVar2->OwnerID == (pl->super_TCreature).ID;
                }
                if (bVar4) {
                    print();
                    i = 0;
                    sprintf(Buffer,"# Subowners of %s\n",pTVar1->Name);
                    if (0 < pTVar1->Subowners) {
                        do {
                            __src = vector<>::operator()(&pTVar1->Subowner,i);
                            i = i + 1;
                            strcat(Buffer,__src->Name);
                            strcat(Buffer,"\n");
                        } while (i < pTVar1->Subowners);
                    }
                    return;
                }
                puVar3 = (undefined4 *)__cxa_allocate_exception(4);
                *puVar3 = 1;
                goto LAB_0806137f;
            }
            Text = "ShowSubownerList: Buffer ist NULL.\n";
        }
        error(Text);
    }
    puVar3 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar3 = 0xffffffff;
LAB_0806137f:
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar3,&RESULT::typeinfo,0);
}



void ShowGuestList(ushort HouseID,TPlayer *pl,char *Buffer)

{
    THouse *pTVar1;
    THouse *pTVar2;
    THouseGuest *__src;
    undefined4 *puVar3;
    THouse *house_1;
    int i;
    THouse *house;
    bool bVar4;
    char *Text;
    
                    // try { // try from 08061429 to 080615b2 has its CatchHandler @ 080615b5
    pTVar1 = GetHouse(HouseID);
    if (pTVar1 == (THouse *)0x0) {
        error("ShowGuestList: Haus mit ID %d existiert nicht.\n",(uint)HouseID);
    }
    else {
        if (pl == (TPlayer *)0x0) {
            Text = "ShowGuestList: pl ist NULL.\n";
        }
        else {
            if (Buffer != (char *)0x0) {
                pTVar2 = GetHouse(HouseID);
                if (pTVar2 == (THouse *)0x0) {
                    error("IsOwner: Haus mit ID %d existiert nicht.\n",(uint)HouseID);
                    bVar4 = false;
                }
                else {
                    bVar4 = pTVar2->OwnerID == (pl->super_TCreature).ID;
                }
                if (((bVar4) || (bVar4 = IsSubowner(HouseID,pl,0x7fffffff), bVar4)) &&
                   (bVar4 = CheckRight((pl->super_TCreature).ID,PREMIUM_ACCOUNT), bVar4)) {
                    print();
                    i = 0;
                    sprintf(Buffer,"# Guests of %s\n",pTVar1->Name);
                    if (0 < pTVar1->Guests) {
                        do {
                            __src = vector<>::operator()(&pTVar1->Guest,i);
                            i = i + 1;
                            strcat(Buffer,__src->Name);
                            strcat(Buffer,"\n");
                        } while (i < pTVar1->Guests);
                    }
                    return;
                }
                puVar3 = (undefined4 *)__cxa_allocate_exception(4);
                *puVar3 = 1;
                goto LAB_0806152d;
            }
            Text = "ShowGuestList: Buffer ist NULL.\n";
        }
        error(Text);
    }
    puVar3 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar3 = 0xffffffff;
LAB_0806152d:
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar3,&RESULT::typeinfo,0);
}



// WARNING: Variable defined which should be unmapped: house

void ChangeSubowners(ushort HouseID,TPlayer *pl,char *Buffer)

{
    char cVar1;
    int l;
    THouse *pTVar2;
    THouse *pTVar3;
    size_t sVar4;
    char *pcVar5;
    int iVar6;
    THouseGuest *__dest;
    undefined4 *puVar7;
    THouse *house_1;
    uint uVar8;
    bool bVar9;
    THouse *house;
    
    uVar8 = (uint)HouseID;
                    // try { // try from 080615ec to 08061790 has its CatchHandler @ 08061793
    pTVar2 = GetHouse(HouseID);
    if (pTVar2 == (THouse *)0x0) {
        error("ChangeSubowners: Haus mit ID %d existiert nicht.\n",uVar8);
    }
    else {
        if (pl == (TPlayer *)0x0) {
            pcVar5 = "ChangeSubowners: pl ist NULL.\n";
        }
        else {
            if (Buffer != (char *)0x0) {
                pTVar3 = GetHouse(HouseID);
                if (pTVar3 == (THouse *)0x0) {
                    error("IsOwner: Haus mit ID %d existiert nicht.\n",uVar8);
                    bVar9 = false;
                }
                else {
                    bVar9 = pTVar3->OwnerID == (pl->super_TCreature).ID;
                }
                if (bVar9) {
                    Log("houses",&DAT_080f3120,(pl->super_TCreature).Name,uVar8);
                    sVar4 = strlen(Buffer);
                    Buffer[sVar4] = '\n';
                    Buffer[sVar4 + 1] = '\0';
                    pTVar2->Subowners = 0;
                    cVar1 = *Buffer;
                    do {
                        if (cVar1 == '\0') {
LAB_080616f4:
                            KickGuests(HouseID);
                            return;
                        }
                        pcVar5 = strchr(Buffer,10);
                        if (pcVar5 == (char *)0x0) {
                            error("ChangeSubowners: Kein Newline am Textende.\n");
                            goto LAB_080616f4;
                        }
                        if ((*Buffer != '#') && (Buffer != pcVar5)) {
                            iVar6 = (int)pcVar5 - (int)Buffer;
                            if (0x3b < iVar6) {
                                iVar6 = 0x3b;
                            }
                            Buffer[iVar6] = '\0';
                            __dest = vector<>::operator()(&pTVar2->Subowner,pTVar2->Subowners);
                            strcpy(__dest->Name,Buffer);
                            iVar6 = pTVar2->Subowners + 1;
                            pTVar2->Subowners = iVar6;
                            if (9 < iVar6) goto LAB_080616f4;
                        }
                        cVar1 = pcVar5[1];
                        Buffer = pcVar5 + 1;
                    } while( true );
                }
                puVar7 = (undefined4 *)__cxa_allocate_exception(4);
                *puVar7 = 1;
                goto LAB_08061729;
            }
            pcVar5 = "ChangeSubowners: Buffer ist NULL.\n";
        }
        error(pcVar5);
    }
    puVar7 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar7 = 0xffffffff;
LAB_08061729:
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar7,&RESULT::typeinfo,0);
}



// WARNING: Variable defined which should be unmapped: house

void ChangeGuests(ushort HouseID,TPlayer *pl,char *Buffer)

{
    char cVar1;
    int l;
    THouse *pTVar2;
    THouse *pTVar3;
    size_t sVar4;
    char *pcVar5;
    int iVar6;
    THouseGuest *__dest;
    undefined4 *puVar7;
    THouse *house_1;
    uint uVar8;
    bool bVar9;
    THouse *house;
    
    uVar8 = (uint)HouseID;
                    // try { // try from 080617cc to 080619af has its CatchHandler @ 080619b2
    pTVar2 = GetHouse(HouseID);
    if (pTVar2 == (THouse *)0x0) {
        error("ChangeGuests: Haus mit ID %d existiert nicht.\n",uVar8);
    }
    else {
        if (pl == (TPlayer *)0x0) {
            pcVar5 = "ChangeGuests: pl ist NULL.\n";
        }
        else {
            if (Buffer != (char *)0x0) {
                pTVar3 = GetHouse(HouseID);
                if (pTVar3 == (THouse *)0x0) {
                    error("IsOwner: Haus mit ID %d existiert nicht.\n",uVar8);
                    bVar9 = false;
                }
                else {
                    bVar9 = pTVar3->OwnerID == (pl->super_TCreature).ID;
                }
                if (((bVar9) || (bVar9 = IsSubowner(HouseID,pl,0x7fffffff), bVar9)) &&
                   (bVar9 = CheckRight((pl->super_TCreature).ID,PREMIUM_ACCOUNT), bVar9)) {
                    Log("houses",&DAT_080f3240,(pl->super_TCreature).Name,uVar8);
                    sVar4 = strlen(Buffer);
                    Buffer[sVar4] = '\n';
                    Buffer[sVar4 + 1] = '\0';
                    pTVar2->Guests = 0;
                    cVar1 = *Buffer;
                    do {
                        if (cVar1 == '\0') {
LAB_080618f2:
                            KickGuests(HouseID);
                            return;
                        }
                        pcVar5 = strchr(Buffer,10);
                        if (pcVar5 == (char *)0x0) {
                            error("ChangeGuests: Kein Newline am Textende.\n");
                            goto LAB_080618f2;
                        }
                        if ((*Buffer != '#') && (Buffer != pcVar5)) {
                            iVar6 = (int)pcVar5 - (int)Buffer;
                            if (0x3b < iVar6) {
                                iVar6 = 0x3b;
                            }
                            Buffer[iVar6] = '\0';
                            __dest = vector<>::operator()(&pTVar2->Guest,pTVar2->Guests);
                            strcpy(__dest->Name,Buffer);
                            iVar6 = pTVar2->Guests + 1;
                            pTVar2->Guests = iVar6;
                            if (99 < iVar6) goto LAB_080618f2;
                        }
                        cVar1 = pcVar5[1];
                        Buffer = pcVar5 + 1;
                    } while( true );
                }
                puVar7 = (undefined4 *)__cxa_allocate_exception(4);
                *puVar7 = 1;
                goto LAB_08061927;
            }
            pcVar5 = "ChangeGuests: Buffer ist NULL.\n";
        }
        error(pcVar5);
    }
    puVar7 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar7 = 0xffffffff;
LAB_08061927:
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar7,&RESULT::typeinfo,0);
}



// WARNING: Variable defined which should be unmapped: z_local

void GetExitPosition(ushort HouseID,int *x,int *y,int *z)

{
    THouse *pTVar1;
    THouse *house;
    int *z_local;
    
    pTVar1 = GetHouse(HouseID);
    if (pTVar1 != (THouse *)0x0) {
        *x = pTVar1->ExitX;
        *y = pTVar1->ExitY;
        *z = pTVar1->ExitZ;
        return;
    }
    error("GetExitPosition: Haus mit ID %d existiert nicht.\n");
    return;
}



void KickGuest(ushort HouseID,TPlayer *Guest)

{
    ulong uVar1;
    bool bVar2;
    bool bVar3;
    RESULT r;
    THouse *pTVar4;
    ulong uVar5;
    undefined4 *puVar6;
    THouse *house;
    Object local_6c [4];
    Object local_5c [4];
    Object local_4c [4];
    Object local_3c;
    Object Bed;
    Object Obj;
    
                    // try { // try from 08061a5c to 08061bbc has its CatchHandler @ 08061cc7
    pTVar4 = GetHouse(HouseID);
    if (pTVar4 == (THouse *)0x0) {
        error("KickGuest(houses 1): Haus mit ID %d existiert nicht.\n",(uint)HouseID);
    }
    else {
        if (Guest != (TPlayer *)0x0) {
            uVar1 = (Guest->super_TCreature).CrObject.ObjectID;
            local_3c.ObjectID = uVar1;
            GraphicalEffect(&local_3c,3);
            GetFirstObject();
            while( true ) {
                bVar2 = false;
                local_4c[0].ObjectID = NONE.ObjectID;
                local_5c[0].ObjectID = NONE.ObjectID;
                if (local_3c.ObjectID != NONE.ObjectID) {
                    Object::getObjectType(local_5c);
                    bVar3 = ObjectType::getFlag((ObjectType *)local_5c,BED);
                    if (!bVar3) {
                        bVar2 = true;
                    }
                }
                if (!bVar2) break;
                Object::getNextObject(local_4c);
                local_3c.ObjectID = local_4c[0].ObjectID;
            }
            bVar2 = false;
            local_5c[0].ObjectID = NONE.ObjectID;
            local_4c[0].ObjectID = NONE.ObjectID;
            if (local_3c.ObjectID != NONE.ObjectID) {
                    // try { // try from 08061bf0 to 08061c81 has its CatchHandler @ 08061cc7
                uVar5 = Object::getAttribute(&local_3c,TEXTSTRING);
                if (uVar5 != 0) {
                    bVar2 = true;
                }
            }
            if (bVar2) {
                print();
                local_4c[0].ObjectID = local_3c.ObjectID;
                local_6c[0].ObjectID = local_3c.ObjectID;
                    // try { // try from 08061bdb to 08061bdf has its CatchHandler @ 08061c84
                UseObjects(0,local_6c,local_4c);
            }
            local_6c[0].ObjectID = NONE.ObjectID;
            GetMapContainer((int)local_5c,pTVar4->ExitX,pTVar4->ExitY);
            local_4c[0].ObjectID = uVar1;
            Move(0,local_4c,local_5c,-1,false,local_6c);
            local_6c[0].ObjectID = uVar1;
            GraphicalEffect(local_6c,0xb);
            return;
        }
        error("KickGuest(houses 1): Guest ist NULL.\n");
    }
    puVar6 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar6 = 0xffffffff;
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar6,&RESULT::typeinfo,0);
}



// WARNING: Variable defined which should be unmapped: SelfKick

void KickGuest(ushort HouseID,TPlayer *Host,TPlayer *Guest)

{
    ushort uVar1;
    THouse *house;
    THouse *pTVar2;
    undefined4 *puVar3;
    THouse *house_1;
    uint uVar4;
    bool bVar5;
    bool bVar6;
    char *Text;
    bool SelfKick;
    
    uVar4 = (uint)HouseID;
                    // try { // try from 08061cfc to 08061eaa has its CatchHandler @ 08061eb0
    pTVar2 = GetHouse(HouseID);
    if (pTVar2 == (THouse *)0x0) {
        error("KickGuest(houses 2): Haus mit ID %d existiert nicht.\n",uVar4);
    }
    else {
        if (Host == (TPlayer *)0x0) {
            Text = "KickGuest(houses 2): Host ist NULL.\n";
        }
        else {
            if (Guest != (TPlayer *)0x0) {
                bVar5 = Host == Guest;
                uVar1 = GetHouseID((Guest->super_TCreature).posx,(Guest->super_TCreature).posy,
                                   (Guest->super_TCreature).posz);
                if (uVar1 == HouseID) {
                    pTVar2 = GetHouse(HouseID);
                    if (pTVar2 == (THouse *)0x0) {
                        error("IsOwner: Haus mit ID %d existiert nicht.\n",uVar4);
                        bVar6 = false;
                    }
                    else {
                        bVar6 = pTVar2->OwnerID == (Host->super_TCreature).ID;
                    }
                    if ((((bVar6) || (bVar6 = IsSubowner(HouseID,Host,0x7fffffff), bVar6)) ||
                        (bVar5)) &&
                       ((bVar6 = CheckRight((Guest->super_TCreature).ID,ENTER_HOUSES), !bVar6 ||
                        (bVar5)))) {
                        pTVar2 = GetHouse(HouseID);
                        if (pTVar2 == (THouse *)0x0) {
                            error("IsOwner: Haus mit ID %d existiert nicht.\n",uVar4);
LAB_08061e13:
                            bVar6 = false;
                        }
                        else {
                            if (Guest == (TPlayer *)0x0) {
                                error("IsOwner: pl ist NULL.\n");
                                goto LAB_08061e13;
                            }
                            bVar6 = pTVar2->OwnerID == (Guest->super_TCreature).ID;
                        }
                        if ((!bVar6) || (bVar5)) {
                            KickGuest(HouseID,Guest);
                            return;
                        }
                    }
                }
                puVar3 = (undefined4 *)__cxa_allocate_exception(4);
                *puVar3 = 1;
                goto LAB_08061def;
            }
            Text = "KickGuest(houses 2): Guest ist NULL.\n";
        }
        error(Text);
    }
    puVar3 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar3 = 0xffffffff;
LAB_08061def:
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar3,&RESULT::typeinfo,0);
}



void KickGuests(ushort HouseID)

{
    bool bVar1;
    ushort uVar2;
    THouse *pTVar3;
    ulong CharacterID;
    TPlayer *pl;
    undefined4 *puVar4;
    THouse *house;
    ulong ID;
    TPlayer *Guest;
    undefined1 local_4c [4];
    TFindCreatures Search;
    
                    // try { // try from 08061ee6 to 08061ff6 has its CatchHandler @ 08061ff7
    pTVar3 = GetHouse(HouseID);
    if (pTVar3 != (THouse *)0x0) {
        TFindCreatures::TFindCreatures
                  ((TFindCreatures *)local_4c,MaxHouseX,MaxHouseY,pTVar3->CenterX,pTVar3->CenterY,1)
        ;
        while( true ) {
            CharacterID = TFindCreatures::getNext((TFindCreatures *)local_4c);
            if (CharacterID == 0) break;
            pl = GetPlayer(CharacterID);
            uVar2 = GetHouseID((pl->super_TCreature).posx,(pl->super_TCreature).posy,
                               (pl->super_TCreature).posz);
            if (uVar2 == HouseID) {
                bVar1 = IsInvited(HouseID,pl,0x7fffffff);
                if (!bVar1) {
                    bVar1 = CheckRight(CharacterID,ENTER_HOUSES);
                    if (!bVar1) {
                        KickGuest(HouseID,pl);
                    }
                }
            }
        }
        return;
    }
    error("KickGuests: Haus mit ID %d existiert nicht.\n",(uint)HouseID);
    puVar4 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar4 = 0xffffffff;
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar4,&RESULT::typeinfo,0);
}



bool MayOpenDoor(Object *Door,TPlayer *pl)

{
    char cVar1;
    int iVar2;
    bool bVar3;
    ulong Number;
    size_t sVar4;
    char *pcVar5;
    int iVar6;
    char *Text;
    undefined4 local_50;
    char *pcVar7;
    char acStack_44 [20];
    undefined1 *local_30;
    Object local_2c [7];
    
    local_30 = &stack0xffffffb4;
    local_50 = 0x806202d;
    bVar3 = Object::exists(Door);
    if (bVar3) {
        if (pl == (TPlayer *)0x0) {
            pcVar7 = "MayOpenDoor: pl ist NULL.\n";
        }
        else {
            local_50 = 0x806204f;
            Object::getObjectType(local_2c);
            local_50 = 0x8062062;
            bVar3 = ObjectType::getFlag((ObjectType *)local_2c,NAMEDOOR);
            if (bVar3) {
                local_50 = 0x8062072;
                Object::getObjectType(local_2c);
                local_50 = 0x8062085;
                bVar3 = ObjectType::getFlag((ObjectType *)local_2c,TEXT);
                if (bVar3) {
                    local_50 = 0x80620b4;
                    Number = Object::getAttribute(Door,TEXTSTRING);
                    local_50 = 0x80620bc;
                    pcVar7 = GetDynamicString(Number);
                    if (pcVar7 == (char *)0x0) {
                        return false;
                    }
                    local_50 = 0x80620cc;
                    sVar4 = strlen(pcVar7);
                    iVar2 = -(sVar4 + 0x11 & 0xfffffff0);
                    *(char **)((int)local_2c + iVar2 + -0x1c) = pcVar7;
                    pcVar7 = acStack_44 + iVar2;
                    *(char **)((int)local_2c + iVar2 + -0x20) = pcVar7;
                    *(undefined4 *)((int)&local_50 + iVar2) = 0x80620e6;
                    strcpy(*(char **)((int)local_2c + iVar2 + -0x20),
                           *(char **)((int)local_2c + iVar2 + -0x1c));
                    acStack_44[sVar4 + iVar2] = '\n';
                    acStack_44[sVar4 + iVar2 + 1] = '\0';
                    cVar1 = acStack_44[iVar2];
                    do {
                        if (cVar1 == '\0') {
                            return false;
                        }
                        *(undefined4 *)((int)local_2c + iVar2 + -0x1c) = 10;
                        *(char **)((int)local_2c + iVar2 + -0x20) = pcVar7;
                        *(undefined4 *)((int)&local_50 + iVar2) = 0x8062110;
                        pcVar5 = strchr(*(char **)((int)local_2c + iVar2 + -0x20),
                                        *(int *)((int)local_2c + iVar2 + -0x1c));
                        if (pcVar5 == (char *)0x0) {
                            *(char **)((int)local_2c + iVar2 + -0x20) =
                                 "MayOpenDoor: Kein Newline am Textende.\n";
                            *(undefined4 *)((int)&local_50 + iVar2) = 0x806215d;
                            error(*(char **)((int)local_2c + iVar2 + -0x20));
                            return false;
                        }
                        if ((*pcVar7 != '#') && (pcVar7 != pcVar5)) {
                            *pcVar5 = '\0';
                            *(char **)((int)local_2c + iVar2 + -0x20) = pcVar7;
                            *(TPlayer **)((int)local_2c + iVar2 + -0x1c) = pl;
                            *(undefined4 *)((int)&local_50 + iVar2) = 0x8062131;
                            iVar6 = CheckAccessRight(*(char **)((int)local_2c + iVar2 + -0x20),
                                                     *(TPlayer **)((int)local_2c + iVar2 + -0x1c));
                            if (iVar6 == -1) {
                                return false;
                            }
                            if (iVar6 == 1) {
                                return true;
                            }
                        }
                        cVar1 = pcVar5[1];
                        pcVar7 = pcVar5 + 1;
                    } while( true );
                }
            }
            pcVar7 = &DAT_080f3580;
        }
    }
    else {
        pcVar7 = &DAT_080f3600;
    }
    local_50 = 0x8062095;
    error(pcVar7);
    return false;
}



void ShowNameDoor(Object *Door,TPlayer *pl,char *Buffer)

{
    bool bVar1;
    ushort ID;
    char *Text;
    THouse *pTVar2;
    ulong Number;
    char *pcVar3;
    undefined4 *puVar4;
    THouse *house;
    ushort HouseID;
    uint uVar5;
    char *pcVar6;
    int local_38;
    int x;
    int y;
    int z;
    
                    // try { // try from 08062198 to 080623b3 has its CatchHandler @ 080623d0
    bVar1 = Object::exists(Door);
    if (bVar1) {
        if (pl == (TPlayer *)0x0) {
            pcVar3 = "ShowNameDoor: pl ist NULL.\n";
            goto LAB_080623af;
        }
        if (Buffer == (char *)0x0) {
            pcVar3 = "ShowNameDoor: Buffer ist NULL.\n";
            goto LAB_080623af;
        }
        z = Door->ObjectID;
        GetObjectCoordinates((Object *)&z,&local_38,&x,&y);
        ID = GetHouseID(local_38,x,y);
        uVar5 = (uint)ID;
        if (ID == 0) {
            pcVar3 = &DAT_080f36e0;
        }
        else {
            pTVar2 = GetHouse(ID);
            if (pTVar2 == (THouse *)0x0) {
                error("IsOwner: Haus mit ID %d existiert nicht.\n",uVar5);
                bVar1 = false;
            }
            else {
                bVar1 = pTVar2->OwnerID == (pl->super_TCreature).ID;
            }
            if (!bVar1) {
                pcVar3 = (pl->super_TCreature).Name;
                pcVar6 = "Spieler %s ist nicht Mieter des Hauses %d.\n";
                print();
                puVar4 = (undefined4 *)__cxa_allocate_exception(4,pcVar6,pcVar3,uVar5);
                *puVar4 = 1;
                goto LAB_0806231d;
            }
            print();
            Object::getObjectType((Object *)&z);
            bVar1 = ObjectType::getFlag((ObjectType *)&z,TEXT);
            if (bVar1) {
                Number = Object::getAttribute(Door,TEXTSTRING);
                pcVar3 = GetDynamicString(Number);
                if (pcVar3 == (char *)0x0) {
                    Buffer[0] = '#';
                    Buffer[1] = ' ';
                    Buffer[2] = 'P';
                    Buffer[3] = 'l';
                    Buffer[4] = 'a';
                    Buffer[5] = 'y';
                    Buffer[6] = 'e';
                    Buffer[7] = 'r';
                    Buffer[8] = 's';
                    Buffer[9] = ' ';
                    Buffer[10] = 'a';
                    Buffer[0xb] = 'l';
                    Buffer[0xc] = 'l';
                    Buffer[0xd] = 'o';
                    Buffer[0xe] = 'w';
                    Buffer[0xf] = 'e';
                    Buffer[0x10] = 'd';
                    Buffer[0x11] = ' ';
                    Buffer[0x12] = 't';
                    Buffer[0x13] = 'o';
                    Buffer[0x14] = ' ';
                    Buffer[0x15] = 'o';
                    Buffer[0x16] = 'p';
                    Buffer[0x17] = 'e';
                    Buffer[0x18] = 'n';
                    Buffer[0x19] = ' ';
                    Buffer[0x1a] = 't';
                    Buffer[0x1b] = 'h';
                    Buffer[0x1c] = 'i';
                    Buffer[0x1d] = 's';
                    Buffer[0x1e] = ' ';
                    Buffer[0x1f] = 'd';
                    *(uchar **)(Buffer + 0x20) = CommunicationThreadStacks + 0xa750f;
                    Buffer[0x24] = '\0';
                }
                else {
                    strcpy(Buffer,pcVar3);
                }
                return;
            }
            pcVar3 = &DAT_080f3640;
        }
        error(pcVar3,local_38,x,y);
    }
    else {
        pcVar3 = &DAT_080f3760;
LAB_080623af:
        error(pcVar3);
    }
    puVar4 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar4 = 0xffffffff;
LAB_0806231d:
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar4,&RESULT::typeinfo,0);
}



void ChangeNameDoor(Object *Door,TPlayer *pl,char *Buffer)

{
    bool bVar1;
    ushort ID;
    THouse *pTVar2;
    ulong uVar3;
    undefined4 *puVar4;
    THouse *house;
    ushort HouseID;
    char *pcVar5;
    int local_38;
    int x;
    int y;
    int z;
    
                    // try { // try from 08062408 to 080625ed has its CatchHandler @ 08062605
    bVar1 = Object::exists(Door);
    if (bVar1) {
        if (pl == (TPlayer *)0x0) {
            pcVar5 = "ChangeNameDoor: pl ist NULL.\n";
            goto LAB_080625e9;
        }
        if (Buffer == (char *)0x0) {
            pcVar5 = "ChangeNameDoor: Buffer ist NULL.\n";
            goto LAB_080625e9;
        }
        z = Door->ObjectID;
        GetObjectCoordinates((Object *)&z,&local_38,&x,&y);
        ID = GetHouseID(local_38,x,y);
        if (ID == 0) {
            pcVar5 = &DAT_080f3840;
        }
        else {
            pTVar2 = GetHouse(ID);
            if (pTVar2 == (THouse *)0x0) {
                error("IsOwner: Haus mit ID %d existiert nicht.\n",(uint)ID);
                bVar1 = false;
            }
            else {
                bVar1 = pTVar2->OwnerID == (pl->super_TCreature).ID;
            }
            if (!bVar1) {
                puVar4 = (undefined4 *)__cxa_allocate_exception(4);
                *puVar4 = 1;
                goto LAB_08062581;
            }
            Object::getObjectType((Object *)&z);
            bVar1 = ObjectType::getFlag((ObjectType *)&z,TEXT);
            if (bVar1) {
                Log("houses",&DAT_080f37a0,(pl->super_TCreature).Name,(uint)ID,local_38,x,y);
                uVar3 = Object::getAttribute(Door,TEXTSTRING);
                DeleteDynamicString(uVar3);
                z = Door->ObjectID;
                uVar3 = AddDynamicString(Buffer);
                Change((Object *)&z,TEXTSTRING,uVar3);
                return;
            }
            pcVar5 = &DAT_080f37e0;
        }
        error(pcVar5,local_38,x,y);
    }
    else {
        pcVar5 = &DAT_080f38e0;
LAB_080625e9:
        error(pcVar5);
    }
    puVar4 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar4 = 0xffffffff;
LAB_08062581:
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar4,&RESULT::typeinfo,0);
}



int DeleteCoins(Object *Con,ObjectType *Type,int Amount)

{
    bool bVar1;
    ulong uVar2;
    Object local_5c [4];
    Object local_4c [4];
    ObjectType local_3c [4];
    Object local_2c;
    Object Obj;
    
    do {
        if (Amount == 0) {
            return 0;
        }
        local_3c[0].TypeID = Con->ObjectID;
        GetFirstContainerObject(&local_2c);
        if (local_2c.ObjectID == NONE.ObjectID) {
            return Amount;
        }
        while( true ) {
            local_4c[0].ObjectID = NONE.ObjectID;
            local_3c[0].TypeID = NONE.ObjectID;
            Object::getObjectType(local_4c);
            ObjectType::setTypeID(local_3c,Type->TypeID);
            if (local_4c[0].ObjectID == local_3c[0].TypeID) break;
            Object::getObjectType(local_5c);
            bVar1 = ObjectType::getFlag((ObjectType *)local_5c,CONTAINER);
            if (bVar1) {
                ObjectType::setTypeID((ObjectType *)local_5c,Type->TypeID);
                local_4c[0].ObjectID = local_2c.ObjectID;
                Amount = DeleteCoins(local_4c,(ObjectType *)local_5c,Amount);
                if (Amount == 0) {
                    return 0;
                }
            }
            Object::getNextObject(local_4c);
            local_5c[0].ObjectID = local_4c[0].ObjectID;
            local_2c.ObjectID = local_5c[0].ObjectID;
            if (local_4c[0].ObjectID == NONE.ObjectID) {
                return Amount;
            }
        }
        uVar2 = Object::getAttribute(&local_2c,AMOUNT);
        if (Amount < (int)uVar2) {
            local_5c[0].ObjectID = local_2c.ObjectID;
            uVar2 = Object::getAttribute(&local_2c,AMOUNT);
            Change(local_5c,AMOUNT,uVar2 - Amount);
            return 0;
        }
        uVar2 = Object::getAttribute(&local_2c,AMOUNT);
        Amount = Amount - uVar2;
        local_5c[0].ObjectID = local_2c.ObjectID;
        DeleteObject(local_5c);
    } while( true );
}



void DeleteMoney(Object *Con,int Amount)

{
    int local_58;
    int Gold;
    int Platinum;
    int Crystal;
    Object local_3c [4];
    ObjectType local_2c [7];
    
    GetSpecialObject((SPECIALMEANING)local_2c);
    Crystal = Con->ObjectID;
    GetFirstContainerObject(local_3c);
    Platinum = CountObjects(local_3c,local_2c,0);
    GetSpecialObject((SPECIALMEANING)&Crystal);
    local_2c[0].TypeID = Con->ObjectID;
    GetFirstContainerObject(local_3c);
    Gold = CountObjects(local_3c,(ObjectType *)&Crystal,0);
    GetSpecialObject((SPECIALMEANING)&Crystal);
    local_2c[0].TypeID = Con->ObjectID;
    GetFirstContainerObject(local_3c);
    local_58 = CountObjects(local_3c,(ObjectType *)&Crystal,0);
    CalculateChange(Amount,&local_58,&Gold,&Platinum);
    if (0 < local_58) {
        GetSpecialObject((SPECIALMEANING)&Crystal);
        local_3c[0] = (Object)Con->ObjectID;
        DeleteCoins(local_3c,(ObjectType *)&Crystal,local_58);
    }
    if (local_58 < 0) {
        GetSpecialObject((SPECIALMEANING)local_3c);
        local_2c[0].TypeID = Con->ObjectID;
        SetObject((Object *)&Crystal,local_2c,(ulong)local_3c);
        ChangeObject((Object *)&Crystal,AMOUNT,-local_58);
    }
    if (0 < Gold) {
        GetSpecialObject((SPECIALMEANING)&Crystal);
        local_3c[0] = (Object)Con->ObjectID;
        DeleteCoins(local_3c,(ObjectType *)&Crystal,Gold);
    }
    if (Gold < 0) {
        GetSpecialObject((SPECIALMEANING)local_3c);
        local_2c[0].TypeID = Con->ObjectID;
        SetObject((Object *)&Crystal,local_2c,(ulong)local_3c);
        ChangeObject((Object *)&Crystal,AMOUNT,-Gold);
    }
    if (0 < Platinum) {
        GetSpecialObject((SPECIALMEANING)&Crystal);
        local_3c[0] = (Object)Con->ObjectID;
        DeleteCoins(local_3c,(ObjectType *)&Crystal,Platinum);
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void CleanField(void)

{
    bool bVar1;
    ulong uVar2;
    ulong *in_stack_00000010;
    Object local_6c;
    Object Help;
    Object local_5c;
    Object Content;
    Object local_4c;
    Object Help_1;
    Object local_3c [4];
    Object local_2c;
    Object Obj;
    
    local_2c.ObjectID = NONE.ObjectID;
    if (*in_stack_00000010 == NONE.ObjectID) {
        error("CleanField: Depot-Box existiert nicht.\n");
    }
    else {
        GetFirstObject();
        if (local_2c.ObjectID != NONE.ObjectID) {
            do {
                local_4c.ObjectID = NONE.ObjectID;
                local_3c[0].ObjectID = NONE.ObjectID;
                Object::getObjectType(&local_4c);
                bVar1 = ObjectType::getFlag((ObjectType *)&local_4c,NAMEDOOR);
                if (bVar1) {
                    uVar2 = Object::getAttribute(&local_2c,TEXTSTRING);
                    DeleteDynamicString(uVar2);
                    local_4c.ObjectID = local_2c.ObjectID;
                    Change(&local_4c,TEXTSTRING,0);
                    uVar2 = Object::getAttribute(&local_2c,EDITOR);
                    DeleteDynamicString(uVar2);
                    local_4c.ObjectID = local_2c.ObjectID;
                    Change(&local_4c,EDITOR,0);
                }
                Object::getObjectType(&local_4c);
                bVar1 = ObjectType::getFlag((ObjectType *)&local_4c,UNMOVE);
                if (bVar1) {
LAB_08062ae1:
                    Object::getObjectType(&local_5c);
                    bVar1 = ObjectType::getFlag((ObjectType *)&local_5c,CONTAINER);
                    if (bVar1) {
                        local_4c.ObjectID = local_2c.ObjectID;
                        GetFirstContainerObject(&local_5c);
                        local_4c = (Object)NONE.ObjectID;
                        local_3c[0].ObjectID = local_4c.ObjectID;
                        if (local_5c.ObjectID != NONE.ObjectID) {
                            do {
                                local_4c.ObjectID = local_5c.ObjectID;
                                local_3c[0].ObjectID = NONE.ObjectID;
                                Object::getNextObject(&local_6c);
                                local_5c.ObjectID = local_6c.ObjectID;
                                local_6c.ObjectID = *in_stack_00000010;
                                local_3c[0].ObjectID = local_4c.ObjectID;
                                MoveObject(local_3c,&local_6c);
                                local_4c = (Object)NONE.ObjectID;
                                local_3c[0].ObjectID = local_4c.ObjectID;
                            } while (local_5c.ObjectID != NONE.ObjectID);
                        }
                    }
                    Object::getObjectType(&local_6c);
                    bVar1 = ObjectType::getFlag((ObjectType *)&local_6c,UNMOVE);
                    if (bVar1) {
                        Object::getNextObject(&local_5c);
                        local_6c.ObjectID = local_5c.ObjectID;
                        local_2c.ObjectID = local_6c.ObjectID;
                    }
                    else {
                        local_6c.ObjectID = local_2c.ObjectID;
                        Object::getNextObject(&local_4c);
                        local_2c.ObjectID = local_4c.ObjectID;
                        local_5c.ObjectID = local_6c.ObjectID;
                        DeleteObject(&local_5c);
                    }
                }
                else {
                    Object::getObjectType(&local_4c);
                    bVar1 = ObjectType::getFlag((ObjectType *)&local_4c,TAKE);
                    if (!bVar1) goto LAB_08062ae1;
                    local_4c.ObjectID = local_2c.ObjectID;
                    Object::getNextObject(&local_5c);
                    local_2c.ObjectID = local_5c.ObjectID;
                    local_5c.ObjectID = *in_stack_00000010;
                    local_3c[0].ObjectID = local_4c.ObjectID;
                    MoveObject(local_3c,&local_5c);
                }
            } while (local_2c.ObjectID != NONE.ObjectID);
        }
    }
    return;
}



void CleanHouse(THouse *house,TPlayerData *PlayerData)

{
    int x_00;
    bool bVar1;
    ushort uVar2;
    int iVar3;
    int iVar4;
    int y_1;
    int y_00;
    int x_1;
    int x_01;
    bool bVar5;
    char *Text;
    int local_70;
    int local_68;
    int local_60;
    int z_1;
    int iStack_58;
    bool PlayerDataAssigned;
    int x;
    int y;
    int z;
    undefined1 local_3c [16];
    Object local_2c;
    Object Box;
    
    if (house == (THouse *)0x0) {
        Text = "CleanHouse: house ist NULL.\n";
    }
    else {
        if (house->OwnerID == 0) {
            error("CleanHouse: Haus %d hat keinen Besitzer.\n",(uint)house->ID);
            return;
        }
        bVar5 = PlayerData != (TPlayerData *)0x0;
        if ((bVar5) ||
           (PlayerData = AssignPlayerPoolSlot(house->OwnerID,false),
           PlayerData != (TPlayerData *)0x0)) {
            GetStartPosition(&stack0xffffffa8,&x,&y,true);
            GetSpecialObject((SPECIALMEANING)local_3c);
            GetMapContainer((int)&z,iStack_58,x);
            SetObject(&local_2c,(ObjectType *)&z,(ulong)local_3c);
            z = local_2c.ObjectID;
            LoadDepot(PlayerData,house->DepotNr,(Object *)&z);
            local_60 = 0;
            local_68 = house->CenterX;
            local_70 = MaxHouseX;
            do {
                x_01 = (local_68 - local_70) + -1;
                if (x_01 <= local_68 + local_70) {
                    iVar3 = house->CenterY;
                    iVar4 = MaxHouseY;
                    do {
                        y_00 = (iVar3 - iVar4) + -1;
                        x_00 = x_01 + 1;
                        if (y_00 <= iVar4 + iVar3) {
                            do {
                                uVar2 = GetHouseID(x_01,y_00,local_60);
                                if (uVar2 == house->ID) {
LAB_08062f90:
                                    z = local_2c.ObjectID;
                                    CleanField();
                                }
                                else {
                                    bVar1 = CoordinateFlag();
                                    if (bVar1) {
                                        iVar3 = y_00 + 1;
                                        uVar2 = GetHouseID(x_01 + -1,iVar3,local_60);
                                        if (((uVar2 == house->ID) ||
                                            (uVar2 = GetHouseID(x_01,iVar3,local_60),
                                            uVar2 == house->ID)) ||
                                           (uVar2 = GetHouseID(x_00,iVar3,local_60),
                                           uVar2 == house->ID)) goto LAB_08062f90;
                                    }
                                    bVar1 = CoordinateFlag();
                                    if ((bVar1) &&
                                       (((uVar2 = GetHouseID(x_00,y_00 + -1,local_60),
                                         uVar2 == house->ID ||
                                         (uVar2 = GetHouseID(x_00,y_00,local_60), uVar2 == house->ID
                                         )) || (uVar2 = GetHouseID(x_00,y_00 + 1,local_60),
                                               uVar2 == house->ID)))) goto LAB_08062f90;
                                }
                                y_00 = y_00 + 1;
                                iVar3 = house->CenterY;
                            } while (y_00 <= MaxHouseY + iVar3);
                            local_68 = house->CenterX;
                            local_70 = MaxHouseX;
                            iVar4 = MaxHouseY;
                        }
                        x_01 = x_00;
                    } while (x_00 <= local_68 + local_70);
                }
                local_60 = local_60 + 1;
                if (0xf < local_60) {
                    z = local_2c.ObjectID;
                    SaveDepot(PlayerData,house->DepotNr,(Object *)&z);
                    z = local_2c.ObjectID;
                    DeleteObject((Object *)&z);
                    if (bVar5) {
                        return;
                    }
                    ReleasePlayerPoolSlot(PlayerData);
                    return;
                }
            } while( true );
        }
        Text = &DAT_080f3960;
    }
    error(Text);
    return;
}



void ClearHouse(THouse *house)

{
    house->OwnerID = 0;
    house->OwnerName[0] = '\0';
    house->Subowners = 0;
    house->Guests = 0;
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void FinishAuctions(void)

{
    ushort uVar1;
    int iVar2;
    int_0_ *piVar3;
    TPlayerData *pTVar4;
    time_t tVar5;
    ulong_0_ *puVar6;
    int iVar7;
    THouse *pTVar8;
    int iVar9;
    ulong uVar10;
    uint uVar11;
    int iVar12;
    char_0__30_ *CharacterNames;
    undefined4 local_310;
    int aiStack_2fc [2];
    int_0_ aiStack_2f4 [8];
    int_0_ *local_2ec;
    TPlayerData *local_2e8;
    TPlayerData *PlayerData;
    THouse *house;
    int i;
    time_t TimeStamp;
    int_0_ *Bids;
    ulong_0_ *CharacterIDs;
    ushort_0_ *HouseIDs;
    int NumberOfAuctions;
    int x;
    int y;
    int z;
    ulong local_2ac [4];
    undefined1 local_29c [4];
    char Welcome [500];
    ulong local_9c [4];
    undefined1 local_8c [4];
    char HelpWorld [60];
    ObjectType local_4c [4];
    ulong local_3c [4];
    Object local_2c;
    Object Con;
    
                    // try { // try from 080630d9 to 08063742 has its CatchHandler @ 08063748
    local_310 = 0x80630de;
    GetStartPosition(&NumberOfAuctions,&x,&y,true);
    local_310 = 0x80630f4;
    GetSpecialObject((SPECIALMEANING)local_3c);
    local_310 = 0x8063120;
    GetMapContainer((int)local_4c,NumberOfAuctions,x);
    local_310 = 0x806313e;
    SetObject(&local_2c,local_4c,(ulong)local_3c);
    local_310 = 0x8063155;
    Log("houses","Bearbeite beendete Auktionen...\n");
    HouseIDs = (ushort_0_ *)Houses;
    iVar12 = Houses + -1;
    iVar2 = -(Houses + 0x10 + iVar12 & 0xfffffff0U);
    uVar11 = iVar12 * 4 + 0x13U & 0xfffffff0;
    CharacterIDs = aiStack_2f4 + iVar2;
    Bids = aiStack_2f4 + -uVar11 + iVar2;
    iVar12 = -(iVar12 * 0x1e + 0x2dU & 0xfffffff0);
    TimeStamp = (time_t)(aiStack_2f4 + iVar12 + uVar11 * -2 + iVar2);
    *(int_0_ **)((int)aiStack_2fc + iVar12 + uVar11 * -2 + iVar2 + 4) =
         aiStack_2f4 + iVar12 + uVar11 * -2 + iVar2;
    *(int_0_ **)((int)aiStack_2fc + iVar12 + uVar11 * -2 + iVar2) =
         aiStack_2f4 + iVar12 + -uVar11 + iVar2;
    *(int_0_ **)(&stack0xfffffd00 + iVar12 + uVar11 * -2 + iVar2) = Bids;
    puVar6 = CharacterIDs;
    *(ushort_0_ ***)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2) = &HouseIDs;
    *(ulong_0_ **)(&stack0xfffffcfc + iVar12 + uVar11 * -2 + iVar2) = puVar6;
    *(TQueryManagerConnection **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) =
         QueryManagerConnection;
    *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) = 0x80631de;
    iVar7 = TQueryManagerConnection::finishAuctions
                      (*(TQueryManagerConnection **)
                        (&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2),
                       *(int **)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2),
                       *(ushort **)(&stack0xfffffcfc + iVar12 + uVar11 * -2 + iVar2),
                       *(ulong **)(&stack0xfffffd00 + iVar12 + uVar11 * -2 + iVar2),
                       *(char (**) [30])((int)aiStack_2fc + iVar12 + uVar11 * -2 + iVar2),
                       *(int **)((int)aiStack_2fc + iVar12 + uVar11 * -2 + iVar2 + 4));
    if (iVar7 == 0) {
        *(char **)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2) = WorldName;
        *(undefined1 **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) = local_8c;
        *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) = 0x8063224;
        AddSlashes(*(char **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2),
                   *(char **)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2));
        *(undefined4 *)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) = 0;
        *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) = 0x8063230;
        i = time(*(time_t **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2));
        house = (THouse *)0x0;
        if (0 < (int)HouseIDs) {
            local_2ec = aiStack_2f4 + iVar12 + -uVar11 + iVar2;
            do {
                tVar5 = TimeStamp;
                pTVar8 = house;
                *(undefined4 *)((int)aiStack_2fc + iVar12 + uVar11 * -2 + iVar2) =
                     *(undefined4 *)(TimeStamp + (int)house * 4);
                *(int_0_ **)(&stack0xfffffd00 + iVar12 + uVar11 * -2 + iVar2) = local_2ec;
                uVar1 = *(ushort *)(CharacterIDs + (int)pTVar8 * 2);
                *(char **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) = "houses";
                *(undefined **)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2) = &DAT_080f3a60;
                *(uint *)(&stack0xfffffcfc + iVar12 + uVar11 * -2 + iVar2) = (uint)uVar1;
                *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) = 0x8063291;
                Log(*(char **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2),
                    *(char **)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2));
                pTVar8 = house;
                *(undefined4 *)((int)aiStack_2fc + iVar12 + uVar11 * -2 + iVar2 + 4) =
                     *(undefined4 *)(tVar5 + (int)house * 4);
                *(undefined4 *)((int)aiStack_2fc + iVar12 + uVar11 * -2 + iVar2) =
                     *(undefined4 *)(Bids + (int)pTVar8 * 4);
                uVar1 = *(ushort *)(CharacterIDs + (int)pTVar8 * 2);
                *(char **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) = "houses";
                *(char **)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2) =
                     "bei Reset: INSERT INTO HouseAssignments VALUES (\'%s\',%d,%d,%d);\n";
                *(uint *)(&stack0xfffffd00 + iVar12 + uVar11 * -2 + iVar2) = (uint)uVar1;
                *(undefined1 **)(&stack0xfffffcfc + iVar12 + uVar11 * -2 + iVar2) = local_8c;
                *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) = 0x80632d7;
                Log(*(char **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2),
                    *(char **)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2));
                pTVar8 = house;
                *(uint *)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) =
                     (uint)*(ushort *)(CharacterIDs + (int)house * 2);
                *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) = 0x80632ef;
                PlayerData = (TPlayerData *)
                             GetHouse(*(ushort *)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2));
                if (PlayerData == (TPlayerData *)0x0) {
                    uVar1 = *(ushort *)(CharacterIDs + (int)pTVar8 * 2);
                    *(char **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) =
                         "FinishAuctions: Haus mit Nummer %d existiert nicht.\n";
                    *(uint *)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2) = (uint)uVar1;
                    *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) = 0x8063743;
                    error(*(char **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2));
                }
                else if (PlayerData->Cycle[4] == 0) {
                    *(undefined4 *)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2) = 0;
                    *(undefined4 *)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) =
                         *(undefined4 *)(Bids + (int)house * 4);
                    *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) = 0x806344f;
                    local_2e8 = AssignPlayerPoolSlot
                                          (*(ulong *)(&stack0xfffffcf4 +
                                                     iVar12 + uVar11 * -2 + iVar2),
                                           (bool)(&stack0xfffffcf8)[iVar12 + uVar11 * -2 + iVar2]);
                    if (local_2e8 == (TPlayerData *)0x0) {
                        *(undefined **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) =
                             &DAT_080f3cc0;
                        *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) = 0x8063724;
                        error(*(char **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2));
                    }
                    else {
                        local_4c[0].TypeID = local_2c.ObjectID;
                        *(ObjectType **)(&stack0xfffffcfc + iVar12 + uVar11 * -2 + iVar2) = local_4c
                        ;
                        pTVar4 = PlayerData;
                        *(int *)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2) =
                             PlayerData->MagicDeltaAct[0x15];
                        *(TPlayerData **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) =
                             local_2e8;
                        *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) = 0x8063488;
                        LoadDepot(*(TPlayerData **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2)
                                  ,*(int *)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2),
                                  *(Object **)(&stack0xfffffcfc + iVar12 + uVar11 * -2 + iVar2));
                        local_3c[0] = local_2c.ObjectID;
                        *(ulong **)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2) = local_3c;
                        *(ObjectType **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) = local_4c
                        ;
                        *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) = 0x806349d;
                        GetFirstContainerObject
                                  (*(Object **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2));
                        *(ObjectType **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) = local_4c
                        ;
                        *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) = 0x80634ab;
                        iVar7 = CountMoney(*(Object **)
                                            (&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2));
                        if (iVar7 < pTVar4->MagicDeltaAct[0x14] +
                                    *(int *)(TimeStamp + (int)house * 4)) {
                            *(undefined **)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2) =
                                 &DAT_080f3c80;
                            *(char **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) = "houses";
                            *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) =
                                 0x80636d0;
                            Log(*(char **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2),
                                *(char **)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2));
                            piVar3 = local_2ec;
                            PlayerData->Cycle[4] = *(int *)(Bids + (int)house * 4);
                            *(int **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) =
                                 PlayerData->Cycle + 5;
                            *(int_0_ **)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2) = piVar3;
                            *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) =
                                 0x8063705;
                            strcpy(*(char **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2),
                                   *(char **)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2));
                            PlayerData->Cycle[0xe] = 0;
                        }
                        else {
                            *(undefined **)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2) =
                                 &DAT_080f3b80;
                            *(char **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) = "houses";
                            *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) =
                                 0x80634dc;
                            Log(*(char **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2),
                                *(char **)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2));
                            local_9c[0] = local_2c.ObjectID;
                            iVar7 = PlayerData->MagicDeltaAct[0x14];
                            iVar9 = *(int *)(TimeStamp + (int)house * 4);
                            *(ulong **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) = local_9c;
                            *(int *)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2) =
                                 iVar7 + iVar9;
                            *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) =
                                 0x8063514;
                            DeleteMoney(*(Object **)
                                         (&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2),
                                        *(int *)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2));
                            pTVar4 = PlayerData;
                            *(char **)(&stack0xfffffcfc + iVar12 + uVar11 * -2 + iVar2) =
                                 "Welcome!\n\nCongratulations on your choice\nfor house \"%s\".\nThe rent for the first month\nhas already been debited to your\ndepot. The next rent will be\npayable in thirty days.\nHave a good time in your new home!"
                            ;
                            *(undefined1 **)(&stack0xfffffd00 + iVar12 + uVar11 * -2 + iVar2) =
                                 (undefined1 *)((int)&pTVar4->CharacterID + 2);
                            *(undefined4 *)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2) = 500;
                            *(undefined1 **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) =
                                 local_29c;
                            *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) =
                                 0x806353f;
                            snprintf(*(char **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2),
                                     *(size_t *)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2),
                                     *(char **)(&stack0xfffffcfc + iVar12 + uVar11 * -2 + iVar2));
                            *(undefined1 **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) =
                                 local_29c;
                            *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) =
                                 0x8063547;
                            uVar10 = AddDynamicString(*(char **)(&stack0xfffffcf4 +
                                                                iVar12 + uVar11 * -2 + iVar2));
                            *(undefined4 *)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2) = 0x1a;
                            *(ulong **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) = local_2ac
                            ;
                            *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) =
                                 0x806355f;
                            GetSpecialObject(*(SPECIALMEANING *)
                                              (&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2));
                            z = local_2c.ObjectID;
                            *(undefined4 *)(&stack0xfffffd00 + iVar12 + uVar11 * -2 + iVar2) = 0;
                            *(ulong **)(&stack0xfffffcfc + iVar12 + uVar11 * -2 + iVar2) = local_2ac
                            ;
                            *(int **)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2) = &z;
                            *(ulong **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) = local_9c;
                            *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) =
                                 0x8063595;
                            SetObject(*(Object **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2),
                                      *(ObjectType **)
                                       (&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2),
                                      *(ulong *)(&stack0xfffffcfc + iVar12 + uVar11 * -2 + iVar2));
                            *(ulong *)(&stack0xfffffcfc + iVar12 + uVar11 * -2 + iVar2) = uVar10;
                            *(undefined4 *)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2) = 9;
                            *(ulong **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) = local_9c;
                            *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) =
                                 0x80635b2;
                            ChangeObject(*(Object **)
                                          (&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2),
                                         *(INSTANCEATTRIBUTE *)
                                          (&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2),
                                         *(ulong *)(&stack0xfffffcfc + iVar12 + uVar11 * -2 + iVar2)
                                        );
                            z = local_2c.ObjectID;
                            *(int **)(&stack0xfffffcfc + iVar12 + uVar11 * -2 + iVar2) = &z;
                            pTVar4 = PlayerData;
                            *(int *)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2) =
                                 PlayerData->MagicDeltaAct[0x15];
                            *(TPlayerData **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) =
                                 local_2e8;
                            *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) =
                                 0x80635e3;
                            SaveDepot(*(TPlayerData **)
                                       (&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2),
                                      *(int *)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2),
                                      *(Object **)(&stack0xfffffcfc + iVar12 + uVar11 * -2 + iVar2))
                            ;
                            pTVar4->Cycle[4] = *(int *)(Bids + (int)house * 4);
                            *(int_0_ **)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2) =
                                 local_2ec;
                            *(int **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) =
                                 PlayerData->Cycle + 5;
                            *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) =
                                 0x8063615;
                            strcpy(*(char **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2),
                                   *(char **)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2));
                            PlayerData->Cycle[0xd] = i;
                            PlayerData->Cycle[0xe] = i + 0x278d00;
                        }
                        while( true ) {
                            local_2ac[0] = local_2c.ObjectID;
                            *(ulong **)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2) = local_2ac
                            ;
                            *(int **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) = &z;
                            *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) =
                                 0x806365c;
                            GetFirstContainerObject
                                      (*(Object **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2)
                                      );
                            local_9c[0] = NONE.ObjectID;
                            local_4c[0].TypeID = NONE.ObjectID;
                            if (z == NONE.ObjectID) break;
                            local_2ac[0] = local_2c.ObjectID;
                            *(ulong **)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2) = local_2ac
                            ;
                            *(int **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) = &z;
                            *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) =
                                 0x8063696;
                            GetFirstContainerObject
                                      (*(Object **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2)
                                      );
                            *(int **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) = &z;
                            *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) =
                                 0x80636a7;
                            DeleteObject(*(Object **)
                                          (&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2));
                        }
                        *(TPlayerData **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) =
                             local_2e8;
                        *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) = 0x80636b7;
                        ReleasePlayerPoolSlot
                                  (*(TPlayerData **)
                                    (&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2));
                    }
                }
                else {
                    *(int *)(&stack0xfffffcfc + iVar12 + uVar11 * -2 + iVar2) = PlayerData->Cycle[4]
                    ;
                    uVar1 = *(ushort *)(CharacterIDs + (int)house * 2);
                    *(undefined **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) = &DAT_080f3b00
                    ;
                    *(uint *)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2) = (uint)uVar1;
                    *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) = 0x8063335;
                    error(*(char **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2));
                }
                house = (THouse *)((int)&house->ID + 1);
                local_2ec = local_2ec + 0x1e;
            } while ((int)house < (int)HouseIDs);
        }
        iVar7 = 0;
        if (0 < Houses) {
            do {
                *(int *)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2) = iVar7;
                *(vector<THouse> **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) = &House;
                *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) = 0x8063385;
                pTVar8 = vector<THouse>::operator()
                                   (*(vector<THouse> **)
                                     (&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2),
                                    *(int *)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2));
                if (pTVar8->PaidUntil == 0) {
                    *(int *)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2) = iVar7;
                    *(vector<THouse> **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) = &House;
                    *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) = 0x80633b0;
                    pTVar8 = vector<THouse>::operator()
                                       (*(vector<THouse> **)
                                         (&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2),
                                        *(int *)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2));
                    if (pTVar8->OwnerID != 0) {
                        *(int *)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2) = iVar7;
                        *(vector<THouse> **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) =
                             &House;
                        *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) = 0x80633ca;
                        pTVar8 = vector<THouse>::operator()
                                           (*(vector<THouse> **)
                                             (&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2),
                                            *(int *)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2
                                                    ));
                        *(undefined4 *)(&stack0xfffffcfc + iVar12 + uVar11 * -2 + iVar2) = 1;
                        *(ulong *)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2) =
                             pTVar8->OwnerID;
                        *(TQueryManagerConnection **)
                         (&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) = QueryManagerConnection;
                        *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) = 0x80633e9;
                        iVar9 = TQueryManagerConnection::excludeFromAuctions
                                          (*(TQueryManagerConnection **)
                                            (&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2),
                                           *(ulong *)(&stack0xfffffcf8 +
                                                     iVar12 + uVar11 * -2 + iVar2),
                                           (bool)(&stack0xfffffcfc)[iVar12 + uVar11 * -2 + iVar2]);
                        if (iVar9 != 0) {
                            *(char **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) =
                                 "FinishAuctions: Kann Ersteigerer nicht verbannen.\n";
                            *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) =
                                 0x806342d;
                            error(*(char **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2));
                        }
                        *(int *)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2) = iVar7;
                        *(vector<THouse> **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) =
                             &House;
                        *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) = 0x80633fd;
                        pTVar8 = vector<THouse>::operator()
                                           (*(vector<THouse> **)
                                             (&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2),
                                            *(int *)(&stack0xfffffcf8 + iVar12 + uVar11 * -2 + iVar2
                                                    ));
                        pTVar8->OwnerName[0] = '\0';
                        pTVar8->OwnerID = 0;
                        pTVar8->Subowners = 0;
                        pTVar8->Guests = 0;
                    }
                }
                iVar7 = iVar7 + 1;
            } while (iVar7 < Houses);
        }
        z = local_2c.ObjectID;
        *(int **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) = &z;
    }
    else {
        *(char **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) =
             "FinishAuctions: Kann Versteigerungen nicht ermitteln.\n";
        *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) = 0x80631ee;
        error(*(char **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2));
        local_4c[0].TypeID = local_2c.ObjectID;
        *(ObjectType **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2) = local_4c;
    }
    *(undefined4 *)((int)&local_310 + iVar12 + uVar11 * -2 + iVar2) = 0x80631ff;
    DeleteObject(*(Object **)(&stack0xfffffcf4 + iVar12 + uVar11 * -2 + iVar2));
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void CollectRents(void)

{
    TPlayerData *pTVar1;
    ushort uVar2;
    undefined4 uVar3;
    int_0_ *piVar4;
    ulong_0_ *puVar5;
    int iVar6;
    ulong uVar7;
    int iVar8;
    THouse *pTVar9;
    THouse *pTVar10;
    uint uVar11;
    char *pcVar12;
    int *piVar13;
    ObjectType *pOVar14;
    char_0__30_ *NewOwnerNames;
    int iVar15;
    int iVar16;
    ushort_0_ **ppuVar17;
    int *piVar18;
    int NumberOfGuildhouses;
    int iVar19;
    undefined4 local_350;
    uint auStack_33c [3];
    int_0_ aiStack_330 [8];
    int_0_ *local_328;
    int *local_324;
    ushort *local_320;
    char *local_31c;
    TPlayerData *local_318;
    TPlayerData *PlayerData_1;
    time_t Deadline;
    ulong_0_ *OwnerIDs;
    int Crystal;
    TPlayerData *PlayerData;
    THouse *house;
    int i_1;
    time_t TimeStamp;
    int_0_ *Prices;
    ulong_0_ *NewOwnerIDs;
    ushort_0_ *HouseIDs;
    int local_2e8;
    int NumberOfEvictions;
    int local_2e0;
    int local_2dc;
    int NumberOfTransfers;
    int x;
    int y;
    int z;
    ulong local_2bc [4];
    ulong local_2ac [4];
    ulong local_29c [4];
    undefined1 local_28c [4];
    char Warning [500];
    undefined1 local_8c [4];
    char HelpWorld [60];
    ObjectType local_4c [4];
    ulong local_3c [4];
    Object local_2c;
    Object Con;
    
                    // try { // try from 08063799 to 08064aff has its CatchHandler @ 08064b16
    local_350 = 0x806379e;
    GetStartPosition(&NumberOfTransfers,&x,&y,true);
    local_350 = 0x80637b4;
    GetSpecialObject((SPECIALMEANING)local_3c);
    local_350 = 0x80637e0;
    GetMapContainer((int)local_4c,NumberOfTransfers,x);
    local_350 = 0x80637fe;
    SetObject(&local_2c,local_4c,(ulong)local_3c);
    iVar15 = 0;
    if (0 < Houses) {
        do {
            local_350 = 0x8064b00;
            pTVar9 = vector<THouse>::operator()(&House,iVar15);
            iVar16 = Houses;
            iVar15 = iVar15 + 1;
            pTVar9->Help = 0;
        } while (iVar15 < iVar16);
    }
    local_350 = 0x8063823;
    Log("houses",&DAT_080f3d40);
    local_2dc = Houses;
    iVar16 = Houses + -1;
    iVar15 = -(Houses + 0x10 + iVar16 & 0xfffffff0U);
    uVar11 = iVar16 * 4 + 0x13U & 0xfffffff0;
    NewOwnerIDs = aiStack_330 + iVar15;
    iVar16 = -(iVar16 * 0x1e + 0x2dU & 0xfffffff0);
    piVar18 = (int *)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c);
    Prices = aiStack_330 + -uVar11 + iVar15;
    TimeStamp = (time_t)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15);
    *(int_0_ **)((int)auStack_33c + iVar16 + uVar11 * -2 + iVar15 + 4) =
         aiStack_330 + iVar16 + uVar11 * -2 + iVar15;
    *(int_0_ **)((int)auStack_33c + iVar16 + uVar11 * -2 + iVar15) =
         aiStack_330 + iVar16 + -uVar11 + iVar15;
    *(int_0_ **)(&stack0xfffffcc0 + iVar16 + uVar11 * -2 + iVar15) = Prices;
    puVar5 = NewOwnerIDs;
    *(int **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) = &local_2dc;
    *(ulong_0_ **)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15) = puVar5;
    *(TQueryManagerConnection **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
         QueryManagerConnection;
    *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x80638ac;
    iVar6 = TQueryManagerConnection::transferHouses
                      (*(TQueryManagerConnection **)
                        (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                       *(int **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15),
                       *(ushort **)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15),
                       *(ulong **)(&stack0xfffffcc0 + iVar16 + uVar11 * -2 + iVar15),
                       *(char (**) [30])((int)auStack_33c + iVar16 + uVar11 * -2 + iVar15),
                       *(int **)((int)auStack_33c + iVar16 + uVar11 * -2 + iVar15 + 4));
    if (iVar6 != 0) {
        *(undefined **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &DAT_080f3d80;
        *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x80638bc;
        error(*(char **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
        pOVar14 = local_4c;
        local_4c[0].TypeID = local_2c.ObjectID;
        goto LAB_080638c5;
    }
    *(char **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) = WorldName;
    *(undefined1 **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = local_8c;
    *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x80638f2;
    AddSlashes(*(char **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
               *(char **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15));
    *(undefined4 *)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = 0;
    *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x80638fe;
    i_1 = time(*(time_t **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
    house = (THouse *)0x0;
    if (0 < local_2dc) {
        local_328 = aiStack_330 + iVar16 + -uVar11 + iVar15;
        local_320 = (ushort *)NewOwnerIDs;
        local_324 = (int *)Prices;
        do {
            *(uint *)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = (uint)*local_320;
            *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x8063949;
            PlayerData = (TPlayerData *)
                         GetHouse(*(ushort *)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
            if (PlayerData == (TPlayerData *)0x0) {
                uVar2 = *local_320;
                *(char **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                     "CollectRents: Haus mit Nummer %d existiert nicht.\n";
                *(uint *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) = (uint)uVar2;
                *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x8064ae9;
                error(*(char **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
            }
            else if ((*local_324 == 0) || (iVar6 = *(int *)(TimeStamp + (int)house * 4), iVar6 < 1))
            {
LAB_0806489a:
                *(int *)(&stack0xfffffcc0 + iVar16 + uVar11 * -2 + iVar15) = PlayerData->Cycle[4];
                uVar2 = *local_320;
                *(char **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = "houses";
                *(undefined **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) = &DAT_080f4e1a;
                *(uint *)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15) = (uint)uVar2;
                *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x80648cb;
                Log(*(char **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                    *(char **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15));
                if (*local_324 == 0) {
                    *(undefined4 *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) = 0;
                    *(TPlayerData **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                         PlayerData;
                    *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x8064a2b;
                    CleanHouse(*(THouse **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                               *(TPlayerData **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15));
                }
                PlayerData->Cycle[4] = 0;
                *(undefined1 *)(PlayerData->Cycle + 5) = 0;
                PlayerData->MaxCycle[0xc] = 0;
                PlayerData->Count[10] = 0;
                PlayerData->Count[0xb] = 1;
                if (*local_324 != 0) {
                    *(int *)(&stack0xfffffcc0 + iVar16 + uVar11 * -2 + iVar15) = *local_324;
                    uVar2 = *local_320;
                    *(char **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = "houses";
                    *(undefined **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) =
                         &DAT_080f4e32;
                    *(uint *)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15) = (uint)uVar2;
                    *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x806493c;
                    Log(*(char **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                        *(char **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15));
                    piVar4 = local_328;
                    PlayerData->Cycle[4] = *local_324;
                    PlayerData->Cycle[0xd] = i_1;
                    *(int **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                         PlayerData->Cycle + 5;
                    *(int_0_ **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) = piVar4;
                    *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x8064976;
                    strcpy(*(char **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                           *(char **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15));
                    if (*local_324 != 0) {
                        uVar2 = *local_320;
                        *(undefined1 **)((int)auStack_33c + iVar16 + uVar11 * -2 + iVar15 + 4) =
                             local_8c;
                        *(uint *)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -4) = (uint)uVar2;
                        *(undefined4 *)((int)auStack_33c + iVar16 + uVar11 * -2 + iVar15) =
                             *(undefined4 *)(TimeStamp + (int)house * 4);
                        *(int *)(&stack0xfffffcc0 + iVar16 + uVar11 * -2 + iVar15) = *local_324;
                        iVar6 = i_1;
                        *(char **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = "houses";
                        *(char **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) =
                             "bei Reset: UPDATE HouseOwners SET Termination=%d,NewOwner=%ld,Accepted=1,Price=%d WHERE World=\'%s\' AND HouseID=%d;\n"
                        ;
                        *(int *)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15) = iVar6;
                        *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x8064a10
                        ;
                        Log(*(char **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                            *(char **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15));
                        goto LAB_08063bd9;
                    }
                }
                uVar2 = *local_320;
                *(undefined1 **)(&stack0xfffffcc0 + iVar16 + uVar11 * -2 + iVar15) = local_8c;
                *(uint *)((int)auStack_33c + iVar16 + uVar11 * -2 + iVar15) = (uint)uVar2;
                iVar6 = i_1;
                *(char **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = "houses";
                *(char **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) =
                     "bei Reset: UPDATE HouseOwners SET Termination=%d,NewOwner=null,Accepted=0,Price=0 WHERE World=\'%s\' AND HouseID=%d;\n"
                ;
                *(int *)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15) = iVar6;
                *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x80649b7;
                Log(*(char **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                    *(char **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15));
            }
            else {
                *(int *)((int)auStack_33c + iVar16 + uVar11 * -2 + iVar15) = iVar6;
                *(int *)(&stack0xfffffcc0 + iVar16 + uVar11 * -2 + iVar15) = *local_324;
                uVar2 = *local_320;
                *(char **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = "houses";
                *(undefined **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) = &DAT_080f3dc0;
                *(uint *)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15) = (uint)uVar2;
                *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x80639af;
                Log(*(char **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                    *(char **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15));
                *(undefined4 *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) = 0;
                *(int *)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = *local_324;
                *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x80639c7;
                Crystal = (int)AssignPlayerPoolSlot
                                         (*(ulong *)(aiStack_330 +
                                                    iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                          (bool)(&stack0xfffffcb8)[iVar16 + uVar11 * -2 + iVar15]);
                if ((TPlayerData *)Crystal == (TPlayerData *)0x0) {
                    *(undefined **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                         &DAT_080f4420;
                }
                else {
                    local_4c[0].TypeID = local_2c.ObjectID;
                    *(ObjectType **)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15) = local_4c;
                    *(int *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) =
                         PlayerData->MagicDeltaAct[0x15];
                    *(int *)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = Crystal;
                    *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x8063a00;
                    LoadDepot(*(TPlayerData **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c)
                              ,*(int *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15),
                              *(Object **)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15));
                    local_3c[0] = local_2c.ObjectID;
                    *(ulong **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) = local_3c;
                    *(ObjectType **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = local_4c
                    ;
                    *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x8063a15;
                    GetFirstContainerObject
                              (*(Object **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
                    *(ObjectType **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = local_4c
                    ;
                    *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x8063a23;
                    iVar6 = CountMoney(*(Object **)
                                        (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
                    if (iVar6 < *(int *)(TimeStamp + (int)house * 4)) {
                        *(undefined **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) =
                             &DAT_080f3e00;
                        *(char **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = "houses";
                        *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x8063a4c
                        ;
                        Log(*(char **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                            *(char **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15));
                        pTVar1 = PlayerData;
                        *(char **)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15) =
                             "Warning!\n\nYou have not enough gold to pay\nthe price for house \"%s\".\nTherefore the transfer is cancelled."
                        ;
                        *(undefined1 **)(&stack0xfffffcc0 + iVar16 + uVar11 * -2 + iVar15) =
                             (undefined1 *)((int)&pTVar1->CharacterID + 2);
                        *(undefined4 *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) = 500;
                        *(undefined1 **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                             local_28c;
                        *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x8063a77
                        ;
                        snprintf(*(char **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                 *(size_t *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15),
                                 *(char **)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15));
                        *(undefined1 **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                             local_28c;
                        *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x8063a7f
                        ;
                        uVar7 = AddDynamicString(*(char **)(aiStack_330 +
                                                           iVar16 + uVar11 * -2 + iVar15 + -0x1c));
                        *(undefined4 *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) = 0x1a;
                        *(ulong **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = local_2ac
                        ;
                        *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x8063a97
                        ;
                        GetSpecialObject(*(SPECIALMEANING *)
                                          (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
                        local_2bc[0] = local_2c.ObjectID;
                        *(ulong **)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15) = local_2ac;
                        *(undefined4 *)(&stack0xfffffcc0 + iVar16 + uVar11 * -2 + iVar15) = 0;
                        *(ulong **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) = local_2bc;
                        *(ulong **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = local_29c
                        ;
                        *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x8063acd
                        ;
                        SetObject(*(Object **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                  *(ObjectType **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15)
                                  ,*(ulong *)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15));
                        *(ulong *)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15) = uVar7;
                        *(undefined4 *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) = 9;
                        *(ulong **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = local_29c
                        ;
                        *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x8063aea
                        ;
                        ChangeObject(*(Object **)
                                      (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                     *(INSTANCEATTRIBUTE *)
                                      (&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15),
                                     *(ulong *)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15));
                        local_2bc[0] = local_2c.ObjectID;
                        *(ulong **)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15) = local_2bc;
                        *(int *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) =
                             PlayerData->MagicDeltaAct[0x15];
                        *(int *)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = Crystal;
                        *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x8063b1b
                        ;
                        SaveDepot(*(TPlayerData **)
                                   (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                  *(int *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15),
                                  *(Object **)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15));
                        while( true ) {
                            local_2ac[0] = local_2c.ObjectID;
                            *(ulong **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) =
                                 local_2ac;
                            *(ulong **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                 local_2bc;
                            *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) =
                                 0x8063b42;
                            GetFirstContainerObject
                                      (*(Object **)
                                        (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
                            local_29c[0] = NONE.ObjectID;
                            z = NONE.ObjectID;
                            if (local_2bc[0] == NONE.ObjectID) break;
                            local_2bc[0] = local_2c.ObjectID;
                            *(ulong **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) =
                                 local_2bc;
                            *(int **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &z;
                            *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) =
                                 0x8063b79;
                            GetFirstContainerObject
                                      (*(Object **)
                                        (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
                            *(int **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &z;
                            *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) =
                                 0x8063b84;
                            DeleteObject(*(Object **)
                                          (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
                        }
                        *(int *)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = Crystal;
                        *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x8063b94
                        ;
                        ReleasePlayerPoolSlot
                                  (*(TPlayerData **)
                                    (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
                        uVar2 = *local_320;
                        *(char **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = "houses";
                        *(undefined1 **)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15) =
                             local_8c;
                        *(char **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) =
                             "bei Reset: UPDATE HouseOwners SET Termination=null,NewOwner=null,Accepted=0,Price=null WHERE World=\'%s\' AND HouseID=%d;\n"
                        ;
                        *(uint *)(&stack0xfffffcc0 + iVar16 + uVar11 * -2 + iVar15) = (uint)uVar2;
                        *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x8063bbf
                        ;
                        Log(*(char **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                            *(char **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15));
                        *(uint *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) =
                             (uint)*local_320;
                        *(TQueryManagerConnection **)
                         (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                             QueryManagerConnection;
                        *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x8063bd9
                        ;
                        TQueryManagerConnection::cancelHouseTransfer
                                  (*(TQueryManagerConnection **)
                                    (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                   *(ushort *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15));
                        goto LAB_08063bd9;
                    }
                    z = local_2c.ObjectID;
                    uVar3 = *(undefined4 *)(TimeStamp + (int)house * 4);
                    *(int **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &z;
                    *(undefined4 *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) = uVar3;
                    *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x806456d;
                    DeleteMoney(*(Object **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                *(int *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15));
                    z = local_2c.ObjectID;
                    *(int **)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15) = &z;
                    *(int *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) =
                         PlayerData->MagicDeltaAct[0x15];
                    *(int *)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = Crystal;
                    *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x8064598;
                    SaveDepot(*(TPlayerData **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c)
                              ,*(int *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15),
                              *(Object **)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15));
                    while( true ) {
                        local_2bc[0] = local_2c.ObjectID;
                        *(ulong **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) = local_2bc;
                        *(int **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &z;
                        *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x80645b9
                        ;
                        GetFirstContainerObject
                                  (*(Object **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c)
                                  );
                        local_2ac[0] = NONE.ObjectID;
                        local_29c[0] = NONE.ObjectID;
                        if (z == NONE.ObjectID) break;
                        local_2bc[0] = local_2c.ObjectID;
                        *(ulong **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) = local_2bc;
                        *(int **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &z;
                        *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x80645f6
                        ;
                        GetFirstContainerObject
                                  (*(Object **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c)
                                  );
                        *(int **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &z;
                        *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x8064607
                        ;
                        DeleteObject(*(Object **)
                                      (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
                    }
                    *(int *)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = Crystal;
                    *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x8064617;
                    ReleasePlayerPoolSlot
                              (*(TPlayerData **)
                                (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
                    *(undefined4 *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) = 0;
                    *(int *)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                         PlayerData->Cycle[4];
                    *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x8064633;
                    Crystal = (int)AssignPlayerPoolSlot
                                             (*(ulong *)(aiStack_330 +
                                                        iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                              (bool)(&stack0xfffffcb8)
                                                    [iVar16 + uVar11 * -2 + iVar15]);
                    if ((TPlayerData *)Crystal != (TPlayerData *)0x0) {
                        z = local_2c.ObjectID;
                        *(int **)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15) = &z;
                        *(int *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) =
                             PlayerData->MagicDeltaAct[0x15];
                        *(int *)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = Crystal;
                        *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x8064672
                        ;
                        LoadDepot(*(TPlayerData **)
                                   (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                  *(int *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15),
                                  *(Object **)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15));
                        for (iVar6 = *(int *)(TimeStamp + (int)house * 4); 9999 < iVar6;
                            iVar6 = iVar6 + (int)OwnerIDs * -10000) {
                            NumberOfEvictions = 100;
                            local_2e0 = iVar6 / 10000;
                            piVar13 = &NumberOfEvictions;
                            if (iVar6 / 10000 < 0x65) {
                                piVar13 = &local_2e0;
                            }
                            OwnerIDs = (ulong_0_ *)*piVar13;
                            *(undefined4 *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) = 3;
                            *(ulong **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                 local_2bc;
                            *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) =
                                 0x80646e3;
                            GetSpecialObject(*(SPECIALMEANING *)
                                              (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c))
                            ;
                            local_2ac[0] = local_2c.ObjectID;
                            *(undefined4 *)(&stack0xfffffcc0 + iVar16 + uVar11 * -2 + iVar15) = 0;
                            *(ulong **)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15) =
                                 local_2bc;
                            *(ulong **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) =
                                 local_2ac;
                            *(int **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &z;
                            *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) =
                                 0x8064719;
                            SetObject(*(Object **)
                                       (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                      *(ObjectType **)
                                       (&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15),
                                      *(ulong *)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15));
                            puVar5 = OwnerIDs;
                            *(undefined4 *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) = 2;
                            *(ulong_0_ **)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15) =
                                 puVar5;
                            *(int **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &z;
                            *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) =
                                 0x806473c;
                            ChangeObject(*(Object **)
                                          (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                         *(INSTANCEATTRIBUTE *)
                                          (&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15),
                                         *(ulong *)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15
                                                   ));
                        }
                        if (99 < iVar6) {
                            *(undefined4 *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) = 2;
                            *(ulong **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                 local_2bc;
                            *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) =
                                 0x8064a46;
                            GetSpecialObject(*(SPECIALMEANING *)
                                              (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c))
                            ;
                            local_2ac[0] = local_2c.ObjectID;
                            *(ulong **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) =
                                 local_2ac;
                            *(undefined4 *)(&stack0xfffffcc0 + iVar16 + uVar11 * -2 + iVar15) = 0;
                            *(ulong **)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15) =
                                 local_2bc;
                            *(int **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &z;
                            *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) =
                                 0x8064a7c;
                            SetObject(*(Object **)
                                       (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                      *(ObjectType **)
                                       (&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15),
                                      *(ulong *)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15));
                            *(undefined4 *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) = 2;
                            *(int *)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15) = iVar6 / 100
                            ;
                            *(int **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &z;
                            *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) =
                                 0x8064aac;
                            ChangeObject(*(Object **)
                                          (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                         *(INSTANCEATTRIBUTE *)
                                          (&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15),
                                         *(ulong *)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15
                                                   ));
                        }
                        if (0 < iVar6 % 100) {
                            *(undefined4 *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) = 1;
                            *(ulong **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                 local_2bc;
                            *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) =
                                 0x8064797;
                            GetSpecialObject(*(SPECIALMEANING *)
                                              (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c))
                            ;
                            local_2ac[0] = local_2c.ObjectID;
                            *(ulong **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) =
                                 local_2ac;
                            *(undefined4 *)(&stack0xfffffcc0 + iVar16 + uVar11 * -2 + iVar15) = 0;
                            *(ulong **)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15) =
                                 local_2bc;
                            *(int **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &z;
                            *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) =
                                 0x80647cd;
                            SetObject(*(Object **)
                                       (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                      *(ObjectType **)
                                       (&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15),
                                      *(ulong *)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15));
                            *(int *)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15) = iVar6 % 100
                            ;
                            *(undefined4 *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) = 2;
                            *(int **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &z;
                            *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) =
                                 0x80647ea;
                            ChangeObject(*(Object **)
                                          (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                         *(INSTANCEATTRIBUTE *)
                                          (&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15),
                                         *(ulong *)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15
                                                   ));
                        }
                        z = local_2c.ObjectID;
                        *(int **)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15) = &z;
                        *(int *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) =
                             PlayerData->MagicDeltaAct[0x15];
                        *(int *)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = Crystal;
                        *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x806481b
                        ;
                        SaveDepot(*(TPlayerData **)
                                   (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                  *(int *)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15),
                                  *(Object **)(&stack0xfffffcbc + iVar16 + uVar11 * -2 + iVar15));
                        while( true ) {
                            local_2bc[0] = local_2c.ObjectID;
                            *(ulong **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) =
                                 local_2bc;
                            *(int **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &z;
                            *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) =
                                 0x806483c;
                            GetFirstContainerObject
                                      (*(Object **)
                                        (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
                            local_2ac[0] = NONE.ObjectID;
                            local_29c[0] = NONE.ObjectID;
                            if (z == NONE.ObjectID) break;
                            local_2bc[0] = local_2c.ObjectID;
                            *(ulong **)(&stack0xfffffcb8 + iVar16 + uVar11 * -2 + iVar15) =
                                 local_2bc;
                            *(int **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &z;
                            *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) =
                                 0x8064879;
                            GetFirstContainerObject
                                      (*(Object **)
                                        (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
                            *(int **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &z;
                            *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) =
                                 0x806488a;
                            DeleteObject(*(Object **)
                                          (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
                        }
                        *(int *)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = Crystal;
                        *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x806489a
                        ;
                        ReleasePlayerPoolSlot
                                  (*(TPlayerData **)
                                    (aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
                        goto LAB_0806489a;
                    }
                    *(undefined **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                         &DAT_080f43e0;
                }
                *(undefined4 *)((int)&local_350 + iVar16 + uVar11 * -2 + iVar15) = 0x8064abd;
                error(*(char **)(aiStack_330 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
            }
LAB_08063bd9:
            house = (THouse *)((int)&house->ID + 1);
            local_320 = local_320 + 1;
            local_324 = local_324 + 1;
            local_328 = local_328 + 0x1e;
        } while ((int)house < local_2dc);
    }
    local_2e8 = Houses;
    iVar6 = -(Houses * 4 + 0xfU & 0xfffffff0);
    piVar18 = (int *)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c);
    Deadline = (time_t)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15);
    *(int_0_ **)(&stack0xfffffcc0 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
         aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15;
    puVar5 = NewOwnerIDs;
    *(int **)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = &local_2e8;
    *(ulong_0_ **)(&stack0xfffffcbc + iVar6 + iVar16 + uVar11 * -2 + iVar15) = puVar5;
    *(TQueryManagerConnection **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
         QueryManagerConnection;
    *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = 0x8063c4c;
    iVar8 = TQueryManagerConnection::evictFreeAccounts
                      (*(TQueryManagerConnection **)
                        (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                       *(int **)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15),
                       *(ushort **)(&stack0xfffffcbc + iVar6 + iVar16 + uVar11 * -2 + iVar15),
                       *(ulong **)(&stack0xfffffcc0 + iVar6 + iVar16 + uVar11 * -2 + iVar15));
    if (iVar8 == 0) {
        iVar8 = 0;
        if (0 < local_2e8) {
            do {
                *(uint *)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                     (uint)*(ushort *)(NewOwnerIDs + iVar8 * 2);
                *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = 0x8064480
                ;
                pTVar9 = GetHouse(*(ushort *)
                                   (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
                if (pTVar9 == (THouse *)0x0) {
                    uVar2 = *(ushort *)(NewOwnerIDs + iVar8 * 2);
                    *(char **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                         "CollectRents: Haus mit Nummer %d existiert nicht.\n";
                    *(uint *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                         (uint)uVar2;
                    *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                         0x8064535;
                    error(*(char **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
                }
                else {
                    uVar2 = *(ushort *)(NewOwnerIDs + iVar8 * 2);
                    *(char **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                         "houses";
                    *(char **)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                         "Account von Haus %d ist nicht mehr bezahlt.\n";
                    *(uint *)(&stack0xfffffcbc + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                         (uint)uVar2;
                    *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                         0x80644ac;
                    Log(*(char **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                        *(char **)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15));
                    if (*(ulong *)(Deadline + iVar8 * 4) == pTVar9->OwnerID) {
                        *(undefined4 *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                             0;
                        *(THouse **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                             pTVar9;
                        *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                             0x80644ef;
                        CleanHouse(*(THouse **)
                                    (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                   *(TPlayerData **)
                                    (&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15));
                        pTVar9->OwnerName[0] = '\0';
                        pTVar9->OwnerID = 0;
                        pTVar9->Subowners = 0;
                        pTVar9->Guests = 0;
                        pTVar9->Help = 1;
                    }
                    else {
                        *(undefined **)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                             &DAT_080f4260;
                        *(char **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                             "houses";
                        *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                             0x80644d1;
                        Log(*(char **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                            *(char **)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15));
                    }
                }
                iVar8 = iVar8 + 1;
            } while (iVar8 < local_2e8);
        }
        local_2e8 = Houses;
        *(ulong_0_ **)(&stack0xfffffcbc + iVar6 + iVar16 + uVar11 * -2 + iVar15) = NewOwnerIDs;
        *(int **)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = &local_2e8;
        *(TQueryManagerConnection **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
             QueryManagerConnection;
        *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = 0x8063c8e;
        iVar8 = TQueryManagerConnection::evictDeletedCharacters
                          (*(TQueryManagerConnection **)
                            (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                           *(int **)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15),
                           *(ushort **)(&stack0xfffffcbc + iVar6 + iVar16 + uVar11 * -2 + iVar15));
        if (iVar8 != 0) {
            *(undefined **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                 &DAT_080f41e0;
            goto LAB_08064464;
        }
        iVar8 = 0;
        if (0 < local_2e8) {
            do {
                *(uint *)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                     (uint)*(ushort *)(NewOwnerIDs + iVar8 * 2);
                *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = 0x80643d1
                ;
                pTVar9 = GetHouse(*(ushort *)
                                   (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
                if (pTVar9 == (THouse *)0x0) {
                    uVar2 = *(ushort *)(NewOwnerIDs + iVar8 * 2);
                    *(char **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                         "CollectRents: Haus mit Nummer %d existiert nicht.\n";
                    *(uint *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                         (uint)uVar2;
                    *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                         0x806445b;
                    error(*(char **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
                }
                else {
                    uVar2 = *(ushort *)(NewOwnerIDs + iVar8 * 2);
                    *(char **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                         "houses";
                    *(undefined **)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                         &DAT_080f41a0;
                    *(uint *)(&stack0xfffffcbc + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                         (uint)uVar2;
                    *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                         0x80643f9;
                    Log(*(char **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                        *(char **)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15));
                    *(undefined4 *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = 0;
                    *(THouse **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                         pTVar9;
                    *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                         0x8064409;
                    CleanHouse(*(THouse **)
                                (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                               *(TPlayerData **)
                                (&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15));
                    pTVar9->OwnerName[0] = '\0';
                    pTVar9->OwnerID = 0;
                    pTVar9->Subowners = 0;
                    pTVar9->Guests = 0;
                    pTVar9->Help = 1;
                }
                iVar8 = iVar8 + 1;
            } while (iVar8 < local_2e8);
        }
        iVar19 = 0;
        iVar8 = 0;
        if (0 < Houses) {
            do {
                *(int *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = iVar8;
                *(vector<THouse> **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                     &House;
                *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = 0x806434e
                ;
                pTVar9 = vector<THouse>::operator()
                                   (*(vector<THouse> **)
                                     (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                    *(int *)(&stack0xfffffcb8 +
                                            iVar6 + iVar16 + uVar11 * -2 + iVar15));
                if (pTVar9->GuildHouse != false) {
                    *(int *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = iVar8;
                    *(vector<THouse> **)
                     (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &House;
                    *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                         0x8064376;
                    pTVar9 = vector<THouse>::operator()
                                       (*(vector<THouse> **)
                                         (aiStack_330 +
                                         iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                        *(int *)(&stack0xfffffcb8 +
                                                iVar6 + iVar16 + uVar11 * -2 + iVar15));
                    if (pTVar9->OwnerID != 0) {
                        *(int *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = iVar8;
                        *(vector<THouse> **)
                         (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &House;
                        *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                             0x8064390;
                        pTVar9 = vector<THouse>::operator()
                                           (*(vector<THouse> **)
                                             (aiStack_330 +
                                             iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                            *(int *)(&stack0xfffffcb8 +
                                                    iVar6 + iVar16 + uVar11 * -2 + iVar15));
                        *(ushort *)(NewOwnerIDs + iVar19 * 2) = pTVar9->ID;
                        *(int *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = iVar8;
                        *(vector<THouse> **)
                         (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &House;
                        *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                             0x80643ad;
                        pTVar9 = vector<THouse>::operator()
                                           (*(vector<THouse> **)
                                             (aiStack_330 +
                                             iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                            *(int *)(&stack0xfffffcb8 +
                                                    iVar6 + iVar16 + uVar11 * -2 + iVar15));
                        *(ulong *)(Deadline + iVar19 * 4) = pTVar9->OwnerID;
                        iVar19 = iVar19 + 1;
                    }
                }
                iVar8 = iVar8 + 1;
            } while (iVar8 < Houses);
        }
        if (0 < iVar19) {
            *(time_t *)((int)auStack_33c + iVar6 + iVar16 + uVar11 * -2 + iVar15) = Deadline;
            puVar5 = NewOwnerIDs;
            *(int *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = iVar19;
            *(int **)(&stack0xfffffcbc + iVar6 + iVar16 + uVar11 * -2 + iVar15) = &local_2e8;
            *(ulong_0_ **)(&stack0xfffffcc0 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = puVar5;
            *(TQueryManagerConnection **)
             (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = QueryManagerConnection;
            *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = 0x8063ce8;
            iVar8 = TQueryManagerConnection::evictExGuildleaders
                              (*(TQueryManagerConnection **)
                                (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                               *(int *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15),
                               *(int **)(&stack0xfffffcbc + iVar6 + iVar16 + uVar11 * -2 + iVar15),
                               *(ushort **)
                                (&stack0xfffffcc0 + iVar6 + iVar16 + uVar11 * -2 + iVar15),
                               *(ulong **)((int)auStack_33c + iVar6 + iVar16 + uVar11 * -2 + iVar15)
                              );
            if (iVar8 != 0) {
                *(undefined **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                     &DAT_080f4160;
                *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = 0x8064331
                ;
                error(*(char **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
                local_2e8 = 0;
            }
            iVar8 = 0;
            if (0 < local_2e8) {
                do {
                    *(uint *)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                         (uint)*(ushort *)(NewOwnerIDs + iVar8 * 2);
                    *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                         0x8064299;
                    pTVar9 = GetHouse(*(ushort *)
                                       (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c)
                                     );
                    if (pTVar9 == (THouse *)0x0) {
                        uVar2 = *(ushort *)(NewOwnerIDs + iVar8 * 2);
                        *(char **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                             "CollectRents: Haus mit Nummer %d existiert nicht.\n";
                        *(uint *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                             (uint)uVar2;
                        *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                             0x8064323;
                        error(*(char **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c
                                        ));
                    }
                    else {
                        uVar2 = *(ushort *)(NewOwnerIDs + iVar8 * 2);
                        *(char **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                             "houses";
                        *(undefined **)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                             &DAT_080f40e0;
                        *(uint *)(&stack0xfffffcbc + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                             (uint)uVar2;
                        *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                             0x80642c1;
                        Log(*(char **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                            *(char **)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15));
                        *(undefined4 *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                             0;
                        *(THouse **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                             pTVar9;
                        *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                             0x80642d1;
                        CleanHouse(*(THouse **)
                                    (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                   *(TPlayerData **)
                                    (&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15));
                        pTVar9->OwnerName[0] = '\0';
                        pTVar9->OwnerID = 0;
                        pTVar9->Subowners = 0;
                        pTVar9->Guests = 0;
                        pTVar9->Help = 1;
                    }
                    iVar8 = iVar8 + 1;
                } while (iVar8 < local_2e8);
            }
        }
        iVar8 = 0;
        if (0 < Houses) {
            do {
                *(int *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = iVar8;
                *(vector<THouse> **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                     &House;
                *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = 0x8064223
                ;
                pTVar9 = vector<THouse>::operator()
                                   (*(vector<THouse> **)
                                     (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                    *(int *)(&stack0xfffffcb8 +
                                            iVar6 + iVar16 + uVar11 * -2 + iVar15));
                if (pTVar9->Help == 1) {
                    *(int *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = iVar8;
                    *(vector<THouse> **)
                     (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &House;
                    *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                         0x806424a;
                    pTVar9 = vector<THouse>::operator()
                                       (*(vector<THouse> **)
                                         (aiStack_330 +
                                         iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                        *(int *)(&stack0xfffffcb8 +
                                                iVar6 + iVar16 + uVar11 * -2 + iVar15));
                    *(uint *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                         (uint)pTVar9->ID;
                    *(TQueryManagerConnection **)
                     (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                         QueryManagerConnection;
                    *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                         0x806425e;
                    iVar19 = TQueryManagerConnection::deleteHouseOwner
                                       (*(TQueryManagerConnection **)
                                         (aiStack_330 +
                                         iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                        *(ushort *)
                                         (&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15))
                    ;
                    if (iVar19 != 0) {
                        *(int *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = iVar8;
                        *(vector<THouse> **)
                         (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &House;
                        *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                             0x8064272;
                        pTVar9 = vector<THouse>::operator()
                                           (*(vector<THouse> **)
                                             (aiStack_330 +
                                             iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                            *(int *)(&stack0xfffffcb8 +
                                                    iVar6 + iVar16 + uVar11 * -2 + iVar15));
                        uVar2 = pTVar9->ID;
                        *(char **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                             "CollectRents: Kann Haus %d nicht aus HouseOwners austragen.\n";
                        *(uint *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                             (uint)uVar2;
                        *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                             0x8064285;
                        error(*(char **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c
                                        ));
                    }
                }
                iVar8 = iVar8 + 1;
            } while (iVar8 < Houses);
        }
        *(char **)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
             "Treibe Mieten ein...\n";
        *(char **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = "houses";
        *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = 0x8063d21;
        Log(*(char **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
            *(char **)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15));
        iVar8 = 0;
        if (0 < Houses) {
            do {
                *(int *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = iVar8;
                *(vector<THouse> **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                     &House;
                *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = 0x8063d3b
                ;
                pTVar9 = vector<THouse>::operator()
                                   (*(vector<THouse> **)
                                     (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                    *(int *)(&stack0xfffffcb8 +
                                            iVar6 + iVar16 + uVar11 * -2 + iVar15));
                if (pTVar9->OwnerID != 0) {
                    *(int *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = iVar8;
                    *(vector<THouse> **)
                     (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &House;
                    *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                         0x8063d72;
                    pTVar9 = vector<THouse>::operator()
                                       (*(vector<THouse> **)
                                         (aiStack_330 +
                                         iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                        *(int *)(&stack0xfffffcb8 +
                                                iVar6 + iVar16 + uVar11 * -2 + iVar15));
                    if (pTVar9->PaidUntil <= i_1) {
                        *(int *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = iVar8;
                        *(vector<THouse> **)
                         (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &House;
                        *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                             0x8063d90;
                        pTVar9 = vector<THouse>::operator()
                                           (*(vector<THouse> **)
                                             (aiStack_330 +
                                             iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                            *(int *)(&stack0xfffffcb8 +
                                                    iVar6 + iVar16 + uVar11 * -2 + iVar15));
                        *(int *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = iVar8;
                        *(vector<THouse> **)
                         (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &House;
                        *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                             0x8063da2;
                        pTVar10 = vector<THouse>::operator()
                                            (*(vector<THouse> **)
                                              (aiStack_330 +
                                              iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                             *(int *)(&stack0xfffffcb8 +
                                                     iVar6 + iVar16 + uVar11 * -2 + iVar15));
                        uVar2 = pTVar10->ID;
                        uVar7 = pTVar9->OwnerID;
                        *(char **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                             "houses";
                        *(undefined **)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                             &DAT_080f3f40;
                        *(ulong *)(&stack0xfffffcc0 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = uVar7
                        ;
                        *(uint *)(&stack0xfffffcbc + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                             (uint)uVar2;
                        *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                             0x8063dc7;
                        Log(*(char **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                            *(char **)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15));
                        *(int *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = iVar8;
                        *(vector<THouse> **)
                         (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &House;
                        *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                             0x8063dd7;
                        pTVar9 = vector<THouse>::operator()
                                           (*(vector<THouse> **)
                                             (aiStack_330 +
                                             iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                            *(int *)(&stack0xfffffcb8 +
                                                    iVar6 + iVar16 + uVar11 * -2 + iVar15));
                        HouseIDs = (ushort_0_ *)(pTVar9->PaidUntil + 0x93a80);
                        ppuVar17 = (ushort_0_ **)&PaymentExtension;
                        if (PaymentExtension <= (int)HouseIDs) {
                            ppuVar17 = &HouseIDs;
                        }
                        PlayerData_1 = (TPlayerData *)*ppuVar17;
                        *(int *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = iVar8;
                        *(vector<THouse> **)
                         (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &House;
                        *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                             0x8063e14;
                        pTVar9 = vector<THouse>::operator()
                                           (*(vector<THouse> **)
                                             (aiStack_330 +
                                             iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                            *(int *)(&stack0xfffffcb8 +
                                                    iVar6 + iVar16 + uVar11 * -2 + iVar15));
                        *(undefined4 *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                             0;
                        *(ulong *)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                             pTVar9->OwnerID;
                        *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                             0x8063e2a;
                        local_318 = AssignPlayerPoolSlot
                                              (*(ulong *)(aiStack_330 +
                                                         iVar6 + iVar16 + uVar11 * -2 + iVar15 +
                                                         -0x1c),
                                               (bool)(&stack0xfffffcb8)
                                                     [iVar6 + iVar16 + uVar11 * -2 + iVar15]);
                        if (local_318 == (TPlayerData *)0x0) {
                            *(undefined **)
                             (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                 &DAT_080f4060;
                            *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15)
                                 = 0x806420e;
                            error(*(char **)(aiStack_330 +
                                            iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
                        }
                        else {
                            z = local_2c.ObjectID;
                            *(int *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                 iVar8;
                            *(vector<THouse> **)
                             (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &House;
                            *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15)
                                 = 0x8063e51;
                            pTVar9 = vector<THouse>::operator()
                                               (*(vector<THouse> **)
                                                 (aiStack_330 +
                                                 iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                                *(int *)(&stack0xfffffcb8 +
                                                        iVar6 + iVar16 + uVar11 * -2 + iVar15));
                            *(int **)(&stack0xfffffcbc + iVar6 + iVar16 + uVar11 * -2 + iVar15) = &z
                            ;
                            *(int *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                 pTVar9->DepotNr;
                            *(TPlayerData **)
                             (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                 local_318;
                            *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15)
                                 = 0x8063e73;
                            LoadDepot(*(TPlayerData **)
                                       (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c)
                                      ,*(int *)(&stack0xfffffcb8 +
                                               iVar6 + iVar16 + uVar11 * -2 + iVar15),
                                      *(Object **)
                                       (&stack0xfffffcbc + iVar6 + iVar16 + uVar11 * -2 + iVar15));
                            local_2bc[0] = local_2c.ObjectID;
                            *(ulong **)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                 local_2bc;
                            *(int **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                 &z;
                            *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15)
                                 = 0x8063e94;
                            GetFirstContainerObject
                                      (*(Object **)
                                        (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c
                                        ));
                            *(int **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                 &z;
                            *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15)
                                 = 0x8063ea5;
                            iVar19 = CountMoney(*(Object **)
                                                 (aiStack_330 +
                                                 iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
                            *(int *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                 iVar8;
                            *(vector<THouse> **)
                             (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &House;
                            *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15)
                                 = 0x8063eb7;
                            pTVar9 = vector<THouse>::operator()
                                               (*(vector<THouse> **)
                                                 (aiStack_330 +
                                                 iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                                *(int *)(&stack0xfffffcb8 +
                                                        iVar6 + iVar16 + uVar11 * -2 + iVar15));
                            if (iVar19 < (int)pTVar9->Rent) {
                                if (i_1 < (int)PlayerData_1) {
                                    *(undefined **)
                                     (&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                         &DAT_080f4dca;
                                    *(char **)(aiStack_330 +
                                              iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                         "houses";
                                    *(undefined4 *)
                                     ((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                         0x8063ee9;
                                    Log(*(char **)(aiStack_330 +
                                                  iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                        *(char **)(&stack0xfffffcb8 +
                                                  iVar6 + iVar16 + uVar11 * -2 + iVar15));
                                    pTVar1 = (TPlayerData *)((int)PlayerData_1 - i_1);
                                    PlayerData_1 = pTVar1;
                                    *(vector<THouse> **)
                                     (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                         &House;
                                    *(int *)(&stack0xfffffcb8 +
                                            iVar6 + iVar16 + uVar11 * -2 + iVar15) = iVar8;
                                    iVar19 = (int)(pTVar1[-1].Title + 0x18) / 0x15180 + 1;
                                    *(undefined4 *)
                                     ((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                         0x8063f29;
                                    pTVar9 = vector<THouse>::operator()
                                                       (*(vector<THouse> **)
                                                         (aiStack_330 +
                                                         iVar6 + iVar16 + uVar11 * -2 + iVar15 +
                                                         -0x1c),*(int *)(&stack0xfffffcb8 +
                                                                        iVar6 + iVar16 + uVar11 * -2
                                                                                         + iVar15));
                                    local_31c = pTVar9->Name;
                                    *(int *)(&stack0xfffffcb8 +
                                            iVar6 + iVar16 + uVar11 * -2 + iVar15) = iVar8;
                                    *(vector<THouse> **)
                                     (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                         &House;
                                    *(undefined4 *)
                                     ((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                         0x8063f42;
                                    pTVar9 = vector<THouse>::operator()
                                                       (*(vector<THouse> **)
                                                         (aiStack_330 +
                                                         iVar6 + iVar16 + uVar11 * -2 + iVar15 +
                                                         -0x1c),*(int *)(&stack0xfffffcb8 +
                                                                        iVar6 + iVar16 + uVar11 * -2
                                                                                         + iVar15));
                                    *(int *)((int)auStack_33c +
                                            iVar6 + iVar16 + uVar11 * -2 + iVar15 + 4) = iVar19;
                                    pcVar12 = "";
                                    if (iVar19 != 1) {
                                        pcVar12 = "s";
                                    }
                                    *(char **)(aiStack_330 +
                                              iVar6 + iVar16 + uVar11 * -2 + iVar15 + -4) = pcVar12;
                                    *(char **)((int)auStack_33c +
                                              iVar6 + iVar16 + uVar11 * -2 + iVar15) = local_31c;
                                    uVar7 = pTVar9->Rent;
                                    *(undefined1 **)
                                     (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                         local_28c;
                                    *(char **)(&stack0xfffffcbc +
                                              iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                         "Warning!\n\nThe monthly rent of %ld gold\nfor your house \"%s\"\nis payable. Have it available\nwithin %d day%s, or you will\nlose this house."
                                    ;
                                    *(undefined4 *)
                                     (&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                         500;
                                    *(ulong *)(&stack0xfffffcc0 +
                                              iVar6 + iVar16 + uVar11 * -2 + iVar15) = uVar7;
                                    *(undefined4 *)
                                     ((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                         0x8063f8c;
                                    snprintf(*(char **)(aiStack_330 +
                                                       iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c
                                                       ),
                                             *(size_t *)
                                              (&stack0xfffffcb8 +
                                              iVar6 + iVar16 + uVar11 * -2 + iVar15),
                                             *(char **)(&stack0xfffffcbc +
                                                       iVar6 + iVar16 + uVar11 * -2 + iVar15));
                                    *(undefined1 **)
                                     (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                         local_28c;
                                    *(undefined4 *)
                                     ((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                         0x8063f94;
                                    uVar7 = AddDynamicString(*(char **)(aiStack_330 +
                                                                       iVar6 + iVar16 + uVar11 * -2
                                                                                        + iVar15 +
                                                                       -0x1c));
                                    *(undefined4 *)
                                     (&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                         0x1a;
                                    *(ulong **)
                                     (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                         local_29c;
                                    *(undefined4 *)
                                     ((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                         0x8063fac;
                                    GetSpecialObject(*(SPECIALMEANING *)
                                                      (aiStack_330 +
                                                      iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c)
                                                    );
                                    local_4c[0].TypeID = local_2c.ObjectID;
                                    *(ulong **)
                                     (&stack0xfffffcbc + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                         local_29c;
                                    *(undefined4 *)
                                     (&stack0xfffffcc0 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = 0;
                                    *(ObjectType **)
                                     (&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                         local_4c;
                                    *(ulong **)
                                     (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                         local_2ac;
                                    *(undefined4 *)
                                     ((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                         0x8063fdc;
                                    SetObject(*(Object **)
                                               (aiStack_330 +
                                               iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                              *(ObjectType **)
                                               (&stack0xfffffcb8 +
                                               iVar6 + iVar16 + uVar11 * -2 + iVar15),
                                              *(ulong *)(&stack0xfffffcbc +
                                                        iVar6 + iVar16 + uVar11 * -2 + iVar15));
                                    *(ulong *)(&stack0xfffffcbc +
                                              iVar6 + iVar16 + uVar11 * -2 + iVar15) = uVar7;
                                    *(undefined4 *)
                                     (&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = 9;
                                    *(ulong **)
                                     (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                         local_2ac;
                                    *(undefined4 *)
                                     ((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                         0x8063ff9;
                                    ChangeObject(*(Object **)
                                                  (aiStack_330 +
                                                  iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                                 *(INSTANCEATTRIBUTE *)
                                                  (&stack0xfffffcb8 +
                                                  iVar6 + iVar16 + uVar11 * -2 + iVar15),
                                                 *(ulong *)(&stack0xfffffcbc +
                                                           iVar6 + iVar16 + uVar11 * -2 + iVar15));
                                    local_2ac[0] = local_2c.ObjectID;
                                    *(int *)(&stack0xfffffcb8 +
                                            iVar6 + iVar16 + uVar11 * -2 + iVar15) = iVar8;
                                    *(vector<THouse> **)
                                     (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                         &House;
                                    *(undefined4 *)
                                     ((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                         0x8064012;
                                    pTVar9 = vector<THouse>::operator()
                                                       (*(vector<THouse> **)
                                                         (aiStack_330 +
                                                         iVar6 + iVar16 + uVar11 * -2 + iVar15 +
                                                         -0x1c),*(int *)(&stack0xfffffcb8 +
                                                                        iVar6 + iVar16 + uVar11 * -2
                                                                                         + iVar15));
                                    *(ulong **)
                                     (&stack0xfffffcbc + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                         local_2ac;
                                    *(int *)(&stack0xfffffcb8 +
                                            iVar6 + iVar16 + uVar11 * -2 + iVar15) = pTVar9->DepotNr
                                    ;
                                    *(TPlayerData **)
                                     (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                         local_318;
                                    *(undefined4 *)
                                     ((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                         0x8064034;
                                    SaveDepot(*(TPlayerData **)
                                               (aiStack_330 +
                                               iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                              *(int *)(&stack0xfffffcb8 +
                                                      iVar6 + iVar16 + uVar11 * -2 + iVar15),
                                              *(Object **)
                                               (&stack0xfffffcbc +
                                               iVar6 + iVar16 + uVar11 * -2 + iVar15));
                                }
                                else {
                                    *(char **)(&stack0xfffffcb8 +
                                              iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                         "Mieter wird hinausgeworfen.\n";
                                    *(char **)(aiStack_330 +
                                              iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                         "houses";
                                    *(undefined4 *)
                                     ((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                         0x80640cc;
                                    Log(*(char **)(aiStack_330 +
                                                  iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                        *(char **)(&stack0xfffffcb8 +
                                                  iVar6 + iVar16 + uVar11 * -2 + iVar15));
                                    *(int *)(&stack0xfffffcb8 +
                                            iVar6 + iVar16 + uVar11 * -2 + iVar15) = iVar8;
                                    *(vector<THouse> **)
                                     (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                         &House;
                                    *(undefined4 *)
                                     ((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                         0x80640dc;
                                    pTVar9 = vector<THouse>::operator()
                                                       (*(vector<THouse> **)
                                                         (aiStack_330 +
                                                         iVar6 + iVar16 + uVar11 * -2 + iVar15 +
                                                         -0x1c),*(int *)(&stack0xfffffcb8 +
                                                                        iVar6 + iVar16 + uVar11 * -2
                                                                                         + iVar15));
                                    *(undefined4 *)
                                     (&stack0xfffffcbc + iVar6 + iVar16 + uVar11 * -2 + iVar15) = 0;
                                    *(ulong *)(&stack0xfffffcb8 +
                                              iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                         pTVar9->OwnerID;
                                    *(TQueryManagerConnection **)
                                     (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                         QueryManagerConnection;
                                    *(undefined4 *)
                                     ((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                         0x80640fb;
                                    iVar19 = TQueryManagerConnection::excludeFromAuctions
                                                       (*(TQueryManagerConnection **)
                                                         (aiStack_330 +
                                                         iVar6 + iVar16 + uVar11 * -2 + iVar15 +
                                                         -0x1c),*(ulong *)(&stack0xfffffcb8 +
                                                                          iVar6 + iVar16 + uVar11 * 
                                                  -2 + iVar15),
                                                  (bool)(&stack0xfffffcbc)
                                                        [iVar6 + iVar16 + uVar11 * -2 + iVar15]);
                                    if (iVar19 != 0) {
                                        *(char **)(aiStack_330 +
                                                  iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                             "CollectRents: Kann Mieter nicht verbannen.\n";
                                        *(undefined4 *)
                                         ((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                             0x8064161;
                                        error(*(char **)(aiStack_330 +
                                                        iVar6 + iVar16 + uVar11 * -2 + iVar15 +
                                                        -0x1c));
                                    }
                                    *(int *)(&stack0xfffffcb8 +
                                            iVar6 + iVar16 + uVar11 * -2 + iVar15) = iVar8;
                                    *(vector<THouse> **)
                                     (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                         &House;
                                    *(undefined4 *)
                                     ((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                         0x806410f;
                                    pTVar9 = vector<THouse>::operator()
                                                       (*(vector<THouse> **)
                                                         (aiStack_330 +
                                                         iVar6 + iVar16 + uVar11 * -2 + iVar15 +
                                                         -0x1c),*(int *)(&stack0xfffffcb8 +
                                                                        iVar6 + iVar16 + uVar11 * -2
                                                                                         + iVar15));
                                    pTVar1 = local_318;
                                    *(THouse **)
                                     (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                         pTVar9;
                                    *(TPlayerData **)
                                     (&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                         pTVar1;
                                    *(undefined4 *)
                                     ((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                         0x8064121;
                                    CleanHouse(*(THouse **)
                                                (aiStack_330 +
                                                iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                               *(TPlayerData **)
                                                (&stack0xfffffcb8 +
                                                iVar6 + iVar16 + uVar11 * -2 + iVar15));
                                    *(int *)(&stack0xfffffcb8 +
                                            iVar6 + iVar16 + uVar11 * -2 + iVar15) = iVar8;
                                    *(vector<THouse> **)
                                     (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                         &House;
                                    *(undefined4 *)
                                     ((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                         0x8064131;
                                    pTVar9 = vector<THouse>::operator()
                                                       (*(vector<THouse> **)
                                                         (aiStack_330 +
                                                         iVar6 + iVar16 + uVar11 * -2 + iVar15 +
                                                         -0x1c),*(int *)(&stack0xfffffcb8 +
                                                                        iVar6 + iVar16 + uVar11 * -2
                                                                                         + iVar15));
                                    pTVar9->OwnerName[0] = '\0';
                                    pTVar9->OwnerID = 0;
                                    pTVar9->Subowners = 0;
                                    pTVar9->Guests = 0;
                                }
                            }
                            else {
                                *(undefined **)
                                 (&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                     &DAT_080f4dff;
                                *(char **)(aiStack_330 +
                                          iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = "houses";
                                *(undefined4 *)
                                 ((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                     0x8064177;
                                Log(*(char **)(aiStack_330 +
                                              iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                    *(char **)(&stack0xfffffcb8 +
                                              iVar6 + iVar16 + uVar11 * -2 + iVar15));
                                *(int *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                     iVar8;
                                *(vector<THouse> **)
                                 (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                     &House;
                                *(undefined4 *)
                                 ((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                     0x8064187;
                                pTVar9 = vector<THouse>::operator()
                                                   (*(vector<THouse> **)
                                                     (aiStack_330 +
                                                     iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                                    *(int *)(&stack0xfffffcb8 +
                                                            iVar6 + iVar16 + uVar11 * -2 + iVar15));
                                local_2ac[0] = local_2c.ObjectID;
                                uVar7 = pTVar9->Rent;
                                *(ulong **)
                                 (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                     local_2ac;
                                *(ulong *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15)
                                     = uVar7;
                                *(undefined4 *)
                                 ((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                     0x80641a8;
                                DeleteMoney(*(Object **)
                                             (aiStack_330 +
                                             iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                            *(int *)(&stack0xfffffcb8 +
                                                    iVar6 + iVar16 + uVar11 * -2 + iVar15));
                                local_2ac[0] = local_2c.ObjectID;
                                *(int *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                     iVar8;
                                *(vector<THouse> **)
                                 (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                     &House;
                                *(undefined4 *)
                                 ((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                     0x80641c1;
                                pTVar9 = vector<THouse>::operator()
                                                   (*(vector<THouse> **)
                                                     (aiStack_330 +
                                                     iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                                    *(int *)(&stack0xfffffcb8 +
                                                            iVar6 + iVar16 + uVar11 * -2 + iVar15));
                                *(ulong **)
                                 (&stack0xfffffcbc + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                     local_2ac;
                                *(int *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                     pTVar9->DepotNr;
                                *(TPlayerData **)
                                 (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                     local_318;
                                *(undefined4 *)
                                 ((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                     0x80641e3;
                                SaveDepot(*(TPlayerData **)
                                           (aiStack_330 +
                                           iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                          *(int *)(&stack0xfffffcb8 +
                                                  iVar6 + iVar16 + uVar11 * -2 + iVar15),
                                          *(Object **)
                                           (&stack0xfffffcbc + iVar6 + iVar16 + uVar11 * -2 + iVar15
                                           ));
                                *(int *)(&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                     iVar8;
                                *(vector<THouse> **)
                                 (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                     &House;
                                *(undefined4 *)
                                 ((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                     0x80641f3;
                                pTVar9 = vector<THouse>::operator()
                                                   (*(vector<THouse> **)
                                                     (aiStack_330 +
                                                     iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c),
                                                    *(int *)(&stack0xfffffcb8 +
                                                            iVar6 + iVar16 + uVar11 * -2 + iVar15));
                                pTVar9->PaidUntil = pTVar9->PaidUntil + 0x278d00;
                            }
                            while( true ) {
                                local_2bc[0] = local_2c.ObjectID;
                                *(ulong **)
                                 (&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                     local_2bc;
                                *(int **)(aiStack_330 +
                                         iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &z;
                                *(undefined4 *)
                                 ((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                     0x8064055;
                                GetFirstContainerObject
                                          (*(Object **)
                                            (aiStack_330 +
                                            iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
                                local_2ac[0] = NONE.ObjectID;
                                local_29c[0] = NONE.ObjectID;
                                if (z == NONE.ObjectID) break;
                                local_2bc[0] = local_2c.ObjectID;
                                *(ulong **)
                                 (&stack0xfffffcb8 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                     local_2bc;
                                *(int **)(aiStack_330 +
                                         iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &z;
                                *(undefined4 *)
                                 ((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                     0x8064092;
                                GetFirstContainerObject
                                          (*(Object **)
                                            (aiStack_330 +
                                            iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
                                *(int **)(aiStack_330 +
                                         iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) = &z;
                                *(undefined4 *)
                                 ((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) =
                                     0x80640a3;
                                DeleteObject(*(Object **)
                                              (aiStack_330 +
                                              iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
                            }
                            *(TPlayerData **)
                             (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
                                 local_318;
                            *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15)
                                 = 0x80640b3;
                            ReleasePlayerPoolSlot
                                      (*(TPlayerData **)
                                        (aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c
                                        ));
                        }
                    }
                }
                iVar8 = iVar8 + 1;
            } while (iVar8 < Houses);
        }
    }
    else {
        *(char **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c) =
             "CollectRents: Kann Zahlungsdaten nicht ermitteln.\n";
LAB_08064464:
        *(undefined4 *)((int)&local_350 + iVar6 + iVar16 + uVar11 * -2 + iVar15) = 0x8064469;
        error(*(char **)(aiStack_330 + iVar6 + iVar16 + uVar11 * -2 + iVar15 + -0x1c));
    }
    pOVar14 = (ObjectType *)&z;
    z = local_2c.ObjectID;
LAB_080638c5:
    *piVar18 = (int)pOVar14;
    piVar18[-1] = 0x80638cd;
    DeleteObject((Object *)*piVar18);
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void StartAuctions(void)

{
    ushort uVar1;
    ulong uVar2;
    int iVar3;
    int iVar4;
    char_0__30_ *OwnerNames;
    int iVar5;
    THouse *pTVar6;
    THouse *pTVar7;
    THouse *pTVar8;
    int iVar9;
    int iVar10;
    THouse *house;
    int i;
    undefined4 *puVar11;
    ushort_0_ *HouseIDs;
    int_0_ *PaidUntils;
    uint uVar12;
    int iVar13;
    uint uStack_90;
    int iStack_78;
    ushort auStack_74 [4];
    int local_6c;
    ulong_0_ *OwnerIDs;
    int local_64;
    int NumberOfHouses;
    int NumberOfAuctions;
    char HelpWorld [60];
    
    OwnerIDs = &stack0xffffff74;
    uStack_90 = 0x8064b52;
    Log("houses","Starte neue Versteigerungen...\n");
    iVar13 = 0;
    if (0 < Houses) {
        do {
            iVar9 = iVar13 + 1;
            uStack_90 = 0x8065101;
            pTVar6 = vector<THouse>::operator()(&House,iVar13);
            pTVar6->Help = 0;
            iVar13 = iVar9;
        } while (iVar9 < Houses);
    }
    NumberOfHouses = Houses;
    iVar9 = -(Houses * 2 + 0xfU & 0xfffffff0);
    puVar11 = (undefined4 *)(&stack0xffffff74 + iVar9);
    iVar13 = (int)auStack_74 + iVar9;
    *(int *)(&stack0xffffff7c + iVar9) = iVar13;
    *(int **)(&stack0xffffff78 + iVar9) = &NumberOfHouses;
    *(TQueryManagerConnection **)(&stack0xffffff74 + iVar9) = QueryManagerConnection;
    *(undefined4 *)((int)&uStack_90 + iVar9) = 0x8064b87;
    iVar5 = TQueryManagerConnection::getAuctions
                      (*(TQueryManagerConnection **)(&stack0xffffff74 + iVar9),
                       *(int **)(&stack0xffffff78 + iVar9),*(ushort **)(&stack0xffffff7c + iVar9));
    if (iVar5 == 0) {
        iVar5 = 0;
        if (0 < NumberOfHouses) {
            do {
                *(uint *)(&stack0xffffff74 + iVar9) = (uint)*(ushort *)(iVar13 + iVar5 * 2);
                *(undefined4 *)((int)&uStack_90 + iVar9) = 0x80650ad;
                pTVar6 = GetHouse(*(ushort *)(&stack0xffffff74 + iVar9));
                if (pTVar6 == (THouse *)0x0) {
                    uVar1 = *(ushort *)(iVar13 + iVar5 * 2);
                    *(char **)(&stack0xffffff74 + iVar9) =
                         "StartAuctions: Haus mit Nummer %d existiert nicht (1).\n";
                    *(uint *)(&stack0xffffff78 + iVar9) = (uint)uVar1;
                    *(undefined4 *)((int)&uStack_90 + iVar9) = 0x80650db;
                    error(*(char **)(&stack0xffffff74 + iVar9));
                }
                else {
                    pTVar6->Help = 1;
                }
                iVar5 = iVar5 + 1;
            } while (iVar5 < NumberOfHouses);
        }
        *(char **)(&stack0xffffff78 + iVar9) = WorldName;
        iVar5 = 0;
        *(int **)(&stack0xffffff74 + iVar9) = &NumberOfAuctions;
        *(undefined4 *)((int)&uStack_90 + iVar9) = 0x8064baf;
        AddSlashes(*(char **)(&stack0xffffff74 + iVar9),*(char **)(&stack0xffffff78 + iVar9));
        if (0 < Houses) {
            do {
                *(int *)(&stack0xffffff78 + iVar9) = iVar5;
                *(vector<THouse> **)(&stack0xffffff74 + iVar9) = &House;
                *(undefined4 *)((int)&uStack_90 + iVar9) = 0x8064fa7;
                pTVar6 = vector<THouse>::operator()
                                   (*(vector<THouse> **)(&stack0xffffff74 + iVar9),
                                    *(int *)(&stack0xffffff78 + iVar9));
                if (pTVar6->OwnerID == 0) {
                    *(int *)(&stack0xffffff78 + iVar9) = iVar5;
                    *(vector<THouse> **)(&stack0xffffff74 + iVar9) = &House;
                    *(undefined4 *)((int)&uStack_90 + iVar9) = 0x8064fd0;
                    pTVar6 = vector<THouse>::operator()
                                       (*(vector<THouse> **)(&stack0xffffff74 + iVar9),
                                        *(int *)(&stack0xffffff78 + iVar9));
                    if (pTVar6->Help == 0) {
                        *(int *)(&stack0xffffff78 + iVar9) = iVar5;
                        *(vector<THouse> **)(&stack0xffffff74 + iVar9) = &House;
                        *(undefined4 *)((int)&uStack_90 + iVar9) = 0x8064fea;
                        pTVar6 = vector<THouse>::operator()
                                           (*(vector<THouse> **)(&stack0xffffff74 + iVar9),
                                            *(int *)(&stack0xffffff78 + iVar9));
                        if (pTVar6->NoAuction == false) {
                            *(int *)(&stack0xffffff78 + iVar9) = iVar5;
                            *(vector<THouse> **)(&stack0xffffff74 + iVar9) = &House;
                            *(undefined4 *)((int)&uStack_90 + iVar9) = 0x8065003;
                            pTVar6 = vector<THouse>::operator()
                                               (*(vector<THouse> **)(&stack0xffffff74 + iVar9),
                                                *(int *)(&stack0xffffff78 + iVar9));
                            uVar1 = pTVar6->ID;
                            *(char **)(&stack0xffffff74 + iVar9) = "houses";
                            *(char **)(&stack0xffffff78 + iVar9) =
                                 "Trage Haus %d zur Versteigerung ein.\n";
                            *(uint *)(&stack0xffffff7c + iVar9) = (uint)uVar1;
                            *(undefined4 *)((int)&uStack_90 + iVar9) = 0x806501e;
                            Log(*(char **)(&stack0xffffff74 + iVar9),
                                *(char **)(&stack0xffffff78 + iVar9));
                            *(vector<THouse> **)(&stack0xffffff74 + iVar9) = &House;
                            *(int *)(&stack0xffffff78 + iVar9) = iVar5;
                            *(undefined4 *)((int)&uStack_90 + iVar9) = 0x806502e;
                            pTVar6 = vector<THouse>::operator()
                                               (*(vector<THouse> **)(&stack0xffffff74 + iVar9),
                                                *(int *)(&stack0xffffff78 + iVar9));
                            uVar1 = pTVar6->ID;
                            *(char **)(&stack0xffffff74 + iVar9) = "houses";
                            *(int **)(&stack0xffffff7c + iVar9) = &NumberOfAuctions;
                            *(char **)(&stack0xffffff78 + iVar9) =
                                 "bei Reset: DELETE FROM Auctions WHERE World=\'%s\' AND HouseID=%d;\n"
                            ;
                            *(uint *)(&stack0xffffff80 + iVar9) = (uint)uVar1;
                            *(undefined4 *)((int)&uStack_90 + iVar9) = 0x806504d;
                            Log(*(char **)(&stack0xffffff74 + iVar9),
                                *(char **)(&stack0xffffff78 + iVar9));
                            *(vector<THouse> **)(&stack0xffffff74 + iVar9) = &House;
                            *(int *)(&stack0xffffff78 + iVar9) = iVar5;
                            *(undefined4 *)((int)&uStack_90 + iVar9) = 0x806505d;
                            pTVar6 = vector<THouse>::operator()
                                               (*(vector<THouse> **)(&stack0xffffff74 + iVar9),
                                                *(int *)(&stack0xffffff78 + iVar9));
                            *(uint *)(&stack0xffffff78 + iVar9) = (uint)pTVar6->ID;
                            *(TQueryManagerConnection **)(&stack0xffffff74 + iVar9) =
                                 QueryManagerConnection;
                            *(undefined4 *)((int)&uStack_90 + iVar9) = 0x8065071;
                            iVar10 = TQueryManagerConnection::startAuction
                                               (*(TQueryManagerConnection **)
                                                 (&stack0xffffff74 + iVar9),
                                                *(ushort *)(&stack0xffffff78 + iVar9));
                            if (iVar10 != 0) {
                                *(int *)(&stack0xffffff78 + iVar9) = iVar5;
                                *(vector<THouse> **)(&stack0xffffff74 + iVar9) = &House;
                                *(undefined4 *)((int)&uStack_90 + iVar9) = 0x8065089;
                                pTVar6 = vector<THouse>::operator()
                                                   (*(vector<THouse> **)(&stack0xffffff74 + iVar9),
                                                    *(int *)(&stack0xffffff78 + iVar9));
                                uVar1 = pTVar6->ID;
                                *(char **)(&stack0xffffff74 + iVar9) =
                                     "StartAuctions: Kann Haus %d nicht zur Versteigerung eintragen.\n"
                                ;
                                *(uint *)(&stack0xffffff78 + iVar9) = (uint)uVar1;
                                *(undefined4 *)((int)&uStack_90 + iVar9) = 0x806509c;
                                error(*(char **)(&stack0xffffff74 + iVar9));
                            }
                        }
                    }
                }
                iVar5 = iVar5 + 1;
            } while (iVar5 < Houses);
        }
        iVar5 = 0;
        if (0 < Houses) {
            do {
                *(int *)(&stack0xffffff78 + iVar9) = iVar5;
                iVar5 = iVar5 + 1;
                *(vector<THouse> **)(&stack0xffffff74 + iVar9) = &House;
                *(undefined4 *)((int)&uStack_90 + iVar9) = 0x8064f83;
                pTVar6 = vector<THouse>::operator()
                                   (*(vector<THouse> **)(&stack0xffffff74 + iVar9),
                                    *(int *)(&stack0xffffff78 + iVar9));
                pTVar6->Help = 0;
            } while (iVar5 < Houses);
        }
        local_64 = Houses;
        uVar12 = (Houses + -1) * 4 + 0x13U & 0xfffffff0;
        iVar5 = -uVar12;
        iVar4 = iVar5 + iVar9 + -0x8c;
        iVar10 = -((Houses + -1) * 0x1e + 0x2dU & 0xfffffff0);
        local_6c = (int)auStack_74 + iVar5 + iVar9;
        iVar3 = -uVar12;
        puVar11 = (undefined4 *)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c);
        *(int *)(&stack0xffffff84 + iVar3 + iVar10 + iVar4 + 0x8c) =
             (int)auStack_74 + iVar10 + iVar5 + iVar9 + -0x8c + 0x8c;
        iVar9 = (int)auStack_74 + iVar3 + iVar10 + iVar4 + 0x8c;
        *(int *)(HelpWorld + iVar3 + iVar10 + iVar4 + 0x6c) = iVar9;
        iVar5 = local_6c;
        *(int **)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) = &local_64;
        *(int *)(&stack0xffffff7c + iVar3 + iVar10 + iVar4 + 0x8c) = iVar13;
        *(int *)(&stack0xffffff80 + iVar3 + iVar10 + iVar4 + 0x8c) = iVar5;
        *(TQueryManagerConnection **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) =
             QueryManagerConnection;
        *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064c20;
        iVar5 = TQueryManagerConnection::getHouseOwners
                          (*(TQueryManagerConnection **)
                            (&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c),
                           *(int **)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c),
                           *(ushort **)(&stack0xffffff7c + iVar3 + iVar10 + iVar4 + 0x8c),
                           *(ulong **)(&stack0xffffff80 + iVar3 + iVar10 + iVar4 + 0x8c),
                           *(char (**) [30])(&stack0xffffff84 + iVar3 + iVar10 + iVar4 + 0x8c),
                           *(int **)(HelpWorld + iVar3 + iVar10 + iVar4 + 0x6c));
        if (iVar5 == 0) {
            iVar5 = 0;
            if (0 < local_64) {
                do {
                    *(uint *)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) =
                         (uint)*(ushort *)(iVar13 + iVar5 * 2);
                    *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064efc;
                    pTVar6 = GetHouse(*(ushort *)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c))
                    ;
                    if (pTVar6 == (THouse *)0x0) {
                        uVar1 = *(ushort *)(iVar13 + iVar5 * 2);
                        *(char **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) =
                             "StartAuctions: Haus mit Nummer %d existiert nicht (2).\n";
                        *(uint *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) = (uint)uVar1;
                        *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064f5b
                        ;
                        error(*(char **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c));
                    }
                    else {
                        pTVar6->Help = 1;
                        if (pTVar6->OwnerID != *(ulong *)(local_6c + iVar5 * 4)) {
                            pTVar6->Help = 2;
                        }
                        if (pTVar6->PaidUntil != *(int *)(iVar9 + iVar5 * 4)) {
                            pTVar6->Help = 2;
                        }
                    }
                    iVar5 = iVar5 + 1;
                } while (iVar5 < local_64);
            }
            *(char **)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) =
                 "Aktualisiere Liste der Mieter...\n";
            iVar13 = 0;
            *(char **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) = "houses";
            *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064c49;
            Log(*(char **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c),
                *(char **)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c));
            if (Houses < 1) {
                return;
            }
            do {
                *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) = iVar13;
                *(vector<THouse> **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) = &House;
                *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064c70;
                pTVar6 = vector<THouse>::operator()
                                   (*(vector<THouse> **)
                                     (&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c),
                                    *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c));
                if (pTVar6->OwnerID == 0) {
                    *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) = iVar13;
                    *(vector<THouse> **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) = &House;
                    *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064e60;
                    pTVar6 = vector<THouse>::operator()
                                       (*(vector<THouse> **)
                                         (&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c),
                                        *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c));
                    if (pTVar6->Help != 0) {
                        *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) = iVar13;
                        *(vector<THouse> **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) =
                             &House;
                        *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064e7e
                        ;
                        pTVar6 = vector<THouse>::operator()
                                           (*(vector<THouse> **)
                                             (&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c),
                                            *(int *)(&stack0xffffff78 +
                                                    iVar3 + iVar10 + iVar4 + 0x8c));
                        uVar1 = pTVar6->ID;
                        *(char **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) = "houses";
                        *(char **)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) =
                             "Trage nicht mehr vermietetes Haus %d aus.\n";
                        *(uint *)(&stack0xffffff7c + iVar3 + iVar10 + iVar4 + 0x8c) = (uint)uVar1;
                        *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064e99
                        ;
                        Log(*(char **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c),
                            *(char **)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c));
                        *(vector<THouse> **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) =
                             &House;
                        *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) = iVar13;
                        *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064ea9
                        ;
                        pTVar6 = vector<THouse>::operator()
                                           (*(vector<THouse> **)
                                             (&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c),
                                            *(int *)(&stack0xffffff78 +
                                                    iVar3 + iVar10 + iVar4 + 0x8c));
                        *(uint *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) =
                             (uint)pTVar6->ID;
                        *(TQueryManagerConnection **)
                         (&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) = QueryManagerConnection
                        ;
                        *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064ebd
                        ;
                        iVar9 = TQueryManagerConnection::deleteHouseOwner
                                          (*(TQueryManagerConnection **)
                                            (&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c),
                                           *(ushort *)
                                            (&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c));
                        if (iVar9 != 0) {
                            *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) = iVar13;
                            *(vector<THouse> **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) =
                                 &House;
                            *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) =
                                 0x8064ed5;
                            pTVar6 = vector<THouse>::operator()
                                               (*(vector<THouse> **)
                                                 (&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c),
                                                *(int *)(&stack0xffffff78 +
                                                        iVar3 + iVar10 + iVar4 + 0x8c));
                            uVar1 = pTVar6->ID;
                            *(char **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) =
                                 "StartAuctions: Kann nicht mehr vermietetes Haus %d nicht austragen.\n"
                            ;
                            *(uint *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) =
                                 (uint)uVar1;
                            *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) =
                                 0x8064ee8;
                            error(*(char **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c));
                        }
                    }
                }
                *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) = iVar13;
                *(vector<THouse> **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) = &House;
                *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064c8e;
                pTVar6 = vector<THouse>::operator()
                                   (*(vector<THouse> **)
                                     (&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c),
                                    *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c));
                if (pTVar6->OwnerID != 0) {
                    *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) = iVar13;
                    *(vector<THouse> **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) = &House;
                    *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064d87;
                    pTVar6 = vector<THouse>::operator()
                                       (*(vector<THouse> **)
                                         (&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c),
                                        *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c));
                    if (pTVar6->Help == 0) {
                        *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) = iVar13;
                        *(vector<THouse> **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) =
                             &House;
                        *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064da5
                        ;
                        pTVar6 = vector<THouse>::operator()
                                           (*(vector<THouse> **)
                                             (&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c),
                                            *(int *)(&stack0xffffff78 +
                                                    iVar3 + iVar10 + iVar4 + 0x8c));
                        uVar1 = pTVar6->ID;
                        *(char **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) = "houses";
                        *(char **)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) =
                             "Trage vermietetes Haus %d ein.\n";
                        *(uint *)(&stack0xffffff7c + iVar3 + iVar10 + iVar4 + 0x8c) = (uint)uVar1;
                        *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064dc0
                        ;
                        Log(*(char **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c),
                            *(char **)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c));
                        *(vector<THouse> **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) =
                             &House;
                        *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) = iVar13;
                        *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064dd0
                        ;
                        pTVar6 = vector<THouse>::operator()
                                           (*(vector<THouse> **)
                                             (&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c),
                                            *(int *)(&stack0xffffff78 +
                                                    iVar3 + iVar10 + iVar4 + 0x8c));
                        *(vector<THouse> **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) =
                             &House;
                        *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) = iVar13;
                        *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064de2
                        ;
                        pTVar7 = vector<THouse>::operator()
                                           (*(vector<THouse> **)
                                             (&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c),
                                            *(int *)(&stack0xffffff78 +
                                                    iVar3 + iVar10 + iVar4 + 0x8c));
                        *(vector<THouse> **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) =
                             &House;
                        *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) = iVar13;
                        *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064df4
                        ;
                        pTVar8 = vector<THouse>::operator()
                                           (*(vector<THouse> **)
                                             (&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c),
                                            *(int *)(&stack0xffffff78 +
                                                    iVar3 + iVar10 + iVar4 + 0x8c));
                        uVar1 = pTVar8->ID;
                        *(int *)(&stack0xffffff80 + iVar3 + iVar10 + iVar4 + 0x8c) =
                             pTVar6->PaidUntil;
                        uVar2 = pTVar7->OwnerID;
                        *(uint *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) = (uint)uVar1;
                        *(ulong *)(&stack0xffffff7c + iVar3 + iVar10 + iVar4 + 0x8c) = uVar2;
                        *(TQueryManagerConnection **)
                         (&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) = QueryManagerConnection
                        ;
                        *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064e1c
                        ;
                        iVar9 = TQueryManagerConnection::insertHouseOwner
                                          (*(TQueryManagerConnection **)
                                            (&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c),
                                           *(ushort *)
                                            (&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c),
                                           *(ulong *)(&stack0xffffff7c +
                                                     iVar3 + iVar10 + iVar4 + 0x8c),
                                           *(int *)(&stack0xffffff80 + iVar3 + iVar10 + iVar4 + 0x8c
                                                   ));
                        if (iVar9 != 0) {
                            *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) = iVar13;
                            *(vector<THouse> **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) =
                                 &House;
                            *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) =
                                 0x8064e34;
                            pTVar6 = vector<THouse>::operator()
                                               (*(vector<THouse> **)
                                                 (&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c),
                                                *(int *)(&stack0xffffff78 +
                                                        iVar3 + iVar10 + iVar4 + 0x8c));
                            uVar1 = pTVar6->ID;
                            *(char **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) =
                                 "StartAuctions: Kann vermietetes Haus %d nicht eintragen.\n";
                            *(uint *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) =
                                 (uint)uVar1;
                            *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) =
                                 0x8064e47;
                            error(*(char **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c));
                        }
                    }
                }
                *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) = iVar13;
                *(vector<THouse> **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) = &House;
                *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064cac;
                pTVar6 = vector<THouse>::operator()
                                   (*(vector<THouse> **)
                                     (&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c),
                                    *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c));
                if (pTVar6->Help == 2) {
                    *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) = iVar13;
                    *(vector<THouse> **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) = &House;
                    *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064cd0;
                    pTVar6 = vector<THouse>::operator()
                                       (*(vector<THouse> **)
                                         (&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c),
                                        *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c));
                    uVar1 = pTVar6->ID;
                    *(char **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) = "houses";
                    *(char **)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) =
                         "Aktualisiere vermietetes Haus %d.\n";
                    *(uint *)(&stack0xffffff7c + iVar3 + iVar10 + iVar4 + 0x8c) = (uint)uVar1;
                    *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064ceb;
                    Log(*(char **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c),
                        *(char **)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c));
                    *(vector<THouse> **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) = &House;
                    *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) = iVar13;
                    *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064cfb;
                    pTVar6 = vector<THouse>::operator()
                                       (*(vector<THouse> **)
                                         (&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c),
                                        *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c));
                    *(vector<THouse> **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) = &House;
                    *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) = iVar13;
                    *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064d0d;
                    pTVar7 = vector<THouse>::operator()
                                       (*(vector<THouse> **)
                                         (&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c),
                                        *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c));
                    *(vector<THouse> **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) = &House;
                    *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) = iVar13;
                    *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064d1f;
                    pTVar8 = vector<THouse>::operator()
                                       (*(vector<THouse> **)
                                         (&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c),
                                        *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c));
                    uVar1 = pTVar8->ID;
                    *(int *)(&stack0xffffff80 + iVar3 + iVar10 + iVar4 + 0x8c) = pTVar6->PaidUntil;
                    uVar2 = pTVar7->OwnerID;
                    *(uint *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) = (uint)uVar1;
                    *(ulong *)(&stack0xffffff7c + iVar3 + iVar10 + iVar4 + 0x8c) = uVar2;
                    *(TQueryManagerConnection **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c)
                         = QueryManagerConnection;
                    *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064d47;
                    iVar9 = TQueryManagerConnection::updateHouseOwner
                                      (*(TQueryManagerConnection **)
                                        (&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c),
                                       *(ushort *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c)
                                       ,*(ulong *)(&stack0xffffff7c + iVar3 + iVar10 + iVar4 + 0x8c)
                                       ,*(int *)(&stack0xffffff80 + iVar3 + iVar10 + iVar4 + 0x8c));
                    if (iVar9 != 0) {
                        *(int *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) = iVar13;
                        *(vector<THouse> **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) =
                             &House;
                        *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064d5f
                        ;
                        pTVar6 = vector<THouse>::operator()
                                           (*(vector<THouse> **)
                                             (&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c),
                                            *(int *)(&stack0xffffff78 +
                                                    iVar3 + iVar10 + iVar4 + 0x8c));
                        uVar1 = pTVar6->ID;
                        *(char **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) =
                             "StartAuctions: Kann Daten des vermieteten Hauses %d nicht aktualisieren.\n"
                        ;
                        *(uint *)(&stack0xffffff78 + iVar3 + iVar10 + iVar4 + 0x8c) = (uint)uVar1;
                        *(undefined4 *)((int)&uStack_90 + iVar3 + iVar10 + iVar4 + 0x8c) = 0x8064d72
                        ;
                        error(*(char **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c));
                    }
                }
                iVar13 = iVar13 + 1;
            } while (iVar13 < Houses);
            return;
        }
        *(undefined **)(&stack0xffffff74 + iVar3 + iVar10 + iVar4 + 0x8c) = &DAT_080f46a0;
    }
    else {
        *(char **)(&stack0xffffff74 + iVar9) =
             "StartAuctions: Kann laufende Versteigerungen nicht ermitteln.\n";
    }
    puVar11[-1] = 0x8064f69;
    error((char *)*puVar11);
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void PrepareHouseCleanup(void)

{
    HelpDepots = 0;
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void FinishHouseCleanup(void)

{
    THelpDepot *pTVar1;
    TPlayerData *PlayerData_00;
    TPlayerData *PlayerData;
    int i;
    int i_00;
    int iVar2;
    Object local_2c [7];
    
    if (0 < HelpDepots) {
        i_00 = 1;
        do {
            pTVar1 = vector<THelpDepot>::operator()(&HelpDepot,i_00);
            PlayerData_00 = AssignPlayerPoolSlot(pTVar1->CharacterID,false);
            if (PlayerData_00 == (TPlayerData *)0x0) {
                error(&DAT_080f4860);
                return;
            }
            pTVar1 = vector<THelpDepot>::operator()(&HelpDepot,i_00);
            local_2c[0].ObjectID = (pTVar1->Box).ObjectID;
            pTVar1 = vector<THelpDepot>::operator()(&HelpDepot,i_00);
            SaveDepot(PlayerData_00,pTVar1->DepotNr,local_2c);
            iVar2 = i_00 + 1;
            pTVar1 = vector<THelpDepot>::operator()(&HelpDepot,i_00);
            local_2c[0].ObjectID = (pTVar1->Box).ObjectID;
            DeleteObject(local_2c);
            ReleasePlayerPoolSlot(PlayerData_00);
            i_00 = iVar2;
        } while (iVar2 <= HelpDepots);
    }
    HelpDepots = 0;
    return;
}



void CleanHouseField(int x,int y,int z)

{
    bool bVar1;
    ushort ID;
    THouse *pTVar2;
    THelpDepot *pTVar3;
    TPlayerData *PlayerData_00;
    ushort HouseID;
    int i;
    int DepotLoaded;
    int iVar4;
    THouse *house;
    TPlayerData *PlayerData;
    int sx;
    int sy;
    int sz;
    undefined1 local_4c [16];
    Object local_3c [4];
    ulong local_2c;
    
    ID = GetHouseID(x,y,z);
    if (ID == 0) {
        bVar1 = CoordinateFlag();
        if (bVar1) {
            iVar4 = y + 1;
            ID = GetHouseID(x,iVar4,z);
            if ((ID != 0) || (ID = GetHouseID(x + -1,iVar4,z), ID != 0)) goto LAB_0806526c;
            ID = GetHouseID(x + 1,iVar4,z);
        }
        if (ID == 0) {
            bVar1 = CoordinateFlag();
            if (bVar1) {
                iVar4 = x + 1;
                ID = GetHouseID(iVar4,y,z);
                if ((ID != 0) || (ID = GetHouseID(iVar4,y + -1,z), ID != 0)) goto LAB_0806526c;
                ID = GetHouseID(iVar4,y + 1,z);
            }
            if (ID == 0) {
                error("CleanHouseField: Kein Haus zu Feld [%d,%d,%d] gefunden.\n",x,y,z);
                return;
            }
        }
    }
LAB_0806526c:
    pTVar2 = GetHouse(ID);
    if ((pTVar2 != (THouse *)0x0) && (pTVar2->OwnerID != 0)) {
        i = 1;
        iVar4 = -1;
        if (0 < HelpDepots) {
            do {
                pTVar3 = vector<THelpDepot>::operator()(&HelpDepot,i);
                if ((pTVar3->CharacterID == pTVar2->OwnerID) &&
                   (pTVar3 = vector<THelpDepot>::operator()(&HelpDepot,i),
                   pTVar3->DepotNr == pTVar2->DepotNr)) {
                    iVar4 = i;
                }
                i = i + 1;
            } while (i <= HelpDepots);
        }
        if (iVar4 == -1) {
            PlayerData_00 = AssignPlayerPoolSlot(pTVar2->OwnerID,false);
            if (PlayerData_00 == (TPlayerData *)0x0) {
                error(&DAT_080f48c0);
                return;
            }
            HelpDepots = HelpDepots + 1;
            pTVar3 = vector<THelpDepot>::operator()(&HelpDepot,HelpDepots);
            pTVar3->CharacterID = pTVar2->OwnerID;
            pTVar3 = vector<THelpDepot>::operator()(&HelpDepot,HelpDepots);
            pTVar3->DepotNr = pTVar2->DepotNr;
            GetStartPosition((int *)&PlayerData,&sx,&sy,true);
            pTVar3 = vector<THelpDepot>::operator()(&HelpDepot,HelpDepots);
            GetSpecialObject((SPECIALMEANING)local_4c);
            GetMapContainer((int)&sz,(int)PlayerData,sx);
            SetObject(local_3c,(ObjectType *)&sz,(ulong)local_4c);
            (pTVar3->Box).ObjectID = local_3c[0].ObjectID;
            local_2c = local_3c[0].ObjectID;
            pTVar3 = vector<THelpDepot>::operator()(&HelpDepot,HelpDepots);
            sz = (pTVar3->Box).ObjectID;
            LoadDepot(PlayerData_00,pTVar2->DepotNr,(Object *)&sz);
            iVar4 = HelpDepots;
            ReleasePlayerPoolSlot(PlayerData_00);
        }
        pTVar3 = vector<THelpDepot>::operator()(&HelpDepot,iVar4);
        sz = (pTVar3->Box).ObjectID;
        CleanField();
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void LoadHouseAreas(void)

{
    bool bVar1;
    THouseArea *pTVar2;
    int iVar3;
    char *__s;
    char *__oflag;
    undefined1 local_4ffc [4];
    TReadScriptFile Script;
    char local_101c [4];
    char FileName [4096];
    
                    // try { // try from 080655d1 to 0806562e has its CatchHandler @ 08065780
    Log("houses",&DAT_080f4940);
    __oflag = DATAPATH;
    __s = local_101c;
    sprintf(__s,"%s/houseareas.dat");
    bVar1 = FileExists(__s);
    if (bVar1) {
        TReadScriptFile::TReadScriptFile((TReadScriptFile *)local_4ffc);
                    // try { // try from 08065636 to 08065747 has its CatchHandler @ 08065755
        TReadScriptFile::open((TReadScriptFile *)local_4ffc,__s,(int)__oflag);
        while( true ) {
            TReadScriptFile::nextToken((TReadScriptFile *)local_4ffc);
            if (local_4ffc == (undefined1  [4])0x0) break;
            if (local_4ffc != (undefined1  [4])0x1) {
                TReadScriptFile::error((TReadScriptFile *)local_4ffc,"Identifier expected");
            }
            TReadScriptFile::readSymbol((TReadScriptFile *)local_4ffc,'=');
            TReadScriptFile::readSymbol((TReadScriptFile *)local_4ffc,'(');
            pTVar2 = vector<THouseArea>::operator()(&HouseArea,HouseAreas);
            iVar3 = TReadScriptFile::readNumber((TReadScriptFile *)local_4ffc);
            pTVar2->ID = (ushort)iVar3;
            TReadScriptFile::readSymbol((TReadScriptFile *)local_4ffc,',');
            TReadScriptFile::readString((TReadScriptFile *)local_4ffc);
            TReadScriptFile::readSymbol((TReadScriptFile *)local_4ffc,',');
            pTVar2 = vector<THouseArea>::operator()(&HouseArea,HouseAreas);
            iVar3 = TReadScriptFile::readNumber((TReadScriptFile *)local_4ffc);
            pTVar2->SQMPrice = iVar3;
            TReadScriptFile::readSymbol((TReadScriptFile *)local_4ffc,',');
            pTVar2 = vector<THouseArea>::operator()(&HouseArea,HouseAreas);
            iVar3 = TReadScriptFile::readNumber((TReadScriptFile *)local_4ffc);
            pTVar2->DepotNr = iVar3;
            __s = (char *)0x29;
            TReadScriptFile::readSymbol((TReadScriptFile *)local_4ffc,')');
            HouseAreas = HouseAreas + 1;
        }
        TReadScriptFile::close((TReadScriptFile *)local_4ffc,(int)__s);
                    // try { // try from 0806574b to 0806574f has its CatchHandler @ 08065780
        TReadScriptFile::~TReadScriptFile((TReadScriptFile *)local_4ffc,(int)__s);
    }
    else {
        Log("houses",&DAT_080f4980);
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void LoadHouses(void)

{
    int iVar1;
    bool bVar2;
    char cVar3;
    THouse *pTVar4;
    int iVar5;
    THouse *pTVar6;
    char *pcVar7;
    THouseArea *pTVar8;
    undefined4 *puVar9;
    int *piVar10;
    int i;
    int iVar11;
    uint uVar12;
    int_0_ *piVar13;
    int i_1;
    int iVar14;
    undefined1 uVar15;
    undefined4 uStack_5080;
    char *pcVar16;
    int local_506c [8];
    int_0_ local_504c [4];
    int_0_ *local_5048;
    bool_0_ *Guildhouses;
    int_0_ *Sizes;
    int_0_ *Rents;
    char_0__30_ *Towns;
    char___0_ *Descriptions;
    char___0_ *Names;
    int_0_ *PositionsZ;
    int_0_ *PositionsY;
    int_0_ *PositionsX;
    ushort_0_ *HouseIDs;
    TQueryManagerConnection *local_501c;
    THouseArea *local_5018;
    int local_5014;
    int RentOffset;
    int local_500c;
    int local_5008;
    int x;
    int y;
    int z;
    TReadScriptFile Script;
    char local_101c [4];
    char FileName [4096];
    
    HouseIDs = &stack0xffffaf84;
                    // try { // try from 080657b7 to 0806582d has its CatchHandler @ 080663c1
    uStack_5080 = 0x80657bc;
    Log("houses",&DAT_080f4e5f);
    pcVar7 = local_101c;
    MaxHouseX = 0;
    Houses = 0;
    MaxHouseY = 0;
    pcVar16 = DATAPATH;
    uStack_5080 = 0x80657f2;
    sprintf(pcVar7,"%s/houses.dat");
    uStack_5080 = 0x80657fa;
    bVar2 = FileExists(pcVar7);
    if (bVar2) {
        uStack_5080 = 0x806582e;
        TReadScriptFile::TReadScriptFile((TReadScriptFile *)&z);
                    // try { // try from 0806583b to 08066090 has its CatchHandler @ 080663bb
        uStack_5080 = 0x8065840;
        TReadScriptFile::open((TReadScriptFile *)&z,pcVar7,(int)pcVar16);
        while( true ) {
            uStack_5080 = 0x806584e;
            TReadScriptFile::nextToken((TReadScriptFile *)&z);
            if (z == 0) break;
            if (z != 1) {
                uStack_5080 = 0x8065875;
                TReadScriptFile::error((TReadScriptFile *)&z,"Identifier expected");
            }
            uStack_5080 = 0x806588b;
            TReadScriptFile::readSymbol((TReadScriptFile *)&z,'=');
            uStack_5080 = 0x80658a0;
            pTVar4 = vector<THouse>::operator()(&House,Houses);
            uStack_5080 = 0x80658b0;
            iVar5 = TReadScriptFile::readNumber((TReadScriptFile *)&z);
            pTVar4->ID = (ushort)iVar5;
            uStack_5080 = 0x80658c8;
            pTVar4 = vector<THouse>::operator()(&House,Houses);
            if (pTVar4->ID == 0) {
                uStack_5080 = 0x8066056;
                pTVar4 = vector<THouse>::operator()(&House,Houses);
                uVar12 = (uint)pTVar4->ID;
                uStack_5080 = 0x8066069;
                error(&DAT_080f4eb7);
LAB_08065fc4:
                uStack_5080 = 0x8065fc9;
                TReadScriptFile::close((TReadScriptFile *)&z,uVar12);
                uStack_5080 = 0x8065fd5;
                puVar9 = (undefined4 *)__cxa_allocate_exception();
                *puVar9 = "Cannot load houses";
                    // WARNING: Subroutine does not return
                uStack_5080 = 0x8065ff3;
                __cxa_throw();
            }
            if (0 < Houses) {
                uStack_5080 = 0x80658eb;
                pTVar4 = vector<THouse>::operator()(&House,Houses);
                uStack_5080 = 0x8065903;
                pTVar6 = vector<THouse>::operator()(&House,Houses + -1);
                if (pTVar4->ID <= pTVar6->ID) {
                    uStack_5080 = 0x8066023;
                    pTVar4 = vector<THouse>::operator()(&House,Houses);
                    uVar12 = (uint)pTVar4->ID;
                    uStack_5080 = 0x8066036;
                    error("LoadHouses: IDs nicht aufsteigend sortiert (ID=%d).\n");
                    goto LAB_08065fc4;
                }
            }
            uStack_5080 = 0x806591d;
            TReadScriptFile::readIdentifier((TReadScriptFile *)&z);
            uStack_5080 = 0x8065933;
            TReadScriptFile::readSymbol((TReadScriptFile *)&z,'=');
            uStack_5080 = 0x8065941;
            pcVar7 = TReadScriptFile::readString((TReadScriptFile *)&z);
            uStack_5080 = 0x8065958;
            pTVar4 = vector<THouse>::operator()(&House,Houses);
            uStack_5080 = 0x806596d;
            strcpy(pTVar4->Name,pcVar7);
            uStack_5080 = 0x8065975;
            TReadScriptFile::readIdentifier((TReadScriptFile *)&z);
            uStack_5080 = 0x8065985;
            TReadScriptFile::readSymbol((TReadScriptFile *)&z,'=');
            uStack_5080 = 0x806598d;
            pcVar7 = TReadScriptFile::readString((TReadScriptFile *)&z);
            uStack_5080 = 0x80659a4;
            pTVar4 = vector<THouse>::operator()(&House,Houses);
            uStack_5080 = 0x80659b3;
            strcpy(pTVar4->Description,pcVar7);
            uStack_5080 = 0x80659bb;
            TReadScriptFile::readIdentifier((TReadScriptFile *)&z);
            uStack_5080 = 0x80659cb;
            TReadScriptFile::readSymbol((TReadScriptFile *)&z,'=');
            uStack_5080 = 0x80659d3;
            local_5014 = TReadScriptFile::readNumber((TReadScriptFile *)&z);
            uStack_5080 = 0x80659e1;
            TReadScriptFile::readIdentifier((TReadScriptFile *)&z);
            uStack_5080 = 0x80659f1;
            TReadScriptFile::readSymbol((TReadScriptFile *)&z,'=');
            uStack_5080 = 0x80659f9;
            iVar5 = TReadScriptFile::readNumber((TReadScriptFile *)&z);
            iVar11 = 0;
            if (0 < HouseAreas) {
                do {
                    uStack_5080 = 0x8065a16;
                    pTVar8 = vector<THouseArea>::operator()(&HouseArea,iVar11);
                    if (pTVar8->ID == (ushort)iVar5) {
                        uStack_5080 = 0x8066003;
                        local_5018 = vector<THouseArea>::operator()(&HouseArea,iVar11);
                        goto LAB_08065a40;
                    }
                    iVar11 = iVar11 + 1;
                } while (iVar11 < HouseAreas);
            }
            uStack_5080 = 0x8065a38;
            error("GetHouseArea: Gebiet mit ID %d nicht gefunden.\n");
            local_5018 = (THouseArea *)0x0;
LAB_08065a40:
            uVar15 = local_5018 == (THouseArea *)0x0;
            if ((bool)uVar15) {
                uStack_5080 = 0x8065fa8;
                pTVar4 = vector<THouse>::operator()(&House,Houses);
                uVar12 = (uint)pTVar4->ID;
                uStack_5080 = 0x8065fbb;
                error(&DAT_080f4a00);
                goto LAB_08065fc4;
            }
            uStack_5080 = 0x8065a63;
            pTVar4 = vector<THouse>::operator()(&House,Houses);
            pTVar4->DepotNr = local_5018->DepotNr;
            uStack_5080 = 0x8065a80;
            TReadScriptFile::readIdentifier((TReadScriptFile *)&z);
            uStack_5080 = 0x8065a90;
            TReadScriptFile::readSymbol((TReadScriptFile *)&z,'=');
            uStack_5080 = 0x8065aa5;
            pTVar4 = vector<THouse>::operator()(&House,Houses);
            uStack_5080 = 0x8065aaf;
            pcVar7 = TReadScriptFile::readIdentifier((TReadScriptFile *)&z);
            iVar5 = 5;
            pcVar16 = "true";
            do {
                if (iVar5 == 0) break;
                iVar5 = iVar5 + -1;
                uVar15 = *pcVar7 == *pcVar16;
                pcVar7 = pcVar7 + 1;
                pcVar16 = pcVar16 + 1;
            } while ((bool)uVar15);
            pTVar4->GuildHouse = (bool)uVar15;
            uStack_5080 = 0x8065adc;
            pTVar4 = vector<THouse>::operator()(&House,Houses);
            pTVar4->NoAuction = false;
            uStack_5080 = 0x8065af1;
            TReadScriptFile::readIdentifier((TReadScriptFile *)&z);
            uStack_5080 = 0x8065b07;
            TReadScriptFile::readSymbol((TReadScriptFile *)&z,'=');
            uStack_5080 = 0x8065b1c;
            vector<THouse>::operator()(&House,Houses);
            uStack_5080 = 0x8065b37;
            vector<THouse>::operator()(&House,Houses);
            uStack_5080 = 0x8065b52;
            vector<THouse>::operator()(&House,Houses);
            uStack_5080 = 0x8065b71;
            TReadScriptFile::readCoordinate((TReadScriptFile *)&z);
            uStack_5080 = 0x8065b86;
            pTVar4 = vector<THouse>::operator()(&House,Houses);
            if (pTVar4->ExitX == 0) {
                uStack_5080 = 0x8065f7b;
                vector<THouse>::operator()(&House,Houses);
                uStack_5080 = 0x8065f8e;
                error(&DAT_080f49c0);
            }
            uStack_5080 = 0x8065ba2;
            TReadScriptFile::readIdentifier((TReadScriptFile *)&z);
            uStack_5080 = 0x8065bb2;
            TReadScriptFile::readSymbol((TReadScriptFile *)&z,'=');
            uStack_5080 = 0x8065bc7;
            vector<THouse>::operator()(&House,Houses);
            uStack_5080 = 0x8065be2;
            vector<THouse>::operator()(&House,Houses);
            uStack_5080 = 0x8065bfd;
            vector<THouse>::operator()(&House,Houses);
            uStack_5080 = 0x8065c16;
            TReadScriptFile::readCoordinate((TReadScriptFile *)&z);
            uStack_5080 = 0x8065c2b;
            pTVar4 = vector<THouse>::operator()(&House,Houses);
            if (pTVar4->CenterX == 0) {
                uStack_5080 = 0x8065f4e;
                vector<THouse>::operator()(&House,Houses);
                uStack_5080 = 0x8065f61;
                error(&DAT_080f49c0);
            }
            uStack_5080 = 0x8065c47;
            TReadScriptFile::readIdentifier((TReadScriptFile *)&z);
            uStack_5080 = 0x8065c5d;
            TReadScriptFile::readSymbol((TReadScriptFile *)&z,'=');
            uStack_5080 = 0x8065c6d;
            TReadScriptFile::readSymbol((TReadScriptFile *)&z,'{');
            uStack_5080 = 0x8065c82;
            pTVar4 = vector<THouse>::operator()(&House,Houses);
            pTVar4->Size = 0;
            while( true ) {
                uStack_5080 = 0x8065c98;
                TReadScriptFile::nextToken((TReadScriptFile *)&z);
                if (z != 6) goto LAB_08065cd2;
                uStack_5080 = 0x8065caf;
                cVar3 = TReadScriptFile::getSpecial((TReadScriptFile *)&z);
                if (cVar3 == '}') break;
                if (z != 6) goto LAB_08065cd2;
                uStack_5080 = 0x8065cce;
                cVar3 = TReadScriptFile::getSpecial((TReadScriptFile *)&z);
                if (cVar3 != ',') {
LAB_08065cd2:
                    uStack_5080 = 0x8065cfe;
                    TReadScriptFile::getCoordinate((TReadScriptFile *)&z);
                    uStack_5080 = 0x8065d13;
                    pTVar4 = vector<THouse>::operator()(&House,Houses);
                    uStack_5080 = 0x8065d3c;
                    SetHouseID(local_5008,x,y,pTVar4->ID);
                    uStack_5080 = 0x8065d51;
                    pTVar4 = vector<THouse>::operator()(&House,Houses);
                    pTVar4->Size = pTVar4->Size + 1;
                    uStack_5080 = 0x8065d6c;
                    pTVar4 = vector<THouse>::operator()(&House,Houses);
                    uVar12 = local_5008 - pTVar4->CenterX;
                    if (0x7fffffff < uVar12) {
                        uVar12 = -uVar12;
                    }
                    if (MaxHouseX < (int)uVar12) {
                        uStack_5080 = 0x8065e12;
                        pTVar4 = vector<THouse>::operator()(&House,Houses);
                        MaxHouseX = local_5008 - pTVar4->CenterX;
                        if (0x7fffffff < (uint)MaxHouseX) {
                            MaxHouseX = -MaxHouseX;
                        }
                    }
                    uStack_5080 = 0x8065da1;
                    pTVar4 = vector<THouse>::operator()(&House,Houses);
                    uVar12 = x - pTVar4->CenterY;
                    if (0x7fffffff < uVar12) {
                        uVar12 = -uVar12;
                    }
                    if (MaxHouseY < (int)uVar12) {
                        uStack_5080 = 0x8065dda;
                        pTVar4 = vector<THouse>::operator()(&House,Houses);
                        MaxHouseY = x - pTVar4->CenterY;
                        if (0x7fffffff < (uint)MaxHouseY) {
                            MaxHouseY = -MaxHouseY;
                        }
                    }
                }
            }
            uStack_5080 = 0x8065e4a;
            pTVar4 = vector<THouse>::operator()(&House,Houses);
            uStack_5080 = 0x8065e61;
            pTVar6 = vector<THouse>::operator()(&House,Houses);
            iVar5 = Houses;
            pTVar4->Rent = local_5018->SQMPrice * pTVar6->Size + local_5014;
            uStack_5080 = 0x8065e96;
            pTVar4 = vector<THouse>::operator()(&House,iVar5);
            pTVar4->OwnerID = 0;
            uStack_5080 = 0x8065eb3;
            pTVar4 = vector<THouse>::operator()(&House,Houses);
            pTVar4->OwnerName[0] = '\0';
            uStack_5080 = 0x8065ecf;
            pTVar4 = vector<THouse>::operator()(&House,Houses);
            pTVar4->LastTransition = 0;
            uStack_5080 = 0x8065eec;
            pTVar4 = vector<THouse>::operator()(&House,Houses);
            pTVar4->PaidUntil = 0;
            uStack_5080 = 0x8065f09;
            pTVar4 = vector<THouse>::operator()(&House,Houses);
            pTVar4->Subowners = 0;
            uStack_5080 = 0x8065f26;
            pcVar7 = (char *)Houses;
            pTVar4 = vector<THouse>::operator()(&House,Houses);
            pTVar4->Guests = 0;
            Houses = Houses + 1;
        }
        uStack_5080 = 0x8066085;
        TReadScriptFile::close((TReadScriptFile *)&z,(int)pcVar7);
        uStack_5080 = 0x8066091;
        local_501c = (TQueryManagerConnection *)operator_new(0x30);
        local_500c = 0x4000;
        RentOffset = Houses * 600;
        piVar10 = &RentOffset;
        if (Houses * 600 < 0x4001) {
            piVar10 = &local_500c;
        }
                    // try { // try from 080660d6 to 080660da has its CatchHandler @ 08066388
        uStack_5080 = 0x80660db;
        TQueryManagerConnection::TQueryManagerConnection(local_501c,*piVar10);
        QueryManagerConnection = local_501c;
        iVar5 = Houses + -1;
        iVar11 = -(Houses + 0x10 + iVar5 & 0xfffffff0U);
        PositionsX = local_504c + iVar11;
        uVar12 = iVar5 * 4 + 0x13U & 0xfffffff0;
        PositionsY = local_504c + (iVar11 - uVar12);
        PositionsZ = local_504c + uVar12 * -2 + iVar11;
        Names = local_504c + uVar12 * -3 + iVar11;
        Descriptions = local_504c + uVar12 * -4 + iVar11;
        iVar5 = -(iVar5 * 0x1e + 0x2dU & 0xfffffff0);
        Towns = local_504c + uVar12 * -5 + iVar11;
        piVar13 = local_504c + iVar5 + uVar12 * -5 + iVar11;
        Rents = piVar13;
        Sizes = local_504c + iVar5 + uVar12 * -6 + iVar11;
        iVar1 = -(Houses + 0xfU & 0xfffffff0);
        local_5048 = local_504c + iVar1 + iVar5 + uVar12 * -7 + iVar11;
        iVar14 = 0;
        Guildhouses = local_504c + iVar5 + uVar12 * -7 + iVar11;
        if (0 < Houses) {
            do {
                *(int *)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc) = iVar14;
                *(vector<THouse> **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10)
                     = &House;
                    // try { // try from 080661a4 to 0806635c has its CatchHandler @ 080663bb
                *(undefined4 *)((int)&uStack_5080 + iVar1 + iVar5 + uVar12 * -7 + iVar11) =
                     0x80661a9;
                pTVar4 = vector<THouse>::operator()
                                   (*(vector<THouse> **)
                                     ((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10
                                     ),*(int *)((int)local_506c +
                                               iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc));
                *(ushort *)(PositionsX + iVar14 * 2) = pTVar4->ID;
                *(int *)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc) = iVar14;
                *(vector<THouse> **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10)
                     = &House;
                *(undefined4 *)((int)&uStack_5080 + iVar1 + iVar5 + uVar12 * -7 + iVar11) =
                     0x80661c6;
                pTVar4 = vector<THouse>::operator()
                                   (*(vector<THouse> **)
                                     ((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10
                                     ),*(int *)((int)local_506c +
                                               iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc));
                *(char **)(Descriptions + iVar14 * 4) = pTVar4->Name;
                *(int *)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc) = iVar14;
                *(vector<THouse> **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10)
                     = &House;
                *(undefined4 *)((int)&uStack_5080 + iVar1 + iVar5 + uVar12 * -7 + iVar11) =
                     0x80661e2;
                pTVar4 = vector<THouse>::operator()
                                   (*(vector<THouse> **)
                                     ((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10
                                     ),*(int *)((int)local_506c +
                                               iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc));
                *(ulong *)(Sizes + iVar14 * 4) = pTVar4->Rent;
                *(int *)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc) = iVar14;
                *(vector<THouse> **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10)
                     = &House;
                *(undefined4 *)((int)&uStack_5080 + iVar1 + iVar5 + uVar12 * -7 + iVar11) =
                     0x8066201;
                pTVar4 = vector<THouse>::operator()
                                   (*(vector<THouse> **)
                                     ((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10
                                     ),*(int *)((int)local_506c +
                                               iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc));
                *(char **)(Towns + iVar14 * 4) = pTVar4->Description;
                *(int *)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc) = iVar14;
                *(vector<THouse> **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10)
                     = &House;
                *(undefined4 *)((int)&uStack_5080 + iVar1 + iVar5 + uVar12 * -7 + iVar11) =
                     0x806621d;
                pTVar4 = vector<THouse>::operator()
                                   (*(vector<THouse> **)
                                     ((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10
                                     ),*(int *)((int)local_506c +
                                               iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc));
                *(int *)(Guildhouses + iVar14 * 4) = pTVar4->Size;
                *(int *)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc) = iVar14;
                *(vector<THouse> **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10)
                     = &House;
                *(undefined4 *)((int)&uStack_5080 + iVar1 + iVar5 + uVar12 * -7 + iVar11) =
                     0x806623c;
                pTVar4 = vector<THouse>::operator()
                                   (*(vector<THouse> **)
                                     ((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10
                                     ),*(int *)((int)local_506c +
                                               iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc));
                *(int *)(PositionsY + iVar14 * 4) = pTVar4->CenterX;
                *(int *)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc) = iVar14;
                *(vector<THouse> **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10)
                     = &House;
                *(undefined4 *)((int)&uStack_5080 + iVar1 + iVar5 + uVar12 * -7 + iVar11) =
                     0x806625b;
                pTVar4 = vector<THouse>::operator()
                                   (*(vector<THouse> **)
                                     ((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10
                                     ),*(int *)((int)local_506c +
                                               iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc));
                *(int *)(PositionsZ + iVar14 * 4) = pTVar4->CenterY;
                *(int *)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc) = iVar14;
                *(vector<THouse> **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10)
                     = &House;
                *(undefined4 *)((int)&uStack_5080 + iVar1 + iVar5 + uVar12 * -7 + iVar11) =
                     0x806627a;
                pTVar4 = vector<THouse>::operator()
                                   (*(vector<THouse> **)
                                     ((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10
                                     ),*(int *)((int)local_506c +
                                               iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc));
                *(int *)(Names + iVar14 * 4) = pTVar4->CenterZ;
                *(int *)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc) = iVar14;
                *(vector<THouse> **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10)
                     = &House;
                *(undefined4 *)((int)&uStack_5080 + iVar1 + iVar5 + uVar12 * -7 + iVar11) =
                     0x8066299;
                pTVar4 = vector<THouse>::operator()
                                   (*(vector<THouse> **)
                                     ((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10
                                     ),*(int *)((int)local_506c +
                                               iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc));
                *(int *)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10) =
                     pTVar4->DepotNr;
                *(undefined4 *)((int)&uStack_5080 + iVar1 + iVar5 + uVar12 * -7 + iVar11) =
                     0x80662a7;
                pcVar7 = GetDepotName(*(int *)((int)local_506c +
                                              iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10));
                *(char **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc) = pcVar7;
                *(int_0_ **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10) =
                     piVar13;
                *(undefined4 *)((int)&uStack_5080 + iVar1 + iVar5 + uVar12 * -7 + iVar11) =
                     0x80662b3;
                strcpy(*(char **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10),
                       *(char **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc));
                *(vector<THouse> **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10)
                     = &House;
                *(int *)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc) = iVar14;
                *(undefined4 *)((int)&uStack_5080 + iVar1 + iVar5 + uVar12 * -7 + iVar11) =
                     0x80662c3;
                pTVar4 = vector<THouse>::operator()
                                   (*(vector<THouse> **)
                                     ((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10
                                     ),*(int *)((int)local_506c +
                                               iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc));
                piVar13 = piVar13 + 0x1e;
                local_5048[iVar14] = pTVar4->GuildHouse;
                iVar14 = iVar14 + 1;
            } while (iVar14 < Houses);
        }
        *(int_0_ **)(local_504c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -4) = local_5048;
        *(int_0_ **)(local_504c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -8) = Rents;
        *(char___0_ **)(local_504c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc) = Names;
        *(int_0_ **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + 0x10) = PositionsZ;
        *(int_0_ **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + 0xc) = PositionsY;
        *(bool_0_ **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + 8) = Guildhouses;
        *(char_0__30_ **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + 4) = Towns;
        *(int_0_ **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11) = Sizes;
        *(char___0_ **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -4) = Descriptions;
        *(int_0_ **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -8) = PositionsX;
        *(int *)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc) = Houses;
        *(TQueryManagerConnection **)
         ((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10) = QueryManagerConnection;
        *(undefined4 *)((int)&uStack_5080 + iVar1 + iVar5 + uVar12 * -7 + iVar11) = 0x806635d;
        iVar14 = TQueryManagerConnection::insertHouses
                           (*(TQueryManagerConnection **)
                             ((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10),
                            *(int *)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc),
                            *(ushort **)
                             ((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -8),
                            *(char ***)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -4)
                            ,*(int **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11),
                            *(char ***)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + 4),
                            *(int **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + 8),
                            *(int **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + 0xc),
                            *(int **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + 0x10)
                            ,*(int **)(local_504c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc),
                            *(char (**) [30])
                             (local_504c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -8),
                            *(bool **)(local_504c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -4));
        if (iVar14 != 0) {
            *(undefined **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10) =
                 &DAT_080f4a80;
                    // try { // try from 08066381 to 08066385 has its CatchHandler @ 080663bb
            *(undefined4 *)((int)&uStack_5080 + iVar1 + iVar5 + uVar12 * -7 + iVar11) = 0x8066386;
            error(*(char **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10));
        }
        *(int **)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10) = &z;
                    // try { // try from 0806636a to 0806636e has its CatchHandler @ 080663c1
        *(undefined4 *)((int)&uStack_5080 + iVar1 + iVar5 + uVar12 * -7 + iVar11) = 0x806636f;
        TReadScriptFile::~TReadScriptFile
                  (*(TReadScriptFile **)
                    ((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0x10),
                   *(int *)((int)local_506c + iVar1 + iVar5 + uVar12 * -7 + iVar11 + -0xc));
    }
    else {
        uStack_5080 = 0x8065812;
        Log("houses",&DAT_080f4e82);
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void LoadOwners(void)

{
    ushort uVar1;
    char_0__30_ *pcVar2;
    bool bVar3;
    char cVar4;
    bool bVar5;
    int_0_ *PaidUntils;
    THouse *pTVar6;
    ulong uVar7;
    THouseGuest *pTVar8;
    undefined4 *puVar9;
    int iVar10;
    int iVar11;
    int iVar12;
    int iVar13;
    int iVar14;
    ulong_0_ *OwnerIDs;
    uint uVar15;
    int iVar16;
    undefined4 *puVar17;
    THouse *house;
    int iVar18;
    char *pcVar19;
    undefined1 uVar20;
    undefined4 uStack_5080;
    char *pcVar21;
    char *pcVar22;
    int aiStack_5070 [3];
    undefined1 auStack_5064 [16];
    int local_5054;
    int z;
    int y;
    int x;
    THouse *house_2;
    int i_1;
    char_0__30_ *OwnerNames;
    ushort_0_ *HouseIDs;
    char local_5032;
    char local_5031;
    bool ClearBeds;
    int iStack_5030;
    bool ClearGuests;
    int NumberOfHouses;
    ulong local_501c [4];
    ulong local_500c;
    Object Bed;
    undefined1 local_4ffc [4];
    TReadScriptFile Script;
    char local_101c [4];
    char FileName [4096];
    
    HouseIDs = &stack0xffffaf84;
    puVar17 = (undefined4 *)&stack0xffffaf84;
                    // try { // try from 080663f7 to 0806646d has its CatchHandler @ 08066c00
    uStack_5080 = 0x80663fc;
    Log("houses","Lade Mieterdaten...\n");
    local_5031 = '\0';
    pcVar21 = local_101c;
    PaymentExtension = 0;
    local_5032 = '\0';
    pcVar22 = DATAPATH;
    uStack_5080 = 0x806642f;
    sprintf(pcVar21,"%s/owners.dat");
    uStack_5080 = 0x8066437;
    bVar3 = FileExists(pcVar21);
    if (bVar3) {
        uStack_5080 = 0x806646e;
        TReadScriptFile::TReadScriptFile((TReadScriptFile *)local_4ffc);
                    // try { // try from 0806647b to 080668c5 has its CatchHandler @ 08066bf6
        uStack_5080 = 0x8066480;
        TReadScriptFile::open((TReadScriptFile *)local_4ffc,pcVar21,(int)pcVar22);
        while( true ) {
            uStack_5080 = 0x806648e;
            TReadScriptFile::nextToken((TReadScriptFile *)local_4ffc);
            if (local_4ffc == (undefined1  [4])0x0) break;
            uVar20 = local_4ffc == (undefined1  [4])0x1;
            if (!(bool)uVar20) {
                pcVar21 = "Identifier expected";
                uStack_5080 = 0x80664af;
                TReadScriptFile::error((TReadScriptFile *)local_4ffc,"Identifier expected");
            }
            uStack_5080 = 0x80664bd;
            pcVar22 = TReadScriptFile::getIdentifier((TReadScriptFile *)local_4ffc);
            iVar11 = 10;
            pcVar19 = "extension";
            do {
                if (iVar11 == 0) break;
                iVar11 = iVar11 + -1;
                uVar20 = *pcVar22 == *pcVar19;
                pcVar22 = pcVar22 + 1;
                pcVar19 = pcVar19 + 1;
            } while ((bool)uVar20);
            if ((bool)uVar20) {
                pcVar21 = (char *)0x3d;
                uStack_5080 = 0x80667f9;
                TReadScriptFile::readSymbol((TReadScriptFile *)local_4ffc,'=');
                uStack_5080 = 0x8066807;
                PaymentExtension = TReadScriptFile::readNumber((TReadScriptFile *)local_4ffc);
            }
            else {
                uStack_5080 = 0x80664e2;
                pcVar22 = TReadScriptFile::getIdentifier((TReadScriptFile *)local_4ffc);
                iVar11 = 0xc;
                pcVar19 = "clearguests";
                do {
                    if (iVar11 == 0) break;
                    iVar11 = iVar11 + -1;
                    uVar20 = *pcVar22 == *pcVar19;
                    pcVar22 = pcVar22 + 1;
                    pcVar19 = pcVar19 + 1;
                } while ((bool)uVar20);
                if ((bool)uVar20) {
                    local_5031 = '\x01';
                }
                else {
                    uStack_5080 = 0x8066507;
                    pcVar22 = TReadScriptFile::getIdentifier((TReadScriptFile *)local_4ffc);
                    iVar11 = 10;
                    pcVar19 = "clearbeds";
                    do {
                        if (iVar11 == 0) break;
                        iVar11 = iVar11 + -1;
                        uVar20 = *pcVar22 == *pcVar19;
                        pcVar22 = pcVar22 + 1;
                        pcVar19 = pcVar19 + 1;
                    } while ((bool)uVar20);
                    if ((bool)uVar20) {
                        local_5032 = '\x01';
                    }
                    else {
                        uStack_5080 = 0x806652c;
                        pcVar21 = TReadScriptFile::getIdentifier((TReadScriptFile *)local_4ffc);
                        iVar11 = 3;
                        pcVar22 = "id";
                        do {
                            if (iVar11 == 0) break;
                            iVar11 = iVar11 + -1;
                            uVar20 = *pcVar21 == *pcVar22;
                            pcVar21 = pcVar21 + 1;
                            pcVar22 = pcVar22 + 1;
                        } while ((bool)uVar20);
                        if (!(bool)uVar20) {
                            uStack_5080 = 0x80667c6;
                            TReadScriptFile::error
                                      ((TReadScriptFile *)local_4ffc,"Unknown identifier");
                        }
                        uStack_5080 = 0x8066559;
                        TReadScriptFile::readSymbol((TReadScriptFile *)local_4ffc,'=');
                        uStack_5080 = 0x8066567;
                        iVar11 = TReadScriptFile::readNumber((TReadScriptFile *)local_4ffc);
                        uStack_5080 = 0x8066572;
                        pTVar6 = GetHouse((ushort)iVar11);
                        if (pTVar6 == (THouse *)0x0) {
                            uStack_5080 = 0x8066780;
                            error("LoadOwners: Haus zu ID %d existiert nicht.");
                            goto LAB_08066780;
                        }
                        uStack_5080 = 0x806658a;
                        TReadScriptFile::readIdentifier((TReadScriptFile *)local_4ffc);
                        uStack_5080 = 0x80665a0;
                        TReadScriptFile::readSymbol((TReadScriptFile *)local_4ffc,'=');
                        uStack_5080 = 0x80665ae;
                        uVar7 = TReadScriptFile::readNumber((TReadScriptFile *)local_4ffc);
                        pTVar6->OwnerID = uVar7;
                        uStack_5080 = 0x80665bc;
                        TReadScriptFile::readIdentifier((TReadScriptFile *)local_4ffc);
                        uStack_5080 = 0x80665cc;
                        TReadScriptFile::readSymbol((TReadScriptFile *)local_4ffc,'=');
                        uStack_5080 = 0x80665d4;
                        iVar11 = TReadScriptFile::readNumber((TReadScriptFile *)local_4ffc);
                        pTVar6->LastTransition = iVar11;
                        uStack_5080 = 0x80665e2;
                        TReadScriptFile::readIdentifier((TReadScriptFile *)local_4ffc);
                        uStack_5080 = 0x80665f2;
                        TReadScriptFile::readSymbol((TReadScriptFile *)local_4ffc,'=');
                        uStack_5080 = 0x80665fa;
                        iVar11 = TReadScriptFile::readNumber((TReadScriptFile *)local_4ffc);
                        pTVar6->PaidUntil = iVar11;
                        uStack_5080 = 0x8066608;
                        TReadScriptFile::readIdentifier((TReadScriptFile *)local_4ffc);
                        uStack_5080 = 0x8066618;
                        TReadScriptFile::readSymbol((TReadScriptFile *)local_4ffc,'=');
                        uStack_5080 = 0x8066628;
                        TReadScriptFile::readSymbol((TReadScriptFile *)local_4ffc,'{');
                        while( true ) {
                            uStack_5080 = 0x8066636;
                            TReadScriptFile::nextToken((TReadScriptFile *)local_4ffc);
                            if (local_4ffc != (undefined1  [4])0x6) goto LAB_0806666c;
                            uStack_5080 = 0x806664d;
                            cVar4 = TReadScriptFile::getSpecial((TReadScriptFile *)local_4ffc);
                            if (cVar4 == '}') break;
                            if (local_4ffc != (undefined1  [4])0x6) goto LAB_0806666c;
                            uStack_5080 = 0x8066668;
                            cVar4 = TReadScriptFile::getSpecial((TReadScriptFile *)local_4ffc);
                            if (cVar4 != ',') {
LAB_0806666c:
                                uStack_5080 = 0x806667a;
                                pcVar21 = TReadScriptFile::getString((TReadScriptFile *)local_4ffc);
                                uStack_5080 = 0x8066694;
                                pTVar8 = vector<>::operator()(&pTVar6->Guest,pTVar6->Guests);
                                uStack_5080 = 0x80666a0;
                                strcpy(pTVar8->Name,pcVar21);
                                pTVar6->Guests = pTVar6->Guests + 1;
                            }
                        }
                        uStack_5080 = 0x80666b6;
                        TReadScriptFile::readIdentifier((TReadScriptFile *)local_4ffc);
                        uStack_5080 = 0x80666cc;
                        TReadScriptFile::readSymbol((TReadScriptFile *)local_4ffc,'=');
                        pcVar21 = (char *)0x7b;
                        uStack_5080 = 0x80666dc;
                        TReadScriptFile::readSymbol((TReadScriptFile *)local_4ffc,'{');
                        while( true ) {
                            uStack_5080 = 0x80666ea;
                            TReadScriptFile::nextToken((TReadScriptFile *)local_4ffc);
                            if (local_4ffc != (undefined1  [4])0x6) goto LAB_0806671a;
                            uStack_5080 = 0x8066701;
                            cVar4 = TReadScriptFile::getSpecial((TReadScriptFile *)local_4ffc);
                            if (cVar4 == '}') break;
                            if (local_4ffc != (undefined1  [4])0x6) goto LAB_0806671a;
                            uStack_5080 = 0x8066716;
                            cVar4 = TReadScriptFile::getSpecial((TReadScriptFile *)local_4ffc);
                            if (cVar4 != ',') {
LAB_0806671a:
                                uStack_5080 = 0x8066728;
                                pcVar21 = TReadScriptFile::getString((TReadScriptFile *)local_4ffc);
                                uStack_5080 = 0x8066742;
                                pTVar8 = vector<>::operator()(&pTVar6->Subowner,pTVar6->Subowners);
                                uStack_5080 = 0x806674e;
                                strcpy(pTVar8->Name,pcVar21);
                                pTVar6->Subowners = pTVar6->Subowners + 1;
                            }
                        }
                        if (local_5031 != '\0') {
                            pTVar6->Guests = 0;
                        }
                    }
                }
            }
        }
        uStack_5080 = 0x806681f;
        TReadScriptFile::close((TReadScriptFile *)local_4ffc,(int)pcVar21);
        iStack_5030 = Houses;
        iVar12 = Houses + -1;
        iVar11 = -(Houses + 0x10 + iVar12 & 0xfffffff0U);
        uVar15 = iVar12 * 4 + 0x13U & 0xfffffff0;
        OwnerNames = auStack_5064 + iVar11;
        iVar12 = -(iVar12 * 0x1e + 0x2dU & 0xfffffff0);
        puVar17 = (undefined4 *)(auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -0x18);
        i_1 = (int)(auStack_5064 + iVar12 + -uVar15 + iVar11);
        *(undefined1 **)(auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -4) =
             auStack_5064 + iVar12 + uVar15 * -2 + iVar11;
        *(undefined1 **)((int)aiStack_5070 + iVar12 + uVar15 * -2 + iVar11 + 4) =
             auStack_5064 + iVar12 + -uVar15 + iVar11;
        *(undefined1 **)((int)aiStack_5070 + iVar12 + uVar15 * -2 + iVar11) =
             auStack_5064 + -uVar15 + iVar11;
        pcVar2 = OwnerNames;
        *(int **)(auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -0x14) = &stack0xffffafd0;
        *(char_0__30_ **)(&stack0xffffaf8c + iVar12 + uVar15 * -2 + iVar11) = pcVar2;
        *(TQueryManagerConnection **)(auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -0x18) =
             QueryManagerConnection;
        *(undefined4 *)((int)&uStack_5080 + iVar12 + uVar15 * -2 + iVar11) = 0x806689c;
        iVar10 = TQueryManagerConnection::getHouseOwners
                           (*(TQueryManagerConnection **)
                             (auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -0x18),
                            *(int **)(auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -0x14),
                            *(ushort **)(&stack0xffffaf8c + iVar12 + uVar15 * -2 + iVar11),
                            *(ulong **)((int)aiStack_5070 + iVar12 + uVar15 * -2 + iVar11),
                            *(char (**) [30])((int)aiStack_5070 + iVar12 + uVar15 * -2 + iVar11 + 4)
                            ,*(int **)(auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -4));
        if (iVar10 != 0) {
            *(char **)(auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -0x18) =
                 "LoadOwners: Kann Namen der Mieter nicht ermitteln.\n";
            *(undefined4 *)((int)&uStack_5080 + iVar12 + uVar15 * -2 + iVar11) = 0x8066ba3;
            error(*(char **)(auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -0x18));
LAB_08066780:
            *puVar17 = 4;
            puVar17[-1] = 0x806678c;
            puVar9 = (undefined4 *)__cxa_allocate_exception();
            *puVar9 = "Cannot load owners";
            puVar17[2] = 0;
            puVar17[1] = char_const*::typeinfo;
            *puVar17 = puVar9;
                    // WARNING: Subroutine does not return
            puVar17[-1] = &UNK_080667aa;
            __cxa_throw();
        }
        iVar18 = 0;
        iVar10 = i_1;
        if (0 < iStack_5030) {
            do {
                *(uint *)(auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -0x18) =
                     (uint)*(ushort *)(OwnerNames + iVar18 * 2);
                *(undefined4 *)((int)&uStack_5080 + iVar12 + uVar15 * -2 + iVar11) = 0x80668c6;
                pTVar6 = GetHouse(*(ushort *)(auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -0x18))
                ;
                if (pTVar6 == (THouse *)0x0) {
                    uVar1 = *(ushort *)(OwnerNames + iVar18 * 2);
                    *(char **)(auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -0x18) =
                         "LoadOwners: Haus %d existiert nicht.\n";
                    *(uint *)(auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -0x14) = (uint)uVar1;
                    *(undefined4 *)((int)&uStack_5080 + iVar12 + uVar15 * -2 + iVar11) = 0x8066b92;
                    error(*(char **)(auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -0x18));
                }
                else if (pTVar6->OwnerID != 0) {
                    *(int *)(auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -0x14) = iVar10;
                    *(char **)(auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -0x18) =
                         pTVar6->OwnerName;
                    *(undefined4 *)((int)&uStack_5080 + iVar12 + uVar15 * -2 + iVar11) = 0x8066b73;
                    strcpy(*(char **)(auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -0x18),
                           *(char **)(auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -0x14));
                }
                iVar18 = iVar18 + 1;
                iVar10 = iVar10 + 0x1e;
            } while (iVar18 < iStack_5030);
        }
        if (local_5032 != '\0') {
            *(undefined **)(auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -0x14) = &DAT_080f4f5b;
            *(undefined4 *)(auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -0x18) = 1;
                    // try { // try from 08066919 to 08066a1c has its CatchHandler @ 08066bf6
            *(undefined4 *)((int)&uStack_5080 + iVar12 + uVar15 * -2 + iVar11) = 0x806691e;
            print();
            house_2 = (THouse *)0x0;
            if (0 < Houses) {
                do {
                    pTVar6 = house_2;
                    *(vector<THouse> **)(auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -0x18) =
                         &House;
                    *(THouse **)(auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -0x14) = pTVar6;
                    *(undefined4 *)((int)&uStack_5080 + iVar12 + uVar15 * -2 + iVar11) = 0x8066946;
                    x = (int)vector<THouse>::operator()
                                       (*(vector<THouse> **)
                                         (auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -0x18),
                                        *(int *)(auStack_5064 +
                                                iVar12 + uVar15 * -2 + iVar11 + -0x14));
                    iVar10 = ((THouse *)x)->CenterX;
                    y = iVar10 - MaxHouseX;
                    if (iVar10 - MaxHouseX <= MaxHouseX + iVar10) {
                        iVar18 = ((THouse *)x)->CenterY;
                        iVar14 = MaxHouseX;
                        iVar16 = MaxHouseY;
                        do {
                            z = iVar18 - iVar16;
                            iVar13 = SectorZMax;
                            if (iVar18 - iVar16 <= iVar16 + iVar18) {
                                do {
                                    local_5054 = SectorZMin;
                                    if (SectorZMin <= iVar13) {
                                        do {
                                            *(int *)((int)aiStack_5070 +
                                                    iVar12 + uVar15 * -2 + iVar11) = local_5054;
                                            *(int *)(&stack0xffffaf8c +
                                                    iVar12 + uVar15 * -2 + iVar11) = z;
                                            iVar10 = y;
                                            *(ulong **)
                                             (auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -0x18)
                                                 = &local_500c;
                                            *(int *)(auStack_5064 +
                                                    iVar12 + uVar15 * -2 + iVar11 + -0x14) = iVar10;
                                            *(undefined4 *)
                                             ((int)&uStack_5080 + iVar12 + uVar15 * -2 + iVar11) =
                                                 0x80669d9;
                                            GetFirstObject();
                                            while( true ) {
                                                bVar3 = false;
                                                local_501c[0] = NONE.ObjectID;
                                                NumberOfHouses = NONE.ObjectID;
                                                if (local_500c != NONE.ObjectID) {
                                                    *(int **)(auStack_5064 +
                                                             iVar12 + uVar15 * -2 + iVar11 + -0x18)
                                                         = &NumberOfHouses;
                                                    *(ulong **)
                                                     (auStack_5064 +
                                                     iVar12 + uVar15 * -2 + iVar11 + -0x14) =
                                                         &local_500c;
                                                    *(undefined4 *)
                                                     ((int)&uStack_5080 +
                                                     iVar12 + uVar15 * -2 + iVar11) = 0x8066b40;
                                                    Object::getObjectType
                                                              (*(Object **)
                                                                (auStack_5064 +
                                                                iVar12 + uVar15 * -2 + iVar11 +
                                                                -0x18));
                                                    *(undefined4 *)
                                                     (auStack_5064 +
                                                     iVar12 + uVar15 * -2 + iVar11 + -0x14) = 0x14;
                                                    *(int **)(auStack_5064 +
                                                             iVar12 + uVar15 * -2 + iVar11 + -0x18)
                                                         = &NumberOfHouses;
                                                    *(undefined4 *)
                                                     ((int)&uStack_5080 +
                                                     iVar12 + uVar15 * -2 + iVar11) = 0x8066b53;
                                                    bVar5 = ObjectType::getFlag(*(ObjectType **)
                                                                                 (auStack_5064 +
                                                                                 iVar12 + uVar15 * 
                                                  -2 + iVar11 + -0x18),
                                                  *(FLAG *)(auStack_5064 +
                                                           iVar12 + uVar15 * -2 + iVar11 + -0x14));
                                                  if (!bVar5) {
                                                      bVar3 = true;
                                                  }
                                                }
                                                if (!bVar3) break;
                                                *(ulong **)
                                                 (auStack_5064 +
                                                 iVar12 + uVar15 * -2 + iVar11 + -0x14) =
                                                     &local_500c;
                                                *(ulong **)
                                                 (auStack_5064 +
                                                 iVar12 + uVar15 * -2 + iVar11 + -0x18) = local_501c
                                                ;
                                                *(undefined4 *)
                                                 ((int)&uStack_5080 + iVar12 + uVar15 * -2 + iVar11)
                                                     = 0x8066a1d;
                                                Object::getNextObject
                                                          (*(Object **)
                                                            (auStack_5064 +
                                                            iVar12 + uVar15 * -2 + iVar11 + -0x18));
                                                local_500c = local_501c[0];
                                            }
                                            bVar3 = false;
                                            NumberOfHouses = NONE.ObjectID;
                                            if (local_500c == NONE.ObjectID) {
LAB_08066a4d:
                                                bVar3 = true;
                                            }
                                            else {
                                                *(undefined4 *)
                                                 (auStack_5064 +
                                                 iVar12 + uVar15 * -2 + iVar11 + -0x14) = 9;
                                                *(ulong **)
                                                 (auStack_5064 +
                                                 iVar12 + uVar15 * -2 + iVar11 + -0x18) =
                                                     &local_500c;
                    // try { // try from 08066b1c to 08066ba2 has its CatchHandler @ 08066bf6
                                                *(undefined4 *)
                                                 ((int)&uStack_5080 + iVar12 + uVar15 * -2 + iVar11)
                                                     = 0x8066b21;
                                                uVar7 = Object::getAttribute
                                                                  (*(Object **)
                                                                    (auStack_5064 +
                                                                    iVar12 + uVar15 * -2 + iVar11 +
                                                                    -0x18),*(INSTANCEATTRIBUTE *)
                                                                            (auStack_5064 +
                                                                            iVar12 + uVar15 * -2 +
                                                                                     iVar11 + -0x14)
                                                                  );
                                                if (uVar7 == 0) goto LAB_08066a4d;
                                            }
                                            if (!bVar3) {
                                                NumberOfHouses = local_500c;
                                                local_501c[0] = local_500c;
                                                *(int **)(&stack0xffffaf8c +
                                                         iVar12 + uVar15 * -2 + iVar11) =
                                                     &NumberOfHouses;
                                                *(ulong **)
                                                 (auStack_5064 +
                                                 iVar12 + uVar15 * -2 + iVar11 + -0x14) = local_501c
                                                ;
                                                *(undefined4 *)
                                                 (auStack_5064 +
                                                 iVar12 + uVar15 * -2 + iVar11 + -0x18) = 0;
                    // try { // try from 08066b01 to 08066b05 has its CatchHandler @ 08066ba8
                                                *(undefined4 *)
                                                 ((int)&uStack_5080 + iVar12 + uVar15 * -2 + iVar11)
                                                     = 0x8066b06;
                                                UseObjects(*(ulong *)(auStack_5064 +
                                                                     iVar12 + uVar15 * -2 + iVar11 +
                                                                     -0x18),
                                                           *(Object **)
                                                            (auStack_5064 +
                                                            iVar12 + uVar15 * -2 + iVar11 + -0x14),
                                                           *(Object **)
                                                            (&stack0xffffaf8c +
                                                            iVar12 + uVar15 * -2 + iVar11));
                                            }
                                            local_5054 = local_5054 + 1;
                                        } while (local_5054 <= SectorZMax);
                                        iVar18 = *(int *)(x + 0x248);
                                        iVar13 = SectorZMax;
                                        iVar16 = MaxHouseY;
                                    }
                                    z = z + 1;
                                } while (z <= iVar16 + iVar18);
                                iVar10 = *(int *)(x + 0x244);
                                iVar14 = MaxHouseX;
                            }
                            y = y + 1;
                        } while (y <= iVar14 + iVar10);
                    }
                    house_2 = (THouse *)((int)&house_2->ID + 1);
                } while ((int)house_2 < Houses);
            }
        }
        *(undefined1 **)(auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -0x18) = local_4ffc;
                    // try { // try from 080668fa to 080668fe has its CatchHandler @ 08066c00
        *(undefined4 *)((int)&uStack_5080 + iVar12 + uVar15 * -2 + iVar11) = 0x80668ff;
        TReadScriptFile::~TReadScriptFile
                  (*(TReadScriptFile **)(auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -0x18),
                   *(int *)(auStack_5064 + iVar12 + uVar15 * -2 + iVar11 + -0x14));
    }
    else {
        uStack_5080 = 0x806644f;
        Log("houses","Keine Mieterdaten gefunden.\n");
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void SaveOwners(void)

{
    time_t tVar1;
    THouse *pTVar2;
    THouseGuest *pTVar3;
    int i;
    int j;
    int iVar4;
    char *__s;
    char *pcVar5;
    undefined1 local_202c [4];
    TWriteScriptFile Script;
    char local_101c [4];
    char FileName [4096];
    
                    // try { // try from 08066c31 to 08066c61 has its CatchHandler @ 08066f20
    Log("houses","Speichere Mieterdaten...\n");
    pcVar5 = DATAPATH;
    __s = local_101c;
    sprintf(__s,"%s/owners.dat");
    TWriteScriptFile::TWriteScriptFile((TWriteScriptFile *)local_202c);
                    // try { // try from 08066c69 to 08066c97 has its CatchHandler @ 08066f06
    TWriteScriptFile::open((TWriteScriptFile *)local_202c,__s,(int)pcVar5);
    tVar1 = time((time_t *)0x0);
    if (tVar1 < PaymentExtension) {
        TWriteScriptFile::writeText((TWriteScriptFile *)local_202c,"Extension = ");
        __s = (char *)PaymentExtension;
        TWriteScriptFile::writeNumber((TWriteScriptFile *)local_202c,PaymentExtension);
        TWriteScriptFile::writeLn((TWriteScriptFile *)local_202c);
        TWriteScriptFile::writeLn((TWriteScriptFile *)local_202c);
    }
    pcVar5 = (char *)0x0;
    if (0 < Houses) {
        do {
            __s = pcVar5;
                    // try { // try from 08066cb8 to 08066f00 has its CatchHandler @ 08066f06
            pTVar2 = vector<THouse>::operator()(&House,(int)pcVar5);
            if (pTVar2->OwnerID != 0) {
                TWriteScriptFile::writeText((TWriteScriptFile *)local_202c,"ID = ");
                pTVar2 = vector<THouse>::operator()(&House,(int)pcVar5);
                TWriteScriptFile::writeNumber((TWriteScriptFile *)local_202c,(uint)pTVar2->ID);
                TWriteScriptFile::writeLn((TWriteScriptFile *)local_202c);
                TWriteScriptFile::writeText((TWriteScriptFile *)local_202c,"Owner = ");
                pTVar2 = vector<THouse>::operator()(&House,(int)pcVar5);
                TWriteScriptFile::writeNumber((TWriteScriptFile *)local_202c,pTVar2->OwnerID);
                TWriteScriptFile::writeLn((TWriteScriptFile *)local_202c);
                TWriteScriptFile::writeText((TWriteScriptFile *)local_202c,"LastTransition = ");
                pTVar2 = vector<THouse>::operator()(&House,(int)pcVar5);
                TWriteScriptFile::writeNumber((TWriteScriptFile *)local_202c,pTVar2->LastTransition)
                ;
                TWriteScriptFile::writeLn((TWriteScriptFile *)local_202c);
                TWriteScriptFile::writeText((TWriteScriptFile *)local_202c,"PaidUntil = ");
                pTVar2 = vector<THouse>::operator()(&House,(int)pcVar5);
                TWriteScriptFile::writeNumber((TWriteScriptFile *)local_202c,pTVar2->PaidUntil);
                TWriteScriptFile::writeLn((TWriteScriptFile *)local_202c);
                TWriteScriptFile::writeText((TWriteScriptFile *)local_202c,"Guests = {");
                for (iVar4 = 0; pTVar2 = vector<THouse>::operator()(&House,(int)pcVar5),
                    iVar4 < pTVar2->Guests; iVar4 = iVar4 + 1) {
                    if (0 < iVar4) {
                        TWriteScriptFile::writeText((TWriteScriptFile *)local_202c,",");
                    }
                    pTVar2 = vector<THouse>::operator()(&House,(int)pcVar5);
                    pTVar3 = vector<>::operator()(&pTVar2->Guest,iVar4);
                    TWriteScriptFile::writeString((TWriteScriptFile *)local_202c,pTVar3->Name);
                }
                TWriteScriptFile::writeText((TWriteScriptFile *)local_202c,"}");
                TWriteScriptFile::writeLn((TWriteScriptFile *)local_202c);
                TWriteScriptFile::writeText((TWriteScriptFile *)local_202c,"Subowners = {");
                for (iVar4 = 0; pTVar2 = vector<THouse>::operator()(&House,(int)pcVar5),
                    iVar4 < pTVar2->Subowners; iVar4 = iVar4 + 1) {
                    if (0 < iVar4) {
                        TWriteScriptFile::writeText((TWriteScriptFile *)local_202c,",");
                    }
                    pTVar2 = vector<THouse>::operator()(&House,(int)pcVar5);
                    pTVar3 = vector<>::operator()(&pTVar2->Subowner,iVar4);
                    TWriteScriptFile::writeString((TWriteScriptFile *)local_202c,pTVar3->Name);
                }
                __s = "}";
                TWriteScriptFile::writeText((TWriteScriptFile *)local_202c,"}");
                TWriteScriptFile::writeLn((TWriteScriptFile *)local_202c);
                TWriteScriptFile::writeLn((TWriteScriptFile *)local_202c);
            }
            pcVar5 = pcVar5 + 1;
        } while ((int)pcVar5 < Houses);
    }
    TWriteScriptFile::close((TWriteScriptFile *)local_202c,(int)__s);
                    // try { // try from 08066c9b to 08066c9f has its CatchHandler @ 08066f20
    TWriteScriptFile::~TWriteScriptFile((TWriteScriptFile *)local_202c,(int)__s);
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void InitHouses(void)

{
    TQueryManagerConnection *pTVar1;
    RESULT r;
    int in_stack_ffffffe8;
    
                    // try { // try from 08066f43 to 08066f81 has its CatchHandler @ 08066f90
    InitLog("houses");
    LoadHouseAreas();
    LoadHouses();
    LoadOwners();
    FinishAuctions();
    CollectRents();
    StartAuctions();
    pTVar1 = QueryManagerConnection;
    if (QueryManagerConnection != (TQueryManagerConnection *)0x0) {
        TQueryManagerConnection::~TQueryManagerConnection(QueryManagerConnection,in_stack_ffffffe8);
        operator_delete(pTVar1);
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ExitHouses(void)

{
                    // try { // try from 08067009 to 0806700d has its CatchHandler @ 08067015
    SaveOwners();
    return;
}



void __tcf_0(void *param_1)

{
    if (HouseArea.entry == (THouseArea *)0x0) {
        return;
    }
    operator_delete__(HouseArea.entry);
    return;
}



void __tcf_1(void *param_1)

{
    THouseGuest *pTVar1;
    THouse *pTVar2;
    THouse *pTVar3;
    
    if (House.entry != (THouse *)0x0) {
        pTVar2 = House.entry + House.entry[-1].Help;
        while (House.entry != pTVar2) {
            pTVar3 = pTVar2 + -1;
            pTVar1 = pTVar2[-1].Guest.entry;
            if (pTVar1 != (THouseGuest *)0x0) {
                operator_delete__(pTVar1);
            }
            pTVar1 = pTVar2[-1].Subowner.entry;
            pTVar2 = pTVar3;
            if (pTVar1 != (THouseGuest *)0x0) {
                operator_delete__(pTVar1);
            }
        }
        operator_delete__(&House.entry[-1].Help);
    }
    if (House.init.Guest.entry != (THouseGuest *)0x0) {
        operator_delete__(House.init.Guest.entry);
    }
    if (House.init.Subowner.entry != (THouseGuest *)0x0) {
        operator_delete__(House.init.Subowner.entry);
        return;
    }
    return;
}



void __tcf_2(void *param_1)

{
    if (HelpDepot.entry == (THelpDepot *)0x0) {
        return;
    }
    operator_delete__(HelpDepot.entry);
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__I_HouseArea(void)

{
    __static_initialization_and_destruction_0(1,0xffff);
    return;
}

void __static_initialization_and_destruction_0(int __initialize_p,int __priority)

{
    if ((__priority == 0xffff) && (__initialize_p == 1)) {
        NONE.ObjectID = 0;
        Semaphore::Semaphore(&ProtocolMutex,1);
        __cxa_atexit(__tcf_0,0,&__dso_handle);
        Semaphore::Semaphore(&ProtocolBufferEmpty,1000);
        __cxa_atexit(__tcf_1,0,&__dso_handle);
        Semaphore::Semaphore(&ProtocolBufferFull,0);
        __cxa_atexit(__tcf_2,0,&__dso_handle);
        Semaphore::Semaphore(&OrderBufferEmpty,2000);
        __cxa_atexit(__tcf_3,0,&__dso_handle);
        Semaphore::Semaphore(&OrderBufferFull,0);
        __cxa_atexit(__tcf_4,0,&__dso_handle);
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void InitProtocol(void)

{
    ProtocolPointerWrite = 0;
    ProtocolPointerRead = 0;
    return;
}



// WARNING: Variable defined which should be unmapped: Text_local

void InsertProtocolOrder(char *ProtocolName,char *Text)

{
    int iVar1;
    char *pcVar2;
    char *pcVar3;
    bool bVar4;
    char *Text_local;
    
    if (ProtocolName == (char *)0x0) {
        ProtocolName = "InsertProtocolOrder: Protokoll-Name nicht angegeben.\n";
    }
    else {
        if (Text != (char *)0x0) {
            bVar4 = ProtocolPointerWrite - ProtocolPointerRead == 999;
            if (999 < ProtocolPointerWrite - ProtocolPointerRead) {
                iVar1 = 6;
                pcVar2 = ProtocolName;
                pcVar3 = "error";
                do {
                    if (iVar1 == 0) break;
                    iVar1 = iVar1 + -1;
                    bVar4 = *pcVar2 == *pcVar3;
                    pcVar2 = pcVar2 + 1;
                    pcVar3 = pcVar3 + 1;
                } while (bVar4);
                if (!bVar4) {
                    error(&DAT_080f5260);
                }
            }
            Semaphore::down(&ProtocolMutex);
            Semaphore::down(&ProtocolBufferEmpty);
            strcpy(ProtocolBuffer[ProtocolPointerWrite % 1000].ProtocolName,ProtocolName);
            strcpy(ProtocolBuffer[ProtocolPointerWrite % 1000].Text,Text);
            ProtocolPointerWrite = ProtocolPointerWrite + 1;
            Semaphore::up(&ProtocolBufferFull);
            Semaphore::up(&ProtocolMutex);
            return;
        }
        ProtocolName = "InsertProtocolOrder: Text nicht angegeben.\n";
    }
    error(ProtocolName);
    return;
}



void GetProtocolOrder(char *ProtocolName,char *Text)

{
    Semaphore::down(&ProtocolBufferFull);
    strcpy(ProtocolName,ProtocolBuffer[ProtocolPointerRead % 1000].ProtocolName);
    strcpy(Text,ProtocolBuffer[ProtocolPointerRead % 1000].Text);
    ProtocolPointerRead = ProtocolPointerRead + 1;
    Semaphore::up(&ProtocolBufferEmpty);
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void WriteProtocol(void)

{
    FILE *__stream;
    int iVar1;
    int *piVar2;
    FILE *f;
    undefined4 in_stack_00000008;
    char local_100c [4];
    char FileName [4096];
    
    sprintf(local_100c,"%s/%s.log",LOGPATH);
    __stream = fopen(local_100c,"at");
    if (__stream != (FILE *)0x0) {
        fprintf(__stream,"%s",in_stack_00000008);
        iVar1 = fclose(__stream);
        if (iVar1 != 0) {
            piVar2 = __errno_location();
            error(&DAT_080f5320,*piVar2);
        }
    }
    return;
}



int ProtocolThreadLoop(void *param_1)

{
    FILE *__stream;
    int iVar1;
    int *piVar2;
    int iVar3;
    FILE *f;
    undefined8 local_1144;
    char local_113c [4];
    char FileName [4096];
    char Text [256];
    char ProtocolName [20];
    
    while( true ) {
        Semaphore::down(&ProtocolBufferFull);
        iVar1 = ProtocolPointerRead;
        iVar3 = ProtocolPointerRead >> 0x1f;
        strcpy(Text + 0xfc,
               ProtocolBuffer[ProtocolPointerRead + ((local_1144._4_4_ >> 6) - iVar3) * -1000].
               ProtocolName);
        local_1144 = (longlong)ProtocolPointerRead * 0x10624dd3;
        strcpy(FileName + 0xffc,
               ProtocolBuffer
               [ProtocolPointerRead +
                ((iVar1 / 1000 + iVar3) - (ProtocolPointerRead >> 0x1f)) * -1000].Text);
        ProtocolPointerRead = ProtocolPointerRead + 1;
        Semaphore::up(&ProtocolBufferEmpty);
        if (Text[0xfc] == '\0') break;
        sprintf(local_113c,"%s/%s.log",LOGPATH,Text + 0xfc);
        __stream = fopen(local_113c,"at");
        if (__stream != (FILE *)0x0) {
            fprintf(__stream,"%s",FileName + 0xffc);
            iVar1 = fclose(__stream);
            if (iVar1 != 0) {
                piVar2 = __errno_location();
                error(&DAT_080f5320,*piVar2);
            }
        }
    }
    return 0;
}



void InitLog(char *ProtocolName)

{
    FILE *__stream;
    char *pcVar1;
    FILE *f;
    time_t local_1020;
    time_t Time;
    char FileName [4096];
    
    if (ProtocolName == (char *)0x0) {
        error("InitLog: Protokoll-Name nicht angegeben.\n");
    }
    else {
        sprintf((char *)&Time,"%s/%s.log",LOGPATH,ProtocolName);
        __stream = fopen((char *)&Time,"at");
        if (__stream == (FILE *)0x0) {
            error("InitLog: Kann Protokoll %s nicht anlegen.\n",ProtocolName);
        }
        else {
            time(&local_1020);
            fprintf(__stream,
                    "-------------------------------------------------------------------------------\n"
                   );
            fprintf(__stream,"Tibia - Graphical Multi-User-Dungeon\n");
            pcVar1 = ctime(&local_1020);
            fprintf(__stream,"%s.log - gestartet %s",ProtocolName,pcVar1);
            fclose(__stream);
        }
    }
    return;
}



void Log(char *ProtocolName,char *Text,...)

{
    uint *__dest;
    tm *ptVar1;
    FILE *__stream;
    int *piVar2;
    int iVar3;
    uint *puVar4;
    uint *puVar5;
    uint uVar6;
    uint uVar7;
    bool WriteDate;
    char *pcVar8;
    char *pcVar9;
    bool bVar10;
    bool bVar11;
    time_t local_1220;
    time_t Time;
    char FileName [4096];
    char Line [256];
    char Output [256];
    
    if ((ProtocolName == (char *)0x0) || (*ProtocolName == '\0')) {
        error("Log: Protokoll-Name nicht angegeben.\n");
    }
    else {
        iVar3 = 10;
        bVar11 = false;
        bVar10 = true;
        pcVar8 = ProtocolName;
        pcVar9 = "bugreport";
        do {
            if (iVar3 == 0) break;
            iVar3 = iVar3 + -1;
            bVar10 = *pcVar8 == *pcVar9;
            pcVar8 = pcVar8 + 1;
            pcVar9 = pcVar9 + 1;
        } while (bVar10);
        if (!bVar10) {
            iVar3 = 0xd;
            pcVar8 = ProtocolName;
            pcVar9 = "client-error";
            do {
                if (iVar3 == 0) break;
                iVar3 = iVar3 + -1;
                bVar10 = *pcVar8 == *pcVar9;
                pcVar8 = pcVar8 + 1;
                pcVar9 = pcVar9 + 1;
            } while (bVar10);
            if (!bVar10) {
                iVar3 = 5;
                pcVar8 = ProtocolName;
                pcVar9 = "load";
                do {
                    if (iVar3 == 0) break;
                    iVar3 = iVar3 + -1;
                    bVar10 = *pcVar8 == *pcVar9;
                    pcVar8 = pcVar8 + 1;
                    pcVar9 = pcVar9 + 1;
                } while (bVar10);
                if (!bVar10) {
                    bVar11 = true;
                }
            }
        }
        pcVar8 = Line + 0xfc;
        vsnprintf(pcVar8,0x100,Text,&stack0x0000000c);
        if (bVar11) {
            print();
            time(&local_1220);
            ptVar1 = localtime(&local_1220);
            snprintf(FileName + 0xffc,0x100,"%02d.%02d.%04d %02d:%02d:%02d (%ld): %s",
                     ptVar1->tm_mday,ptVar1->tm_mon + 1,ptVar1->tm_year + 0x76c,ptVar1->tm_hour,
                     ptVar1->tm_min,ptVar1->tm_sec,RoundNr,pcVar8);
        }
        else {
            strcpy(FileName + 0xffc,pcVar8);
        }
        __dest = (uint *)(FileName + 0xffc);
        Line[0xfa] = '\0';
        puVar5 = __dest;
        if (FileName[0xffc] != '\0') {
            do {
                puVar4 = puVar5;
                uVar6 = *puVar4 + 0xfefefeff & ~*puVar4;
                uVar7 = uVar6 & 0x80808080;
                puVar5 = puVar4 + 1;
            } while (uVar7 == 0);
            bVar11 = (uVar6 & 0x8080) == 0;
            if (bVar11) {
                uVar7 = uVar7 >> 0x10;
            }
            if (bVar11) {
                puVar5 = (uint *)((int)puVar4 + 6);
            }
            if (*(char *)((int)puVar5 +
                         (int)(FileName +
                              (-(int)__dest - (uint)CARRY1((byte)uVar7,(byte)uVar7)) + 0xff8)) !=
                '\n') {
                strcat((char *)__dest,"\n");
            }
        }
        if (ProtocolThread == 0) {
            sprintf((char *)&Time,"%s/%s.log",LOGPATH,ProtocolName);
            __stream = fopen((char *)&Time,"at");
            if (__stream != (FILE *)0x0) {
                fprintf(__stream,"%s",__dest);
                iVar3 = fclose(__stream);
                if (iVar3 != 0) {
                    piVar2 = __errno_location();
                    error(&DAT_080f5320,*piVar2);
                }
            }
        }
        else {
            InsertProtocolOrder(ProtocolName,(char *)__dest);
        }
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void InitWriterBuffers(void)

{
    OrderPointerWrite = 0;
    ReplyPointerWrite = 0;
    OrderPointerRead = 0;
    ReplyPointerRead = 0;
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int GetOrderBufferSpace(void)

{
    int iVar1;
    
    if (WriterThread == 0) {
        iVar1 = 0x7fffffff;
    }
    else {
        iVar1 = 2000 - (OrderPointerWrite - OrderPointerRead);
    }
    return iVar1;
}



void InsertOrder(TWriterThreadOrderType OrderType,void *Data)

{
    if (WriterThread != 0) {
        if (1999 < OrderPointerWrite - OrderPointerRead) {
            error(&DAT_080f5500);
        }
        Semaphore::down(&OrderBufferEmpty);
        OrderBuffer[OrderPointerWrite % 2000].OrderType = OrderType;
        OrderBuffer[OrderPointerWrite % 2000].Data = Data;
        OrderPointerWrite = OrderPointerWrite + 1;
        Semaphore::up(&OrderBufferFull);
        return;
    }
    return;
}



void GetOrder(TWriterThreadOrderType *OrderType,void **Data)

{
    int iVar1;
    
    Semaphore::down(&OrderBufferFull);
    iVar1 = OrderPointerRead % 2000;
    *OrderType = OrderBuffer[iVar1].OrderType;
    OrderPointerRead = OrderPointerRead + 1;
    *Data = OrderBuffer[iVar1].Data;
    Semaphore::up(&OrderBufferEmpty);
    return;
}



void InsertReply(TWriterThreadReplyType ReplyType,void *Data)

{
    if (ReplyPointerWrite - ReplyPointerRead < 100) {
        ReplyBuffer[ReplyPointerWrite % 100].ReplyType = ReplyType;
        ReplyBuffer[ReplyPointerWrite % 100].Data = Data;
        ReplyPointerWrite = ReplyPointerWrite + 1;
        return;
    }
    error(&DAT_080f5540);
    return;
}



void DirectReply(ulong CharacterID,char *Text,...)

{
    ulong *puVar1;
    TDirectReplyData *Data;
    char *Text_00;
    
    if (CharacterID != 0) {
        if (Text == (char *)0x0) {
            Text_00 = "SendDirectReply: Kein Text angegeben.\n";
        }
        else {
            puVar1 = (ulong *)operator_new(0x68);
            *puVar1 = CharacterID;
            vsnprintf((char *)(puVar1 + 1),100,Text,&stack0x0000000c);
            if (ReplyPointerWrite - ReplyPointerRead < 100) {
                ReplyBuffer[ReplyPointerWrite % 100].Data = puVar1;
                ReplyBuffer[ReplyPointerWrite % 100].ReplyType = REPLY_DIRECT;
                ReplyPointerWrite = ReplyPointerWrite + 1;
                return;
            }
            Text_00 = &DAT_080f5540;
        }
        error(Text_00);
    }
    return;
}



void LogoutReply(char *PlayerName)

{
    int Length;
    size_t sVar1;
    char *__dest;
    char *Buffer;
    
    sVar1 = strlen(PlayerName);
    __dest = (char *)operator_new__(sVar1 + 1);
    strcpy(__dest,PlayerName);
    if (ReplyPointerWrite - ReplyPointerRead < 100) {
        ReplyBuffer[ReplyPointerWrite % 100].ReplyType = REPLY_LOGOUT;
        ReplyBuffer[ReplyPointerWrite % 100].Data = __dest;
        ReplyPointerWrite = ReplyPointerWrite + 1;
        return;
    }
    error(&DAT_080f5540);
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

bool GetReply(void)

{
    bool bVar1;
    TWriterThreadReplyType *in_stack_00000004;
    undefined4 *in_stack_00000008;
    
    bVar1 = ReplyPointerRead != ReplyPointerWrite;
    if (bVar1) {
        *in_stack_00000004 = ReplyBuffer[ReplyPointerRead % 100].ReplyType;
        *in_stack_00000008 = ReplyBuffer[ReplyPointerRead % 100].Data;
        ReplyPointerRead = ReplyPointerRead + 1;
    }
    return bVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void TerminateWriterOrder(void)

{
    if (WriterThread != 0) {
        if (1999 < OrderPointerWrite - OrderPointerRead) {
            error(&DAT_080f5500);
        }
        Semaphore::down(&OrderBufferEmpty);
        OrderBuffer[OrderPointerWrite % 2000].OrderType = ORDER_TERMINATE;
        OrderBuffer[OrderPointerWrite % 2000].Data = (void *)0x0;
        OrderPointerWrite = OrderPointerWrite + 1;
        Semaphore::up(&OrderBufferFull);
    }
    return;
}



void LogoutOrder(TPlayer *Player)

{
    int iVar1;
    byte bVar2;
    ulong *puVar3;
    ulong uVar4;
    TLogoutOrderData *Data;
    
    if (Player == (TPlayer *)0x0) {
        error(&DAT_080f5680);
        return;
    }
    puVar3 = (ulong *)operator_new(0x34);
    *puVar3 = (Player->super_TCreature).ID;
    uVar4 = TSkill::Get((Player->super_TCreature).super_TSkillBase.Skills[0]);
    puVar3[1] = uVar4;
    bVar2 = TPlayer::GetActiveProfession(Player);
    puVar3[2] = (uint)bVar2;
    if (Player->PlayerData == (TPlayerData *)0x0) {
        error("LogoutOrder: PlayerData ist NULL.\n");
        puVar3[3] = 0;
    }
    else {
        puVar3[3] = Player->PlayerData->LastLoginTime;
    }
    puVar3[4] = Player->TutorActivities;
    iVar1 = (Player->super_TCreature).startx;
    if (iVar1 == 0x7f89) {
        puVar3[5] = 0x6f7a614b;
        puVar3[6] = 0x6f6f6472;
LAB_080699b2:
        *(undefined2 *)(puVar3 + 7) = 0x6e;
    }
    else {
        if (iVar1 < 0x7f8a) {
            if (iVar1 == 0x7e68) {
                puVar3[5] = 0x6c726143;
                *(undefined2 *)(puVar3 + 6) = 0x6e69;
LAB_0806990d:
                *(undefined1 *)((int)puVar3 + 0x1a) = 0;
                goto LAB_08069820;
            }
            if (iVar1 < 0x7e69) {
                if (iVar1 == 0x7d61) {
                    puVar3[5] = 0x6b6f6f52;
                    puVar3[6] = 0x72616167;
                    *(undefined2 *)(puVar3 + 7) = 100;
                    goto LAB_08069820;
                }
            }
            else {
                if (iVar1 == 0x7e71) {
                    puVar3[5] = 0x69616854;
                    *(undefined2 *)(puVar3 + 6) = 0x73;
                    goto LAB_08069820;
                }
                if (iVar1 == 0x7f53) {
                    puVar3[5] = 0x74726f50;
                    puVar3[6] = 0x706f4820;
                    *(undefined2 *)(puVar3 + 7) = 0x65;
                    goto LAB_08069820;
                }
            }
        }
        else {
            if (iVar1 == 0x81aa) {
                puVar3[5] = 0x726b6e41;
                puVar3[6] = 0x756d6861;
                goto LAB_080699b2;
            }
            if (iVar1 < 0x81ab) {
                if (iVar1 == 0x7fdc) {
                    puVar3[5] = 0x44276241;
                    puVar3[6] = 0x72646e65;
                    puVar3[7] = 0x6c6569;
                    goto LAB_08069820;
                }
                if (iVar1 == 0x80bd) {
                    puVar3[5] = 0x6f6e6556;
                    *(undefined2 *)(puVar3 + 6) = 0x6572;
                    goto LAB_0806990d;
                }
            }
            else {
                if (iVar1 == 0x81bd) {
                    puVar3[5] = 0x61726144;
                    puVar3[6] = 0x61696873;
                    *(undefined1 *)(puVar3 + 7) = 0;
                    goto LAB_08069820;
                }
                if (iVar1 == 0x81c1) {
                    puVar3[5] = 0x6f726445;
                    *(undefined2 *)(puVar3 + 6) = 0x6e;
                    goto LAB_08069820;
                }
            }
        }
        error("LogoutOrder: Unbekannte Startkoordinate [%d,%d,%d] bei Spieler %s.\n",iVar1,
              (Player->super_TCreature).starty,(Player->super_TCreature).startz,
              (Player->super_TCreature).Name);
        puVar3[5] = 0x6e6b6e55;
        puVar3[6] = 0x6e776f;
    }
LAB_08069820:
    if (WriterThread != 0) {
        if (1999 < OrderPointerWrite - OrderPointerRead) {
            error(&DAT_080f5500);
        }
        Semaphore::down(&OrderBufferEmpty);
        OrderBuffer[OrderPointerWrite % 2000].OrderType = ORDER_LOGOUT;
        OrderBuffer[OrderPointerWrite % 2000].Data = puVar3;
        OrderPointerWrite = OrderPointerWrite + 1;
        Semaphore::up(&OrderBufferFull);
        return;
    }
    return;
}



// WARNING: Variable defined which should be unmapped: NumberOfPlayers_local

void PlayerlistOrder(int NumberOfPlayers,char *PlayerNames,int *PlayerLevels,int *PlayerProfessions)

{
    int *piVar1;
    TPlayerlistOrderData *Data;
    int *PlayerProfessions_local;
    int NumberOfPlayers_local;
    
    if (PlayerNames == (char *)0x0) {
        NumberOfPlayers = (int)s_PlayerlistOrder__PlayerNames_ist_080f5740;
    }
    else if (PlayerLevels == (int *)0x0) {
        NumberOfPlayers = (int)s_PlayerlistOrder__PlayerLevels_is_080f5700;
    }
    else {
        if (PlayerProfessions != (int *)0x0) {
            piVar1 = (int *)operator_new(0x10);
            piVar1[1] = (int)PlayerNames;
            piVar1[2] = (int)PlayerLevels;
            *piVar1 = NumberOfPlayers;
            piVar1[3] = (int)PlayerProfessions;
            if (WriterThread != 0) {
                if (1999 < OrderPointerWrite - OrderPointerRead) {
                    error(&DAT_080f5500);
                }
                Semaphore::down(&OrderBufferEmpty);
                OrderBuffer[OrderPointerWrite % 2000].OrderType = ORDER_PLAYERLIST;
                OrderBuffer[OrderPointerWrite % 2000].Data = piVar1;
                OrderPointerWrite = OrderPointerWrite + 1;
                Semaphore::up(&OrderBufferFull);
                return;
            }
            return;
        }
        NumberOfPlayers = (int)s_PlayerlistOrder__PlayerProfessio_080f56c0;
    }
    error((char *)NumberOfPlayers);
    return;
}



// WARNING: Variable defined which should be unmapped: NumberOfRaces_local

void KillStatisticsOrder(int NumberOfRaces,char *RaceNames,int *KilledPlayers,int *KilledCreatures)

{
    int *piVar1;
    TKillStatisticsOrderData *Data;
    int *KilledCreatures_local;
    int NumberOfRaces_local;
    
    if (RaceNames == (char *)0x0) {
        NumberOfRaces = (int)s_KillStatisticsOrder__RaceNames_i_080f5800;
    }
    else if (KilledPlayers == (int *)0x0) {
        NumberOfRaces = (int)s_KillStatisticsOrder__KilledPlaye_080f57c0;
    }
    else {
        if (KilledCreatures != (int *)0x0) {
            piVar1 = (int *)operator_new(0x10);
            piVar1[1] = (int)RaceNames;
            piVar1[2] = (int)KilledPlayers;
            *piVar1 = NumberOfRaces;
            piVar1[3] = (int)KilledCreatures;
            if (WriterThread != 0) {
                if (1999 < OrderPointerWrite - OrderPointerRead) {
                    error(&DAT_080f5500);
                }
                Semaphore::down(&OrderBufferEmpty);
                OrderBuffer[OrderPointerWrite % 2000].OrderType = ORDER_KILLSTATISTICS;
                OrderBuffer[OrderPointerWrite % 2000].Data = piVar1;
                OrderPointerWrite = OrderPointerWrite + 1;
                Semaphore::up(&OrderBufferFull);
                return;
            }
            return;
        }
        NumberOfRaces = (int)s_KillStatisticsOrder__KilledCreat_080f5780;
    }
    error((char *)NumberOfRaces);
    return;
}



// WARNING: Variable defined which should be unmapped: IPAddress_local

void PunishmentOrder(TCreature *cr,char *Name,char *IPAddress,int Reason,int Action,char *Comment,
                    int NumberOfStatements,vector<> *ReportedStatements,ulong StatementID,
                    bool IPBanishment)

{
    ulong *puVar1;
    ulong uVar2;
    char *__src;
    TPunishmentOrderData *Data;
    bool IPBanishment_local;
    ulong StatementID_local;
    vector<> *ReportedStatements_local;
    int NumberOfStatements_local;
    char *Comment_local;
    int Action_local;
    int Reason_local;
    char *IPAddress_local;
    
    if (Name == (char *)0x0) {
        cr = (TCreature *)s_PunishmentOrder__Name_ist_NULL__080f5880;
    }
    else {
        if (Comment != (char *)0x0) {
            puVar1 = (ulong *)operator_new(0x130);
            uVar2 = 0;
            if (cr != (TCreature *)0x0) {
                uVar2 = cr->ID;
            }
            *puVar1 = uVar2;
            __src = "automatic";
            if (cr != (TCreature *)0x0) {
                __src = cr->Name;
            }
            strcpy((char *)(puVar1 + 1),__src);
            strcpy((char *)((int)puVar1 + 0x22),Name);
            if (IPAddress == (char *)0x0) {
                *(undefined1 *)(puVar1 + 0x10) = 0;
            }
            else {
                strcpy((char *)(puVar1 + 0x10),IPAddress);
            }
            puVar1[0x14] = Reason;
            puVar1[0x15] = Action;
            strcpy((char *)(puVar1 + 0x16),Comment);
            puVar1[0x48] = NumberOfStatements;
            puVar1[0x49] = (ulong)ReportedStatements;
            puVar1[0x4a] = StatementID;
            *(bool *)(puVar1 + 0x4b) = IPBanishment;
            if (WriterThread != 0) {
                if (1999 < OrderPointerWrite - OrderPointerRead) {
                    error(&DAT_080f5500);
                }
                Semaphore::down(&OrderBufferEmpty);
                OrderBuffer[OrderPointerWrite % 2000].OrderType = ORDER_PUNISHMENT;
                OrderBuffer[OrderPointerWrite % 2000].Data = puVar1;
                OrderPointerWrite = OrderPointerWrite + 1;
                Semaphore::up(&OrderBufferFull);
                return;
            }
            return;
        }
        cr = (TCreature *)s_PunishmentOrder__Comment_ist_NUL_080f5840;
    }
    error((char *)cr);
    return;
}



// WARNING: Variable defined which should be unmapped: OldLevel_local

void CharacterDeathOrder(TCreature *cr,int OldLevel,ulong Offender,char *Remark,bool Unjustified)

{
    ulong *puVar1;
    ulong uVar2;
    TCharacterDeathOrderData *Data;
    ulong Offender_local;
    int OldLevel_local;
    
    if (cr == (TCreature *)0x0) {
        cr = (TCreature *)s_CharacterDeathOrder__cr_ist_NULL_080f5900;
    }
    else {
        if (Remark != (char *)0x0) {
            puVar1 = (ulong *)operator_new(0x30);
            *puVar1 = cr->ID;
            puVar1[1] = OldLevel;
            puVar1[2] = Offender;
            strcpy((char *)(puVar1 + 3),Remark);
            *(bool *)((int)puVar1 + 0x2a) = Unjustified;
            uVar2 = time((time_t *)0x0);
            puVar1[0xb] = uVar2;
            if (WriterThread != 0) {
                if (1999 < OrderPointerWrite - OrderPointerRead) {
                    error(&DAT_080f5500);
                }
                Semaphore::down(&OrderBufferEmpty);
                OrderBuffer[OrderPointerWrite % 2000].OrderType = ORDER_CHARACTERDEATH;
                OrderBuffer[OrderPointerWrite % 2000].Data = puVar1;
                OrderPointerWrite = OrderPointerWrite + 1;
                Semaphore::up(&OrderBufferFull);
                return;
            }
            return;
        }
        cr = (TCreature *)s_CharacterDeathOrder__Remark_ist_N_080f58c0;
    }
    error((char *)cr);
    return;
}



void AddBuddyOrder(TCreature *cr,ulong Buddy)

{
    _func_int_varargs **pp_Var1;
    undefined4 *puVar2;
    TBuddyOrderData *Data;
    
    if (cr == (TCreature *)0x0) {
        cr = (TCreature *)s_AddBuddyOrder__cr_ist_NULL__080f51a0;
    }
    else {
        if (cr->Type == PLAYER) {
            puVar2 = (undefined4 *)operator_new(8);
            pp_Var1 = cr[1]._vptr_TCreature;
            puVar2[1] = Buddy;
            *puVar2 = pp_Var1;
            if (WriterThread != 0) {
                if (1999 < OrderPointerWrite - OrderPointerRead) {
                    error(&DAT_080f5500);
                }
                Semaphore::down(&OrderBufferEmpty);
                OrderBuffer[OrderPointerWrite % 2000].OrderType = ORDER_ADDBUDDY;
                OrderBuffer[OrderPointerWrite % 2000].Data = puVar2;
                OrderPointerWrite = OrderPointerWrite + 1;
                Semaphore::up(&OrderBufferFull);
                return;
            }
            return;
        }
        cr = (TCreature *)s_AddBuddyOrder__Kreatur_ist_kein_S_080f5940;
    }
    error((char *)cr);
    return;
}



void RemoveBuddyOrder(TCreature *cr,ulong Buddy)

{
    _func_int_varargs **pp_Var1;
    undefined4 *puVar2;
    TBuddyOrderData *Data;
    
    if (cr == (TCreature *)0x0) {
        cr = (TCreature *)s_RemoveBuddyOrder__cr_ist_NULL__080f59c0;
    }
    else {
        if (cr->Type == PLAYER) {
            puVar2 = (undefined4 *)operator_new(8);
            pp_Var1 = cr[1]._vptr_TCreature;
            puVar2[1] = Buddy;
            *puVar2 = pp_Var1;
            if (WriterThread != 0) {
                if (1999 < OrderPointerWrite - OrderPointerRead) {
                    error(&DAT_080f5500);
                }
                Semaphore::down(&OrderBufferEmpty);
                OrderBuffer[OrderPointerWrite % 2000].OrderType = ORDER_REMOVEBUDDY;
                OrderBuffer[OrderPointerWrite % 2000].Data = puVar2;
                OrderPointerWrite = OrderPointerWrite + 1;
                Semaphore::up(&OrderBufferFull);
                return;
            }
            return;
        }
        cr = (TCreature *)s_RemoveBuddyOrder__Kreatur_ist_ke_080f5980;
    }
    error((char *)cr);
    return;
}



void DecrementIsOnlineOrder(ulong CharacterID)

{
    if (WriterThread != 0) {
        if (1999 < OrderPointerWrite - OrderPointerRead) {
            error(&DAT_080f5500);
        }
        Semaphore::down(&OrderBufferEmpty);
        OrderBuffer[OrderPointerWrite % 2000].OrderType = ORDER_DECREMENTISONLINE;
        OrderBuffer[OrderPointerWrite % 2000].Data = (void *)CharacterID;
        OrderPointerWrite = OrderPointerWrite + 1;
        Semaphore::up(&OrderBufferFull);
        return;
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void SavePlayerDataOrder(void)

{
    if (WriterThread != 0) {
        if (1999 < OrderPointerWrite - OrderPointerRead) {
            error(&DAT_080f5500);
        }
        Semaphore::down(&OrderBufferEmpty);
        OrderBuffer[OrderPointerWrite % 2000].OrderType = ORDER_SAVEPLAYERDATA;
        OrderBuffer[OrderPointerWrite % 2000].Data = (void *)0x0;
        OrderPointerWrite = OrderPointerWrite + 1;
        Semaphore::up(&OrderBufferFull);
    }
    return;
}



// WARNING: Variable defined which should be unmapped: HelpProfession

void ProcessLogoutOrder(void *RawData)

{
    int iVar1;
    undefined4 uVar2;
    char *Buffer;
    int iVar3;
    undefined4 uVar4;
    undefined4 uVar5;
    char local_2c [4];
    char HelpProfession [30];
    
    if (RawData == (void *)0x0) {
        error(&DAT_080f5a60);
    }
    else {
        Buffer = local_2c;
        GetProfessionName(Buffer,*(int *)((int)RawData + 8),false,true);
        if (0 < *(int *)((int)RawData + 0x10)) {
            print();
        }
        uVar5 = *(undefined4 *)((int)RawData + 0x10);
        iVar3 = (int)RawData + 0x14;
        uVar4 = *(undefined4 *)((int)RawData + 0xc);
        uVar2 = *(undefined4 *)((int)RawData + 4);
        iVar1 = TQueryManagerConnection::logoutGame(QueryManagerConnection);
        if (iVar1 != 0) {
                    // WARNING: Load size is inaccurate
            error(&DAT_080f5a20,*RawData,uVar2,Buffer,iVar3,uVar4,uVar5);
        }
        operator_delete(RawData);
    }
    return;
}



// WARNING: Variable defined which should be unmapped: NewRecord

void ProcessPlayerlistOrder(void *RawData)

{
    bool *pbVar1;
    int iVar2;
    int iVar3;
    int iVar4;
    void *pvVar5;
    uint uVar6;
    int i;
    int iVar7;
    uint *puVar8;
    int iVar9;
    undefined4 uStack_40;
    char *Text;
    int local_24;
    char_0__30_ *Professions;
    int_0_ *Levels;
    char___0_ *Names;
    bool local_11 [4];
    bool NewRecord;
    
    if (RawData == (void *)0x0) {
        Text = &DAT_080f5b60;
LAB_0806a54b:
        uStack_40 = 0x806a550;
        error(Text);
    }
    else {
                    // WARNING: Load size is inaccurate
        iVar9 = *RawData;
        if (iVar9 < 1) {
                    // WARNING: Load size is inaccurate
            uStack_40 = 0x806a53c;
            iVar9 = TQueryManagerConnection::createPlayerlist
                              (QueryManagerConnection,*RawData,(char **)0x0,(int *)0x0,
                               (char (*) [30])0x0,local_11);
            puVar8 = (uint *)&stack0xffffffc4;
            if (iVar9 != 0) {
                Text = "ProcessPlayerlistOrder: Anfrage fehlgeschlagen (1).\n";
                goto LAB_0806a54b;
            }
        }
        else {
            Names = &stack0xffffffc4;
            uVar6 = (iVar9 + -1) * 4 + 0x13U & 0xfffffff0;
            iVar3 = uVar6 * -2;
            Levels = (int_0_ *)((int)&local_24 - uVar6);
            Professions = (char_0__30_ *)((int)&local_24 + iVar3);
            iVar7 = 0;
            iVar2 = -((iVar9 + -1) * 0x1e + 0x2dU & 0xfffffff0);
            local_24 = (int)&local_24 + iVar2 + iVar3;
            if (0 < iVar9) {
                iVar9 = 0;
                do {
                    *(int *)(Levels + iVar7 * 4) = *(int *)((int)RawData + 4) + iVar9;
                    *(undefined4 *)(Professions + iVar7 * 4) =
                         *(undefined4 *)(*(int *)((int)RawData + 8) + iVar7 * 4);
                    pbVar1 = local_11 + iVar2 + iVar3 + -0x1f;
                    pbVar1[0] = true;
                    pbVar1[1] = false;
                    pbVar1[2] = false;
                    pbVar1[3] = false;
                    *(undefined4 *)(&stack0xffffffcc + iVar2 + iVar3) = 0;
                    iVar4 = iVar7 * 4;
                    iVar7 = iVar7 + 1;
                    *(undefined4 *)(&stack0xffffffc8 + iVar2 + iVar3) =
                         *(undefined4 *)(*(int *)((int)RawData + 0xc) + iVar4);
                    iVar4 = local_24 + iVar9;
                    iVar9 = iVar9 + 0x1e;
                    *(int *)(&stack0xffffffc4 + iVar2 + iVar3) = iVar4;
                    *(undefined4 *)((int)&uStack_40 + iVar2 + iVar3) = 0x806a3e2;
                    GetProfessionName(*(char **)(&stack0xffffffc4 + iVar2 + iVar3),
                                      *(int *)(&stack0xffffffc8 + iVar2 + iVar3),
                                      (bool)(&stack0xffffffcc)[iVar2 + iVar3],
                                      local_11[iVar2 + iVar3 + -0x1f]);
                    // WARNING: Load size is inaccurate
                } while (iVar7 < *RawData);
            }
            *(bool **)(&stack0xffffffd8 + iVar2 + iVar3) = local_11;
            *(int *)(&stack0xffffffd4 + iVar2 + iVar3) = local_24;
            *(char_0__30_ **)(local_11 + iVar2 + iVar3 + -0x1f) = Professions;
            *(int_0_ **)(&stack0xffffffcc + iVar2 + iVar3) = Levels;
                    // WARNING: Load size is inaccurate
            *(undefined4 *)(&stack0xffffffc8 + iVar2 + iVar3) = *RawData;
            *(TQueryManagerConnection **)(&stack0xffffffc4 + iVar2 + iVar3) = QueryManagerConnection
            ;
            *(undefined4 *)((int)&uStack_40 + iVar2 + iVar3) = 0x806a415;
            iVar9 = TQueryManagerConnection::createPlayerlist
                              (*(TQueryManagerConnection **)(&stack0xffffffc4 + iVar2 + iVar3),
                               *(int *)(&stack0xffffffc8 + iVar2 + iVar3),
                               *(char ***)(&stack0xffffffcc + iVar2 + iVar3),
                               *(int **)(local_11 + iVar2 + iVar3 + -0x1f),
                               *(char (**) [30])(&stack0xffffffd4 + iVar2 + iVar3),
                               *(bool **)(&stack0xffffffd8 + iVar2 + iVar3));
            puVar8 = (uint *)Names;
            if (iVar9 != 0) {
                *(char **)(&stack0xffffffc4 + iVar2 + iVar3) =
                     "ProcessPlayerlistOrder: Anfrage fehlgeschlagen (2).\n";
                *(undefined4 *)((int)&uStack_40 + iVar2 + iVar3) = 0x806a502;
                error(*(char **)(&stack0xffffffc4 + iVar2 + iVar3));
                return;
            }
        }
        if (local_11[0] != false) {
            *puVar8 = 100;
            puVar8[-1] = 0x806a475;
            pvVar5 = operator_new__(*puVar8);
                    // WARNING: Load size is inaccurate
            uVar6 = *RawData;
            puVar8[1] = 100;
            puVar8[2] = (uint)"New record: %d players are logged in.";
            *puVar8 = (uint)pvVar5;
            puVar8[3] = uVar6;
            puVar8[-1] = 0x806a495;
            snprintf((char *)*puVar8,puVar8[1],(char *)puVar8[2]);
            if (ReplyPointerWrite - ReplyPointerRead < 100) {
                iVar9 = ReplyPointerWrite % 100;
                ReplyBuffer[iVar9].Data = pvVar5;
                ReplyPointerWrite = ReplyPointerWrite + 1;
                ReplyBuffer[iVar9].ReplyType = REPLY_BROADCAST;
            }
            else {
                *puVar8 = (uint)&DAT_080f5540;
                puVar8[-1] = 0x806a4f1;
                error((char *)*puVar8);
            }
        }
        if (*(int *)((int)RawData + 4) != 0) {
            *puVar8 = *(int *)((int)RawData + 4);
            puVar8[-1] = 0x806a467;
            operator_delete__((void *)*puVar8);
        }
        if (*(int *)((int)RawData + 8) != 0) {
            *puVar8 = *(int *)((int)RawData + 8);
            puVar8[-1] = 0x806a45d;
            operator_delete__((void *)*puVar8);
        }
        if (*(int *)((int)RawData + 0xc) != 0) {
            *puVar8 = *(int *)((int)RawData + 0xc);
            puVar8[-1] = 0x806a453;
            operator_delete__((void *)*puVar8);
        }
        *puVar8 = (uint)RawData;
        puVar8[-1] = 0x806a443;
        operator_delete((void *)*puVar8);
    }
    return;
}



void ProcessKillStatisticsOrder(void *RawData)

{
    int iVar1;
    int iVar2;
    int iVar3;
    int i;
    int iVar4;
    int iVar5;
    uint uVar6;
    int_0_ *KilledPlayers;
    int iStack_40;
    int aiStack_28 [4];
    int_0_ *KilledCreatures;
    char___0_ *RaceNames;
    
    RaceNames = &stack0xffffffc4;
    if (RawData == (void *)0x0) {
        iStack_40 = 0x806a661;
        error(&DAT_080f5be0);
    }
    else {
                    // WARNING: Load size is inaccurate
        iVar4 = 0;
        uVar6 = *RawData * 4 + 0xfU & 0xfffffff0;
        iVar1 = uVar6 * -3;
        iVar3 = (int)aiStack_28 + uVar6 * -2;
        KilledCreatures = (int_0_ *)((int)aiStack_28 - uVar6);
        aiStack_28[3] = (int)aiStack_28 + iVar1;
        if (0 < *RawData) {
            iVar5 = 0;
            do {
                iVar2 = *(int *)((int)RawData + 4) + iVar5;
                iVar5 = iVar5 + 0x1e;
                *(int *)(KilledCreatures + iVar4 * 4) = iVar2;
                *(undefined4 *)(iVar3 + iVar4 * 4) =
                     *(undefined4 *)(*(int *)((int)RawData + 8) + iVar4 * 4);
                *(undefined4 *)(aiStack_28[3] + iVar4 * 4) =
                     *(undefined4 *)(*(int *)((int)RawData + 0xc) + iVar4 * 4);
                iVar4 = iVar4 + 1;
                    // WARNING: Load size is inaccurate
            } while (iVar4 < *RawData);
        }
        iVar4 = aiStack_28[3];
        *(int *)(&stack0xffffffd0 + iVar1) = iVar3;
        *(int *)(&stack0xffffffd4 + iVar1) = iVar4;
        *(int_0_ **)(&stack0xffffffcc + iVar1) = KilledCreatures;
                    // WARNING: Load size is inaccurate
        *(undefined4 *)(&stack0xffffffc8 + iVar1) = *RawData;
        *(TQueryManagerConnection **)(&stack0xffffffc4 + iVar1) = QueryManagerConnection;
        *(undefined4 *)((int)&iStack_40 + iVar1) = 0x806a5fd;
        iVar3 = TQueryManagerConnection::logKilledCreatures
                          (*(TQueryManagerConnection **)(&stack0xffffffc4 + iVar1),
                           *(int *)(&stack0xffffffc8 + iVar1),*(char ***)(&stack0xffffffcc + iVar1),
                           *(int **)(&stack0xffffffd0 + iVar1),*(int **)(&stack0xffffffd4 + iVar1));
        if (iVar3 == 0) {
            if (*(int *)((int)RawData + 4) != 0) {
                *(int *)(&stack0xffffffc4 + iVar1) = *(int *)((int)RawData + 4);
                *(undefined4 *)((int)&iStack_40 + iVar1) = 0x806a645;
                operator_delete__(*(void **)(&stack0xffffffc4 + iVar1));
            }
            if (*(int *)((int)RawData + 8) != 0) {
                *(int *)(&stack0xffffffc4 + iVar1) = *(int *)((int)RawData + 8);
                *(undefined4 *)((int)&iStack_40 + iVar1) = 0x806a63b;
                operator_delete__(*(void **)(&stack0xffffffc4 + iVar1));
            }
            if (*(int *)((int)RawData + 0xc) != 0) {
                *(int *)(&stack0xffffffc4 + iVar1) = *(int *)((int)RawData + 0xc);
                *(undefined4 *)((int)&iStack_40 + iVar1) = 0x806a631;
                operator_delete__(*(void **)(&stack0xffffffc4 + iVar1));
            }
            *(void **)(&stack0xffffffc4 + iVar1) = RawData;
            *(undefined4 *)((int)&iStack_40 + iVar1) = 0x806a61e;
            operator_delete(*(void **)(&stack0xffffffc4 + iVar1));
        }
        else {
            *(char **)(&stack0xffffffc4 + iVar1) =
                 "ProcessKillStatisticsOrder: Anfrage fehlgeschlagen.\n";
            *(undefined4 *)((int)&iStack_40 + iVar1) = 0x806a653;
            error(*(char **)(&stack0xffffffc4 + iVar1));
        }
    }
    return;
}



void ProcessPunishmentOrder(void *RawData)

{
    ulong uVar1;
    int iVar2;
    int iVar3;
    int Length;
    char *pcVar4;
    int iVar5;
    size_t sVar6;
    void *pvVar7;
    TReportedStatement *pTVar8;
    char *pcVar9;
    uint uVar10;
    int iVar11;
    int i;
    int iVar12;
    int iVar13;
    ulong *puVar14;
    char_0__30_ *Channels;
    char *pcStack_80;
    char *local_74;
    char *local_70;
    char *local_6c;
    char *local_68;
    int *local_64 [5];
    int aiStack_50 [2];
    undefined4 uStack_48;
    undefined8 local_44;
    int local_3c;
    undefined4 local_38;
    char_0__256_ *Texts;
    ulong_0_ *CharacterIDs;
    ulong_0_ *TimeStamps;
    ulong_0_ *StatementIDs;
    int local_24;
    char local_1e;
    char local_1d;
    bool ok;
    char *pcStack_1c;
    bool FinalWarning;
    int Days;
    ulong BanishmentID;
    
    if (RawData == (void *)0x0) {
        pcStack_80 = (char *)0x806b148;
        error(&DAT_080f60e0);
        return;
    }
    local_1e = '\x01';
    Days = 0;
    if (*(int *)((int)RawData + 0x54) == 0) {
        pcVar4 = (char *)((int)RawData + 0x22);
        pcStack_80 = (char *)0x806b091;
        local_6c = GetBanishmentReason(*(int *)((int)RawData + 0x50));
        local_70 = (char *)((int)RawData + 0x40);
        local_64[0] = &Days;
        pcStack_80 = (char *)0x806b0be;
        local_74 = pcVar4;
        local_68 = (char *)((int)RawData + 0x58);
        iVar5 = TQueryManagerConnection::setNotation(QueryManagerConnection);
        if (iVar5 == 1) {
            pcVar4 = "A player with this name does not exist. Perhaps he/she has been renamed?";
LAB_0806b0d9:
                    // WARNING: Load size is inaccurate
            pcStack_80 = (char *)0x806b0e3;
            DirectReply(*RawData,pcVar4);
            local_1e = '\0';
        }
        else if (iVar5 < 2) {
            if (iVar5 == 0) {
                    // WARNING: Load size is inaccurate
                pcStack_80 = (char *)0x806b10a;
                local_74 = pcVar4;
                DirectReply(*RawData,"Notation for player %s inserted.");
                local_74 = (char *)((int)RawData + 4);
                pcStack_80 = (char *)0x806b12d;
                local_70 = pcVar4;
                local_6c = (char *)((int)RawData + 0x58);
                Log("banish","%s notiert zu %s: %s.\n");
            }
        }
        else if (iVar5 == 2) {
            pcVar4 = "You may not report a god or gamemaster.";
            goto LAB_0806b0d9;
        }
    }
    puVar14 = (ulong *)&stack0xffffff84;
    if (local_1e == '\0') goto LAB_0806a710;
    iVar5 = *(int *)((int)RawData + 0x54);
    if (((iVar5 != 1) && (iVar5 != 3)) && (iVar5 != 5)) goto switchD_0806b000_default;
    pcVar4 = (char *)((int)RawData + 0x22);
    pcStack_80 = (char *)0x806afd1;
    local_6c = GetBanishmentReason(*(int *)((int)RawData + 0x50));
    local_68 = (char *)((int)RawData + 0x58);
    pcStack_80 = (char *)0x806aff7;
    local_74 = pcVar4;
    local_70 = (char *)((int)RawData + 0x40);
    iVar5 = TQueryManagerConnection::setNamelock(QueryManagerConnection);
    switch(iVar5) {
    case 0:
                    // WARNING: Load size is inaccurate
        pcStack_80 = (char *)0x806b01d;
        local_74 = pcVar4;
        DirectReply(*RawData,"Player %s reported for renaming.");
        local_74 = (char *)((int)RawData + 4);
        pcStack_80 = (char *)0x806b03c;
        local_70 = pcVar4;
        Log("banish",&DAT_080f5f80);
        break;
    case 1:
        pcVar4 = "A player with this name does not exist. Perhaps he/she has already been renamed?";
        goto LAB_0806b049;
    case 2:
    case 4:
        pcVar4 = "This name has already been approved.";
LAB_0806b049:
                    // WARNING: Load size is inaccurate
        pcStack_80 = (char *)0x806b053;
        DirectReply(*RawData,pcVar4);
        local_1e = '\0';
        break;
    case 3:
                    // WARNING: Load size is inaccurate
        pcStack_80 = (char *)0x806b06e;
        DirectReply(*RawData,"This player has already been reported.");
    }
switchD_0806b000_default:
    puVar14 = (ulong *)&stack0xffffff84;
    if (local_1e == '\0') goto LAB_0806a710;
    if (*(int *)((int)RawData + 0x54) - 2U < 4) {
        local_1d = *(int *)((int)RawData + 0x54) - 4U < 2;
        pcStack_80 = (char *)0x806ad8c;
        local_6c = GetBanishmentReason(*(int *)((int)RawData + 0x50));
        local_64[2] = &Days;
        local_70 = (char *)((int)RawData + 0x40);
        local_68 = (char *)((int)RawData + 0x58);
        pcVar4 = (char *)((int)RawData + 0x22);
        pcStack_80 = (char *)0x806adc9;
        local_74 = pcVar4;
        local_64[0] = (int *)&local_1d;
        local_64[1] = (int *)&stack0xffffffe4;
        iVar5 = TQueryManagerConnection::banishAccount(QueryManagerConnection);
        if (iVar5 == 1) {
            pcVar4 = "A player with this name does not exist. Perhaps he/she has been renamed?";
LAB_0806ae8b:
                    // WARNING: Load size is inaccurate
            pcStack_80 = (char *)0x806ae95;
            DirectReply(*RawData,pcVar4);
            local_1e = '\0';
        }
        else if (iVar5 < 2) {
            if (iVar5 == 0) {
                if (pcStack_1c == (char *)0xffffffff) {
                    // WARNING: Load size is inaccurate
                    pcStack_80 = (char *)0x806afa9;
                    local_74 = pcVar4;
                    DirectReply(*RawData,"Account of player %s banished infinitely.");
                }
                else {
                    if (local_1d == '\0') {
                        pcVar9 = "Account of player %s banished for %d days.";
                    }
                    else {
                        pcVar9 = "Account of player %s banished for %d days with final warning.";
                    }
                    local_70 = pcStack_1c;
                    // WARNING: Load size is inaccurate
                    pcStack_80 = (char *)0x806aed6;
                    local_74 = pcVar4;
                    DirectReply(*RawData,pcVar9);
                }
                pcStack_80 = (char *)0x806aede;
                sVar6 = strlen(pcVar4);
                pcStack_80 = (char *)0x806aee7;
                pcVar9 = (char *)operator_new__(sVar6 + 1);
                pcStack_80 = (char *)0x806aef5;
                strcpy(pcVar9,pcVar4);
                if (ReplyPointerWrite - ReplyPointerRead < 100) {
                    local_44 = (longlong)ReplyPointerWrite * 0x51eb851f;
                    local_3c = ReplyPointerWrite / 100;
                    ReplyBuffer[ReplyPointerWrite % 100].ReplyType = REPLY_LOGOUT;
                    ReplyBuffer[ReplyPointerWrite % 100].Data = pcVar9;
                    ReplyPointerWrite = ReplyPointerWrite + 1;
                }
                else {
                    pcStack_80 = (char *)0x806af7c;
                    error(&DAT_080f5540);
                }
                local_74 = (char *)((int)RawData + 4);
                pcStack_80 = (char *)0x806af6b;
                local_70 = pcVar4;
                Log("banish","%s verbannt Account von Spieler %s.\n");
            }
        }
        else {
            if (iVar5 == 2) {
                pcVar4 = "You may not report a god or gamemaster.";
                goto LAB_0806ae8b;
            }
            if (iVar5 == 3) {
                    // WARNING: Load size is inaccurate
                pcStack_80 = (char *)0x806ae03;
                local_74 = pcVar4;
                DirectReply(*RawData,"Player %s has already been banished.");
                pcStack_80 = (char *)0x806ae0b;
                sVar6 = strlen(pcVar4);
                pcStack_80 = (char *)0x806ae14;
                pcVar9 = (char *)operator_new__(sVar6 + 1);
                pcStack_80 = (char *)0x806ae22;
                strcpy(pcVar9,pcVar4);
                if (ReplyPointerWrite - ReplyPointerRead < 100) {
                    iVar5 = ReplyPointerWrite % 100;
                    ReplyPointerWrite = ReplyPointerWrite + 1;
                    ReplyBuffer[iVar5].ReplyType = REPLY_LOGOUT;
                    ReplyBuffer[iVar5].Data = pcVar9;
                }
                else {
                    pcStack_80 = (char *)0x806ae7e;
                    error(&DAT_080f5540);
                }
            }
        }
    }
    puVar14 = (ulong *)&stack0xffffff84;
    if (local_1e == '\0') goto LAB_0806a710;
    puVar14 = (ulong *)&stack0xffffff84;
    if (*(int *)((int)RawData + 0x128) == 0) goto LAB_0806a800;
    StatementIDs = &stack0xffffff84;
    local_24 = *(int *)((int)RawData + 0x120);
    if ((local_24 == 0) || (*(int *)((int)RawData + 0x124) == 0)) {
        pcStack_80 = (char *)0x806a70d;
        error("ProcessPunishmentOrder: Statements existieren nicht.\n");
        puVar14 = (ulong *)&stack0xffffff84;
        goto LAB_0806a710;
    }
    iVar12 = local_24 + -1;
    uVar10 = iVar12 * 4 + 0x13U & 0xfffffff0;
    iVar3 = uVar10 * -3;
    TimeStamps = (ulong_0_ *)((int)&uStack_48 - uVar10);
    CharacterIDs = (ulong_0_ *)((int)&uStack_48 + uVar10 * -2);
    Texts = (char_0__256_ *)((int)&uStack_48 + iVar3);
    iVar2 = -(iVar12 * 0x1e + 0x2dU & 0xfffffff0);
    iVar5 = (int)&uStack_48 + iVar2 + iVar3;
    iVar12 = -(iVar12 * 0x100 + 0x100);
    local_38 = (int)&uStack_48 + iVar12 + iVar2 + iVar3;
    iVar13 = 0;
    if (0 < local_24) {
        do {
            *(int *)((int)local_64 + iVar12 + iVar2 + iVar3 + -0x14) = iVar13;
            *(undefined4 *)(&stack0xffffff84 + iVar12 + iVar2 + iVar3) =
                 *(undefined4 *)((int)RawData + 0x124);
            *(undefined4 *)((int)&pcStack_80 + iVar12 + iVar2 + iVar3) = 0x806a9e2;
            pTVar8 = vector<>::operator()
                               (*(vector<> **)(&stack0xffffff84 + iVar12 + iVar2 + iVar3),
                                *(int *)((int)local_64 + iVar12 + iVar2 + iVar3 + -0x14));
            *(ulong *)(TimeStamps + iVar13 * 4) = pTVar8->StatementID;
            *(int *)((int)local_64 + iVar12 + iVar2 + iVar3 + -0x14) = iVar13;
            *(undefined4 *)(&stack0xffffff84 + iVar12 + iVar2 + iVar3) =
                 *(undefined4 *)((int)RawData + 0x124);
            *(undefined4 *)((int)&pcStack_80 + iVar12 + iVar2 + iVar3) = 0x806a9fc;
            pTVar8 = vector<>::operator()
                               (*(vector<> **)(&stack0xffffff84 + iVar12 + iVar2 + iVar3),
                                *(int *)((int)local_64 + iVar12 + iVar2 + iVar3 + -0x14));
            *(ulong *)(CharacterIDs + iVar13 * 4) = pTVar8->TimeStamp;
            *(int *)((int)local_64 + iVar12 + iVar2 + iVar3 + -0x14) = iVar13;
            *(undefined4 *)(&stack0xffffff84 + iVar12 + iVar2 + iVar3) =
                 *(undefined4 *)((int)RawData + 0x124);
            *(undefined4 *)((int)&pcStack_80 + iVar12 + iVar2 + iVar3) = 0x806aa17;
            pTVar8 = vector<>::operator()
                               (*(vector<> **)(&stack0xffffff84 + iVar12 + iVar2 + iVar3),
                                *(int *)((int)local_64 + iVar12 + iVar2 + iVar3 + -0x14));
            *(ulong *)(Texts + iVar13 * 4) = pTVar8->CharacterID;
            *(int *)((int)local_64 + iVar12 + iVar2 + iVar3 + -0x14) = iVar13;
            *(undefined4 *)(&stack0xffffff84 + iVar12 + iVar2 + iVar3) =
                 *(undefined4 *)((int)RawData + 0x124);
            *(undefined4 *)((int)&pcStack_80 + iVar12 + iVar2 + iVar3) = 0x806aa32;
            pTVar8 = vector<>::operator()
                               (*(vector<> **)(&stack0xffffff84 + iVar12 + iVar2 + iVar3),
                                *(int *)((int)local_64 + iVar12 + iVar2 + iVar3 + -0x14));
            switch(pTVar8->Mode) {
            default:
                *(int *)((int)local_64 + iVar12 + iVar2 + iVar3 + -0x14) = iVar13;
                *(undefined4 *)(&stack0xffffff84 + iVar12 + iVar2 + iVar3) =
                     *(undefined4 *)((int)RawData + 0x124);
                *(undefined4 *)((int)&pcStack_80 + iVar12 + iVar2 + iVar3) = 0x806aa9c;
                pTVar8 = vector<>::operator()
                                   (*(vector<> **)(&stack0xffffff84 + iVar12 + iVar2 + iVar3),
                                    *(int *)((int)local_64 + iVar12 + iVar2 + iVar3 + -0x14));
                iVar11 = pTVar8->Mode;
                *(undefined **)(&stack0xffffff84 + iVar12 + iVar2 + iVar3) = &DAT_080f5dc0;
                *(int *)((int)local_64 + iVar12 + iVar2 + iVar3 + -0x14) = iVar11;
                *(undefined4 *)((int)&pcStack_80 + iVar12 + iVar2 + iVar3) = 0x806aaaf;
                error(*(char **)(&stack0xffffff84 + iVar12 + iVar2 + iVar3));
                *(undefined4 *)(iVar5 + iVar13 * 0x1e) = 0x6e6b6e55;
                *(undefined4 *)((int)&local_44 + iVar13 * 0x1e + iVar2 + iVar3) = 0x6e776f;
                break;
            case 1:
                *(undefined4 *)(iVar5 + iVar13 * 0x1e) = 0x796153;
                break;
            case 2:
                *(undefined4 *)(iVar5 + iVar13 * 0x1e) = 0x73696857;
                *(undefined4 *)((int)&local_44 + iVar13 * 0x1e + iVar2 + iVar3) = 0x726570;
                break;
            case 3:
                *(undefined4 *)(iVar5 + iVar13 * 0x1e) = 0x6c6c6559;
                *(undefined1 *)((int)&local_44 + iVar13 * 0x1e + iVar2 + iVar3) = 0;
                break;
            case 4:
            case 0xb:
                iVar11 = iVar13 * 0x1e;
                *(undefined4 *)((int)&local_44 + iVar11 + iVar2 + iVar3) = 0x20657461;
                *(undefined4 *)(iVar5 + iVar11) = 0x76697250;
                *(undefined4 *)((int)&local_44 + iVar11 + iVar2 + iVar3 + 4) = 0x7373654d;
                *(undefined4 *)((int)&local_3c + iVar11 + iVar2 + iVar3) = 0x656761;
                break;
            case 5:
            case 10:
            case 0xc:
                *(int *)((int)local_64 + iVar12 + iVar2 + iVar3 + -0x14) = iVar13;
                *(undefined4 *)(&stack0xffffff84 + iVar12 + iVar2 + iVar3) =
                     *(undefined4 *)((int)RawData + 0x124);
                *(undefined4 *)((int)&pcStack_80 + iVar12 + iVar2 + iVar3) = 0x806ac0a;
                pTVar8 = vector<>::operator()
                                   (*(vector<> **)(&stack0xffffff84 + iVar12 + iVar2 + iVar3),
                                    *(int *)((int)local_64 + iVar12 + iVar2 + iVar3 + -0x14));
                switch(pTVar8->Channel) {
                case 0:
                    *(undefined4 *)(iVar5 + iVar13 * 0x1e) = 0x6c697547;
                    *(undefined4 *)((int)&local_44 + iVar13 * 0x1e + iVar2 + iVar3) = 0x68432064;
                    goto LAB_0806ac36;
                case 1:
                    iVar11 = iVar13 * 0x1e;
                    *(undefined4 *)((int)&local_44 + iVar11 + iVar2 + iVar3) = 0x7473616d;
                    *(undefined4 *)(iVar5 + iVar11) = 0x656d6147;
                    *(undefined4 *)((int)&local_44 + iVar11 + iVar2 + iVar3 + 4) = 0x43207265;
                    *(undefined4 *)((int)&local_3c + iVar11 + iVar2 + iVar3) = 0x6e6e6168;
                    *(undefined2 *)((int)&local_38 + iVar11 + iVar2 + iVar3) = 0x6c65;
                    goto LAB_0806ab34;
                case 2:
                    *(undefined4 *)(iVar5 + iVar13 * 0x1e) = 0x6f747554;
                    *(undefined4 *)((int)&local_44 + iVar13 * 0x1e + iVar2 + iVar3) = 0x68432072;
                    goto LAB_0806ac36;
                default:
                    iVar11 = iVar13 * 0x1e;
                    *(undefined4 *)((int)&local_44 + iVar11 + iVar2 + iVar3) = 0x20657461;
                    *(undefined4 *)((int)&local_44 + iVar11 + iVar2 + iVar3 + 4) = 0x74616843;
                    *(undefined4 *)(iVar5 + iVar11) = 0x76697250;
                    *(undefined4 *)((int)&local_3c + iVar11 + iVar2 + iVar3) = 0x61684320;
                    *(undefined4 *)((int)&local_38 + iVar11 + iVar2 + iVar3) = 0x6c656e6e;
                    *(undefined1 *)((int)&Texts + iVar11 + iVar2 + iVar3) = 0;
                    break;
                case 4:
                    *(undefined4 *)(iVar5 + iVar13 * 0x1e) = 0x656d6147;
                    *(undefined4 *)((int)&local_44 + iVar13 * 0x1e + iVar2 + iVar3) = 0x61684320;
                    goto LAB_0806abbc;
                case 5:
                    *(undefined4 *)(iVar5 + iVar13 * 0x1e) = 0x64617254;
                    *(undefined4 *)((int)&local_44 + iVar13 * 0x1e + iVar2 + iVar3) = 0x68432065;
LAB_0806ac36:
                    *(undefined2 *)((int)&local_3c + iVar13 * 0x1e + iVar2 + iVar3) = 0x6c;
                    *(undefined4 *)((int)&local_44 + iVar13 * 0x1e + iVar2 + iVar3 + 4) = 0x656e6e61
                    ;
                    break;
                case 6:
                    iVar11 = iVar13 * 0x1e;
                    *(undefined4 *)(iVar5 + iVar11) = 0x6c616552;
                    *(undefined4 *)((int)&local_44 + iVar11 + iVar2 + iVar3) = 0x6566696c;
                    *(undefined4 *)((int)&local_44 + iVar11 + iVar2 + iVar3 + 4) = 0x61684320;
                    *(undefined2 *)((int)&local_3c + iVar11 + iVar2 + iVar3) = 0x74;
                    break;
                case 7:
                    iVar11 = iVar13 * 0x1e;
                    *(undefined4 *)(iVar5 + iVar11) = 0x706c6548;
                    *(undefined4 *)((int)&local_44 + iVar11 + iVar2 + iVar3) = 0x61684320;
                    *(undefined4 *)((int)&local_44 + iVar11 + iVar2 + iVar3 + 4) = 0x6c656e6e;
                    *(undefined1 *)((int)&local_3c + iVar11 + iVar2 + iVar3) = 0;
                }
                break;
            case 6:
                iVar11 = iVar13 * 0x1e;
                *(undefined4 *)((int)&local_44 + iVar11 + iVar2 + iVar3) = 0x7473616d;
                *(undefined4 *)(iVar5 + iVar11) = 0x656d6147;
                *(undefined4 *)((int)&local_44 + iVar11 + iVar2 + iVar3 + 4) = 0x52207265;
                *(undefined4 *)((int)&local_3c + iVar11 + iVar2 + iVar3) = 0x65757165;
                *(undefined2 *)((int)&local_38 + iVar11 + iVar2 + iVar3) = 0x7473;
LAB_0806ab34:
                *(undefined1 *)((int)&local_38 + iVar13 * 0x1e + iVar2 + iVar3 + 2) = 0;
                break;
            case 7:
                iVar11 = iVar13 * 0x1e;
                *(undefined4 *)((int)&local_44 + iVar11 + iVar2 + iVar3) = 0x7473616d;
                *(undefined4 *)(iVar5 + iVar11) = 0x656d6147;
                *(undefined4 *)((int)&local_44 + iVar11 + iVar2 + iVar3 + 4) = 0x41207265;
                *(undefined4 *)((int)&local_3c + iVar11 + iVar2 + iVar3) = 0x6577736e;
                *(undefined2 *)((int)&local_38 + iVar11 + iVar2 + iVar3) = 0x72;
                break;
            case 8:
                iVar11 = iVar13 * 0x1e;
                *(undefined4 *)(iVar5 + iVar11) = 0x79616c50;
                *(undefined4 *)((int)&local_44 + iVar11 + iVar2 + iVar3) = 0x41207265;
                *(undefined4 *)((int)&local_44 + iVar11 + iVar2 + iVar3 + 4) = 0x6577736e;
                *(undefined2 *)((int)&local_3c + iVar11 + iVar2 + iVar3) = 0x72;
                break;
            case 9:
                *(undefined4 *)(iVar5 + iVar13 * 0x1e) = 0x616f7242;
                *(undefined4 *)((int)&local_44 + iVar13 * 0x1e + iVar2 + iVar3) = 0x73616364;
LAB_0806abbc:
                *(undefined2 *)((int)&local_44 + iVar13 * 0x1e + iVar2 + iVar3 + 4) = 0x74;
            }
            *(int *)((int)local_64 + iVar12 + iVar2 + iVar3 + -0x14) = iVar13;
            *(undefined4 *)(&stack0xffffff84 + iVar12 + iVar2 + iVar3) =
                 *(undefined4 *)((int)RawData + 0x124);
            *(undefined4 *)((int)&pcStack_80 + iVar12 + iVar2 + iVar3) = 0x806aa62;
            pTVar8 = vector<>::operator()
                               (*(vector<> **)(&stack0xffffff84 + iVar12 + iVar2 + iVar3),
                                *(int *)((int)local_64 + iVar12 + iVar2 + iVar3 + -0x14));
            iVar11 = iVar13 * 0x100;
            *(char **)((int)local_64 + iVar12 + iVar2 + iVar3 + -0x14) = pTVar8->Text;
            iVar13 = iVar13 + 1;
            *(int *)(&stack0xffffff84 + iVar12 + iVar2 + iVar3) = iVar11 + local_38;
            *(undefined4 *)((int)&pcStack_80 + iVar12 + iVar2 + iVar3) = 0x806aa7c;
            strcpy(*(char **)(&stack0xffffff84 + iVar12 + iVar2 + iVar3),
                   *(char **)((int)local_64 + iVar12 + iVar2 + iVar3 + -0x14));
        } while (iVar13 < local_24);
    }
    *(undefined4 *)(&stack0xffffff84 + iVar12 + iVar2 + iVar3) =
         *(undefined4 *)((int)RawData + 0x50);
    *(undefined4 *)((int)&pcStack_80 + iVar12 + iVar2 + iVar3) = 0x806a785;
    pcVar4 = GetBanishmentReason(*(int *)(&stack0xffffff84 + iVar12 + iVar2 + iVar3));
    iVar13 = local_38;
    *(int *)((int)aiStack_50 + iVar12 + iVar2 + iVar3) = iVar5;
    *(int *)((int)aiStack_50 + iVar12 + iVar2 + iVar3 + 4) = iVar13;
    *(char_0__256_ **)((int)aiStack_50 + iVar12 + iVar2 + iVar3 + -4) = Texts;
    *(ulong_0_ **)((int)aiStack_50 + iVar12 + iVar2 + iVar3 + -8) = CharacterIDs;
    *(ulong_0_ **)((int)local_64 + iVar12 + iVar2 + iVar3 + 8) = TimeStamps;
    *(int *)((int)local_64 + iVar12 + iVar2 + iVar3 + 4) = local_24;
    *(undefined4 *)((int)local_64 + iVar12 + iVar2 + iVar3) = *(undefined4 *)((int)RawData + 0x128);
    iVar13 = Days;
    *(char **)((int)&stack0xffffff90 + iVar12 + iVar2 + iVar3) = pcVar4;
    *(int *)((int)&stack0xffffff94 + iVar12 + iVar2 + iVar3) = (int)RawData + 0x58;
    iVar5 = (int)RawData + 0x22;
    *(int *)((int)&stack0xffffff8c + iVar12 + iVar2 + iVar3) = iVar5;
    *(int *)((int)&stack0xffffff98 + iVar12 + iVar2 + iVar3) = iVar13;
                    // WARNING: Load size is inaccurate
    *(undefined4 *)((int)local_64 + iVar12 + iVar2 + iVar3 + -0x14) = *RawData;
    *(TQueryManagerConnection **)(&stack0xffffff84 + iVar12 + iVar2 + iVar3) =
         QueryManagerConnection;
    *(undefined4 *)((int)&pcStack_80 + iVar12 + iVar2 + iVar3) = 0x806a7e2;
    iVar13 = TQueryManagerConnection::reportStatement
                       (*(TQueryManagerConnection **)(&stack0xffffff84 + iVar12 + iVar2 + iVar3));
    if (iVar13 == 1) {
        if (*(int *)((int)RawData + 0x54) == 6) {
            *(char **)((int)local_64 + iVar12 + iVar2 + iVar3 + -0x14) =
                 "A player with this name does not exist. Perhaps he/she has been renamed?";
LAB_0806a966:
                    // WARNING: Load size is inaccurate
            *(undefined4 *)(&stack0xffffff84 + iVar12 + iVar2 + iVar3) = *RawData;
            *(undefined4 *)((int)&pcStack_80 + iVar12 + iVar2 + iVar3) = 0x806a970;
            DirectReply(*(ulong *)(&stack0xffffff84 + iVar12 + iVar2 + iVar3),
                        *(char **)((int)local_64 + iVar12 + iVar2 + iVar3 + -0x14));
        }
LAB_0806a955:
        local_1e = '\0';
        puVar14 = (ulong *)StatementIDs;
    }
    else {
        puVar14 = (ulong *)StatementIDs;
        if (iVar13 < 2) {
            if (iVar13 == 0) {
                if (*(int *)((int)RawData + 0x54) == 6) {
                    *(int *)((int)&stack0xffffff8c + iVar12 + iVar2 + iVar3) = iVar5;
                    *(char **)((int)local_64 + iVar12 + iVar2 + iVar3 + -0x14) =
                         "Statement of %s reported.";
                    // WARNING: Load size is inaccurate
                    *(undefined4 *)(&stack0xffffff84 + iVar12 + iVar2 + iVar3) = *RawData;
                    *(undefined4 *)((int)&pcStack_80 + iVar12 + iVar2 + iVar3) = 0x806a9ba;
                    DirectReply(*(ulong *)(&stack0xffffff84 + iVar12 + iVar2 + iVar3),
                                *(char **)((int)local_64 + iVar12 + iVar2 + iVar3 + -0x14));
                }
                *(int *)((int)&stack0xffffff90 + iVar12 + iVar2 + iVar3) = iVar5;
                *(int *)((int)&stack0xffffff8c + iVar12 + iVar2 + iVar3) = (int)RawData + 4;
                *(undefined **)((int)local_64 + iVar12 + iVar2 + iVar3 + -0x14) = &DAT_080f5d80;
                *(char **)(&stack0xffffff84 + iVar12 + iVar2 + iVar3) = "banish";
                *(undefined4 *)((int)&pcStack_80 + iVar12 + iVar2 + iVar3) = 0x806a99f;
                Log(*(char **)(&stack0xffffff84 + iVar12 + iVar2 + iVar3),
                    *(char **)((int)local_64 + iVar12 + iVar2 + iVar3 + -0x14));
                puVar14 = (ulong *)StatementIDs;
            }
        }
        else if (iVar13 == 2) {
            if (*(int *)((int)RawData + 0x54) == 6) {
                *(char **)((int)local_64 + iVar12 + iVar2 + iVar3 + -0x14) =
                     "Statement has already been reported.";
                goto LAB_0806a966;
            }
            goto LAB_0806a955;
        }
    }
LAB_0806a800:
    if ((local_1e == '\0') || (*(char *)((int)RawData + 300) == '\0')) goto LAB_0806a710;
    *puVar14 = *(undefined4 *)((int)RawData + 0x50);
    puVar14[-1] = 0x806a828;
    pcVar4 = GetBanishmentReason(*puVar14);
    puVar14[3] = (int)RawData + 0x40;
    puVar14[5] = (int)RawData + 0x58;
    uVar1 = (int)RawData + 0x22;
    puVar14[4] = (ulong)pcVar4;
    puVar14[2] = uVar1;
                    // WARNING: Load size is inaccurate
    puVar14[1] = *RawData;
    *puVar14 = (ulong)QueryManagerConnection;
    puVar14[-1] = 0x806a84e;
    iVar5 = TQueryManagerConnection::banishIPAddress((TQueryManagerConnection *)*puVar14);
    if (iVar5 == 1) {
        puVar14[1] = (ulong)
                     "A player with this name does not exist. Perhaps he/she has been renamed?";
    }
    else {
        if (iVar5 < 2) {
            if (iVar5 == 0) {
                puVar14[2] = uVar1;
                puVar14[1] = (ulong)"IP address of %s banished.";
                    // WARNING: Load size is inaccurate
                *puVar14 = *RawData;
                puVar14[-1] = 0x806a89a;
                DirectReply(*puVar14,(char *)puVar14[1]);
                *puVar14 = uVar1;
                puVar14[-1] = 0x806a8a2;
                sVar6 = strlen((char *)*puVar14);
                *puVar14 = sVar6 + 1;
                puVar14[-1] = 0x806a8ab;
                pvVar7 = operator_new__(*puVar14);
                puVar14[1] = uVar1;
                *puVar14 = (ulong)pvVar7;
                puVar14[-1] = 0x806a8b9;
                strcpy((char *)*puVar14,(char *)puVar14[1]);
                if (ReplyPointerWrite - ReplyPointerRead < 100) {
                    local_44 = (longlong)ReplyPointerWrite * 0x51eb851f;
                    local_3c = ReplyPointerWrite / 100;
                    ReplyBuffer[ReplyPointerWrite % 100].ReplyType = REPLY_LOGOUT;
                    ReplyBuffer[ReplyPointerWrite % 100].Data = pvVar7;
                    ReplyPointerWrite = ReplyPointerWrite + 1;
                }
                else {
                    *puVar14 = (ulong)&DAT_080f5540;
                    puVar14[-1] = 0x806a940;
                    error((char *)*puVar14);
                }
                puVar14[3] = uVar1;
                puVar14[2] = (int)RawData + 4;
                puVar14[1] = (ulong)"%s sperrt die IP-Adresse von %s.\n";
                *puVar14 = (ulong)"banish";
                puVar14[-1] = 0x806a92f;
                Log((char *)*puVar14,(char *)puVar14[1]);
            }
            goto LAB_0806a710;
        }
        if (iVar5 != 2) goto LAB_0806a710;
        puVar14[1] = (ulong)"You may not report a god or gamemaster.";
    }
                    // WARNING: Load size is inaccurate
    *puVar14 = *RawData;
    puVar14[-1] = 0x806a877;
    DirectReply(*puVar14,(char *)puVar14[1]);
LAB_0806a710:
    *puVar14 = (ulong)RawData;
    puVar14[-1] = 0x806a718;
    operator_delete((void *)*puVar14);
    return;
}



void ProcessCharacterDeathOrder(void *RawData)

{
    int iVar1;
    
    if (RawData != (void *)0x0) {
                    // WARNING: Load size is inaccurate
        iVar1 = TQueryManagerConnection::logCharacterDeath
                          (QueryManagerConnection,*RawData,*(int *)((int)RawData + 4),
                           *(ulong *)((int)RawData + 8),(char *)((int)RawData + 0xc),
                           *(bool *)((int)RawData + 0x2a),*(time_t *)((int)RawData + 0x2c));
        if (iVar1 != 0) {
            error("ProcessCharacterDeathOrder: Protokollierung fehlgeschlagen.\n");
        }
        operator_delete(RawData);
        return;
    }
    error(&DAT_080f6160);
    return;
}



void ProcessAddBuddyOrder(void *RawData)

{
    int iVar1;
    undefined4 uVar2;
    undefined4 uVar3;
    
    if (RawData != (void *)0x0) {
        uVar3 = *(undefined4 *)((int)RawData + 4);
                    // WARNING: Load size is inaccurate
        uVar2 = *RawData;
        iVar1 = TQueryManagerConnection::addBuddy(QueryManagerConnection);
        if (iVar1 != 0) {
            error("ProcessAddBuddyOrder: Aufnahme fehlgeschlagen.\n",uVar2,uVar3);
        }
        operator_delete(RawData);
        return;
    }
    error(&DAT_080f61e0);
    return;
}



void ProcessRemoveBuddyOrder(void *RawData)

{
    int iVar1;
    undefined4 uVar2;
    undefined4 uVar3;
    
    if (RawData != (void *)0x0) {
        uVar3 = *(undefined4 *)((int)RawData + 4);
                    // WARNING: Load size is inaccurate
        uVar2 = *RawData;
        iVar1 = TQueryManagerConnection::removeBuddy(QueryManagerConnection);
        if (iVar1 != 0) {
            error("ProcessRemoveBuddyOrder: Entfernen fehlgeschlagen.\n",uVar2,uVar3);
        }
        operator_delete(RawData);
        return;
    }
    error(&DAT_080f6260);
    return;
}



void ProcessDecrementIsOnlineOrder(void *RawData)

{
    int iVar1;
    
    iVar1 = TQueryManagerConnection::decrementIsOnline(QueryManagerConnection,(ulong)RawData);
    if (iVar1 == 0) {
        return;
    }
    error("ProcessDecrementIsOnlineOrder: Verringerung fehlgeschlagen.\n");
    return;
}



// WARNING: Variable defined which should be unmapped: HelpProfession

int WriterThreadLoop(void *param_1)

{
    TWriterThreadOrderType TVar1;
    ulong *RawData;
    int iVar2;
    char *pcVar3;
    ulong uVar4;
    ulong uVar5;
    ulong uVar6;
    ulong *puVar7;
    char local_2c [4];
    char HelpProfession [30];
    
LAB_0806b310:
    Semaphore::down(&OrderBufferFull);
    TVar1 = OrderBuffer[OrderPointerRead % 2000].OrderType;
    RawData = (ulong *)OrderBuffer[OrderPointerRead % 2000].Data;
    OrderPointerRead = OrderPointerRead + 1;
    Semaphore::up(&OrderBufferEmpty);
    switch(TVar1) {
    case ORDER_TERMINATE:
        return 0;
    case ORDER_LOGOUT:
        if (RawData != (ulong *)0x0) {
            pcVar3 = local_2c;
            GetProfessionName(pcVar3,RawData[2],false,true);
            if (0 < (int)RawData[4]) {
                print();
            }
            uVar6 = RawData[4];
            puVar7 = RawData + 5;
            uVar4 = RawData[3];
            uVar5 = RawData[1];
            iVar2 = TQueryManagerConnection::logoutGame(QueryManagerConnection);
            if (iVar2 != 0) {
                error(&DAT_080f5a20,*RawData,uVar5,pcVar3,puVar7,uVar4,uVar6);
            }
LAB_0806b403:
            operator_delete(RawData);
            goto LAB_0806b310;
        }
        pcVar3 = &DAT_080f5a60;
        break;
    case ORDER_PLAYERLIST:
        ProcessPlayerlistOrder(RawData);
        goto LAB_0806b310;
    case ORDER_KILLSTATISTICS:
        ProcessKillStatisticsOrder(RawData);
        goto LAB_0806b310;
    case ORDER_PUNISHMENT:
        ProcessPunishmentOrder(RawData);
        goto LAB_0806b310;
    case ORDER_CHARACTERDEATH:
        if (RawData != (ulong *)0x0) {
            uVar6 = RawData[1];
            uVar4 = *RawData;
            iVar2 = TQueryManagerConnection::logCharacterDeath
                              (QueryManagerConnection,uVar4,uVar6,RawData[2],(char *)(RawData + 3),
                               *(bool *)((int)RawData + 0x2a),RawData[0xb]);
            if (iVar2 != 0) {
                pcVar3 = "ProcessCharacterDeathOrder: Protokollierung fehlgeschlagen.\n";
LAB_0806b4af:
                error(pcVar3,uVar4,uVar6);
            }
            goto LAB_0806b403;
        }
        pcVar3 = &DAT_080f6160;
        break;
    case ORDER_ADDBUDDY:
        if (RawData != (ulong *)0x0) {
            uVar6 = RawData[1];
            uVar4 = *RawData;
            iVar2 = TQueryManagerConnection::addBuddy(QueryManagerConnection);
            if (iVar2 != 0) {
                pcVar3 = "ProcessAddBuddyOrder: Aufnahme fehlgeschlagen.\n";
                goto LAB_0806b4af;
            }
            goto LAB_0806b403;
        }
        pcVar3 = &DAT_080f61e0;
        break;
    case ORDER_REMOVEBUDDY:
        if (RawData != (ulong *)0x0) {
            uVar6 = RawData[1];
            uVar4 = *RawData;
            iVar2 = TQueryManagerConnection::removeBuddy(QueryManagerConnection);
            if (iVar2 != 0) {
                pcVar3 = "ProcessRemoveBuddyOrder: Entfernen fehlgeschlagen.\n";
                goto LAB_0806b4af;
            }
            goto LAB_0806b403;
        }
        pcVar3 = &DAT_080f6260;
        break;
    case ORDER_DECREMENTISONLINE:
        iVar2 = TQueryManagerConnection::decrementIsOnline(QueryManagerConnection,(ulong)RawData);
        if (iVar2 == 0) goto LAB_0806b310;
        pcVar3 = "ProcessDecrementIsOnlineOrder: Verringerung fehlgeschlagen.\n";
        break;
    case ORDER_SAVEPLAYERDATA:
        SavePlayerPoolSlots();
        goto LAB_0806b310;
    default:
        goto switchD_0806b373_default;
    }
    error(pcVar3);
    goto LAB_0806b310;
switchD_0806b373_default:
    error("WriterThreadLoop: Unbekanntes Kommando %d.\n",TVar1);
    goto LAB_0806b310;
}



void ProcessBroadcastReply(void *RawData)

{
    if (RawData != (void *)0x0) {
        BroadcastMessage(0x15,(char *)RawData);
        operator_delete__(RawData);
        return;
    }
    error(&DAT_080f6320);
    return;
}



void ProcessDirectReply(void *RawData)

{
    TPlayer *pl;
    TPlayer *pTVar1;
    
    if (RawData != (void *)0x0) {
                    // WARNING: Load size is inaccurate
        pTVar1 = GetPlayer(*RawData);
        if (pTVar1 != (TPlayer *)0x0) {
            SendMessage((pTVar1->super_TCreature).Connection,0x16,"%s",(int)RawData + 4);
        }
        operator_delete(RawData);
        return;
    }
    error(&DAT_080f6360);
    return;
}



void ProcessLogoutReply(void *RawData)

{
    TPlayer *this;
    TPlayer *pl;
    Object local_1c [4];
    
    if (RawData == (void *)0x0) {
        error(&DAT_080f63a0);
    }
    else {
        this = GetPlayer((char *)RawData);
        if (this != (TPlayer *)0x0) {
            local_1c[0].ObjectID = (this->super_TCreature).CrObject.ObjectID;
            GraphicalEffect(local_1c,0xf);
            TCreature::StartLogout(&this->super_TCreature,true,true);
        }
        operator_delete__(RawData);
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ProcessWriterThreadReplies(void)

{
    TWriterThreadReplyType TVar1;
    ulong *Text;
    TPlayer *pl;
    TPlayer *pTVar2;
    void *Data;
    TWriterThreadReplyType ReplyType;
    char *Text_00;
    
LAB_0806b6c0:
    do {
        while( true ) {
            if (ReplyPointerRead == ReplyPointerWrite) {
                return;
            }
            TVar1 = ReplyBuffer[ReplyPointerRead % 100].ReplyType;
            Text = (ulong *)ReplyBuffer[ReplyPointerRead % 100].Data;
            ReplyPointerRead = ReplyPointerRead + 1;
            if (TVar1 != REPLY_DIRECT) break;
            if (Text == (ulong *)0x0) {
                Text_00 = &DAT_080f6360;
LAB_0806b762:
                error(Text_00);
            }
            else {
                pTVar2 = GetPlayer(*Text);
                if (pTVar2 != (TPlayer *)0x0) {
                    SendMessage((pTVar2->super_TCreature).Connection,0x16,"%s",Text + 1);
                }
                operator_delete(Text);
            }
        }
        if ((int)TVar1 < 2) {
            if (TVar1 == REPLY_BROADCAST) {
                if (Text == (ulong *)0x0) {
                    Text_00 = &DAT_080f6320;
                    goto LAB_0806b762;
                }
                BroadcastMessage(0x15,(char *)Text);
                operator_delete__(Text);
            }
            else {
LAB_0806b783:
                error(&DAT_080f63e0,TVar1);
            }
            goto LAB_0806b6c0;
        }
        if (TVar1 != REPLY_LOGOUT) goto LAB_0806b783;
        ProcessLogoutReply(Text);
    } while( true );
}



// WARNING: Variable defined which should be unmapped: NumberOfAffectedPlayers
// WARNING: Unknown calling convention -- yet parameter storage is locked

void ClearPlayers(void)

{
    int iVar1;
    int local_8;
    int NumberOfAffectedPlayers;
    
    iVar1 = TQueryManagerConnection::clearIsOnline(QueryManagerConnection,&local_8);
    if (iVar1 == 0) {
        if (local_8 != 0) {
            error("ClearPlayers: %d Spieler waren als eingeloggt markiert.\n",local_8);
        }
    }
    else {
        error(&DAT_080f6460);
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void InitWriter(void)

{
    TQueryManagerConnection *this;
    int iVar1;
    undefined4 *puVar2;
    int *piVar3;
    int local_1c;
    int NumberOfAffectedPlayers;
    int local_14;
    
                    // try { // try from 0806b846 to 0806b84a has its CatchHandler @ 0806b9f0
    this = (TQueryManagerConnection *)operator_new(0x30);
    local_14 = 0x4000;
    NumberOfAffectedPlayers = MaxPlayers * 0x42 + 2;
    piVar3 = &NumberOfAffectedPlayers;
    if (NumberOfAffectedPlayers < 0x4001) {
        piVar3 = &local_14;
    }
                    // try { // try from 0806b87f to 0806b883 has its CatchHandler @ 0806b9c0
    TQueryManagerConnection::TQueryManagerConnection(this,*piVar3);
    QueryManagerConnection = this;
    if (this->Socket < 0) {
        puVar2 = (undefined4 *)__cxa_allocate_exception(4);
        *puVar2 = "cannot connect to query manager";
    }
    else {
                    // try { // try from 0806b8a4 to 0806b9a1 has its CatchHandler @ 0806b9f0
        iVar1 = TQueryManagerConnection::clearIsOnline(this,&local_1c);
        if (iVar1 == 0) {
            if (local_1c != 0) {
                error("ClearPlayers: %d Spieler waren als eingeloggt markiert.\n",local_1c);
            }
        }
        else {
            error(&DAT_080f6460);
        }
        ProtocolPointerWrite = 0;
        ProtocolPointerRead = 0;
        ProtocolThread = StartThread(ProtocolThreadLoop,(void *)0x0,false);
        if (ProtocolThread == 0) {
            puVar2 = (undefined4 *)__cxa_allocate_exception(4);
            *puVar2 = "cannot start protocol thread";
        }
        else {
            OrderPointerWrite = 0;
            OrderPointerRead = 0;
            ReplyPointerWrite = 0;
            ReplyPointerRead = 0;
            WriterThread = StartThread(WriterThreadLoop,(void *)0x0,false);
            if (WriterThread != 0) {
                return;
            }
            puVar2 = (undefined4 *)__cxa_allocate_exception(4);
            *puVar2 = "cannot start writer thread";
        }
    }
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar2,char_const*::typeinfo,0);
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void AbortWriter(void)

{
    if (WriterThread != 0) {
        WriterThread = 0;
        pthread_cancel(0);
        Semaphore::up(&OrderBufferEmpty);
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ExitWriter(void)

{
    TQueryManagerConnection *pTVar1;
    undefined *in_stack_ffffffe8;
    
    if (ProtocolThread != 0) {
        in_stack_ffffffe8 = &DAT_080ef15d;
        InsertProtocolOrder("","");
        JoinThread(ProtocolThread);
        ProtocolThread = 0;
    }
    if (WriterThread != 0) {
        if (1999 < OrderPointerWrite - OrderPointerRead) {
            error(&DAT_080f5500);
        }
        Semaphore::down(&OrderBufferEmpty);
        OrderBuffer[OrderPointerWrite % 2000].OrderType = ORDER_TERMINATE;
        OrderBuffer[OrderPointerWrite % 2000].Data = (void *)0x0;
        OrderPointerWrite = OrderPointerWrite + 1;
        Semaphore::up(&OrderBufferFull);
        JoinThread(WriterThread);
        WriterThread = 0;
    }
    pTVar1 = QueryManagerConnection;
    if (QueryManagerConnection != (TQueryManagerConnection *)0x0) {
        TQueryManagerConnection::~TQueryManagerConnection
                  (QueryManagerConnection,(int)in_stack_ffffffe8);
        operator_delete(pTVar1);
    }
    return;
}



void __tcf_0(void *param_1)

{
    int in_stack_00000008;
    
    Semaphore::~Semaphore(&ProtocolMutex,in_stack_00000008);
    return;
}



void __tcf_1(void *param_1)

{
    int in_stack_00000008;
    
    Semaphore::~Semaphore(&ProtocolBufferEmpty,in_stack_00000008);
    return;
}



void __tcf_2(void *param_1)

{
    int in_stack_00000008;
    
    Semaphore::~Semaphore(&ProtocolBufferFull,in_stack_00000008);
    return;
}



void __tcf_3(void *param_1)

{
    int in_stack_00000008;
    
    Semaphore::~Semaphore(&OrderBufferEmpty,in_stack_00000008);
    return;
}



void __tcf_4(void *param_1)

{
    int in_stack_00000008;
    
    Semaphore::~Semaphore(&OrderBufferFull,in_stack_00000008);
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__I__Z12InitProtocolv(void)

{
    __static_initialization_and_destruction_0(1,0xffff);
    return;
}

void __static_initialization_and_destruction_0(int __initialize_p,int __priority)

{
    if ((__priority == 0xffff) && (__initialize_p == 1)) {
        NONE.ObjectID = 0;
    }
    return;
}



// DWARF original prototype: void load(TOutfit * this, TReadScriptFile * Script)

void __thiscall TOutfit::load(TOutfit *this,TReadScriptFile *Script)

{
    int iVar1;
    anon_union_4_2_730cd3ca_for_TOutfit_2 *paVar2;
    
                    // try { // try from 0806c05d to 0806c0af has its CatchHandler @ 0806c0b7
    TReadScriptFile::readSymbol(Script,'(');
    iVar1 = TReadScriptFile::readNumber(Script);
    this->OutfitID = iVar1;
    TReadScriptFile::readSymbol(Script,',');
    if (this->OutfitID == 0) {
        iVar1 = TReadScriptFile::readNumber(Script);
        (this->field_1).ObjectType = (ushort)iVar1;
    }
    else {
        paVar2 = (anon_union_4_2_730cd3ca_for_TOutfit_2 *)TReadScriptFile::readBytesequence(Script);
        this->field_1 = *paVar2;
    }
    TReadScriptFile::readSymbol(Script,')');
    return;
}



// DWARF original prototype: void save(TOutfit * this, TWriteScriptFile * Script)

void __thiscall TOutfit::save(TOutfit *this,TWriteScriptFile *Script)

{
                    // try { // try from 0806c0ed to 0806c156 has its CatchHandler @ 0806c160
    TWriteScriptFile::writeText(Script,"(");
    TWriteScriptFile::writeNumber(Script,this->OutfitID);
    TWriteScriptFile::writeText(Script,",");
    if (this->OutfitID == 0) {
        TWriteScriptFile::writeNumber(Script,(uint)(this->field_1).ObjectType);
    }
    else {
        TWriteScriptFile::writeBytesequence(Script,(this->field_1).Colors,4);
    }
    TWriteScriptFile::writeText(Script,")");
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void PlayerDataPath(void)

{
    uint in_stack_00000004;
    char *in_stack_0000000c;
    
    sprintf(in_stack_0000000c,"%s/%02ld/%ld.%s",USERPATH,in_stack_00000004 % 100);
    return;
}



bool PlayerDataExists(ulong CharacterID)

{
    bool bVar1;
    char local_100c [4];
    char FileName [4096];
    
    sprintf(local_100c,"%s/%02ld/%ld.%s",USERPATH,CharacterID % 100,CharacterID,&DAT_080f6560);
    bVar1 = FileExists(local_100c);
    return bVar1;
}



// WARNING: Removing unreachable block (ram,0x0806d081)
// WARNING: Removing unreachable block (ram,0x0806d0da)
// WARNING: Removing unreachable block (ram,0x0806d08b)
// WARNING: Removing unreachable block (ram,0x0806d095)
// WARNING: Removing unreachable block (ram,0x0806d0c7)
// WARNING: Removing unreachable block (ram,0x0806d0a0)

bool LoadPlayerData(TPlayerData *Slot)

{
    bool bVar1;
    char cVar2;
    int SkillNr;
    int iVar3;
    uint uVar4;
    int iVar5;
    uchar *puVar6;
    anon_union_4_2_730cd3ca_for_TOutfit_2 *paVar7;
    int DepotNr;
    int SkillNr_2;
    int *piVar8;
    char *pcVar9;
    undefined1 uVar10;
    char *pcVar11;
    undefined1 auStack_500c [3];
    bool FileOk;
    TReadScriptFile Script;
    undefined1 local_102c [4];
    TDynamicWriteBuffer HelpBuffer;
    char FileName [4096];
    
    if (Slot == (TPlayerData *)0x0) {
        pcVar11 = "LoadPlayerData: Slot ist NULL.\n";
    }
    else {
        uVar4 = Slot->CharacterID;
        if (uVar4 != 0) {
            piVar8 = &HelpBuffer.super_TWriteBuffer.Position;
            pcVar11 = USERPATH;
            sprintf((char *)piVar8,"%s/%02ld/%ld.%s",USERPATH,uVar4 % 100,uVar4,&DAT_080f6560);
            bVar1 = FileExists((char *)piVar8);
            if (!bVar1) {
                Slot->Race = 1;
                iVar3 = 0;
                Slot->Profession = 0;
                (Slot->OriginalOutfit).OutfitID = 0;
                (Slot->OriginalOutfit).field_1 = (anon_union_4_2_730cd3ca_for_TOutfit_2)0x0;
                (Slot->CurrentOutfit).OutfitID = 0;
                (Slot->CurrentOutfit).field_1 = (anon_union_4_2_730cd3ca_for_TOutfit_2)0x0;
                Slot->LastLoginTime = 0;
                Slot->LastLogoutTime = 0;
                Slot->startx = 0;
                Slot->starty = 0;
                Slot->startz = 0;
                Slot->posx = 0;
                Slot->posy = 0;
                Slot->posz = 0;
                Slot->PlayerkillerEnd = 0;
                do {
                    Slot->Minimum[iVar3] = -0x80000000;
                    iVar3 = iVar3 + 1;
                } while (iVar3 < 0x19);
                puVar6 = Slot->SpellList;
                for (iVar3 = 0x40; iVar3 != 0; iVar3 = iVar3 + -1) {
                    puVar6[0] = '\0';
                    puVar6[1] = '\0';
                    puVar6[2] = '\0';
                    puVar6[3] = '\0';
                    puVar6 = puVar6 + 4;
                }
                uVar4 = 2000;
                piVar8 = Slot->QuestValues;
                if (((uint)piVar8 & 4) != 0) {
                    piVar8 = Slot->QuestValues + 1;
                    uVar4 = 0x7cc;
                    Slot->QuestValues[0] = 0;
                }
                for (uVar4 = uVar4 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
                    *piVar8 = 0;
                    piVar8 = piVar8 + 1;
                }
                Slot->MurderTimestamps[0] = 0;
                Slot->MurderTimestamps[1] = 0;
                Slot->MurderTimestamps[2] = 0;
                Slot->MurderTimestamps[3] = 0;
                Slot->MurderTimestamps[4] = 0;
                Slot->MurderTimestamps[5] = 0;
                Slot->MurderTimestamps[6] = 0;
                Slot->MurderTimestamps[8] = 0;
                Slot->MurderTimestamps[9] = 0;
                Slot->MurderTimestamps[10] = 0;
                Slot->MurderTimestamps[0xb] = 0;
                Slot->MurderTimestamps[0xc] = 0;
                Slot->MurderTimestamps[7] = 0;
                Slot->MurderTimestamps[0xd] = 0;
                Slot->MurderTimestamps[0xe] = 0;
                Slot->MurderTimestamps[0xf] = 0;
                Slot->MurderTimestamps[0x10] = 0;
                Slot->InventorySize = 0;
                iVar3 = 0;
                Slot->MurderTimestamps[0x11] = 0;
                Slot->MurderTimestamps[0x12] = 0;
                Slot->MurderTimestamps[0x13] = 0;
                Slot->Inventory = (uchar *)0x0;
                do {
                    Slot->Depot[iVar3] = (uchar *)0x0;
                    Slot->DepotSize[iVar3] = 0;
                    iVar3 = iVar3 + 1;
                } while (iVar3 < 9);
                return true;
            }
            TDynamicWriteBuffer::TDynamicWriteBuffer((TDynamicWriteBuffer *)local_102c,0x4000);
                    // try { // try from 0806c499 to 0806c49d has its CatchHandler @ 0806d1cf
            TReadScriptFile::TReadScriptFile((TReadScriptFile *)auStack_500c);
                    // try { // try from 0806c4ab to 0806c5b3 has its CatchHandler @ 0806d1c6
            TReadScriptFile::open((TReadScriptFile *)auStack_500c,(char *)piVar8,(int)pcVar11);
            TReadScriptFile::readIdentifier((TReadScriptFile *)auStack_500c);
            TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'=');
            TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
            TReadScriptFile::readIdentifier((TReadScriptFile *)auStack_500c);
            TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'=');
            pcVar11 = TReadScriptFile::readString((TReadScriptFile *)auStack_500c);
            strcpy(Slot->Name,pcVar11);
            TReadScriptFile::readIdentifier((TReadScriptFile *)auStack_500c);
            TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'=');
            iVar3 = TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
            Slot->Race = iVar3;
            TReadScriptFile::readIdentifier((TReadScriptFile *)auStack_500c);
            TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'=');
            iVar3 = TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
            Slot->Profession = iVar3;
            TReadScriptFile::readIdentifier((TReadScriptFile *)auStack_500c);
            TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'=');
                    // try { // try from 0806c5c8 to 0806c626 has its CatchHandler @ 0806d12c
            TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'(');
            iVar3 = TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
            (Slot->OriginalOutfit).OutfitID = iVar3;
            TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,',');
            if ((Slot->OriginalOutfit).OutfitID == 0) {
                iVar3 = TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
                (Slot->OriginalOutfit).field_1.ObjectType = (ushort)iVar3;
            }
            else {
                    // try { // try from 0806d10d to 0806d111 has its CatchHandler @ 0806d12c
                paVar7 = (anon_union_4_2_730cd3ca_for_TOutfit_2 *)
                         TReadScriptFile::readBytesequence((TReadScriptFile *)auStack_500c);
                (Slot->OriginalOutfit).field_1 = *paVar7;
            }
            TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,')');
                    // try { // try from 0806c630 to 0806c64a has its CatchHandler @ 0806d1c6
            TReadScriptFile::readIdentifier((TReadScriptFile *)auStack_500c);
            TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'=');
                    // try { // try from 0806c65f to 0806c6bd has its CatchHandler @ 0806d12c
            TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'(');
            iVar3 = TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
            (Slot->CurrentOutfit).OutfitID = iVar3;
            TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,',');
            if ((Slot->CurrentOutfit).OutfitID == 0) {
                iVar3 = TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
                (Slot->CurrentOutfit).field_1.ObjectType = (ushort)iVar3;
            }
            else {
                    // try { // try from 0806d0f5 to 0806d0f9 has its CatchHandler @ 0806d12c
                paVar7 = (anon_union_4_2_730cd3ca_for_TOutfit_2 *)
                         TReadScriptFile::readBytesequence((TReadScriptFile *)auStack_500c);
                (Slot->CurrentOutfit).field_1 = *paVar7;
            }
            TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,')');
                    // try { // try from 0806c6c7 to 0806d062 has its CatchHandler @ 0806d1c6
            TReadScriptFile::readIdentifier((TReadScriptFile *)auStack_500c);
            TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'=');
            iVar3 = TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
            Slot->LastLoginTime = iVar3;
            TReadScriptFile::readIdentifier((TReadScriptFile *)auStack_500c);
            TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'=');
            iVar3 = TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
            Slot->LastLogoutTime = iVar3;
            TReadScriptFile::readIdentifier((TReadScriptFile *)auStack_500c);
            TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'=');
            TReadScriptFile::readCoordinate((TReadScriptFile *)auStack_500c);
            TReadScriptFile::readIdentifier((TReadScriptFile *)auStack_500c);
            TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'=');
            TReadScriptFile::readCoordinate((TReadScriptFile *)auStack_500c);
            TReadScriptFile::readIdentifier((TReadScriptFile *)auStack_500c);
            TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'=');
            iVar3 = TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
            Slot->PlayerkillerEnd = iVar3;
            iVar3 = 0;
            do {
                Slot->Minimum[iVar3] = -0x80000000;
                iVar3 = iVar3 + 1;
                uVar10 = iVar3 == 0x18;
            } while (iVar3 < 0x19);
            do {
                TReadScriptFile::readIdentifier((TReadScriptFile *)auStack_500c);
                pcVar11 = TReadScriptFile::getIdentifier((TReadScriptFile *)auStack_500c);
                iVar3 = 6;
                pcVar9 = "skill";
                do {
                    if (iVar3 == 0) break;
                    iVar3 = iVar3 + -1;
                    uVar10 = *pcVar11 == *pcVar9;
                    pcVar11 = pcVar11 + 1;
                    pcVar9 = pcVar9 + 1;
                } while ((bool)uVar10);
                if (!(bool)uVar10) goto LAB_0806cb0a;
                TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'=');
                TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'(');
                iVar3 = TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
                bVar1 = false;
                if ((-1 < iVar3) && (iVar3 < 0x19)) {
                    bVar1 = true;
                }
                uVar10 = !bVar1;
                if ((bool)uVar10) {
                    TReadScriptFile::error((TReadScriptFile *)auStack_500c,"illegal skill number");
                }
                TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,',');
                iVar5 = TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
                Slot->Actual[iVar3] = iVar5;
                TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,',');
                iVar5 = TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
                Slot->Maximum[iVar3] = iVar5;
                TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,',');
                iVar5 = TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
                Slot->Minimum[iVar3] = iVar5;
                TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,',');
                iVar5 = TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
                Slot->DeltaAct[iVar3] = iVar5;
                TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,',');
                iVar5 = TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
                Slot->MagicDeltaAct[iVar3] = iVar5;
                TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,',');
                iVar5 = TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
                Slot->Cycle[iVar3] = iVar5;
                TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,',');
                iVar5 = TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
                Slot->MaxCycle[iVar3] = iVar5;
                TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,',');
                iVar5 = TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
                Slot->Count[iVar3] = iVar5;
                TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,',');
                iVar5 = TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
                Slot->MaxCount[iVar3] = iVar5;
                TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,',');
                iVar5 = TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
                Slot->AddLevel[iVar3] = iVar5;
                TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,',');
                iVar5 = TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
                Slot->Experience[iVar3] = iVar5;
                TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,',');
                iVar5 = TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
                Slot->FactorPercent[iVar3] = iVar5;
                TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,',');
                iVar5 = TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
                Slot->NextLevel[iVar3] = iVar5;
                TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,',');
                iVar5 = TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
                Slot->Delta[iVar3] = iVar5;
                TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,')');
            } while( true );
        }
        pcVar11 = &DAT_080f6720;
    }
    error(pcVar11);
    return false;
LAB_0806cb0a:
    TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'=');
    TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'{');
LAB_0806cb3b:
    TReadScriptFile::nextToken((TReadScriptFile *)auStack_500c);
    if (_auStack_500c != SPECIAL) goto LAB_0806cb7f;
    cVar2 = TReadScriptFile::getSpecial((TReadScriptFile *)auStack_500c);
    if (cVar2 != '}') goto code_r0x0806cb64;
    TReadScriptFile::readIdentifier((TReadScriptFile *)auStack_500c);
    TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'=');
    TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'{');
    while( true ) {
        TReadScriptFile::nextToken((TReadScriptFile *)auStack_500c);
        if (_auStack_500c != SPECIAL) goto LAB_0806cc5a;
        cVar2 = TReadScriptFile::getSpecial((TReadScriptFile *)auStack_500c);
        if (cVar2 == '}') break;
        if (_auStack_500c != SPECIAL) goto LAB_0806cc5a;
        cVar2 = TReadScriptFile::getSpecial((TReadScriptFile *)auStack_500c);
        if (cVar2 != ',') {
            if ((_auStack_500c != SPECIAL) ||
               (cVar2 = TReadScriptFile::getSpecial((TReadScriptFile *)auStack_500c), cVar2 != '('))
            {
LAB_0806cc5a:
                TReadScriptFile::error((TReadScriptFile *)auStack_500c,"\'(\' expected");
            }
            iVar3 = TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
            bVar1 = false;
            if ((-1 < iVar3) && (iVar3 < 500)) {
                bVar1 = true;
            }
            if (!bVar1) {
                TReadScriptFile::error((TReadScriptFile *)auStack_500c,"illegal quest number");
            }
            TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,',');
            iVar5 = TReadScriptFile::readNumber((TReadScriptFile *)auStack_500c);
            Slot->QuestValues[iVar3] = iVar5;
            TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,')');
        }
    }
    TReadScriptFile::readIdentifier((TReadScriptFile *)auStack_500c);
    TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'=');
    TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'{');
LAB_0806cd45:
    TReadScriptFile::nextToken((TReadScriptFile *)auStack_500c);
    if (_auStack_500c != SPECIAL) goto LAB_0806cd89;
    cVar2 = TReadScriptFile::getSpecial((TReadScriptFile *)auStack_500c);
    if (cVar2 != '}') goto code_r0x0806cd6e;
    TReadScriptFile::readIdentifier((TReadScriptFile *)auStack_500c);
    TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'=');
    TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'{');
    HelpBuffer.super_TWriteBuffer.Size = 0;
LAB_0806cdfa:
    TReadScriptFile::nextToken((TReadScriptFile *)auStack_500c);
    if (_auStack_500c != SPECIAL) goto LAB_0806ce42;
    cVar2 = TReadScriptFile::getSpecial((TReadScriptFile *)auStack_500c);
    if (cVar2 != '}') goto code_r0x0806ce27;
    TDynamicWriteBuffer::writeByte((TDynamicWriteBuffer *)local_102c,0xff);
    Slot->InventorySize = HelpBuffer.super_TWriteBuffer.Size;
    puVar6 = (uchar *)operator_new__(HelpBuffer.super_TWriteBuffer.Size);
    Slot->Inventory = puVar6;
    memcpy(puVar6,HelpBuffer.super_TWriteBuffer.super_TWriteStream._vptr_TWriteStream,
           Slot->InventorySize);
    TReadScriptFile::readIdentifier((TReadScriptFile *)auStack_500c);
    TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'=');
    pcVar11 = (char *)0x7b;
    TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'{');
    iVar3 = 0;
    do {
        Slot->Depot[iVar3] = (uchar *)0x0;
        iVar3 = iVar3 + 1;
    } while (iVar3 < 9);
LAB_0806cf45:
    TReadScriptFile::nextToken((TReadScriptFile *)auStack_500c);
    if (_auStack_500c == SPECIAL) goto code_r0x0806cf5c;
    goto LAB_0806cf8d;
code_r0x0806cb64:
    if ((_auStack_500c != SPECIAL) ||
       (cVar2 = TReadScriptFile::getSpecial((TReadScriptFile *)auStack_500c), cVar2 != ',')) {
LAB_0806cb7f:
        iVar3 = TReadScriptFile::getNumber((TReadScriptFile *)auStack_500c);
        bVar1 = false;
        if ((-1 < iVar3) && (iVar3 < 0x100)) {
            bVar1 = true;
        }
        if (!bVar1) {
            TReadScriptFile::error((TReadScriptFile *)auStack_500c,"illegal spell number");
        }
        Slot->SpellList[iVar3] = '\x01';
    }
    goto LAB_0806cb3b;
code_r0x0806cd6e:
    if ((_auStack_500c != SPECIAL) ||
       (cVar2 = TReadScriptFile::getSpecial((TReadScriptFile *)auStack_500c), cVar2 != ',')) {
LAB_0806cd89:
        iVar3 = 1;
        do {
            Slot->MurderTimestamps[iVar3 + -1] = Slot->MurderTimestamps[iVar3];
            iVar3 = iVar3 + 1;
        } while (iVar3 < 0x14);
        iVar3 = TReadScriptFile::getNumber((TReadScriptFile *)auStack_500c);
        Slot->MurderTimestamps[0x13] = iVar3;
    }
    goto LAB_0806cd45;
code_r0x0806ce27:
    if ((_auStack_500c != SPECIAL) ||
       (cVar2 = TReadScriptFile::getSpecial((TReadScriptFile *)auStack_500c), cVar2 != ',')) {
LAB_0806ce42:
        iVar3 = TReadScriptFile::getNumber((TReadScriptFile *)auStack_500c);
        TDynamicWriteBuffer::writeByte((TDynamicWriteBuffer *)local_102c,(uchar)iVar3);
        TReadScriptFile::readIdentifier((TReadScriptFile *)auStack_500c);
        TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'=');
        LoadObjects((TReadScriptFile *)auStack_500c,(TWriteStream *)local_102c,false);
    }
    goto LAB_0806cdfa;
code_r0x0806cf5c:
    cVar2 = TReadScriptFile::getSpecial((TReadScriptFile *)auStack_500c);
    if (cVar2 == '}') {
        TReadScriptFile::nextToken((TReadScriptFile *)auStack_500c);
        if (_auStack_500c != ENDOFFILE) {
            pcVar11 = "end of file expected";
            TReadScriptFile::error((TReadScriptFile *)auStack_500c,"end of file expected");
        }
        TReadScriptFile::close((TReadScriptFile *)auStack_500c,(int)pcVar11);
                    // try { // try from 0806d073 to 0806d077 has its CatchHandler @ 0806d1cf
        TReadScriptFile::~TReadScriptFile((TReadScriptFile *)auStack_500c,(int)pcVar11);
        TDynamicWriteBuffer::~TDynamicWriteBuffer((TDynamicWriteBuffer *)local_102c,(int)pcVar11);
        return true;
    }
    if ((_auStack_500c != SPECIAL) ||
       (cVar2 = TReadScriptFile::getSpecial((TReadScriptFile *)auStack_500c), cVar2 != ',')) {
LAB_0806cf8d:
        iVar3 = TReadScriptFile::getNumber((TReadScriptFile *)auStack_500c);
        TReadScriptFile::readIdentifier((TReadScriptFile *)auStack_500c);
        TReadScriptFile::readSymbol((TReadScriptFile *)auStack_500c,'=');
        HelpBuffer.super_TWriteBuffer.Size = 0;
        LoadObjects((TReadScriptFile *)auStack_500c,(TWriteStream *)local_102c,false);
        Slot->DepotSize[iVar3] = HelpBuffer.super_TWriteBuffer.Size;
        puVar6 = (uchar *)operator_new__(HelpBuffer.super_TWriteBuffer.Size);
        Slot->Depot[iVar3] = puVar6;
        pcVar11 = (char *)HelpBuffer.super_TWriteBuffer.super_TWriteStream;
        memcpy(puVar6,HelpBuffer.super_TWriteBuffer.super_TWriteStream._vptr_TWriteStream,
               Slot->DepotSize[iVar3]);
    }
    goto LAB_0806cf45;
}



void SavePlayerData(TPlayerData *Slot)

{
    uint uVar1;
    bool bVar2;
    bool FirstSpell;
    byte bVar3;
    time_t tVar4;
    int Number;
    int SpellNr;
    int *piVar5;
    int Limitation;
    int iVar6;
    char *pcVar7;
    undefined *__fd;
    undefined1 local_203c;
    bool FirstDepot;
    bool FirstPosition;
    bool FirstMurder;
    TReadBuffer Buffer;
    TWriteScriptFile Script;
    char local_101c [4];
    char FileName [4096];
    
    if (Slot == (TPlayerData *)0x0) {
        pcVar7 = "SavePlayerData: Slot ist NULL.\n";
    }
    else {
        uVar1 = Slot->CharacterID;
        if (uVar1 != 0) {
            pcVar7 = USERPATH;
            sprintf(local_101c,"%s/%02ld/%ld.%s",USERPATH,uVar1 % 100,uVar1,&DAT_080f6560);
                    // try { // try from 0806d29e to 0806d2a2 has its CatchHandler @ 0806de36
            TWriteScriptFile::TWriteScriptFile((TWriteScriptFile *)&Buffer.Position);
                    // try { // try from 0806d2b6 to 0806d3b6 has its CatchHandler @ 0806de30
            TWriteScriptFile::open((TWriteScriptFile *)&Buffer.Position,local_101c,(int)pcVar7);
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,"ID              = ");
            TWriteScriptFile::writeNumber((TWriteScriptFile *)&Buffer.Position,Slot->CharacterID);
            TWriteScriptFile::writeLn((TWriteScriptFile *)&Buffer.Position);
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,"Name            = ");
            TWriteScriptFile::writeString((TWriteScriptFile *)&Buffer.Position,Slot->Name);
            TWriteScriptFile::writeLn((TWriteScriptFile *)&Buffer.Position);
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,"Race            = ");
            TWriteScriptFile::writeNumber((TWriteScriptFile *)&Buffer.Position,Slot->Race);
            TWriteScriptFile::writeLn((TWriteScriptFile *)&Buffer.Position);
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,"Profession      = ");
            TWriteScriptFile::writeNumber((TWriteScriptFile *)&Buffer.Position,Slot->Profession);
            TWriteScriptFile::writeLn((TWriteScriptFile *)&Buffer.Position);
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,"OriginalOutfit  = ");
                    // try { // try from 0806d3cb to 0806d431 has its CatchHandler @ 0806ddc3
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,"(");
            TWriteScriptFile::writeNumber
                      ((TWriteScriptFile *)&Buffer.Position,(Slot->OriginalOutfit).OutfitID);
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,",");
            if ((Slot->OriginalOutfit).OutfitID == 0) {
                TWriteScriptFile::writeNumber
                          ((TWriteScriptFile *)&Buffer.Position,
                           (uint)(Slot->OriginalOutfit).field_1.ObjectType);
            }
            else {
                    // try { // try from 0806ddad to 0806ddb1 has its CatchHandler @ 0806ddc3
                TWriteScriptFile::writeBytesequence
                          ((TWriteScriptFile *)&Buffer.Position,
                           (Slot->OriginalOutfit).field_1.Colors,4);
            }
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,")");
                    // try { // try from 0806d43b to 0806d455 has its CatchHandler @ 0806de30
            TWriteScriptFile::writeLn((TWriteScriptFile *)&Buffer.Position);
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,"CurrentOutfit   = ");
                    // try { // try from 0806d46a to 0806d4d0 has its CatchHandler @ 0806ddc3
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,"(");
            TWriteScriptFile::writeNumber
                      ((TWriteScriptFile *)&Buffer.Position,(Slot->CurrentOutfit).OutfitID);
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,",");
            if ((Slot->CurrentOutfit).OutfitID == 0) {
                TWriteScriptFile::writeNumber
                          ((TWriteScriptFile *)&Buffer.Position,
                           (uint)(Slot->CurrentOutfit).field_1.ObjectType);
            }
            else {
                    // try { // try from 0806dd8b to 0806dd8f has its CatchHandler @ 0806ddc3
                TWriteScriptFile::writeBytesequence
                          ((TWriteScriptFile *)&Buffer.Position,(Slot->CurrentOutfit).field_1.Colors
                           ,4);
            }
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,")");
                    // try { // try from 0806d4da to 0806dd20 has its CatchHandler @ 0806de30
            TWriteScriptFile::writeLn((TWriteScriptFile *)&Buffer.Position);
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,"LastLogin       = ");
            TWriteScriptFile::writeNumber((TWriteScriptFile *)&Buffer.Position,Slot->LastLoginTime);
            TWriteScriptFile::writeLn((TWriteScriptFile *)&Buffer.Position);
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,"LastLogout      = ");
            TWriteScriptFile::writeNumber((TWriteScriptFile *)&Buffer.Position,Slot->LastLogoutTime)
            ;
            TWriteScriptFile::writeLn((TWriteScriptFile *)&Buffer.Position);
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,"StartPosition   = ");
            TWriteScriptFile::writeCoordinate
                      ((TWriteScriptFile *)&Buffer.Position,Slot->startx,Slot->starty,Slot->startz);
            TWriteScriptFile::writeLn((TWriteScriptFile *)&Buffer.Position);
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,"CurrentPosition = ");
            TWriteScriptFile::writeCoordinate
                      ((TWriteScriptFile *)&Buffer.Position,Slot->posx,Slot->posy,Slot->posz);
            TWriteScriptFile::writeLn((TWriteScriptFile *)&Buffer.Position);
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,"PlayerkillerEnd = ");
            TWriteScriptFile::writeNumber
                      ((TWriteScriptFile *)&Buffer.Position,Slot->PlayerkillerEnd);
            TWriteScriptFile::writeLn((TWriteScriptFile *)&Buffer.Position);
            TWriteScriptFile::writeLn((TWriteScriptFile *)&Buffer.Position);
            iVar6 = 0;
            piVar5 = Slot->Delta;
            do {
                if (piVar5[-0x113] != -0x80000000) {
                    TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,"Skill = (");
                    TWriteScriptFile::writeNumber((TWriteScriptFile *)&Buffer.Position,iVar6);
                    TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,",");
                    TWriteScriptFile::writeNumber
                              ((TWriteScriptFile *)&Buffer.Position,piVar5[-0x145]);
                    TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,",");
                    TWriteScriptFile::writeNumber((TWriteScriptFile *)&Buffer.Position,piVar5[-300])
                    ;
                    TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,",");
                    TWriteScriptFile::writeNumber
                              ((TWriteScriptFile *)&Buffer.Position,piVar5[-0x113]);
                    TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,",");
                    TWriteScriptFile::writeNumber
                              ((TWriteScriptFile *)&Buffer.Position,piVar5[-0xfa]);
                    TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,",");
                    TWriteScriptFile::writeNumber
                              ((TWriteScriptFile *)&Buffer.Position,piVar5[-0xe1]);
                    TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,",");
                    TWriteScriptFile::writeNumber((TWriteScriptFile *)&Buffer.Position,piVar5[-200])
                    ;
                    TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,",");
                    TWriteScriptFile::writeNumber
                              ((TWriteScriptFile *)&Buffer.Position,piVar5[-0xaf]);
                    TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,",");
                    TWriteScriptFile::writeNumber
                              ((TWriteScriptFile *)&Buffer.Position,piVar5[-0x96]);
                    TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,",");
                    TWriteScriptFile::writeNumber
                              ((TWriteScriptFile *)&Buffer.Position,piVar5[-0x7d]);
                    TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,",");
                    TWriteScriptFile::writeNumber((TWriteScriptFile *)&Buffer.Position,piVar5[-100])
                    ;
                    TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,",");
                    TWriteScriptFile::writeNumber
                              ((TWriteScriptFile *)&Buffer.Position,piVar5[-0x4b]);
                    TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,",");
                    TWriteScriptFile::writeNumber
                              ((TWriteScriptFile *)&Buffer.Position,piVar5[-0x32]);
                    TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,",");
                    TWriteScriptFile::writeNumber
                              ((TWriteScriptFile *)&Buffer.Position,piVar5[-0x19]);
                    TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,",");
                    TWriteScriptFile::writeNumber((TWriteScriptFile *)&Buffer.Position,*piVar5);
                    TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,")");
                    TWriteScriptFile::writeLn((TWriteScriptFile *)&Buffer.Position);
                }
                iVar6 = iVar6 + 1;
                piVar5 = piVar5 + 1;
            } while (iVar6 < 0x19);
            TWriteScriptFile::writeLn((TWriteScriptFile *)&Buffer.Position);
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,"Spells      = {");
            bVar2 = true;
            iVar6 = 0;
            do {
                if (Slot->SpellList[iVar6] != '\0') {
                    if (!bVar2) {
                        TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,",");
                    }
                    TWriteScriptFile::writeNumber((TWriteScriptFile *)&Buffer.Position,iVar6);
                    bVar2 = false;
                }
                iVar6 = iVar6 + 1;
            } while (iVar6 < 0x100);
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,"}");
            TWriteScriptFile::writeLn((TWriteScriptFile *)&Buffer.Position);
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,"QuestValues = {");
            bVar2 = true;
            iVar6 = 0;
            do {
                if (Slot->QuestValues[iVar6] != 0) {
                    if (!bVar2) {
                        TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,",");
                    }
                    TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,"(");
                    TWriteScriptFile::writeNumber((TWriteScriptFile *)&Buffer.Position,iVar6);
                    TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,",");
                    TWriteScriptFile::writeNumber
                              ((TWriteScriptFile *)&Buffer.Position,Slot->QuestValues[iVar6]);
                    TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,")");
                    bVar2 = false;
                }
                iVar6 = iVar6 + 1;
            } while (iVar6 < 500);
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,"}");
            TWriteScriptFile::writeLn((TWriteScriptFile *)&Buffer.Position);
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,"Murders     = {");
            bVar2 = true;
            iVar6 = 0;
            tVar4 = time((time_t *)0x0);
            do {
                Number = Slot->MurderTimestamps[iVar6];
                if (tVar4 + -0x278d00 < Number) {
                    if (!bVar2) {
                        TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,",");
                        Number = Slot->MurderTimestamps[iVar6];
                    }
                    TWriteScriptFile::writeNumber((TWriteScriptFile *)&Buffer.Position,Number);
                    bVar2 = false;
                }
                iVar6 = iVar6 + 1;
            } while (iVar6 < 0x14);
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,"}");
            TWriteScriptFile::writeLn((TWriteScriptFile *)&Buffer.Position);
            TWriteScriptFile::writeLn((TWriteScriptFile *)&Buffer.Position);
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,"Inventory   = {");
            if (Slot->Inventory != (uchar *)0x0) {
                TReadBuffer::TReadBuffer
                          ((TReadBuffer *)&local_203c,Slot->Inventory,Slot->InventorySize);
                bVar2 = true;
                while (bVar3 = TReadBuffer::readByte((TReadBuffer *)&local_203c), bVar3 != 0xff) {
                    if (bVar2) {
                        bVar2 = false;
                    }
                    else {
                        TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,",");
                        TWriteScriptFile::writeLn((TWriteScriptFile *)&Buffer.Position);
                        TWriteScriptFile::writeText
                                  ((TWriteScriptFile *)&Buffer.Position,"               ");
                    }
                    TWriteScriptFile::writeNumber((TWriteScriptFile *)&Buffer.Position,(uint)bVar3);
                    TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position," Content=");
                    SaveObjects((TReadStream *)&local_203c,(TWriteScriptFile *)&Buffer.Position);
                }
            }
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,"}");
            TWriteScriptFile::writeLn((TWriteScriptFile *)&Buffer.Position);
            TWriteScriptFile::writeLn((TWriteScriptFile *)&Buffer.Position);
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,"Depots      = {");
            bVar2 = true;
            iVar6 = 0;
            do {
                if (Slot->Depot[iVar6] != (uchar *)0x0) {
                    if (bVar2) {
                        bVar2 = false;
                    }
                    else {
                    // try { // try from 0806dd45 to 0806dd6d has its CatchHandler @ 0806de30
                        TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,", ");
                        TWriteScriptFile::writeLn((TWriteScriptFile *)&Buffer.Position);
                        TWriteScriptFile::writeText
                                  ((TWriteScriptFile *)&Buffer.Position,"               ");
                    }
                    TWriteScriptFile::writeNumber((TWriteScriptFile *)&Buffer.Position,iVar6);
                    TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position," Content=");
                    TReadBuffer::TReadBuffer
                              ((TReadBuffer *)&local_203c,Slot->Depot[iVar6],Slot->DepotSize[iVar6])
                    ;
                    SaveObjects((TReadStream *)&local_203c,(TWriteScriptFile *)&Buffer.Position);
                }
                iVar6 = iVar6 + 1;
            } while (iVar6 < 9);
            __fd = &DAT_080f2aa0;
            TWriteScriptFile::writeText((TWriteScriptFile *)&Buffer.Position,"}");
            TWriteScriptFile::writeLn((TWriteScriptFile *)&Buffer.Position);
            TWriteScriptFile::close((TWriteScriptFile *)&Buffer.Position,(int)__fd);
                    // try { // try from 0806dd2a to 0806dd2e has its CatchHandler @ 0806de36
            TWriteScriptFile::~TWriteScriptFile((TWriteScriptFile *)&Buffer.Position,(int)__fd);
            return;
        }
        pcVar7 = &DAT_080f6800;
    }
    error(pcVar7);
    return;
}



void UnlinkPlayerData(ulong CharacterID)

{
    char local_100c [4];
    char FileName [4096];
    
    sprintf(local_100c,"%s/%02ld/%ld.%s",USERPATH,CharacterID % 100,CharacterID,&DAT_080f6560);
    unlink(local_100c);
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__I__ZN7TOutfit4loadER15TReadScriptFile(void)

{
    __static_initialization_and_destruction_0(1,0xffff);
    return;
}



void __static_initialization_and_destruction_0(int __initialize_p,int __priority)

{
    if ((__priority == 0xffff) && (__initialize_p == 1)) {
        NONE.ObjectID = 0;
    }
    return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__I__Z7GetName6Object(void)

{
    __static_initialization_and_destruction_0(1,0xffff);
    return;
}

void RandomShuffle<int>(int *Buffer,int Size)

{
    int iVar1;
    long lVar2;
    int Exchange;
    int Help;
    int Position;
    int iVar3;
    
    if (Buffer == (int *)0x0) {
        error("RandomShuffle: Buffer ist NULL.\n");
        return;
    }
    iVar3 = 0;
    if (0 < Size + -1) {
        do {
            lVar2 = random();
            if (lVar2 != iVar3) {
                iVar1 = Buffer[iVar3];
                Buffer[iVar3] = Buffer[lVar2];
                Buffer[lVar2] = iVar1;
            }
            iVar3 = iVar3 + 1;
        } while (iVar3 < Size + -1);
    }
    return;
}



void __static_initialization_and_destruction_0(int __initialize_p,int __priority)

{
    TMoveUseDatabase *this;
    int local_14;
    
    if (__priority == 0xffff) {
        if (__initialize_p == 1) {
            NONE.ObjectID = 0;
            MoveUseConditions.initialized = false;
            MoveUseConditions.min = 1;
            MoveUseConditions.max = 1000;
            MoveUseConditions.start = 1;
            MoveUseConditions.space = 1000;
            MoveUseConditions.block = 1000;
            MoveUseConditions.entry = (TMoveUseCondition *)operator_new__(28000);
            __cxa_atexit(__tcf_0,0,&__dso_handle);
            MoveUseActions.initialized = false;
            MoveUseActions.min = 1;
            MoveUseActions.start = 1;
            MoveUseActions.max = 1000;
            MoveUseActions.space = 1000;
            MoveUseActions.block = 1000;
            MoveUseActions.entry = (TMoveUseAction *)operator_new__(24000);
            __cxa_atexit(__tcf_1,0,&__dso_handle);
            local_14 = 4;
            this = MoveUseDatabases;
            do {
                    // try { // try from 080722f5 to 080722f9 has its CatchHandler @ 08072413
                vector<>::vector(&this->Rules,1,100,100);
                this->NumberOfRules = 0;
                this = this + 1;
                local_14 = local_14 + -1;
            } while (local_14 != -1);
            __cxa_atexit(__tcf_2,0,&__dso_handle);
        }
        if (__initialize_p == 1) {
            DelayedMail.initialized = false;
            DelayedMail.max = 10;
            DelayedMail.min = 0;
            DelayedMail.start = 0;
            DelayedMail.space = 0xb;
            DelayedMail.block = 10;
            DelayedMail.entry = (TDelayedMail *)operator_new__(0xb0);
            __cxa_atexit(__tcf_3,0,&__dso_handle);
        }
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

Object GetEventObject(void)

{
    Object OVar1;
    ulong *in_stack_00000004;
    undefined4 in_stack_00000008;
    ulong *in_stack_0000000c;
    ulong *in_stack_00000010;
    ulong *in_stack_00000014;
    ulong *in_stack_00000018;
    
    switch(in_stack_00000008) {
    case 1:
        in_stack_00000018 = in_stack_00000010;
        break;
    case 2:
        in_stack_00000018 = in_stack_00000014;
        break;
    case 3:
        in_stack_00000018 = in_stack_0000000c;
        break;
    case 4:
        break;
    default:
        error("GetEventObject: Unbekannte Nummer %d.\n");
    case 0:
        OVar1.ObjectID = NONE.ObjectID;
        goto LAB_08072475;
    }
    OVar1.ObjectID = *in_stack_00000018;
LAB_08072475:
    *in_stack_00000004 = OVar1.ObjectID;
    return (Object)(ulong)in_stack_00000004;
}



bool Compare(int Value1,int Operator,int Value2)

{
    bool bVar1;
    
    switch(Operator) {
    case 0x3c:
        bVar1 = Value1 < Value2;
        break;
    case 0x3d:
        bVar1 = Value1 == Value2;
        break;
    case 0x3e:
        bVar1 = Value2 < Value1;
        break;
    default:
        error(&DAT_080f79e0,Operator);
        bVar1 = false;
        break;
    case 0x47:
        bVar1 = Value2 <= Value1;
        break;
    case 0x4c:
        bVar1 = Value1 <= Value2;
        break;
    case 0x4e:
        bVar1 = Value1 != Value2;
    }
    return bVar1;
}



bool CheckCondition(EventType param_1,TMoveUseCondition *Condition,Object *User,Object *Obj1,
                   Object *Obj2,Object *Temp)

{
    ModifierType MVar1;
    FLAG Flag;
    TYPEATTRIBUTE Attribute;
    byte bVar2;
    char cVar3;
    bool bVar4;
    ushort HouseID;
    TCreature *pTVar5;
    char *__s2;
    char *__s1;
    int iVar6;
    int iVar7;
    ObjectType *pOVar8;
    TPlayer *pTVar9;
    ulong uVar10;
    ulong uVar11;
    long lVar12;
    Object *pOVar13;
    undefined4 uVar14;
    ulong *puVar15;
    ulong *puVar16;
    ulong *puVar17;
    bool local_a7;
    bool local_a6;
    bool local_a5;
    int iStack_a4;
    bool fulfilled;
    int x2;
    int y2;
    int z2;
    int x1;
    int y1;
    int z1;
    Object local_7c [4];
    ObjectType local_6c [4];
    ulong local_5c [4];
    ulong local_4c [4];
    ulong local_3c [4];
    Object local_2c;
    Object Obj;
    
    local_a5 = false;
    local_2c.ObjectID = 0;
    switch(Condition->Condition) {
    case CONDITION_ISPOSITION:
        local_5c[0] = Temp->ObjectID;
        local_6c[0].TypeID = Obj2->ObjectID;
        local_7c[0] = (Object)Obj1->ObjectID;
        z1 = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_4c[0];
        local_3c[0] = local_4c[0];
        UnpackAbsoluteCoordinate();
        z1 = local_2c.ObjectID;
        GetObjectCoordinates((Object *)&z1,&stack0xffffff5c,&x2,&y2);
        local_a5 = false;
        if ((z2 == iStack_a4) && (x1 == x2)) {
            bVar4 = y1 == y2;
LAB_08072693:
            local_a5 = false;
            if (bVar4) {
LAB_08072695:
                local_a5 = true;
            }
        }
        break;
    case CONDITION_ISTYPE:
        local_6c[0].TypeID = Temp->ObjectID;
        local_5c[0] = Obj2->ObjectID;
        local_4c[0] = Obj1->ObjectID;
        local_3c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_7c[0].ObjectID;
        z1 = local_7c[0].ObjectID;
        Object::getObjectType((Object *)&z1);
        local_a5 = z1 == Condition->Parameters[1];
        break;
    case CONDITION_ISCREATURE:
        local_6c[0].TypeID = Temp->ObjectID;
        local_5c[0] = Obj2->ObjectID;
        local_4c[0] = Obj1->ObjectID;
        local_3c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_7c[0].ObjectID;
        z1 = local_7c[0].ObjectID;
        Object::getObjectType((Object *)&z1);
        local_a5 = z1 == 99;
        break;
    case CONDITION_ISPLAYER:
        local_6c[0].TypeID = Temp->ObjectID;
        local_5c[0] = Obj2->ObjectID;
        local_4c[0] = Obj1->ObjectID;
        local_3c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_7c[0].ObjectID;
        z1 = local_7c[0].ObjectID;
        Object::getObjectType((Object *)&z1);
        if (z1 == 99) {
            z1 = local_2c.ObjectID;
LAB_08072828:
            pTVar5 = GetCreature((Object *)&z1);
            local_a5 = false;
            if (pTVar5 != (TCreature *)0x0) {
                bVar4 = pTVar5->Type == PLAYER;
                goto LAB_08072693;
            }
        }
        break;
    case CONDITION_HASFLAG:
        local_6c[0].TypeID = Temp->ObjectID;
        local_5c[0] = Obj2->ObjectID;
        local_4c[0] = Obj1->ObjectID;
        local_3c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_7c[0].ObjectID;
        z1 = local_7c[0].ObjectID;
        Flag = Condition->Parameters[1];
        Object::getObjectType((Object *)&z1);
        local_a5 = ObjectType::getFlag((ObjectType *)&z1,Flag);
        break;
    case CONDITION_HASTYPEATTRIBUTE:
        local_6c[0].TypeID = Temp->ObjectID;
        puVar17 = local_4c;
        local_5c[0] = Obj2->ObjectID;
        puVar16 = local_3c;
        local_4c[0] = Obj1->ObjectID;
        local_3c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_7c[0].ObjectID;
        z1 = local_7c[0].ObjectID;
        Attribute = Condition->Parameters[1];
        Object::getObjectType((Object *)&z1);
        uVar11 = ObjectType::getAttribute((ObjectType *)&z1,Attribute);
        iVar7 = Condition->Parameters[2];
        uVar10 = Condition->Parameters[3];
        switch(iVar7) {
        case 0x3c:
switchD_0807323b_caseD_3c:
            local_a5 = (int)uVar11 < (int)uVar10;
            break;
        case 0x3d:
switchD_0807323b_caseD_3d:
            local_a5 = uVar11 == uVar10;
            break;
        case 0x3e:
switchD_0807323b_caseD_3e:
            local_a5 = (int)uVar10 < (int)uVar11;
            break;
        default:
switchD_0807323b_caseD_3f:
            error(&DAT_080f79e0,iVar7,puVar16,puVar17);
            local_a5 = false;
            break;
        case 0x47:
switchD_0807323b_caseD_47:
            local_a5 = (int)uVar10 <= (int)uVar11;
            break;
        case 0x4c:
switchD_0807323b_caseD_4c:
            local_a5 = (int)uVar11 <= (int)uVar10;
            break;
        case 0x4e:
switchD_0807323b_caseD_4e:
            local_a5 = uVar11 != uVar10;
        }
        break;
    case CONDITION_HASINSTANCEATTRIBUTE:
        local_6c[0].TypeID = Temp->ObjectID;
        puVar17 = local_4c;
        local_5c[0] = Obj2->ObjectID;
        puVar16 = local_3c;
        local_4c[0] = Obj1->ObjectID;
        local_3c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_7c[0].ObjectID;
        z1 = local_7c[0].ObjectID;
        uVar11 = Object::getAttribute(&local_2c,Condition->Parameters[1]);
        iVar7 = Condition->Parameters[2];
        uVar10 = Condition->Parameters[3];
        switch(iVar7) {
        case 0x3c:
            goto switchD_0807323b_caseD_3c;
        case 0x3d:
            goto switchD_0807323b_caseD_3d;
        case 0x3e:
            goto switchD_0807323b_caseD_3e;
        default:
            goto switchD_0807323b_caseD_3f;
        case 0x47:
            goto switchD_0807323b_caseD_47;
        case 0x4c:
            goto switchD_0807323b_caseD_4c;
        case 0x4e:
            goto switchD_0807323b_caseD_4e;
        }
    case CONDITION_HASTEXT:
        local_6c[0].TypeID = Temp->ObjectID;
        local_5c[0] = Obj2->ObjectID;
        local_4c[0] = Obj1->ObjectID;
        local_3c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_7c[0].ObjectID;
        z1 = local_7c[0].ObjectID;
        __s2 = GetDynamicString(Condition->Parameters[1]);
        uVar10 = Object::getAttribute(&local_2c,TEXTSTRING);
        __s1 = GetDynamicString(uVar10);
        iVar7 = strcmp(__s1,__s2);
        local_a5 = iVar7 == 0;
        break;
    case CONDITION_ISPEACEFUL:
        local_6c[0].TypeID = Temp->ObjectID;
        puVar17 = local_4c;
        pOVar8 = local_6c;
        local_5c[0] = Obj2->ObjectID;
        puVar16 = local_3c;
        local_4c[0] = Obj1->ObjectID;
        puVar15 = local_5c;
        local_3c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_7c[0].ObjectID;
        z1 = local_7c[0].ObjectID;
        pOVar13 = &local_2c;
        Object::getObjectType((Object *)&z1);
        if (z1 == 99) {
            z1 = local_2c.ObjectID;
            pTVar5 = GetCreature((Object *)&z1);
            local_a5 = false;
            if (pTVar5 != (TCreature *)0x0) {
                iVar7 = (*pTVar5->_vptr_TCreature[4])(pTVar5,pOVar13,puVar16,puVar17,puVar15,pOVar8)
                ;
                cVar3 = (char)iVar7;
LAB_08072b84:
                local_a5 = false;
                if (cVar3 != '\0') goto LAB_08072695;
            }
        }
        break;
    case CONDITION_MAYLOGOUT:
        local_6c[0].TypeID = Temp->ObjectID;
        local_5c[0] = Obj2->ObjectID;
        local_4c[0] = Obj1->ObjectID;
        local_3c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_7c[0].ObjectID;
        z1 = local_7c[0].ObjectID;
        Object::getObjectType((Object *)&z1);
        if (z1 == 99) {
            z1 = local_2c.ObjectID;
            pTVar5 = GetCreature((Object *)&z1);
            local_a5 = false;
            if ((pTVar5 != (TCreature *)0x0) && (pTVar5->Type == PLAYER)) {
                iVar7 = TCreature::LogoutPossible(pTVar5);
                bVar4 = iVar7 == 0;
                goto LAB_08072693;
            }
        }
        break;
    case CONDITION_HASPROFESSION:
        local_6c[0].TypeID = Temp->ObjectID;
        local_5c[0] = Obj2->ObjectID;
        local_4c[0] = Obj1->ObjectID;
        local_3c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_7c[0].ObjectID;
        z1 = local_7c[0].ObjectID;
        Object::getObjectType((Object *)&z1);
        if (z1 == 99) {
            z1 = local_2c.ObjectID;
            pTVar9 = (TPlayer *)GetCreature((Object *)&z1);
            local_a5 = false;
            if ((pTVar9 != (TPlayer *)0x0) && ((pTVar9->super_TCreature).Type == PLAYER)) {
                bVar2 = TPlayer::GetEffectiveProfession(pTVar9);
                bVar4 = (uint)bVar2 == Condition->Parameters[1];
                goto LAB_08072693;
            }
        }
        break;
    case CONDITION_HASLEVEL:
        local_6c[0].TypeID = Temp->ObjectID;
        puVar17 = local_4c;
        local_5c[0] = Obj2->ObjectID;
        puVar16 = local_3c;
        local_4c[0] = Obj1->ObjectID;
        puVar15 = local_5c;
        local_3c[0] = User->ObjectID;
        pOVar8 = local_6c;
        GetEventObject();
        local_2c.ObjectID = local_7c[0].ObjectID;
        z1 = local_7c[0].ObjectID;
        Object::getObjectType((Object *)&z1);
        if (z1 == 99) {
            z1 = local_2c.ObjectID;
            pTVar5 = GetCreature((Object *)&z1);
            local_a6 = false;
            if (pTVar5 != (TCreature *)0x0) {
                iVar6 = TSkill::Get((pTVar5->super_TSkillBase).Skills[0]);
                iVar7 = Condition->Parameters[2];
                switch(Condition->Parameters[1]) {
                case 0x3c:
                    bVar4 = iVar6 < iVar7;
                    break;
                case 0x3d:
                    bVar4 = iVar6 == iVar7;
                    break;
                case 0x3e:
                    bVar4 = iVar7 < iVar6;
                    break;
                default:
                    error(&DAT_080f79e0,Condition->Parameters[1],puVar16,puVar17,puVar15,pOVar8);
                    bVar4 = false;
                    break;
                case 0x47:
                    bVar4 = iVar7 <= iVar6;
                    break;
                case 0x4c:
                    bVar4 = iVar6 <= iVar7;
                    break;
                case 0x4e:
                    bVar4 = iVar6 != iVar7;
                }
                if (bVar4) {
                    local_a6 = true;
                }
            }
            local_a5 = local_a6;
        }
        break;
    case CONDITION_HASRIGHT:
        local_6c[0].TypeID = Temp->ObjectID;
        local_5c[0] = Obj2->ObjectID;
        local_4c[0] = Obj1->ObjectID;
        local_3c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_7c[0].ObjectID;
        z1 = local_7c[0].ObjectID;
        Object::getObjectType((Object *)&z1);
        if (z1 == 99) {
            z1 = local_2c.ObjectID;
            pTVar5 = GetCreature((Object *)&z1);
            local_a5 = false;
            if ((pTVar5 != (TCreature *)0x0) && (pTVar5->Type == PLAYER)) {
                cVar3 = CheckRight(pTVar5->ID,Condition->Parameters[1]);
                goto LAB_08072b84;
            }
        }
        break;
    case CONDITION_HASQUESTVALUE:
        local_6c[0].TypeID = Temp->ObjectID;
        puVar17 = local_4c;
        puVar16 = local_5c;
        local_5c[0] = Obj2->ObjectID;
        puVar15 = local_3c;
        local_4c[0] = Obj1->ObjectID;
        local_3c[0] = User->ObjectID;
        pOVar8 = local_6c;
        GetEventObject();
        local_2c.ObjectID = local_7c[0].ObjectID;
        z1 = local_7c[0].ObjectID;
        Object::getObjectType((Object *)&z1);
        if (z1 == 99) {
            z1 = local_2c.ObjectID;
            pTVar9 = (TPlayer *)GetCreature((Object *)&z1);
            local_a7 = false;
            if ((pTVar9 != (TPlayer *)0x0) && ((pTVar9->super_TCreature).Type == PLAYER)) {
                iVar6 = TPlayer::GetQuestValue(pTVar9,Condition->Parameters[1]);
                iVar7 = Condition->Parameters[3];
                switch(Condition->Parameters[2]) {
                case 0x3c:
                    bVar4 = iVar6 < iVar7;
                    break;
                case 0x3d:
                    bVar4 = iVar6 == iVar7;
                    break;
                case 0x3e:
                    bVar4 = iVar7 < iVar6;
                    break;
                default:
                    error(&DAT_080f79e0,Condition->Parameters[2],puVar15,puVar17,puVar16,pOVar8);
                    bVar4 = false;
                    break;
                case 0x47:
                    bVar4 = iVar7 <= iVar6;
                    break;
                case 0x4c:
                    bVar4 = iVar6 <= iVar7;
                    break;
                case 0x4e:
                    bVar4 = iVar6 != iVar7;
                }
                if (bVar4) {
                    local_a7 = true;
                }
            }
            local_a5 = local_a7;
        }
        break;
    case CONDITION_TESTSKILL:
        local_6c[0].TypeID = Temp->ObjectID;
        puVar17 = local_4c;
        pOVar8 = local_6c;
        puVar16 = local_5c;
        local_5c[0] = Obj2->ObjectID;
        puVar15 = local_3c;
        local_4c[0] = Obj1->ObjectID;
        local_3c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_7c[0].ObjectID;
        z1 = local_7c[0].ObjectID;
        Object::getObjectType((Object *)&z1);
        if (z1 == 99) {
            z1 = local_2c.ObjectID;
            pTVar5 = GetCreature((Object *)&z1);
            bVar4 = false;
            iVar7 = Condition->Parameters[1];
            if ((-1 < iVar7) && (iVar7 < 0x19)) {
                bVar4 = true;
            }
            if (bVar4) {
                local_a5 = false;
                if (pTVar5 != (TCreature *)0x0) {
                    iVar7 = (*(pTVar5->super_TSkillBase).Skills[iVar7]->_vptr_TSkill[9])
                                      ((pTVar5->super_TSkillBase).Skills[iVar7],
                                       Condition->Parameters[2],Condition->Parameters[3],1);
                    cVar3 = (char)iVar7;
                    goto LAB_08072b84;
                }
            }
            else {
                error(&DAT_080f7a20,iVar7,puVar15,puVar17,puVar16,pOVar8);
            }
        }
        break;
    case CONDITION_COUNTOBJECTS:
        local_6c[0].TypeID = Temp->ObjectID;
        puVar17 = local_4c;
        local_5c[0] = Obj2->ObjectID;
        puVar16 = local_3c;
        local_4c[0] = Obj1->ObjectID;
        local_3c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_7c[0].ObjectID;
        z1 = local_7c[0].ObjectID;
        GetMapContainer((Object *)&z1);
        uVar11 = CountObjectsInContainer((Object *)&z1);
        iVar7 = Condition->Parameters[1];
        uVar10 = Condition->Parameters[2];
        switch(iVar7) {
        case 0x3c:
            goto switchD_0807323b_caseD_3c;
        case 0x3d:
            goto switchD_0807323b_caseD_3d;
        case 0x3e:
            goto switchD_0807323b_caseD_3e;
        default:
            goto switchD_0807323b_caseD_3f;
        case 0x47:
            goto switchD_0807323b_caseD_47;
        case 0x4c:
            goto switchD_0807323b_caseD_4c;
        case 0x4e:
            goto switchD_0807323b_caseD_4e;
        }
    case CONDITION_COUNTOBJECTSONMAP:
        UnpackAbsoluteCoordinate();
        GetMapContainer((int)&z1,z2,x1);
        uVar11 = CountObjectsInContainer((Object *)&z1);
        iVar7 = Condition->Parameters[1];
        uVar10 = Condition->Parameters[2];
        puVar16 = (ulong *)x1;
        puVar17 = (ulong *)y1;
        switch(iVar7) {
        case 0x3c:
            goto switchD_0807323b_caseD_3c;
        case 0x3d:
            goto switchD_0807323b_caseD_3d;
        case 0x3e:
            goto switchD_0807323b_caseD_3e;
        default:
            goto switchD_0807323b_caseD_3f;
        case 0x47:
            goto switchD_0807323b_caseD_47;
        case 0x4c:
            goto switchD_0807323b_caseD_4c;
        case 0x4e:
            goto switchD_0807323b_caseD_4e;
        }
    case CONDITION_ISOBJECTTHERE:
        UnpackAbsoluteCoordinate();
        ObjectType::setTypeID(local_6c,Condition->Parameters[1]);
        goto LAB_080732ab;
    case CONDITION_ISCREATURETHERE:
        UnpackAbsoluteCoordinate();
        ObjectType::setTypeID(local_6c,99);
LAB_080732ab:
        GetFirstSpecObject();
LAB_080732b0:
        Temp->ObjectID = (ulong)local_7c[0];
        local_a5 = Temp->ObjectID != NONE.ObjectID;
        break;
    case CONDITION_ISPLAYERTHERE:
        UnpackAbsoluteCoordinate();
        ObjectType::setTypeID(local_6c,99);
        GetFirstSpecObject();
        Temp->ObjectID = (ulong)local_7c[0];
        z1 = Temp->ObjectID;
        if (z1 != NONE.ObjectID) goto LAB_08072828;
        break;
    case CONDITION_ISOBJECTININVENTORY:
        local_6c[0].TypeID = Temp->ObjectID;
        local_5c[0] = Obj2->ObjectID;
        local_4c[0] = Obj1->ObjectID;
        local_3c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_7c[0].ObjectID;
        z1 = local_7c[0].ObjectID;
        Object::getObjectType((Object *)&z1);
        if (z1 != 99) break;
        ObjectType::setTypeID(local_6c,Condition->Parameters[1]);
        pOVar8 = (ObjectType *)Object::getCreatureID(&local_2c);
        GetInventoryObject((ulong)local_7c,pOVar8,(ulong)local_6c);
        goto LAB_080732b0;
    case CONDITION_ISPROTECTIONZONE:
        local_6c[0].TypeID = Temp->ObjectID;
        local_5c[0] = Obj2->ObjectID;
        local_4c[0] = Obj1->ObjectID;
        local_3c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_7c[0].ObjectID;
        z1 = local_7c[0].ObjectID;
        GetObjectCoordinates((Object *)&z1,&z2,&x1,&y1);
        local_a5 = IsProtectionZone();
        break;
    case CONDITION_ISHOUSE:
        local_6c[0].TypeID = Temp->ObjectID;
        local_5c[0] = Obj2->ObjectID;
        local_4c[0] = Obj1->ObjectID;
        local_3c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_7c[0].ObjectID;
        z1 = local_7c[0].ObjectID;
        GetObjectCoordinates((Object *)&z1,&z2,&x1,&y1);
        local_a5 = IsHouse(z2,x1,y1);
        break;
    case CONDITION_ISHOUSEOWNER:
        local_6c[0].TypeID = Temp->ObjectID;
        local_5c[0] = Obj2->ObjectID;
        local_4c[0] = Obj1->ObjectID;
        local_3c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_7c[0].ObjectID;
        z1 = local_7c[0].ObjectID;
        GetObjectCoordinates((Object *)&z1,&z2,&x1,&y1);
        local_6c[0].TypeID = Temp->ObjectID;
        local_5c[0] = Obj2->ObjectID;
        local_4c[0] = Obj1->ObjectID;
        local_3c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_7c[0].ObjectID;
        z1 = local_7c[0].ObjectID;
        Object::getObjectType((Object *)&z1);
        if (z1 == 99) {
            z1 = local_2c.ObjectID;
            pTVar9 = (TPlayer *)GetCreature((Object *)&z1);
            local_a5 = false;
            if ((pTVar9 != (TPlayer *)0x0) && ((pTVar9->super_TCreature).Type == PLAYER)) {
                HouseID = GetHouseID(z2,x1,y1);
                cVar3 = IsOwner(HouseID,pTVar9);
                goto LAB_08072b84;
            }
        }
        break;
    case CONDITION_ISDRESSED:
        local_6c[0].TypeID = Temp->ObjectID;
        puVar17 = local_4c;
        local_5c[0] = Obj2->ObjectID;
        puVar16 = local_3c;
        local_4c[0] = Obj1->ObjectID;
        puVar15 = local_5c;
        local_3c[0] = User->ObjectID;
        pOVar8 = local_6c;
        GetEventObject();
        local_2c.ObjectID = local_7c[0].ObjectID;
        z1 = local_7c[0].ObjectID;
        Object::getObjectType((Object *)&z1);
        uVar14 = 0x2e;
        bVar4 = ObjectType::getFlag((ObjectType *)&z1,CLOTHES);
        if (bVar4) {
            z1 = local_2c.ObjectID;
            uVar10 = GetObjectBodyPosition((Object *)&z1);
            Object::getObjectType(local_7c);
            uVar11 = ObjectType::getAttribute((ObjectType *)local_7c,BODYPOSITION);
            local_a5 = uVar10 == uVar11;
        }
        else {
            error(&DAT_080f7a60,uVar14,puVar16,puVar17,puVar15,pOVar8);
        }
        break;
    case CONDITION_RANDOM:
        lVar12 = random();
        local_a5 = lVar12 <= Condition->Parameters[0];
        break;
    default:
        error("CheckCondition: Unbekannte Bedingung %d.\n",Condition->Condition);
        goto LAB_08072659;
    }
    MVar1 = Condition->Modifier;
    if (MVar1 == MODIFIER_INVERT) {
        local_a5 = (bool)(local_a5 ^ 1);
    }
    else {
        if ((int)MVar1 < 2) {
            if (MVar1 == MODIFIER_NORMAL) {
                return local_a5;
            }
        }
        else if (MVar1 == MODIFIER_TRUE) {
            return true;
        }
LAB_08072659:
        local_a5 = false;
    }
    return local_a5;
}



Object CreateObject(Object *Con,ObjectType *Type,ulong Value)

{
    bool bVar1;
    ObjectType *Type_00;
    RESULT r;
    int x;
    int y;
    int z;
    Object local_3c [4];
    Object local_2c [7];
    
                    // try { // try from 08073896 to 08073934 has its CatchHandler @ 08073937
    Object::getObjectType(local_2c);
    bVar1 = false;
    if ((0 < (int)local_2c[0].ObjectID) && ((int)local_2c[0].ObjectID < 0xb)) {
        bVar1 = true;
    }
    if (bVar1) {
        ObjectType::setTypeID((ObjectType *)local_2c,*(int *)Value);
        local_3c[0].ObjectID = Type->TypeID;
        Type_00 = (ObjectType *)GetObjectCreatureID(local_3c);
        CreateAtCreature((ulong)Con,Type_00,(ulong)local_2c);
    }
    else {
        ObjectType::setTypeID((ObjectType *)local_3c,*(int *)Value);
        local_2c[0].ObjectID = Type->TypeID;
        Create(Con,(ObjectType *)local_2c,(ulong)local_3c);
    }
    return (Object)(ulong)Con;
}



void ChangeObject(Object *Obj,ObjectType *NewType,ulong Value)

{
    bool bVar1;
    ulong uVar2;
    RESULT r;
    char *Text;
    int iVar3;
    Object local_5c [4];
    Object local_4c [4];
    Object local_3c [4];
    Object local_2c;
    Object Con;
    
                    // try { // try from 08073a18 to 08073a5c has its CatchHandler @ 08073ce0
    bVar1 = Object::exists(Obj);
    if (bVar1) {
        Object::getContainer(&local_2c);
        bVar1 = Object::exists(Obj);
        if (bVar1) {
                    // try { // try from 08073a6f to 08073b27 has its CatchHandler @ 08073b42
            Object::getObjectType(local_3c);
            bVar1 = ObjectType::getFlag((ObjectType *)local_3c,CUMULATIVE);
            if ((bVar1) && (uVar2 = Object::getAttribute(Obj,AMOUNT), 1 < uVar2)) {
                local_3c[0].ObjectID = NONE.ObjectID;
                uVar2 = Object::getAttribute(Obj,AMOUNT);
                local_4c[0].ObjectID = local_2c.ObjectID;
                local_5c[0] = (Object)Obj->ObjectID;
                Move(0,local_5c,local_4c,uVar2 - 1,true,local_3c);
            }
            ObjectType::setTypeID((ObjectType *)local_5c,NewType->TypeID);
            local_4c[0] = (Object)Obj->ObjectID;
            Change(local_4c,(ObjectType *)local_5c,Value);
            return;
        }
        iVar3 = NewType->TypeID;
        Text = &DAT_080f7ba0;
    }
    else {
        iVar3 = NewType->TypeID;
        Text = &DAT_080f7b40;
    }
    error(Text,iVar3);
    return;
}



void MoveOneObject(Object *Obj,Object *Con)

{
    bool bVar1;
    RESULT r;
    char *Text;
    int x;
    int y;
    int z;
    Object local_3c [4];
    Object local_2c [7];
    
    bVar1 = Object::exists(Obj);
    if (bVar1) {
        bVar1 = Object::exists(Con);
        if (bVar1) {
            Object::getObjectType(local_2c);
            bVar1 = ObjectType::getFlag((ObjectType *)local_2c,CONTAINER);
            if (bVar1) {
                Object::getObjectType(local_2c);
                if ((local_2c[0].ObjectID != 99) ||
                   (Object::getObjectType(local_2c), local_2c[0].ObjectID == 0)) {
                    // try { // try from 08073da1 to 08073e39 has its CatchHandler @ 08073e4c
                    Object::getObjectType(local_2c);
                    bVar1 = ObjectType::getFlag((ObjectType *)local_2c,LIQUIDPOOL);
                    if (!bVar1) {
                        Object::getObjectType(local_2c);
                        bVar1 = ObjectType::getFlag((ObjectType *)local_2c,MAGICFIELD);
                        if (!bVar1) {
                            local_2c[0].ObjectID = NONE.ObjectID;
                            local_3c[0] = (Object)Con->ObjectID;
                            z = Obj->ObjectID;
                            Move(0,(Object *)&z,local_3c,-1,true,local_2c);
                            return;
                        }
                    }
                    local_2c[0] = (Object)Obj->ObjectID;
                    Delete(local_2c,-1);
                    return;
                }
                Text = "MoveOneObject: \"Con\" ist kein MapContainer.\n";
                goto LAB_08073d18;
            }
        }
        Text = "MoveOneObject: \"Con\" ist kein Container.\n";
    }
    else {
        Text = &DAT_080f7c60;
    }
LAB_08073d18:
    error(Text);
    return;
}



void MoveAllObjects(Object *Obj,Object *Dest,Object *Exclude,bool MoveUnmovable)

{
    bool bVar1;
    Object *pOVar2;
    bool MoveUnmovable_local;
    int x;
    int y;
    int z;
    Object local_4c;
    ObjectType Type;
    Object local_3c [4];
    Object local_2c [7];
    
    local_2c[0].ObjectID = NONE.ObjectID;
    if (Obj->ObjectID != NONE.ObjectID) {
        pOVar2 = Dest;
        Object::getObjectType(local_2c);
        if (local_2c[0].ObjectID == 0) {
            local_2c[0] = (Object)Exclude->ObjectID;
            local_3c[0] = (Object)Dest->ObjectID;
            Object::getNextObject(&local_4c);
            MoveAllObjects(&local_4c,local_3c,local_2c,MoveUnmovable);
            local_4c = (Object)Exclude->ObjectID;
            if (Obj->ObjectID != local_4c.ObjectID) {
                Object::getObjectType(&local_4c);
                    // try { // try from 08073fb1 to 0807408e has its CatchHandler @ 08074094
                Object::getObjectType(local_3c);
                bVar1 = ObjectType::getFlag((ObjectType *)local_3c,LIQUIDPOOL);
                if (!bVar1) {
                    Object::getObjectType(local_3c);
                    bVar1 = ObjectType::getFlag((ObjectType *)local_3c,MAGICFIELD);
                    if (!bVar1) {
                        if (!MoveUnmovable) {
                            Object::getObjectType(local_3c);
                            bVar1 = ObjectType::getFlag((ObjectType *)local_3c,UNMOVE);
                            if (bVar1) {
                                return;
                            }
                        }
                        local_3c[0].ObjectID = NONE.ObjectID;
                        local_2c[0] = (Object)Dest->ObjectID;
                        z = Obj->ObjectID;
                        Move(0,(Object *)&z,local_2c,-1,true,local_3c);
                        return;
                    }
                }
                local_3c[0] = (Object)Obj->ObjectID;
                Delete(local_3c,-1);
            }
        }
        else {
            error("MoveAllObjects: \"Dest\" ist kein Mapcontainer.\n",pOVar2);
        }
    }
    return;
}



void DeleteAllObjects(Object *Obj,Object *Exclude,bool DeleteUnmovable)

{
    bool bVar1;
    RESULT r;
    int iStack_48;
    bool DeleteUnmovable_local;
    int x;
    int y;
    int z;
    Object local_2c [7];
    
    if (Obj->ObjectID != NONE.ObjectID) {
        local_2c[0] = (Object)Exclude->ObjectID;
        Object::getNextObject((Object *)&z);
        DeleteAllObjects((Object *)&z,local_2c,DeleteUnmovable);
        z = Exclude->ObjectID;
        if (Obj->ObjectID != z) {
            Object::getObjectType((Object *)&z);
            if (z == 99) {
                z = Obj->ObjectID;
                GetObjectCoordinates((Object *)&z,&stack0xffffffb8,&x,&y);
                error(&DAT_080f7e00,iStack_48,x,y);
            }
            else {
                if (!DeleteUnmovable) {
                    // try { // try from 080741bb to 08074244 has its CatchHandler @ 0807429b
                    Object::getObjectType((Object *)&z);
                    bVar1 = ObjectType::getFlag((ObjectType *)&z,UNMOVE);
                    if (bVar1) {
                        Object::getObjectType((Object *)&z);
                        bVar1 = ObjectType::getFlag((ObjectType *)&z,LIQUIDPOOL);
                        if (!bVar1) {
                            Object::getObjectType((Object *)&z);
                            bVar1 = ObjectType::getFlag((ObjectType *)&z,MAGICFIELD);
                            if (!bVar1) {
                                return;
                            }
                        }
                    }
                }
                z = Obj->ObjectID;
                Delete((Object *)&z,-1);
            }
        }
    }
    return;
}



void ClearField(Object *Obj,Object *Exclude)

{
    bool bVar1;
    bool bVar2;
    Object *this;
    Object *Exclude_00;
    int local_58;
    int x;
    int y;
    int z;
    Object local_3c [4];
    Object local_2c [7];
    
    bVar1 = Object::exists(Obj);
    if (!bVar1) {
        error("ClearField: Objekt existiert nicht.\n");
        return;
    }
    local_2c[0] = (Object)Obj->ObjectID;
    GetObjectCoordinates(local_2c,&local_58,&x,&y);
    bVar1 = false;
    bVar2 = CoordinateFlag();
    if (bVar2) {
        bVar1 = CoordinateFlag();
        bVar1 = !bVar1;
    }
    if (bVar1) {
        this = (Object *)&z;
        local_2c[0] = (Object)Exclude->ObjectID;
        GetMapContainer((int)local_3c,local_58 + 1,x);
        Object::getNextObject(this);
        Exclude_00 = local_2c;
        goto LAB_080743c6;
    }
    bVar1 = false;
    bVar2 = CoordinateFlag();
    if (bVar2) {
        bVar1 = CoordinateFlag();
        bVar1 = !bVar1;
    }
    if (bVar1) {
LAB_08074550:
        z = Exclude->ObjectID;
        x = x + 1;
LAB_0807449d:
        GetMapContainer((int)local_3c,local_58,x);
        Object::getNextObject(local_2c);
    }
    else {
        bVar1 = false;
        bVar2 = CoordinateFlag();
        if (bVar2) {
            bVar1 = CoordinateFlag();
            bVar1 = !bVar1;
        }
        if (bVar1) {
LAB_08074594:
            z = Exclude->ObjectID;
            local_58 = local_58 + -1;
            goto LAB_0807449d;
        }
        bVar1 = false;
        bVar2 = CoordinateFlag();
        if (bVar2) {
            bVar1 = CoordinateFlag();
            bVar1 = !bVar1;
        }
        if (bVar1) {
            z = Exclude->ObjectID;
            x = x + -1;
            goto LAB_0807449d;
        }
        bVar1 = JumpPossible(local_58 + 1,x,y,false);
        if (bVar1) {
            z = Exclude->ObjectID;
            local_58 = local_58 + 1;
            goto LAB_0807449d;
        }
        bVar1 = JumpPossible(local_58,x + 1,y,false);
        if (bVar1) goto LAB_08074550;
        bVar1 = JumpPossible(local_58 + -1,x,y,false);
        if (bVar1) goto LAB_08074594;
        bVar1 = JumpPossible(local_58,x + -1,y,false);
        if (!bVar1) {
            return;
        }
        z = Exclude->ObjectID;
        GetMapContainer((int)local_3c,local_58,x + -1);
        Object::getNextObject(local_2c);
    }
    Exclude_00 = (Object *)&z;
    this = local_2c;
LAB_080743c6:
    MoveAllObjects(this,local_3c,Exclude_00,true);
    return;
}



void LoadDepotBox(ulong CreatureID,int Nr,Object *Con)

{
    bool bVar1;
    TCreature *pTVar2;
    int iVar3;
    int iVar4;
    TCreature *cr;
    char *pcVar5;
    Object local_3c [4];
    Object local_2c [7];
    
                    // try { // try from 0807470b to 08074872 has its CatchHandler @ 08074890
    pTVar2 = GetCreature(CreatureID);
    if (pTVar2 == (TCreature *)0x0) {
        pcVar5 = "moveuse::LoadDepotBox: Kreatur nicht gefunden.\n";
    }
    else {
        bVar1 = Object::exists(Con);
        if (bVar1) {
            Object::getObjectType(local_2c);
            bVar1 = ObjectType::getFlag((ObjectType *)local_2c,CONTAINER);
            if (bVar1) {
                if (pTVar2->Type == PLAYER) {
                    local_2c[0] = (Object)Con->ObjectID;
                    LoadDepot((TPlayerData *)pTVar2[1].super_TSkillBase.TimerList[10],Nr,local_2c);
                    local_2c[0] = (Object)Con->ObjectID;
                    pTVar2[1].super_TSkillBase.TimerList[6] = (TSkill *)local_2c[0].ObjectID;
                    pTVar2[1].super_TSkillBase.TimerList[7] = (TSkill *)Nr;
                    local_3c[0] = (Object)Con->ObjectID;
                    iVar3 = CountObjects(local_3c);
                    iVar3 = iVar3 + -1;
                    bVar1 = CheckRight(pTVar2->ID,PREMIUM_ACCOUNT);
                    iVar4 = GetDepotSize(Nr,bVar1);
                    pTVar2[1].super_TSkillBase.TimerList[8] = (TSkill *)(iVar4 - iVar3);
                    print();
                    pcVar5 = "s";
                    if (iVar3 == 1) {
                        pcVar5 = "";
                    }
                    SendMessage(pTVar2->Connection,0x15,"Your depot contains %d item%s.",iVar3,
                                pcVar5);
                    if (-1 < (int)pTVar2[1].super_TSkillBase.TimerList[8]) {
                        return;
                    }
                    SendMessage(pTVar2->Connection,0x16,
                                "Your depot is full. Remove surplus items before storing new ones.",
                                iVar3,pcVar5);
                    return;
                }
                pcVar5 = "moveuse::LoadDepotBox: Kreatur ist kein Spieler.\n";
            }
            else {
                pcVar5 = &DAT_080f8020;
            }
        }
        else {
            pcVar5 = &DAT_080f7ee0;
        }
    }
    error(pcVar5);
    return;
}



void SaveDepotBox(ulong CreatureID,int Nr,Object *Con)

{
    bool bVar1;
    TCreature *pTVar2;
    int iVar3;
    TCreature *cr;
    char *Text;
    int Count;
    Object Obj;
    Object local_2c [7];
    
                    // try { // try from 080748cb to 08074a1a has its CatchHandler @ 08074a40
    pTVar2 = GetCreature(CreatureID);
    if (pTVar2 == (TCreature *)0x0) {
        Text = "moveuse::SaveDepotBox: Kreatur nicht gefunden.\n";
    }
    else {
        bVar1 = Object::exists(Con);
        if (bVar1) {
            Object::getObjectType(local_2c);
            bVar1 = ObjectType::getFlag((ObjectType *)local_2c,CONTAINER);
            if (bVar1) {
                if (pTVar2->Type == PLAYER) {
                    local_2c[0] = (Object)Con->ObjectID;
                    iVar3 = CountObjects(local_2c);
                    Log("game",&DAT_080f8120,Nr,pTVar2->Name,iVar3 + -1);
                    print();
                    local_2c[0] = (Object)Con->ObjectID;
                    SaveDepot((TPlayerData *)pTVar2[1].super_TSkillBase.TimerList[10],Nr,local_2c);
                    Count = NONE.ObjectID;
                    pTVar2[1].super_TSkillBase.TimerList[6] = (TSkill *)NONE.ObjectID;
                    while( true ) {
                        local_2c[0] = (Object)Con->ObjectID;
                        GetFirstContainerObject((Object *)&Count);
                        if (Count == NONE.ObjectID) break;
                        local_2c[0].ObjectID = Count;
                        Delete(local_2c,-1);
                    }
                    return;
                }
                Text = "moveuse::SaveDepotBox: Kreatur ist kein Spieler.\n";
            }
            else {
                Text = &DAT_080f81c0;
            }
        }
        else {
            Text = &DAT_080f80a0;
        }
    }
    error(Text);
    return;
}



void SendMail(Object *Obj)

{
    uint *Text_00;
    TPlayer *pTVar1;
    ulong uVar2;
    bool bVar3;
    RESULT r_1;
    ulong uVar4;
    char *pcVar5;
    int iVar6;
    TDelayedMail *pTVar7;
    uchar *__dest;
    char *Text;
    uint *puVar8;
    uint *puVar9;
    char cVar10;
    uint uVar11;
    uint uVar12;
    int pos;
    int iVar13;
    int pos2;
    int iVar14;
    int *this;
    bool PlayerOnline;
    int DepotNumber;
    TPlayer *local_280;
    TPlayer *Player;
    char Town [256];
    char Addressee [256];
    undefined1 local_6c [4];
    TDynamicWriteBuffer Buffer;
    Object Label;
    Object local_4c [4];
    Object local_3c [4];
    Object local_2c [7];
    
                    // try { // try from 08074a78 to 08074d69 has its CatchHandler @ 08075210
    bVar3 = Object::exists(Obj);
    if (bVar3) {
        bVar3 = false;
        Object::getObjectType(local_2c);
        GetSpecialObject((SPECIALMEANING)local_3c);
        ObjectType::setTypeID((ObjectType *)local_4c,local_3c[0].ObjectID);
        if (local_2c[0].ObjectID != local_4c[0].ObjectID) {
            Object::getObjectType(local_4c);
            GetSpecialObject((SPECIALMEANING)&Buffer.super_TWriteBuffer.Position);
            ObjectType::setTypeID((ObjectType *)local_6c,Buffer.super_TWriteBuffer.Position);
            if ((undefined1  [4])local_4c[0].ObjectID != local_6c) {
                bVar3 = true;
            }
        }
        if (!bVar3) {
            print();
            Object::getObjectType((Object *)local_6c);
            GetSpecialObject((SPECIALMEANING)&Buffer.super_TWriteBuffer.Position);
            this = (int *)Obj;
            if (local_6c != (undefined1  [4])Buffer.super_TWriteBuffer.Position) {
                local_4c[0] = (Object)Obj->ObjectID;
                GetFirstContainerObject((Object *)&Buffer.super_TWriteBuffer.Position);
                while( true ) {
                    bVar3 = false;
                    local_4c[0].ObjectID = NONE.ObjectID;
                    local_3c[0].ObjectID = NONE.ObjectID;
                    if (Buffer.super_TWriteBuffer.Position != NONE.ObjectID) {
                        Object::getObjectType(local_3c);
                        GetSpecialObject((SPECIALMEANING)local_2c);
                        ObjectType::setTypeID((ObjectType *)(Addressee + 0xfc),local_2c[0].ObjectID)
                        ;
                        if (local_3c[0].ObjectID != Addressee._252_4_) {
                            bVar3 = true;
                        }
                    }
                    if (!bVar3) break;
                    Object::getNextObject(local_4c);
                    Addressee._252_4_ = local_4c[0].ObjectID;
                    Buffer.super_TWriteBuffer.Position = Addressee._252_4_;
                }
                Addressee._252_4_ = NONE.ObjectID;
                if (Buffer.super_TWriteBuffer.Position == NONE.ObjectID) {
                    return;
                }
                this = &Buffer.super_TWriteBuffer.Position;
            }
            uVar4 = Object::getAttribute((Object *)this,TEXTSTRING);
            pcVar5 = GetDynamicString(uVar4);
            if (pcVar5 != (char *)0x0) {
                cVar10 = *pcVar5;
                iVar13 = 0;
                if ((cVar10 != '\n') && (cVar10 != '\0')) {
                    while( true ) {
                        Town[iVar13 + 0xfc] = cVar10;
                        iVar13 = iVar13 + 1;
                        cVar10 = pcVar5[iVar13];
                        if (cVar10 == '\n') break;
                        if ((cVar10 == '\0') || (0xff < iVar13)) break;
                    }
                }
                iVar14 = 0;
                Town[iVar13 + 0xfc] = '\0';
                if ((pcVar5[iVar13 + 1] != '\n') && (iVar6 = iVar13, pcVar5[iVar13 + 1] != '\0')) {
                    do {
                        Town[iVar14 + -4] = pcVar5[iVar6 + 1];
                        iVar14 = iVar14 + 1;
                        if ((pcVar5[iVar14 + iVar13 + 1] == '\n') ||
                           (pcVar5[iVar14 + iVar13 + 1] == '\0')) break;
                        iVar6 = iVar14 + iVar13;
                    } while (iVar14 < 0x100);
                }
                Town[iVar14 + -4] = '\0';
                Text_00 = (uint *)(Town + 0xfc);
                Trim((char *)Text_00);
                Trim((char *)&Player);
                puVar9 = Text_00;
                if (Town[0xfc] != '\0') {
                    do {
                        puVar8 = puVar9;
                        uVar11 = *puVar8 + 0xfefefeff & ~*puVar8;
                        uVar12 = uVar11 & 0x80808080;
                        puVar9 = puVar8 + 1;
                    } while (uVar12 == 0);
                    bVar3 = (uVar11 & 0x8080) == 0;
                    if (bVar3) {
                        uVar12 = uVar12 >> 0x10;
                    }
                    if (bVar3) {
                        puVar9 = (uint *)((int)puVar8 + 6);
                    }
                    if (((char *)((int)puVar9 +
                                 ((-3 - (uint)CARRY1((byte)uVar12,(byte)uVar12)) - (int)Text_00)) <
                         (char *)0x1e) && ((char)Player != '\0')) {
                        Log("game","Post an %s in %s.\n",Text_00,&Player);
                        iVar13 = GetDepotNumber((char *)&Player);
                        if (iVar13 != -1) {
                            iVar14 = IdentifyPlayer((char *)Text_00,true,true,&local_280);
                            bVar3 = iVar14 == 0;
                            if (bVar3) {
                                uVar4 = (local_280->super_TCreature).ID;
                            }
                            else {
                    // try { // try from 08075019 to 08075139 has its CatchHandler @ 08075210
                                uVar4 = GetCharacterID((char *)Text_00);
                                if (uVar4 == 0) {
                                    return;
                                }
                            }
                            uVar2 = Addressee._252_4_;
                            if ((bVar3) && (local_280->DepotNr == iVar13)) {
                                local_6c = (undefined1  [4])NONE.ObjectID;
                                Addressee[0xfc] = (undefined1)NONE.ObjectID;
                                Addressee[0xfd] = NONE.ObjectID._1_1_;
                                Addressee[0xfe] = NONE.ObjectID._2_1_;
                                Addressee[0xff] = NONE.ObjectID._3_1_;
                                uVar2 = (ulong)local_6c;
                                if ((local_280->Depot).ObjectID != NONE.ObjectID) {
                                    print();
                                    local_6c = (undefined1  [4])NONE.ObjectID;
                                    Buffer.super_TWriteBuffer.Position = (local_280->Depot).ObjectID
                                    ;
                                    local_4c[0] = (Object)Obj->ObjectID;
                    // try { // try from 08074ef3 to 08075003 has its CatchHandler @ 08075152
                                    Move(0,local_4c,(Object *)&Buffer.super_TWriteBuffer.Position,-1
                                         ,true,(Object *)local_6c);
                                    Object::getObjectType((Object *)local_6c);
                                    GetSpecialObject((SPECIALMEANING)
                                                     &Buffer.super_TWriteBuffer.Position);
                                    GetSpecialObject((SPECIALMEANING)
                                                     &Buffer.super_TWriteBuffer.Position);
                                    local_4c[0] = (Object)Obj->ObjectID;
                                    Change(local_4c,(ObjectType *)
                                                    &Buffer.super_TWriteBuffer.Position,0);
                                    Log("game","Post an %s in %s versandt.\n",Text_00,&Player);
                                    pTVar1 = local_280;
                                    local_6c = (undefined1  [4])Obj->ObjectID;
                                    iVar13 = CountObjects((Object *)local_6c);
                                    pTVar1->DepotSpace = pTVar1->DepotSpace - iVar13;
                                    iVar13 = local_280->DepotSpace;
                                    print();
                                    SendMessage((local_280->super_TCreature).Connection,0x16,
                                                "New mail has arrived.",iVar13);
                                    print();
                                    return;
                                }
                            }
                            Addressee._252_4_ = uVar2;
                            print();
                            Object::getObjectType((Object *)local_6c);
                            GetSpecialObject((SPECIALMEANING)&Buffer.super_TWriteBuffer.Position);
                            GetSpecialObject((SPECIALMEANING)&Buffer.super_TWriteBuffer.Position);
                            local_4c[0] = (Object)Obj->ObjectID;
                            Change(local_4c,(ObjectType *)&Buffer.super_TWriteBuffer.Position,0);
                    // try { // try from 08074d78 to 08074d7c has its CatchHandler @ 08075205
                            TDynamicWriteBuffer::TDynamicWriteBuffer
                                      ((TDynamicWriteBuffer *)local_6c,0x400);
                            Buffer.super_TWriteBuffer.Position = Obj->ObjectID;
                    // try { // try from 08074d97 to 08074de3 has its CatchHandler @ 080751b6
                            SaveObjects((Object *)&Buffer.super_TWriteBuffer.Position,
                                        (TWriteStream *)local_6c,true);
                            Buffer.super_TWriteBuffer.Position = Obj->ObjectID;
                            Delete((Object *)&Buffer.super_TWriteBuffer.Position,-1);
                            pTVar7 = vector<>::operator()(&DelayedMail,DelayedMails);
                            pTVar7->CharacterID = uVar4;
                            pTVar7->DepotNumber = iVar13;
                            pTVar7->PacketSize = Buffer.super_TWriteBuffer.Size;
                            __dest = (uchar *)operator_new__(Buffer.super_TWriteBuffer.Size);
                            pTVar7->Packet = __dest;
                            memcpy(__dest,Buffer.super_TWriteBuffer.super_TWriteStream.
                                          _vptr_TWriteStream,pTVar7->PacketSize);
                    // try { // try from 08074e03 to 08074e07 has its CatchHandler @ 08075205
                            TDynamicWriteBuffer::~TDynamicWriteBuffer
                                      ((TDynamicWriteBuffer *)local_6c,
                                       (int)Buffer.super_TWriteBuffer.super_TWriteStream.
                                            _vptr_TWriteStream);
                            DelayedMails = DelayedMails + 1;
                    // try { // try from 08074e2b to 08074eaa has its CatchHandler @ 08075210
                            Log("game",&DAT_080f82c0,Text_00,&Player);
                            print();
                            if (bVar3) {
                                SendMails(local_280->PlayerData);
                            }
                            else {
                                LoadCharacterOrder(uVar4);
                            }
                        }
                    }
                }
            }
        }
    }
    else {
        error(&DAT_080f8240);
    }
    return;
}



void SendMails(TPlayerData *PlayerData)

{
    __pid_t _Var1;
    TDelayedMail *pTVar2;
    uint uVar3;
    uchar *__dest;
    TDelayedMail *pTVar4;
    int iVar5;
    TDelayedMail *D;
    int i;
    int i_00;
    bool bVar6;
    char *Text;
    uchar *NewDepot;
    int NewDepotSize;
    ushort local_3c;
    bool DepotEmpty;
    undefined1 local_2c [4];
    TWriteBuffer Buffer;
    
    if (PlayerData == (TPlayerData *)0x0) {
        Text = "SendMails: PlayerData ist NULL.\n";
    }
    else if (PlayerData->CharacterID == 0) {
        Text = "SendMails: Slot ist nicht belegt.\n";
    }
    else {
        _Var1 = getpid();
        if (PlayerData->Locked == _Var1) {
            if (DelayedMails < 1) {
                return;
            }
            i_00 = 0;
            do {
                pTVar2 = vector<>::operator()(&DelayedMail,i_00);
                if (pTVar2->CharacterID == PlayerData->CharacterID) {
                    iVar5 = pTVar2->DepotNumber;
                    bVar6 = false;
                    if ((-1 < iVar5) && (iVar5 < 9)) {
                        bVar6 = true;
                    }
                    if (!bVar6) {
                        error(&DAT_080f84e0,iVar5);
                        iVar5 = 0;
                        pTVar2->DepotNumber = 0;
                    }
                    bVar6 = PlayerData->Depot[iVar5] != (uchar *)0x0;
                    if (bVar6) {
                        uVar3 = pTVar2->PacketSize + PlayerData->DepotSize[iVar5];
                    }
                    else {
                        uVar3 = pTVar2->PacketSize + 5;
                    }
                    __dest = (uchar *)operator_new__(uVar3);
                    memcpy(__dest,pTVar2->Packet,pTVar2->PacketSize);
                    if (pTVar2->Packet != (uchar *)0x0) {
                        operator_delete__(pTVar2->Packet);
                    }
                    if (bVar6) {
                        memcpy(__dest + pTVar2->PacketSize,PlayerData->Depot[pTVar2->DepotNumber],
                               PlayerData->DepotSize[pTVar2->DepotNumber]);
                        iVar5 = pTVar2->DepotNumber;
                        if (PlayerData->Depot[iVar5] != (uchar *)0x0) {
                            operator_delete__(PlayerData->Depot[iVar5]);
                            goto LAB_0807537c;
                        }
                    }
                    else {
                        TWriteBuffer::TWriteBuffer
                                  ((TWriteBuffer *)local_2c,__dest + pTVar2->PacketSize,5);
                        GetSpecialObject((SPECIALMEANING)&local_3c);
                        TWriteBuffer::writeWord((TWriteBuffer *)local_2c,local_3c);
                        TWriteBuffer::writeByte((TWriteBuffer *)local_2c,0xff);
                        TWriteBuffer::writeWord((TWriteBuffer *)local_2c,0xffff);
LAB_0807537c:
                        iVar5 = pTVar2->DepotNumber;
                    }
                    PlayerData->Depot[iVar5] = __dest;
                    iVar5 = pTVar2->DepotNumber;
                    PlayerData->Dirty = true;
                    PlayerData->DepotSize[iVar5] = uVar3;
                    Log("game","Post an %s zugestellt.\n",PlayerData->Name);
                    if (i_00 != DelayedMails + -1) {
                        pTVar2 = vector<>::operator()(&DelayedMail,i_00);
                        pTVar4 = vector<>::operator()(&DelayedMail,DelayedMails + -1);
                        pTVar2->CharacterID = pTVar4->CharacterID;
                        pTVar2->DepotNumber = pTVar4->DepotNumber;
                        pTVar2->Packet = pTVar4->Packet;
                        pTVar2->PacketSize = pTVar4->PacketSize;
                    }
                    DelayedMails = DelayedMails + -1;
                    i_00 = i_00 + -1;
                }
                i_00 = i_00 + 1;
                if (DelayedMails <= i_00) {
                    return;
                }
            } while( true );
        }
        Text = "SendMails: Slot ist nicht vom GameThread gesperrt.\n";
    }
    error(Text);
    return;
}



void TextEffect(char *Text,int x,int y,int z,int Radius)

{
    TConnection *this;
    ulong ID;
    ulong CharacterID;
    TPlayer *pTVar1;
    TConnection *Connection;
    int local_58;
    int destX;
    int destY;
    int destZ;
    TFindCreatures Search;
    
    if (Text == (char *)0x0) {
        error("TextEffect: Text existiert nicht.\n");
    }
    else {
        TFindCreatures::TFindCreatures((TFindCreatures *)&destZ,Radius,Radius,x,y,1);
        while( true ) {
            CharacterID = TFindCreatures::getNext((TFindCreatures *)&destZ);
            if (CharacterID == 0) break;
            pTVar1 = GetPlayer(CharacterID);
            if ((pTVar1 != (TPlayer *)0x0) &&
               (this = (pTVar1->super_TCreature).Connection, this != (TConnection *)0x0)) {
                TConnection::GetPosition(this,&local_58,&destX,&destY);
                if (((7 < Radius) || (z == destY)) &&
                   (((0x1e < Radius || (z == destY)) || ((z < 8 && (destY < 8)))))) {
                    SendTalk(this,0,"",0x10,x,y,z,Text);
                }
            }
        }
    }
    return;
}



void ExecuteAction(EventType Event,TMoveUseAction *Action,Object *User,Object *Obj1,Object *Obj2,
                  Object *Temp)

{
    bool bVar1;
    ulong uVar2;
    TPlayer *pTVar3;
    undefined4 *puVar4;
    char *__s;
    size_t sVar5;
    TCreature *pTVar6;
    ulong uVar7;
    int iVar8;
    uint *puVar9;
    uint *puVar10;
    RESULT r;
    uint uVar11;
    uint uVar12;
    TCreature *cr;
    bool bVar13;
    char *pcVar14;
    ActionType AVar15;
    Object *pOVar16;
    INSTANCEATTRIBUTE Attribute;
    ulong *puVar17;
    Object *pOVar18;
    Object *pOVar19;
    Object *pOVar20;
    int local_1c4;
    int pos;
    char *Text2;
    TCreature *cr2;
    int dx;
    int dy;
    int dz;
    int x;
    int y;
    int z;
    Object local_18c [4];
    Object local_17c [4];
    Object local_16c [4];
    Object local_15c [4];
    ulong local_14c [4];
    uint local_13c;
    char Text [256];
    Object Con;
    Object local_2c;
    Object Obj;
    
    Text[0xfc] = '\0';
    Text[0xfd] = '\0';
    Text[0xfe] = '\0';
    Text[0xff] = '\0';
    local_2c.ObjectID = 0;
    switch(Action->Action) {
    case ACTION_CREATEONMAP:
                    // try { // try from 08075619 to 08077e1c has its CatchHandler @ 08077e32
        UnpackAbsoluteCoordinate();
        ObjectType::setTypeID((ObjectType *)local_16c,Action->Parameters[1]);
        GetMapContainer((int)local_17c,dz,x);
        CreateObject(local_15c,(ObjectType *)local_17c,(ulong)local_16c);
        Temp->ObjectID = (ulong)local_15c[0];
        break;
    case ACTION_CREATE:
        local_15c[0] = (Object)Temp->ObjectID;
        local_14c[0] = Obj2->ObjectID;
        local_18c[0] = (Object)Obj1->ObjectID;
        z = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_16c[0].ObjectID;
        local_17c[0].ObjectID = local_16c[0].ObjectID;
        ObjectType::setTypeID((ObjectType *)local_17c,Action->Parameters[1]);
        Object::getContainer(local_16c);
        CreateObject(local_18c,(ObjectType *)local_16c,(ulong)local_17c);
        Temp->ObjectID = (ulong)local_18c[0];
        break;
    case ACTION_MONSTERONMAP:
        UnpackAbsoluteCoordinate();
        iVar8 = Action->Parameters[1];
        goto LAB_080757f5;
    case ACTION_MONSTER:
        local_17c[0] = (Object)Temp->ObjectID;
        local_16c[0] = (Object)Obj2->ObjectID;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = local_18c[0].ObjectID;
        GetObjectCoordinates((Object *)&z,&dz,&x,&y);
        iVar8 = Action->Parameters[1];
LAB_080757f5:
        CreateMonster(iVar8,dz,x,y,0,0,true);
        break;
    case ACTION_EFFECTONMAP:
        UnpackAbsoluteCoordinate();
        GetMapContainer((int)&z,dz,x);
        goto LAB_08075945;
    case ACTION_EFFECT:
        local_17c[0] = (Object)Temp->ObjectID;
        local_16c[0] = (Object)Obj2->ObjectID;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = local_18c[0].ObjectID;
        GetMapContainer((Object *)&z);
LAB_08075945:
        GraphicalEffect((Object *)&z,Action->Parameters[1]);
        break;
    case ACTION_TEXTONMAP:
        UnpackAbsoluteCoordinate();
        pcVar14 = GetDynamicString(Action->Parameters[1]);
        goto LAB_08075a34;
    case ACTION_TEXT:
        local_17c[0] = (Object)Temp->ObjectID;
        local_16c[0] = (Object)Obj2->ObjectID;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = local_18c[0].ObjectID;
        GetObjectCoordinates((Object *)&z,&dz,&x,&y);
        pcVar14 = GetDynamicString(Action->Parameters[1]);
LAB_08075a34:
        TextEffect(pcVar14,dz,x,y,Action->Parameters[2]);
        break;
    case ACTION_CHANGEONMAP:
        UnpackAbsoluteCoordinate();
        ObjectType::setTypeID((ObjectType *)local_17c,Action->Parameters[1]);
        GetFirstSpecObject();
        Temp->ObjectID = (ulong)local_18c[0];
        z = NONE.ObjectID;
        if (Temp->ObjectID == NONE.ObjectID) {
            iVar8 = Action->Parameters[1];
            pcVar14 = "ExecuteAction (CHANGEONMAP): Kein Objekt %d auf [%d,%d,%d].\n";
LAB_08075be0:
            NONE.ObjectID = z;
            error(pcVar14,iVar8,dz,x,y);
            return;
        }
        ObjectType::setTypeID((ObjectType *)&z,Action->Parameters[2]);
        local_18c[0] = (Object)Temp->ObjectID;
        uVar7 = Action->Parameters[3];
        goto LAB_08075c18;
    case ACTION_CHANGE:
        local_17c[0] = (Object)Temp->ObjectID;
        local_16c[0] = (Object)Obj2->ObjectID;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = local_18c[0].ObjectID;
        ObjectType::setTypeID((ObjectType *)&z,Action->Parameters[1]);
        local_18c[0].ObjectID = local_2c.ObjectID;
        uVar7 = Action->Parameters[2];
        goto LAB_08075c18;
    case ACTION_CHANGEREL:
        local_17c[0] = (Object)Temp->ObjectID;
        local_16c[0] = (Object)Obj2->ObjectID;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = local_18c[0].ObjectID;
        GetObjectCoordinates((Object *)&z,&dz,&x,&y);
        UnpackRelativeCoordinate();
        dz = (int)(cr2->super_TSkillBase).Skills + dz + -4;
        x = x + dx;
        y = y + dy;
        ObjectType::setTypeID((ObjectType *)local_17c,Action->Parameters[2]);
        GetFirstSpecObject();
        Temp->ObjectID = (ulong)local_18c[0];
        z = NONE.ObjectID;
        if (Temp->ObjectID == NONE.ObjectID) {
            iVar8 = Action->Parameters[2];
            pcVar14 = "ExecuteAction (CHANGEREL): Kein Objekt %d auf [%d,%d,%d].\n";
            goto LAB_08075be0;
        }
        ObjectType::setTypeID((ObjectType *)&z,Action->Parameters[3]);
        local_18c[0] = (Object)Temp->ObjectID;
        uVar7 = Action->Parameters[4];
LAB_08075c18:
        ChangeObject(local_18c,(ObjectType *)&z,uVar7);
        break;
    case ACTION_SETATTRIBUTE:
        local_17c[0] = (Object)Temp->ObjectID;
        local_16c[0] = (Object)Obj2->ObjectID;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_18c[0].ObjectID;
        uVar7 = Action->Parameters[2];
        Attribute = Action->Parameters[1];
        goto LAB_08075f26;
    case ACTION_CHANGEATTRIBUTE:
        local_17c[0] = (Object)Temp->ObjectID;
        local_16c[0] = (Object)Obj2->ObjectID;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = local_18c[0].ObjectID;
        uVar7 = Object::getAttribute(&local_2c,Action->Parameters[1]);
        uVar7 = uVar7 + Action->Parameters[2];
        if ((int)uVar7 < 1) {
            dz = uVar7;
            uVar7 = Object::getAttribute(&local_2c,Action->Parameters[1]);
            uVar7 = (ulong)(uVar7 != 0);
        }
        Attribute = Action->Parameters[1];
        dz = uVar7;
        goto LAB_08075f26;
    case ACTION_SETQUESTVALUE:
        pOVar18 = local_15c;
        local_17c[0] = (Object)Temp->ObjectID;
        pOVar19 = local_16c;
        local_16c[0] = (Object)Obj2->ObjectID;
        puVar17 = local_14c;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        pOVar20 = local_17c;
        GetEventObject();
        pOVar16 = &local_2c;
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = local_18c[0].ObjectID;
        Object::getObjectType((Object *)&z);
        if (z == 99) {
            z = local_2c.ObjectID;
            pTVar3 = (TPlayer *)GetCreature((Object *)&z);
            if ((pTVar3 != (TPlayer *)0x0) && ((pTVar3->super_TCreature).Type == PLAYER)) {
                TPlayer::SetQuestValue(pTVar3,Action->Parameters[1],Action->Parameters[2]);
                return;
            }
            pcVar14 = 
            "ExecuteAction (SETQUESTVALUE): Kreatur existiert nicht oder ist kein Spieler.\n";
LAB_08076102:
            error(pcVar14,pOVar16,puVar17,pOVar18,pOVar19,pOVar20);
            return;
        }
        Object::getObjectType((Object *)&z);
        pcVar14 = "ExecuteAction (SETQUESTVALUE): Objekt ist keine Kreatur, sondern Typ %ld.\n";
        AVar15 = z;
        goto switchD_080755eb_default;
    case ACTION_DAMAGE:
        local_17c[0] = (Object)Temp->ObjectID;
        local_16c[0] = (Object)Obj2->ObjectID;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        GetEventObject();
        Text2 = (char *)0x0;
        local_2c.ObjectID = local_18c[0].ObjectID;
        bVar13 = local_18c[0].ObjectID != NONE.ObjectID;
        z = NONE.ObjectID;
        local_18c[0].ObjectID = NONE.ObjectID;
        if (bVar13) {
            Object::getObjectType(local_18c);
            if (local_18c[0].ObjectID == 99) {
                local_18c[0].ObjectID = local_2c.ObjectID;
                Text2 = (char *)GetCreature(local_18c);
            }
            Object::getObjectType(local_18c);
            bVar13 = ObjectType::getFlag((ObjectType *)local_18c,MAGICFIELD);
            if ((bVar13) && (uVar7 = Object::getAttribute(&local_2c,RESPONSIBLE), uVar7 != 0)) {
                local_18c[0].ObjectID = local_2c.ObjectID;
                uVar7 = CronInfo(local_18c,false);
                Object::getObjectType(local_17c);
                uVar2 = ObjectType::getAttribute((ObjectType *)local_17c,TOTALEXPIRETIME);
                if (uVar2 < uVar7 + 5) {
                    uVar7 = Object::getAttribute(&local_2c,RESPONSIBLE);
                    Text2 = (char *)GetCreature(uVar7);
                }
            }
        }
        pOVar20 = local_17c;
        pOVar19 = local_16c;
        local_17c[0] = (Object)Temp->ObjectID;
        local_16c[0] = (Object)Obj2->ObjectID;
        puVar17 = local_14c;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        pOVar18 = local_15c;
        GetEventObject();
        pOVar16 = &local_2c;
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = local_18c[0].ObjectID;
        Object::getObjectType((Object *)&z);
        if (z == 99) {
            z = local_2c.ObjectID;
            pTVar6 = GetCreature((Object *)&z);
            if (pTVar6 != (TCreature *)0x0) {
                TCreature::Damage(pTVar6,(TCreature *)Text2,Action->Parameters[3],
                                  Action->Parameters[2]);
                return;
            }
            pcVar14 = "ExecuteAction (DAMAGE): Kreatur existiert nicht.\n";
            goto LAB_08076102;
        }
        Object::getObjectType((Object *)&z);
        pcVar14 = "ExecuteAction (DAMAGE): Objekt ist keine Kreatur, sondern Typ %d.\n";
        AVar15 = z;
        goto switchD_080755eb_default;
    case ACTION_SETSTART:
        pOVar20 = local_16c;
        local_17c[0] = (Object)Temp->ObjectID;
        puVar17 = local_14c;
        local_16c[0] = (Object)Obj2->ObjectID;
        pOVar16 = local_15c;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        pOVar19 = local_17c;
        GetEventObject();
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = local_18c[0].ObjectID;
        pcVar14 = (char *)&local_2c;
        Object::getObjectType((Object *)&z);
        uVar7 = Text._252_4_;
        if (z == 99) {
            z = local_2c.ObjectID;
            pTVar3 = (TPlayer *)GetCreature((Object *)&z);
            uVar7 = Text._252_4_;
            if ((pTVar3 != (TPlayer *)0x0) && ((pTVar3->super_TCreature).Type == PLAYER)) {
                Log("game",&DAT_080f8780,(pTVar3->super_TCreature).Name,pOVar16,pOVar20,pOVar19);
                UnpackAbsoluteCoordinate();
                TPlayer::SaveData(pTVar3);
                return;
            }
        }
        goto LAB_08076474;
    case ACTION_WRITENAME:
        local_17c[0] = (Object)Temp->ObjectID;
        pOVar20 = local_16c;
        local_16c[0] = (Object)Obj2->ObjectID;
        pOVar16 = local_15c;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        puVar17 = local_14c;
        GetEventObject();
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = local_18c[0].ObjectID;
        pcVar14 = (char *)&local_2c;
        Object::getObjectType((Object *)&z);
        uVar7 = Text._252_4_;
        if (z != 99) goto LAB_08076474;
        z = local_2c.ObjectID;
        pTVar6 = GetCreature((Object *)&z);
        uVar7 = Text._252_4_;
        if (pTVar6 == (TCreature *)0x0) goto LAB_08076474;
        puVar10 = &local_13c;
        for (iVar8 = 0x40; iVar8 != 0; iVar8 = iVar8 + -1) {
            *puVar10 = 0;
            puVar10 = puVar10 + 1;
        }
        __s = GetDynamicString(Action->Parameters[1]);
        for (local_1c4 = 0; sVar5 = strlen(__s), local_1c4 < (int)sVar5; local_1c4 = local_1c4 + 1)
        {
            if ((__s[local_1c4] == '%') && (__s[local_1c4 + 1] == 'N')) {
                pcVar14 = pTVar6->Name;
                local_1c4 = local_1c4 + 1;
                strcat((char *)&local_13c,pcVar14);
            }
            else {
                puVar10 = &local_13c;
                do {
                    puVar9 = puVar10;
                    uVar11 = *puVar9 + 0xfefefeff & ~*puVar9;
                    uVar12 = uVar11 & 0x80808080;
                    puVar10 = puVar9 + 1;
                } while (uVar12 == 0);
                bVar13 = (uVar11 & 0x8080) == 0;
                if (bVar13) {
                    uVar12 = uVar12 >> 0x10;
                }
                if (bVar13) {
                    puVar10 = (uint *)((int)puVar9 + 6);
                }
                *(char *)((int)puVar10 + (-3 - (uint)CARRY1((byte)uVar12,(byte)uVar12))) =
                     __s[local_1c4];
            }
            uVar7 = Text._252_4_;
            if (Text[0xc4] != '\0') goto LAB_08076474;
        }
        pOVar20 = local_16c;
        local_17c[0] = (Object)Temp->ObjectID;
        puVar17 = local_14c;
        local_16c[0] = (Object)Obj2->ObjectID;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        pOVar16 = local_15c;
        pcVar14 = (char *)Action->Parameters[2];
        GetEventObject();
        bVar13 = false;
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = NONE.ObjectID;
        if (local_18c[0].ObjectID == NONE.ObjectID) {
LAB_08076725:
            bVar13 = true;
        }
        else {
            Object::getObjectType(local_18c);
            pcVar14 = (char *)0x18;
            bVar1 = ObjectType::getFlag((ObjectType *)local_18c,TEXT);
            if (!bVar1) goto LAB_08076725;
        }
        uVar7 = Text._252_4_;
        if (bVar13) goto LAB_08076474;
        uVar7 = Object::getAttribute(&local_2c,TEXTSTRING);
        DeleteDynamicString(uVar7);
        z = local_2c.ObjectID;
        uVar7 = AddDynamicString((char *)&local_13c);
        Change((Object *)&z,TEXTSTRING,uVar7);
        uVar7 = 0;
        Attribute = EDITOR;
        goto LAB_08075f26;
    case ACTION_WRITETEXT:
        pOVar20 = local_16c;
        local_17c[0] = (Object)Temp->ObjectID;
        pOVar16 = local_15c;
        local_16c[0] = (Object)Obj2->ObjectID;
        puVar17 = local_14c;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        pcVar14 = (char *)Action->Parameters[1];
        GetEventObject();
        bVar13 = false;
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = NONE.ObjectID;
        if (local_18c[0].ObjectID == NONE.ObjectID) {
LAB_08076857:
            bVar13 = true;
        }
        else {
            Object::getObjectType(local_18c);
            pcVar14 = (char *)0x18;
            bVar1 = ObjectType::getFlag((ObjectType *)local_18c,TEXT);
            if (!bVar1) goto LAB_08076857;
        }
        uVar7 = Text._252_4_;
        if (bVar13) goto LAB_08076474;
        uVar7 = Object::getAttribute(&local_2c,TEXTSTRING);
        DeleteDynamicString(uVar7);
        z = local_2c.ObjectID;
        pcVar14 = GetDynamicString(Action->Parameters[0]);
        uVar7 = AddDynamicString(pcVar14);
        Change((Object *)&z,TEXTSTRING,uVar7);
        uVar7 = 0;
        Attribute = EDITOR;
LAB_08075f26:
        z = local_2c.ObjectID;
        Change((Object *)&z,Attribute,uVar7);
        break;
    case ACTION_LOGOUT:
        pOVar20 = local_16c;
        local_17c[0] = (Object)Temp->ObjectID;
        puVar17 = local_14c;
        local_16c[0] = (Object)Obj2->ObjectID;
        pOVar16 = local_15c;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = local_18c[0].ObjectID;
        pcVar14 = (char *)&local_2c;
        Object::getObjectType((Object *)&z);
        uVar7 = Text._252_4_;
        if (z == 99) {
            z = local_2c.ObjectID;
            pTVar6 = GetCreature((Object *)&z);
            uVar7 = Text._252_4_;
            if (pTVar6 != (TCreature *)0x0) {
                TCreature::StartLogout(pTVar6,true,true);
                return;
            }
        }
        goto LAB_08076474;
    case ACTION_MOVEALLONMAP:
        UnpackAbsoluteCoordinate();
        GetFirstObject();
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = local_18c[0].ObjectID;
        UnpackAbsoluteCoordinate();
        GetMapContainer((int)local_18c,dz,x);
        bVar13 = false;
        z = NONE.ObjectID;
        Text[0xfc] = (undefined1)local_18c[0].ObjectID;
        Text[0xfd] = local_18c[0].ObjectID._1_1_;
        Text[0xfe] = local_18c[0].ObjectID._2_1_;
        Text[0xff] = local_18c[0].ObjectID._3_1_;
        local_17c[0].ObjectID = local_2c.ObjectID;
        goto LAB_08076acf;
    case ACTION_MOVEALL:
        local_17c[0] = (Object)Temp->ObjectID;
        local_16c[0] = (Object)Obj2->ObjectID;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = local_18c[0].ObjectID;
        Object::getContainer(local_17c);
        GetFirstContainerObject(local_18c);
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = local_18c[0].ObjectID;
        UnpackAbsoluteCoordinate();
        goto LAB_08076bd6;
    case ACTION_MOVEALLREL:
        local_17c[0] = (Object)Temp->ObjectID;
        local_16c[0] = (Object)Obj2->ObjectID;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = local_18c[0].ObjectID;
        Object::getContainer(local_17c);
        GetFirstContainerObject(local_18c);
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = local_18c[0].ObjectID;
        GetObjectCoordinates((Object *)&z,&dz,&x,&y);
        UnpackRelativeCoordinate();
        x = dx + x;
        dz = (int)(cr2->super_TSkillBase).Skills + dz + -4;
LAB_08076bd6:
        GetMapContainer((int)local_18c,dz,x);
        bVar13 = false;
        Text[0xfc] = (undefined1)local_18c[0].ObjectID;
        Text[0xfd] = local_18c[0].ObjectID._1_1_;
        Text[0xfe] = local_18c[0].ObjectID._2_1_;
        Text[0xff] = local_18c[0].ObjectID._3_1_;
        z = local_2c.ObjectID;
        local_17c[0].ObjectID = local_2c.ObjectID;
        goto LAB_08076acf;
    case ACTION_MOVETOPONMAP:
        UnpackAbsoluteCoordinate();
        ObjectType::setTypeID((ObjectType *)local_17c,Action->Parameters[1]);
        GetFirstSpecObject();
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = NONE.ObjectID;
        if (local_18c[0].ObjectID == NONE.ObjectID) {
            iVar8 = Action->Parameters[1];
            pcVar14 = "ExecuteAction (MOVETOPONMAP): Kein Objekt %d auf [%d,%d,%d].\n";
            goto LAB_08075be0;
        }
        UnpackAbsoluteCoordinate();
        GetMapContainer((int)local_18c,dz,x);
        z = NONE.ObjectID;
        Text[0xfc] = (undefined1)local_18c[0].ObjectID;
        Text[0xfd] = local_18c[0].ObjectID._1_1_;
        Text[0xfe] = local_18c[0].ObjectID._2_1_;
        Text[0xff] = local_18c[0].ObjectID._3_1_;
        Object::getNextObject(local_17c);
        bVar13 = true;
        goto LAB_08076acf;
    case ACTION_MOVETOP:
        local_17c[0] = (Object)Temp->ObjectID;
        local_16c[0] = (Object)Obj2->ObjectID;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = local_18c[0].ObjectID;
        UnpackAbsoluteCoordinate();
        goto LAB_08076f87;
    case ACTION_MOVETOPREL:
        local_17c[0] = (Object)Temp->ObjectID;
        local_16c[0] = (Object)Obj2->ObjectID;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = local_18c[0].ObjectID;
        GetObjectCoordinates((Object *)&z,&dz,&x,&y);
        UnpackRelativeCoordinate();
        x = dx + x;
        dz = (int)(cr2->super_TSkillBase).Skills + dz + -4;
LAB_08076f87:
        GetMapContainer((int)local_18c,dz,x);
        z = NONE.ObjectID;
        Text[0xfc] = (undefined1)local_18c[0].ObjectID;
        Text[0xfd] = local_18c[0].ObjectID._1_1_;
        Text[0xfe] = local_18c[0].ObjectID._2_1_;
        Text[0xff] = local_18c[0].ObjectID._3_1_;
        Object::getNextObject(local_17c);
        bVar13 = true;
LAB_08076acf:
        MoveAllObjects(local_17c,local_18c,(Object *)&z,bVar13);
        break;
    case ACTION_MOVE:
        local_17c[0] = (Object)Temp->ObjectID;
        local_16c[0] = (Object)Obj2->ObjectID;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = local_18c[0].ObjectID;
        UnpackAbsoluteCoordinate();
        GetMapContainer((int)local_18c,dz,x);
        Text[0xfc] = (undefined1)local_18c[0].ObjectID;
        Text[0xfd] = local_18c[0].ObjectID._1_1_;
        Text[0xfe] = local_18c[0].ObjectID._2_1_;
        Text[0xff] = local_18c[0].ObjectID._3_1_;
        goto LAB_080771eb;
    case ACTION_MOVEREL:
        local_17c[0] = (Object)Temp->ObjectID;
        local_16c[0] = (Object)Obj2->ObjectID;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = local_18c[0].ObjectID;
        local_18c[0] = (Object)Temp->ObjectID;
        local_17c[0] = (Object)Obj2->ObjectID;
        local_16c[0] = (Object)Obj1->ObjectID;
        local_15c[0] = (Object)User->ObjectID;
        GetEventObject();
        GetObjectCoordinates((Object *)&z,&dz,&x,&y);
        UnpackRelativeCoordinate();
        GetMapContainer((int)local_18c,(int)(cr2->super_TSkillBase).Skills + dz + -4,dx + x);
        Text[0xfc] = (undefined1)local_18c[0].ObjectID;
        Text[0xfd] = local_18c[0].ObjectID._1_1_;
        Text[0xfe] = local_18c[0].ObjectID._2_1_;
        Text[0xff] = local_18c[0].ObjectID._3_1_;
        goto LAB_080771eb;
    case ACTION_RETRIEVE:
        local_18c[0] = (Object)Temp->ObjectID;
        local_17c[0] = (Object)Obj2->ObjectID;
        local_16c[0] = (Object)Obj1->ObjectID;
        local_15c[0] = (Object)User->ObjectID;
        GetEventObject();
        GetObjectCoordinates((Object *)&z,&dz,&x,&y);
        UnpackRelativeCoordinate();
        GetTopObject((int)local_18c,(int)(cr2->super_TSkillBase).Skills + dz + -4,dx + x,
                     (bool)((char)dy + (char)y));
        bVar13 = false;
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = NONE.ObjectID;
        if (local_18c[0].ObjectID == NONE.ObjectID) {
LAB_080774d6:
            bVar13 = true;
        }
        else {
            Object::getObjectType(local_18c);
            bVar1 = ObjectType::getFlag((ObjectType *)local_18c,UNMOVE);
            if (bVar1) goto LAB_080774d6;
        }
        if (bVar13) {
            return;
        }
        UnpackRelativeCoordinate();
        GetMapContainer((int)local_18c,(int)(cr2->super_TSkillBase).Skills + dz + -4,dx + x);
        Text._252_4_ = local_18c[0].ObjectID;
LAB_080771eb:
        z = Text._252_4_;
        local_18c[0].ObjectID = local_2c.ObjectID;
        MoveOneObject(local_18c,(Object *)&z);
        break;
    case ACTION_DELETEALLONMAP:
        UnpackAbsoluteCoordinate();
        GetFirstObject();
        bVar13 = false;
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = local_18c[0].ObjectID;
        goto LAB_0807762f;
    case ACTION_DELETETOPONMAP:
        UnpackAbsoluteCoordinate();
        pOVar20 = local_17c;
        ObjectType::setTypeID((ObjectType *)pOVar20,Action->Parameters[1]);
        GetFirstSpecObject();
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = NONE.ObjectID;
        pcVar14 = (char *)dz;
        puVar17 = (ulong *)x;
        pOVar16 = (Object *)y;
        uVar7 = Text._252_4_;
        if (local_18c[0].ObjectID == NONE.ObjectID) goto LAB_08076474;
        z = local_18c[0].ObjectID;
        Object::getNextObject(local_18c);
        bVar13 = true;
LAB_0807762f:
        DeleteAllObjects(local_18c,(Object *)&z,bVar13);
        break;
    case ACTION_DELETEONMAP:
        UnpackAbsoluteCoordinate();
        ObjectType::setTypeID((ObjectType *)local_17c,Action->Parameters[1]);
        GetFirstSpecObject();
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = NONE.ObjectID;
        if (local_18c[0].ObjectID == NONE.ObjectID) {
            iVar8 = Action->Parameters[1];
            pcVar14 = "ExecuteAction (DELETEONMAP): Kein Objekt %d auf [%d,%d,%d].\n";
            goto LAB_08075be0;
        }
        goto LAB_080777c6;
    case ACTION_DELETE:
        pOVar16 = local_15c;
        local_17c[0] = (Object)Temp->ObjectID;
        pOVar20 = local_16c;
        local_16c[0] = (Object)Obj2->ObjectID;
        puVar17 = local_14c;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        pcVar14 = (char *)Action->Parameters[0];
        GetEventObject();
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = NONE.ObjectID;
        uVar7 = Text._252_4_;
        if (local_18c[0].ObjectID == NONE.ObjectID) goto LAB_08076474;
LAB_080777c6:
        Delete((Object *)&z,(-(uint)(Event < EVENT_MOVEMENT) & 2) - 1);
        break;
    case ACTION_DELETEININVENTORY:
        pOVar20 = local_16c;
        local_17c[0] = (Object)Temp->ObjectID;
        puVar17 = local_14c;
        local_16c[0] = (Object)Obj2->ObjectID;
        pOVar16 = local_15c;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = local_18c[0].ObjectID;
        pcVar14 = (char *)&local_2c;
        Object::getObjectType((Object *)&z);
        uVar7 = Text._252_4_;
        if (z != 99) goto LAB_08076474;
        ObjectType::setTypeID((ObjectType *)&z,Action->Parameters[1]);
        uVar7 = Object::getCreatureID(&local_2c);
        DeleteAtCreature(uVar7,(ObjectType *)&z,1,Action->Parameters[2]);
        break;
    case ACTION_DESCRIPTION:
        local_17c[0] = (Object)Temp->ObjectID;
        local_16c[0] = (Object)Obj2->ObjectID;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = local_18c[0].ObjectID;
        Object::getObjectType((Object *)&z);
        if (z == 99) {
            z = local_2c.ObjectID;
            pTVar6 = GetCreature((Object *)&z);
            if ((pTVar6 != (TCreature *)0x0) && (pTVar6->Type == PLAYER)) {
                local_17c[0] = (Object)Temp->ObjectID;
                pOVar16 = local_16c;
                local_16c[0] = (Object)Obj2->ObjectID;
                local_15c[0] = (Object)Obj1->ObjectID;
                pOVar20 = local_17c;
                local_14c[0] = User->ObjectID;
                GetEventObject();
                local_2c.ObjectID = local_18c[0].ObjectID;
                z = local_18c[0].ObjectID;
                pcVar14 = GetInfo((Object *)&z);
                SendMessage(pTVar6->Connection,0x16,"%s.",pcVar14,pOVar16,pOVar20);
            }
        }
        break;
    case ACTION_LOADDEPOT:
        pOVar16 = local_15c;
        local_17c[0] = (Object)Temp->ObjectID;
        pOVar20 = local_16c;
        local_16c[0] = (Object)Obj2->ObjectID;
        puVar17 = local_14c;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        GetEventObject();
        pcVar14 = (char *)&local_2c;
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = local_18c[0].ObjectID;
        Object::getObjectType((Object *)&z);
        uVar7 = Text._252_4_;
        if (z == 99) {
            UnpackAbsoluteCoordinate();
            ObjectType::setTypeID((ObjectType *)local_17c,Action->Parameters[1]);
            pOVar20 = local_17c;
            GetFirstSpecObject();
            Text[0xfc] = (undefined1)local_18c[0].ObjectID;
            Text[0xfd] = local_18c[0].ObjectID._1_1_;
            Text[0xfe] = local_18c[0].ObjectID._2_1_;
            Text[0xff] = local_18c[0].ObjectID._3_1_;
            z = NONE.ObjectID;
            pcVar14 = (char *)dz;
            puVar17 = (ulong *)x;
            pOVar16 = (Object *)y;
            uVar7 = Text._252_4_;
            if (local_18c[0].ObjectID != NONE.ObjectID) {
                z = local_18c[0].ObjectID;
                uVar7 = Object::getCreatureID(&local_2c);
                LoadDepotBox(uVar7,Action->Parameters[3],(Object *)&z);
                return;
            }
        }
        goto LAB_08076474;
    case ACTION_SAVEDEPOT:
        pOVar16 = local_15c;
        local_17c[0] = (Object)Temp->ObjectID;
        pOVar20 = local_16c;
        local_16c[0] = (Object)Obj2->ObjectID;
        puVar17 = local_14c;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = local_18c[0].ObjectID;
        pcVar14 = (char *)&local_2c;
        Object::getObjectType((Object *)&z);
        uVar7 = Text._252_4_;
        if (z == 99) {
            UnpackAbsoluteCoordinate();
            ObjectType::setTypeID((ObjectType *)local_17c,Action->Parameters[1]);
            pOVar20 = local_17c;
            GetFirstSpecObject();
            z = NONE.ObjectID;
            Text[0xfc] = (undefined1)local_18c[0].ObjectID;
            Text[0xfd] = local_18c[0].ObjectID._1_1_;
            Text[0xfe] = local_18c[0].ObjectID._2_1_;
            Text[0xff] = local_18c[0].ObjectID._3_1_;
            pcVar14 = (char *)dz;
            puVar17 = (ulong *)x;
            pOVar16 = (Object *)y;
            uVar7 = local_18c[0].ObjectID;
            if (local_18c[0].ObjectID != NONE.ObjectID) {
                z = local_18c[0].ObjectID;
                uVar7 = Object::getCreatureID(&local_2c);
                SaveDepotBox(uVar7,Action->Parameters[3],(Object *)&z);
                return;
            }
        }
LAB_08076474:
        Text._252_4_ = uVar7;
        puVar4 = (undefined4 *)__cxa_allocate_exception(4,pcVar14,puVar17,pOVar16,pOVar20);
        *puVar4 = 0xffffffff;
                    // WARNING: Subroutine does not return
        __cxa_throw(puVar4,&RESULT::typeinfo,0);
    case ACTION_SENDMAIL:
        local_17c[0] = (Object)Temp->ObjectID;
        local_16c[0] = (Object)Obj2->ObjectID;
        local_15c[0] = (Object)Obj1->ObjectID;
        local_14c[0] = User->ObjectID;
        GetEventObject();
        local_2c.ObjectID = local_18c[0].ObjectID;
        z = local_18c[0].ObjectID;
        SendMail((Object *)&z);
        break;
    case ACTION_NOP:
        break;
    default:
        pcVar14 = "ExecuteAction: Unbekannte Aktion %d.\n";
        AVar15 = Action->Action;
switchD_080755eb_default:
        error(pcVar14,AVar15);
    }
    return;
}



bool HandleEvent(EventType Event,Object *User,Object *Obj1,Object *Obj2)

{
    bool bVar1;
    bool bVar2;
    TMoveUseCondition *Condition;
    TMoveUseRule *pTVar3;
    TMoveUseCondition *Condition_00;
    TMoveUseAction *Action;
    int condition;
    int iVar4;
    int iVar5;
    TMoveUseRule *Rule;
    TMoveUseDatabase *DB;
    int iStack_60;
    bool fulfilled;
    int rule;
    Object local_4c [4];
    Object local_3c [4];
    Object local_2c;
    Object Temp;
    
    if (HandleEvent::RecursionDepth < 0xb) {
        iStack_60 = 1;
        HandleEvent::RecursionDepth = HandleEvent::RecursionDepth + 1;
        if (0 < MoveUseDatabases[Event].NumberOfRules) {
            do {
                pTVar3 = vector<>::operator()(&MoveUseDatabases[Event].Rules,iStack_60);
                bVar1 = true;
                local_2c.ObjectID = NONE.ObjectID;
                iVar4 = pTVar3->FirstCondition;
                if (iVar4 <= pTVar3->LastCondition) {
                    do {
                        Condition_00 = vector<>::operator()(&MoveUseConditions,iVar4);
                        local_3c[0] = (Object)Obj2->ObjectID;
                        local_4c[0] = (Object)Obj1->ObjectID;
                        rule = User->ObjectID;
                        bVar2 = CheckCondition(Event,Condition_00,(Object *)&rule,local_4c,local_3c,
                                               &local_2c);
                        if (!bVar2) {
                            bVar1 = false;
                        }
                        iVar4 = iVar4 + 1;
                        if (!bVar1) goto LAB_08077f6d;
                    } while (iVar4 <= pTVar3->LastCondition);
                }
                if (bVar1) {
                    iVar4 = pTVar3->FirstAction;
                    if (pTVar3->FirstAction <= pTVar3->LastAction) {
                        do {
                            iVar5 = iVar4 + 1;
                            Action = vector<>::operator()(&MoveUseActions,iVar4);
                            rule = Obj2->ObjectID;
                            local_4c[0] = (Object)Obj1->ObjectID;
                            local_3c[0] = (Object)User->ObjectID;
                            ExecuteAction(Event,Action,local_3c,local_4c,(Object *)&rule,&local_2c);
                            iVar4 = iVar5;
                        } while (iVar5 <= pTVar3->LastAction);
                    }
                    HandleEvent::RecursionDepth = HandleEvent::RecursionDepth + -1;
                    return true;
                }
LAB_08077f6d:
                iStack_60 = iStack_60 + 1;
            } while (iStack_60 <= MoveUseDatabases[Event].NumberOfRules);
        }
        HandleEvent::RecursionDepth = HandleEvent::RecursionDepth + -1;
    }
    else {
        error("HandleEvent: Endlosschleife im Move/Use-System vermutet.\n");
    }
    return false;
}



void UseContainer(ulong CreatureID,Object *Con,uchar Window)

{
    bool bVar1;
    TPlayer *this;
    undefined4 *puVar2;
    int Window_00;
    char *pcVar3;
    Object *pOVar4;
    TPlayer *pl;
    Object OStack_4c;
    uchar Window_local;
    _func_int_varargs **local_3c;
    _func_int_varargs **local_2c;
    
                    // try { // try from 0807802f to 080781a2 has its CatchHandler @ 080781b0
    bVar1 = Object::exists(Con);
    if (bVar1) {
        Object::getObjectType((Object *)&local_2c);
        bVar1 = ObjectType::getFlag((ObjectType *)&local_2c,CONTAINER);
        if (!bVar1) {
            pcVar3 = &DAT_080f8980;
            goto LAB_0807819e;
        }
        if (Window < 0x10) {
            pOVar4 = Con;
            Object::getObjectType((Object *)&local_2c);
            if (local_2c == (_func_int_varargs **)0x63) {
                puVar2 = (undefined4 *)__cxa_allocate_exception(4,pOVar4);
                *puVar2 = 0x1d;
                goto LAB_0807815a;
            }
            this = GetPlayer(CreatureID);
            if (this != (TPlayer *)0x0) {
                Window_00 = 0;
                do {
                    TPlayer::GetOpenContainer((TPlayer *)&local_2c,(int)this);
                    local_3c = (_func_int_varargs **)Con->ObjectID;
                    if (local_2c == local_3c) {
                        OStack_4c.ObjectID = NONE.ObjectID;
                        TPlayer::SetOpenContainer(this,Window_00,&stack0xffffffb4);
                        SendCloseContainer((this->super_TCreature).Connection,Window_00);
                        return;
                    }
                    Window_00 = Window_00 + 1;
                } while (Window_00 < 0x10);
                OStack_4c.ObjectID = (ulong)local_3c;
                TPlayer::SetOpenContainer(this,(uint)Window,&stack0xffffffb4);
                SendContainer((this->super_TCreature).Connection,(uint)Window);
                return;
            }
            pcVar3 = "UseContainer: Spieler %d existiert nicht.\n";
        }
        else {
            CreatureID = (ulong)Window;
            pcVar3 = &DAT_080f8940;
        }
        error(pcVar3,CreatureID);
    }
    else {
        pcVar3 = &DAT_080f89c0;
LAB_0807819e:
        error(pcVar3);
    }
    puVar2 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar2 = 0xffffffff;
LAB_0807815a:
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar2,&RESULT::typeinfo,0);
}



void UseChest(ulong CreatureID,Object *Chest)

{
    bool bVar1;
    bool bVar2;
    ulong uVar3;
    int iVar4;
    TPlayer *this;
    char *pcVar5;
    int iVar6;
    int iVar7;
    char *pcVar8;
    undefined4 *puVar9;
    int Weight;
    ulong uVar10;
    undefined4 uVar11;
    undefined8 local_bc;
    int iStack_b8;
    bool invert;
    bool first;
    int pos;
    TPlayer *pl;
    int Number;
    int x;
    int y;
    int z;
    Object local_7c [4];
    Object local_6c;
    Object Obj;
    Object local_4c [4];
    Object local_3c [4];
    Object local_2c;
    Object Treasure;
    
                    // try { // try from 080781e8 to 08078562 has its CatchHandler @ 08078948
    bVar2 = Object::exists(Chest);
    if (bVar2) {
        Object::getObjectType(&local_2c);
        bVar2 = ObjectType::getFlag((ObjectType *)&local_2c,CHEST);
        if (bVar2) {
            local_2c = (Object)Chest->ObjectID;
            GetObjectCoordinates(&local_2c,&Number,&x,&y);
            uVar3 = Object::getAttribute(Chest,CHESTQUESTNUMBER);
            bVar2 = false;
            if ((0 < (int)uVar3) && ((int)uVar3 < 500)) {
                bVar2 = true;
            }
            if (!bVar2) {
                error(&DAT_080f8b40,uVar3,Number,x,y);
                goto LAB_0807875e;
            }
            local_2c = (Object)Chest->ObjectID;
            iVar4 = CountObjectsInContainer(&local_2c);
            if (iVar4 != 1) {
                error(&DAT_080f8ae0,Number,x,y);
                goto LAB_0807875e;
            }
            local_3c[0] = (Object)Chest->ObjectID;
            GetFirstContainerObject(&local_2c);
            Object::getObjectType(local_3c);
            bVar2 = ObjectType::getFlag((ObjectType *)local_3c,UNMOVE);
            if (!bVar2) {
                Object::getObjectType(local_3c);
                bVar2 = ObjectType::getFlag((ObjectType *)local_3c,TAKE);
                if (bVar2) {
                    this = GetPlayer(CreatureID);
                    if (this == (TPlayer *)0x0) {
                    // try { // try from 08078759 to 080787f5 has its CatchHandler @ 08078948
                        error("UseChest: Spieler %d existiert nicht.\n",CreatureID);
                        goto LAB_0807875e;
                    }
                    iVar4 = TPlayer::GetQuestValue(this,uVar3);
                    if (iVar4 != 0) {
                        print();
                        Object::getObjectType(local_3c);
                        pcVar5 = ObjectType::getName((ObjectType *)local_3c);
                        SendMessage((this->super_TCreature).Connection,0x16,"The %s is empty.",
                                    pcVar5);
                        return;
                    }
                    bVar2 = CheckRight(CreatureID,UNLIMITED_CAPACITY);
                    if (bVar2) {
LAB_080784f2:
                        Object::getContainer(&local_6c);
                        Copy(local_4c,&local_6c);
                        local_2c.ObjectID = local_4c[0].ObjectID;
                        local_3c[0].ObjectID = local_4c[0].ObjectID;
                        Object::getObjectType(&local_6c);
                        bVar2 = ObjectType::getFlag((ObjectType *)&local_6c,MOVEMENTEVENT);
                        uVar11 = 1;
                        uVar10 = CreatureID;
                    // try { // try from 08078586 to 08078614 has its CatchHandler @ 0807880d
                        GetBodyObject((ulong)&local_6c,CreatureID);
                        if ((bVar2) || (local_6c.ObjectID != NONE.ObjectID)) {
                            bVar1 = false;
                            if (bVar2) {
                                local_7c[0] = (Object)NONE.ObjectID;
                                local_4c[0].ObjectID = NONE.ObjectID;
                                if (local_6c.ObjectID != NONE.ObjectID) {
                                    Object::getObjectType(local_4c);
                                    uVar10 = 4;
                                    bVar2 = ObjectType::getFlag((ObjectType *)local_4c,CONTAINER);
                                    if (bVar2) {
                                        bVar1 = true;
                                    }
                                }
                            }
                            if (!bVar1) {
                                puVar9 = (undefined4 *)__cxa_allocate_exception(4,uVar10,uVar11);
                                *puVar9 = 4;
                    // WARNING: Subroutine does not return
                    // try { // try from 08078698 to 0807873f has its CatchHandler @ 0807880d
                                __cxa_throw(puVar9,&RESULT::typeinfo,0);
                            }
                            local_4c[0].ObjectID = NONE.ObjectID;
                            local_3c[0].ObjectID = local_6c.ObjectID;
                            z = local_2c.ObjectID;
                            Move(CreatureID,(Object *)&z,local_3c,-1,true,local_4c);
                        }
                        else {
                            local_4c[0].ObjectID = NONE.ObjectID;
                            GetBodyContainer((ulong)local_3c,CreatureID);
                            local_7c[0].ObjectID = local_2c.ObjectID;
                            Move(CreatureID,local_7c,local_3c,-1,true,local_4c);
                        }
                        z = local_2c.ObjectID;
                    // try { // try from 08078621 to 0807866d has its CatchHandler @ 08078948
                        pcVar5 = GetName((Object *)&z);
                        SendMessage((this->super_TCreature).Connection,0x16,"You have found %s.\n",
                                    pcVar5);
                        TPlayer::SetQuestValue(this,uVar3,1);
                        return;
                    }
                    local_3c[0].ObjectID = local_2c.ObjectID;
                    iVar4 = GetCompleteWeight(local_3c);
                    iVar6 = GetInventoryWeight(CreatureID);
                    iVar7 = TSkill::Get((this->super_TCreature).super_TSkillBase.Skills[5]);
                    if ((iVar4 + iVar6 <= iVar7 * 100) &&
                       (bVar2 = CheckRight(CreatureID,ZERO_CAPACITY), !bVar2)) goto LAB_080784f2;
                    Object::getObjectType(local_3c);
                    bVar2 = ObjectType::getFlag((ObjectType *)local_3c,CUMULATIVE);
                    if (bVar2) {
                        uVar3 = Object::getAttribute(&local_2c,AMOUNT);
                        pcVar5 = "they are";
                        if (1 < uVar3) goto LAB_0807844b;
                    }
                    pcVar5 = "it is";
LAB_0807844b:
                    local_3c[0].ObjectID = local_2c.ObjectID;
                    pcVar8 = GetName(local_3c);
                    iVar6 = (iStack_b8 >> 5) - (iVar4 >> 0x1f);
                    SendMessage((this->super_TCreature).Connection,0x16,
                                "You have found %s. Weighing %d.%02d oz %s too heavy.",pcVar8,iVar6,
                                iVar4 + iVar6 * -100,pcVar5);
                    return;
                }
            }
            pcVar5 = "UseChest: Schatz auf Position [%d,%d,%d] ist nicht nehmbar.\n";
        }
        else {
            pcVar5 = &DAT_080f8ba0;
        }
    }
    else {
        pcVar5 = &DAT_080f8be0;
    }
    error(pcVar5);
LAB_0807875e:
    puVar9 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar9 = 0xffffffff;
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar9,&RESULT::typeinfo,0);
}



void UseLiquidContainer(ulong CreatureID,Object *Obj,Object *Dest)

{
    TSkill *pTVar1;
    bool bVar2;
    bool bVar3;
    ulong uVar4;
    undefined4 *puVar5;
    TPlayer *this;
    int iVar6;
    char *pcVar7;
    int iVar8;
    undefined4 uVar9;
    int LiquidType;
    int local_58;
    int x;
    int y;
    int z;
    Object local_3c [4];
    Object local_2c;
    Object Help;
    
                    // try { // try from 0807897b to 08078f23 has its CatchHandler @ 08078f43
    bVar2 = Object::exists(Obj);
    if (bVar2) {
        bVar2 = Object::exists(Dest);
        if (bVar2) {
            Object::getObjectType(&local_2c);
            bVar2 = ObjectType::getFlag((ObjectType *)&local_2c,LIQUIDCONTAINER);
            if (!bVar2) {
                pcVar7 = &DAT_080f8ce0;
                goto LAB_08078f0b;
            }
            Object::getObjectType(&local_2c);
            bVar2 = ObjectType::getFlag((ObjectType *)&local_2c,LIQUIDSOURCE);
            if ((bVar2) && (uVar4 = Object::getAttribute(Obj,CONTAINERLIQUIDTYPE), uVar4 == 0)) {
                Object::getObjectType(&local_2c);
                uVar4 = ObjectType::getAttribute((ObjectType *)&local_2c,SOURCELIQUIDTYPE);
                local_2c = (Object)Obj->ObjectID;
LAB_08078ec5:
                Change(&local_2c,CONTAINERLIQUIDTYPE,uVar4);
                return;
            }
            Object::getObjectType(&local_2c);
            bVar2 = ObjectType::getFlag((ObjectType *)&local_2c,LIQUIDCONTAINER);
            if ((bVar2) &&
               ((uVar4 = Object::getAttribute(Obj,CONTAINERLIQUIDTYPE), uVar4 != 0 &&
                (uVar4 = Object::getAttribute(Dest,CONTAINERLIQUIDTYPE), uVar4 == 0)))) {
                local_2c = (Object)Dest->ObjectID;
                uVar4 = Object::getAttribute(Obj,CONTAINERLIQUIDTYPE);
                Change(&local_2c,CONTAINERLIQUIDTYPE,uVar4);
                local_2c = (Object)Obj->ObjectID;
                uVar4 = 0;
                goto LAB_08078ec5;
            }
            Object::getObjectType(&local_2c);
            if (local_2c.ObjectID != 99) {
                Object::getContainer(local_3c);
                GetFirstContainerObject(&local_2c);
                z = NONE.ObjectID;
                local_3c[0].ObjectID = z;
                if (local_2c.ObjectID != NONE.ObjectID) {
                    do {
                        z = NONE.ObjectID;
                        local_3c[0].ObjectID = NONE.ObjectID;
                        Object::getObjectType((Object *)&z);
                        if ((z == 99) &&
                           (uVar4 = Object::getCreatureID(&local_2c), uVar4 == CreatureID)) {
                            local_3c[0].ObjectID = local_2c.ObjectID;
                            Dest->ObjectID = (ulong)local_2c;
                            z = local_2c.ObjectID;
                            break;
                        }
                        Object::getNextObject(local_3c);
                        local_2c.ObjectID = local_3c[0].ObjectID;
                        bVar2 = local_3c[0].ObjectID != NONE.ObjectID;
                        local_3c[0].ObjectID = NONE.ObjectID;
                        z = NONE.ObjectID;
                    } while (bVar2);
                }
            }
            Object::getObjectType((Object *)&z);
            if ((z != 99) || (uVar4 = Object::getCreatureID(Dest), uVar4 != CreatureID)) {
                uVar4 = Object::getAttribute(Obj,CONTAINERLIQUIDTYPE);
                if (uVar4 == 0) {
                    puVar5 = (undefined4 *)__cxa_allocate_exception(4);
                    *puVar5 = 0x1d;
                }
                else {
                    z = Dest->ObjectID;
                    GetObjectCoordinates((Object *)&z,&local_58,&x,&y);
                    bVar2 = false;
                    uVar9 = 0;
                    iVar6 = x;
                    iVar8 = y;
                    bVar3 = CoordinateFlag();
                    if (bVar3) {
                        uVar9 = 0x23;
                        bVar2 = CoordinateFlag();
                        bVar2 = !bVar2;
                        iVar6 = x;
                        iVar8 = y;
                    }
                    if (bVar2) {
                        Object::getAttribute(Obj,CONTAINERLIQUIDTYPE);
                        z = Obj->ObjectID;
                        Change((Object *)&z,CONTAINERLIQUIDTYPE,0);
                        local_3c[0] = (Object)Dest->ObjectID;
                        GetMapContainer((Object *)&z);
                        GetSpecialObject((SPECIALMEANING)&local_2c);
                        CreatePool();
                        return;
                    }
                    puVar5 = (undefined4 *)__cxa_allocate_exception(4,iVar6,iVar8,uVar9);
                    *puVar5 = 4;
                }
                goto LAB_08078b95;
            }
            this = GetPlayer(CreatureID);
            if (this != (TPlayer *)0x0) {
                uVar4 = Object::getAttribute(Obj,CONTAINERLIQUIDTYPE);
                switch(uVar4) {
                case 0:
                    return;
                default:
                    z = Obj->ObjectID;
                    Change((Object *)&z,CONTAINERLIQUIDTYPE,0);
                    pcVar7 = "Gulp.";
                    break;
                case 2:
                case 3:
                    z = Obj->ObjectID;
                    Change((Object *)&z,CONTAINERLIQUIDTYPE,0);
                    pTVar1 = (this->super_TCreature).super_TSkillBase.Skills[0x14];
                    pcVar7 = "Aah...";
                    iVar6 = (*pTVar1->_vptr_TSkill[0xd])(pTVar1);
                    if (iVar6 < 5) {
                        pTVar1 = (this->super_TCreature).super_TSkillBase.Skills[0x14];
                        (*pTVar1->_vptr_TSkill[0xd])(pTVar1);
                        TSkillBase::SetTimer(&(this->super_TCreature).super_TSkillBase);
                    }
                    break;
                case 6:
                    z = Obj->ObjectID;
                    Change((Object *)&z,CONTAINERLIQUIDTYPE,0);
                    pcVar7 = "Urgh!";
                    TCreature::Damage(&this->super_TCreature,(TCreature *)0x0,200,0x20);
                    break;
                case 8:
                    z = Obj->ObjectID;
                    Change((Object *)&z,CONTAINERLIQUIDTYPE,0);
                    pcVar7 = "Urgh!";
                    break;
                case 10:
                case 0xb:
                    z = Obj->ObjectID;
                    DrinkPotion(CreatureID,(Object *)&z);
                    pcVar7 = "Aaaah...";
                    break;
                case 0xc:
                    z = Obj->ObjectID;
                    Change((Object *)&z,CONTAINERLIQUIDTYPE,0);
                    pcVar7 = "Mmmh.";
                }
                Talk(CreatureID,1,(char *)0x0,pcVar7,false);
                return;
            }
            pcVar7 = "UseLiquidContainer: Spieler %d existiert nicht.\n";
        }
        else {
            Object::getObjectType(&local_2c);
            pcVar7 = &DAT_080f8d40;
            CreatureID = local_2c.ObjectID;
        }
        error(pcVar7,CreatureID);
    }
    else {
        pcVar7 = &DAT_080f8da0;
LAB_08078f0b:
        error(pcVar7);
    }
    puVar5 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar5 = 0xffffffff;
LAB_08078b95:
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar5,&RESULT::typeinfo,0);
}



void UseFood(ulong CreatureID,Object *Obj)

{
    TSkill *pTVar1;
    int iVar2;
    bool bVar3;
    TPlayer *pTVar4;
    int iVar5;
    ulong uVar6;
    undefined4 *puVar7;
    char *Text;
    TPlayer *pl;
    
                    // try { // try from 08078f78 to 080790e9 has its CatchHandler @ 080790f5
    bVar3 = Object::exists(Obj);
    if (bVar3) {
        Object::getObjectType((Object *)&pl);
        bVar3 = ObjectType::getFlag((ObjectType *)&pl,FOOD);
        if (!bVar3) {
            Text = &DAT_080f8e20;
            goto LAB_080790e5;
        }
        pTVar4 = GetPlayer(CreatureID);
        if (pTVar4 != (TPlayer *)0x0) {
            pTVar1 = (pTVar4->super_TCreature).super_TSkillBase.Skills[0xe];
            iVar5 = (*pTVar1->_vptr_TSkill[0xd])(pTVar1);
            iVar2 = pTVar1->Max;
            Object::getObjectType((Object *)&pl);
            uVar6 = ObjectType::getAttribute((ObjectType *)&pl,NUTRITION);
            if (iVar5 <= (int)(iVar2 + uVar6 * -0xc)) {
                (*pTVar1->_vptr_TSkill[0xd])(pTVar1);
                Object::getObjectType((Object *)&pl);
                ObjectType::getAttribute((ObjectType *)&pl,NUTRITION);
                TSkillBase::SetTimer(&(pTVar4->super_TCreature).super_TSkillBase);
                pl = (TPlayer *)Obj->ObjectID;
                Delete((Object *)&pl,1);
                return;
            }
            puVar7 = (undefined4 *)__cxa_allocate_exception(4);
            *puVar7 = 0x1e;
            goto LAB_080790a2;
        }
        error("UseFood: Kreatur %d existiert nicht.\n",CreatureID);
    }
    else {
        Text = &DAT_080f8e60;
LAB_080790e5:
        error(Text);
    }
    puVar7 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar7 = 0xffffffff;
LAB_080790a2:
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar7,&RESULT::typeinfo,0);
}



void UseTextObject(ulong CreatureID,Object *Obj)

{
    bool bVar1;
    TPlayer *pTVar2;
    undefined4 *puVar3;
    TPlayer *pl;
    char *Text;
    Object local_2c [7];
    
                    // try { // try from 08079128 to 080791d2 has its CatchHandler @ 080791e0
    bVar1 = Object::exists(Obj);
    if (bVar1) {
        Object::getObjectType(local_2c);
        bVar1 = ObjectType::getFlag((ObjectType *)local_2c,TEXT);
        if (bVar1) {
            pTVar2 = GetPlayer(CreatureID);
            if (pTVar2 != (TPlayer *)0x0) {
                local_2c[0] = (Object)Obj->ObjectID;
                SendEditText((pTVar2->super_TCreature).Connection,local_2c);
                return;
            }
            error("UseTextObject: Kreatur %d existiert nicht.\n",CreatureID);
            goto LAB_0807919d;
        }
        Text = &DAT_080f8ee0;
    }
    else {
        Text = &DAT_080f8f20;
    }
    error(Text);
LAB_0807919d:
    puVar3 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar3 = 0xffffffff;
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar3,&RESULT::typeinfo,0);
}



void UseAnnouncer(ulong CreatureID,Object *Obj)

{
    bool bVar1;
    TPlayer *this;
    ulong uVar2;
    int iVar3;
    undefined4 *puVar4;
    char cVar5;
    char *Text;
    TPlayer *pl;
    int Hour;
    int Minute;
    int Year;
    int Cycle;
    int Day;
    char Help [200];
    Object local_2c [7];
    
                    // try { // try from 0807921b to 080795fa has its CatchHandler @ 08079606
    bVar1 = Object::exists(Obj);
    if (bVar1) {
        Object::getObjectType(local_2c);
        bVar1 = ObjectType::getFlag((ObjectType *)local_2c,INFORMATION);
        if (bVar1) {
            this = GetPlayer(CreatureID);
            if (this != (TPlayer *)0x0) {
                Object::getObjectType(local_2c);
                uVar2 = ObjectType::getAttribute((ObjectType *)local_2c,INFORMATIONTYPE);
                if (uVar2 == 2) {
                    GetTime((int *)&pl,&Hour);
                    SendMessage((this->super_TCreature).Connection,0x16,"The time is %d:%.2d.",pl,
                                Hour);
                    return;
                }
                if (uVar2 < 3) {
                    if (uVar2 == 1) {
                        GetDate(&Minute,&Year,&Cycle);
                        GetTime((int *)&pl,&Hour);
                        SendMessage((this->super_TCreature).Connection,0x16,
                                    "It is the %dth day of the %dth cycle in the year %d. The time is %d:%.2d."
                                    ,Cycle,Year,Minute,pl,Hour);
                        return;
                    }
                }
                else {
                    if (uVar2 == 3) {
                        Day = 0x65636552;
                        builtin_strncpy(Help,"ived blessings:",0x10);
                        iVar3 = TPlayer::GetQuestValue(this,0x65);
                        cVar5 = iVar3 != 0;
                        if ((bool)cVar5) {
                            strcat((char *)&Day,"\nWisdom of Solitude");
                        }
                        iVar3 = TPlayer::GetQuestValue(this,0x66);
                        if (iVar3 != 0) {
                            cVar5 = cVar5 + '\x01';
                            strcat((char *)&Day,"\nSpark of the Phoenix");
                        }
                        iVar3 = TPlayer::GetQuestValue(this,0x67);
                        if (iVar3 != 0) {
                            cVar5 = cVar5 + '\x01';
                            strcat((char *)&Day,"\nFire of the Suns");
                        }
                        iVar3 = TPlayer::GetQuestValue(this,0x68);
                        if (iVar3 != 0) {
                            cVar5 = cVar5 + '\x01';
                            strcat((char *)&Day,"\nSpiritual Shielding");
                        }
                        iVar3 = TPlayer::GetQuestValue(this,0x69);
                        if (iVar3 != 0) {
                            cVar5 = cVar5 + '\x01';
                            strcat((char *)&Day,"\nEmbrace of Tibia");
                        }
                        if (cVar5 == '\0') {
                            builtin_strncpy(Help,"lessings received.",0x13);
                            Day = 0x62206f4e;
                        }
                        SendMessage((this->super_TCreature).Connection,0x16,"%s",&Day);
                        return;
                    }
                    if (uVar2 == 4) {
                        local_2c[0] = (Object)Obj->ObjectID;
                        SendEditText((this->super_TCreature).Connection,local_2c);
                        return;
                    }
                }
                Object::getObjectType(local_2c);
                uVar2 = ObjectType::getAttribute((ObjectType *)local_2c,INFORMATIONTYPE);
                error(&DAT_080f8f60,uVar2);
                return;
            }
            error("UseAnnouncer: Kreatur %d existiert nicht.\n",CreatureID);
            goto LAB_080795c5;
        }
        Text = &DAT_080f9040;
    }
    else {
        Text = &DAT_080f9080;
    }
    error(Text);
LAB_080795c5:
    puVar4 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar4 = 0xffffffff;
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar4,&RESULT::typeinfo,0);
}



void UseKeyDoor(ulong param_1,Object *Key,Object *Door)

{
    bool bVar1;
    ulong uVar2;
    ulong uVar3;
    undefined4 *puVar4;
    char *Text;
    Object local_4c [4];
    Object local_3c [4];
    Object local_2c;
    ObjectType Target;
    
                    // try { // try from 08079638 to 08079834 has its CatchHandler @ 08079850
    bVar1 = Object::exists(Key);
    if (bVar1) {
        bVar1 = Object::exists(Door);
        if (!bVar1) {
            Text = &DAT_080f9140;
            goto LAB_08079830;
        }
        Object::getObjectType(&local_2c);
        bVar1 = ObjectType::getFlag((ObjectType *)&local_2c,KEY);
        if (!bVar1) {
            Text = &DAT_080f9100;
            goto LAB_08079830;
        }
        Object::getObjectType(&local_2c);
        bVar1 = ObjectType::getFlag((ObjectType *)&local_2c,KEYDOOR);
        if (!bVar1) {
            puVar4 = (undefined4 *)__cxa_allocate_exception(4);
            *puVar4 = 0x1d;
            goto LAB_080797e9;
        }
        uVar2 = Object::getAttribute(Door,KEYHOLENUMBER);
        if ((uVar2 == 0) || (uVar2 = Object::getAttribute(Key,KEYNUMBER), uVar2 == 0)) {
LAB_08079801:
            puVar4 = (undefined4 *)__cxa_allocate_exception(4);
            *puVar4 = 0x16;
            goto LAB_080797e9;
        }
        uVar2 = Object::getAttribute(Door,KEYHOLENUMBER);
        uVar3 = Object::getAttribute(Key,KEYNUMBER);
        if (uVar2 != uVar3) goto LAB_08079801;
        Object::getObjectType(local_3c);
        uVar2 = ObjectType::getAttribute((ObjectType *)local_3c,KEYDOORTARGET);
        ObjectType::setTypeID((ObjectType *)&local_2c,uVar2);
        ObjectType::setTypeID((ObjectType *)local_3c,0);
        if (local_2c.ObjectID != local_3c[0].ObjectID) {
            bVar1 = ObjectType::getFlag((ObjectType *)&local_2c,UNPASS);
            if (bVar1) {
                local_4c[0].ObjectID = NONE.ObjectID;
                local_3c[0] = (Object)Door->ObjectID;
                ClearField(local_3c,local_4c);
            }
            ObjectType::setTypeID((ObjectType *)local_4c,local_2c.ObjectID);
            local_3c[0] = (Object)Door->ObjectID;
            Change(local_3c,(ObjectType *)local_4c,0);
            return;
        }
        Object::getObjectType(local_4c);
        error(&DAT_080f90c0,local_4c[0].ObjectID);
    }
    else {
        Text = &DAT_080f9180;
LAB_08079830:
        error(Text);
    }
    puVar4 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar4 = 0xffffffff;
LAB_080797e9:
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar4,&RESULT::typeinfo,0);
}



void UseNameDoor(ulong CreatureID,Object *Door)

{
    bool bVar1;
    ushort HouseID;
    TPlayer *pl_00;
    ulong _TypeID;
    undefined4 *puVar2;
    TPlayer *pl;
    char *Text;
    int local_58;
    int x;
    int y;
    int z;
    Object local_3c [4];
    Object local_2c;
    ObjectType Target;
    
                    // try { // try from 08079885 to 08079ace has its CatchHandler @ 08079af0
    bVar1 = Object::exists(Door);
    if (bVar1) {
        Object::getObjectType(&local_2c);
        bVar1 = ObjectType::getFlag((ObjectType *)&local_2c,NAMEDOOR);
        if (!bVar1) {
            Text = &DAT_080f92c0;
            goto LAB_08079aca;
        }
        Object::getObjectType(&local_2c);
        bVar1 = ObjectType::getFlag((ObjectType *)&local_2c,TEXT);
        if (!bVar1) {
            Text = &DAT_080f9280;
            goto LAB_08079aca;
        }
        pl_00 = GetPlayer(CreatureID);
        if (pl_00 == (TPlayer *)0x0) {
            Text = "UseNameDoor: Spieler existiert nicht.\n";
            goto LAB_08079aca;
        }
        local_2c = (Object)Door->ObjectID;
        GetObjectCoordinates(&local_2c,&local_58,&x,&y);
        HouseID = GetHouseID(local_58,x,y);
        if (HouseID == 0) {
            error(&DAT_080f9200,local_58,x,y);
        }
        else {
            bVar1 = IsOwner(HouseID,pl_00);
            if ((!bVar1) && (bVar1 = CheckRight((pl_00->super_TCreature).ID,OPEN_NAMEDOORS), !bVar1)
               ) {
                local_2c = (Object)Door->ObjectID;
                bVar1 = MayOpenDoor(&local_2c,pl_00);
                if (!bVar1) {
                    puVar2 = (undefined4 *)__cxa_allocate_exception(4);
                    *puVar2 = 1;
                    goto LAB_08079a3a;
                }
            }
            Object::getObjectType(local_3c);
            _TypeID = ObjectType::getAttribute((ObjectType *)local_3c,NAMEDOORTARGET);
            ObjectType::setTypeID((ObjectType *)&local_2c,_TypeID);
            ObjectType::setTypeID((ObjectType *)local_3c,0);
            if (local_2c.ObjectID != local_3c[0].ObjectID) {
                bVar1 = ObjectType::getFlag((ObjectType *)&local_2c,UNPASS);
                if (bVar1) {
                    z = NONE.ObjectID;
                    local_3c[0] = (Object)Door->ObjectID;
                    ClearField(local_3c,(Object *)&z);
                }
                ObjectType::setTypeID((ObjectType *)&z,local_2c.ObjectID);
                local_3c[0] = (Object)Door->ObjectID;
                Change(local_3c,(ObjectType *)&z,0);
                return;
            }
            Object::getObjectType((Object *)&z);
            error(&DAT_080f91c0,z);
        }
    }
    else {
        Text = &DAT_080f9320;
LAB_08079aca:
        error(Text);
    }
    puVar2 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar2 = 0xffffffff;
LAB_08079a3a:
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar2,&RESULT::typeinfo,0);
}



void UseLevelDoor(ulong CreatureID,Object *Door)

{
    bool bVar1;
    bool bVar2;
    TPlayer *pTVar3;
    int iVar4;
    ulong uVar5;
    char *pcVar6;
    undefined4 *puVar7;
    TPlayer *pl;
    Object local_4c [4];
    Object local_3c;
    ObjectType Target;
    Object local_2c [7];
    
                    // try { // try from 08079b28 to 08079d8b has its CatchHandler @ 08079d97
    bVar1 = Object::exists(Door);
    if (bVar1) {
        Object::getObjectType(local_2c);
        bVar1 = ObjectType::getFlag((ObjectType *)local_2c,LEVELDOOR);
        if (!bVar1) goto LAB_08079d8e;
        Object::getContainer(local_2c);
        Object::getObjectType(&local_3c);
        if (local_3c.ObjectID != 0) goto LAB_08079d8e;
        pTVar3 = GetPlayer(CreatureID);
        if (pTVar3 == (TPlayer *)0x0) {
            pcVar6 = "UseLevelDoor: Spieler existiert nicht.\n";
            goto LAB_08079d87;
        }
        Object::getObjectType(&local_3c);
        bVar1 = ObjectType::getFlag((ObjectType *)&local_3c,UNPASS);
        if (!bVar1) {
            puVar7 = (undefined4 *)__cxa_allocate_exception(4);
            *puVar7 = 0x1d;
            goto LAB_08079d37;
        }
        iVar4 = TSkill::Get((pTVar3->super_TCreature).super_TSkillBase.Skills[0]);
        uVar5 = Object::getAttribute(Door,DOORLEVEL);
        if (iVar4 < (int)uVar5) {
            local_3c = (Object)Door->ObjectID;
            pcVar6 = GetInfo(&local_3c);
            SendMessage((pTVar3->super_TCreature).Connection,0x16,"%s.",pcVar6);
            return;
        }
        Object::getObjectType(local_2c);
        uVar5 = ObjectType::getAttribute((ObjectType *)local_2c,LEVELDOORTARGET);
        ObjectType::setTypeID((ObjectType *)&local_3c,uVar5);
        bVar1 = false;
        ObjectType::setTypeID((ObjectType *)local_2c,0);
        if ((local_3c.ObjectID == local_2c[0].ObjectID) ||
           (bVar2 = ObjectType::getFlag((ObjectType *)&local_3c,UNPASS), bVar2)) {
            bVar1 = true;
        }
        if (!bVar1) {
            ObjectType::setTypeID((ObjectType *)local_4c,local_3c.ObjectID);
            local_2c[0] = (Object)Door->ObjectID;
            Change(local_2c,(ObjectType *)local_4c,0);
            local_4c[0].ObjectID = NONE.ObjectID;
            Object::getContainer(local_2c);
            pl = (TPlayer *)(pTVar3->super_TCreature).CrObject.ObjectID;
            Move(0,(Object *)&pl,local_2c,-1,false,local_4c);
            return;
        }
        Object::getObjectType(local_4c);
        error(&DAT_080f9360,local_4c[0].ObjectID);
    }
    else {
LAB_08079d8e:
        pcVar6 = &DAT_080f9400;
LAB_08079d87:
        error(pcVar6);
    }
    puVar7 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar7 = 0xffffffff;
LAB_08079d37:
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar7,&RESULT::typeinfo,0);
}



void UseQuestDoor(ulong CreatureID,Object *Door)

{
    bool bVar1;
    bool bVar2;
    TPlayer *this;
    ulong uVar3;
    ulong uVar4;
    char *pcVar5;
    undefined4 *puVar6;
    TPlayer *pl;
    Object local_4c [4];
    Object local_3c;
    ObjectType Target;
    Object local_2c [7];
    
                    // try { // try from 08079dc8 to 0807a03c has its CatchHandler @ 0807a048
    bVar1 = Object::exists(Door);
    if (bVar1) {
        Object::getObjectType(local_2c);
        bVar1 = ObjectType::getFlag((ObjectType *)local_2c,QUESTDOOR);
        if (!bVar1) goto LAB_0807a03f;
        Object::getContainer(local_2c);
        Object::getObjectType(&local_3c);
        if (local_3c.ObjectID != 0) goto LAB_0807a03f;
        this = GetPlayer(CreatureID);
        if (this == (TPlayer *)0x0) {
            pcVar5 = "UseQuestDoor: Spieler existiert nicht.\n";
            goto LAB_0807a038;
        }
        Object::getObjectType(&local_3c);
        bVar1 = ObjectType::getFlag((ObjectType *)&local_3c,UNPASS);
        if (!bVar1) {
            puVar6 = (undefined4 *)__cxa_allocate_exception(4);
            *puVar6 = 0x1d;
            goto LAB_08079fe8;
        }
        uVar3 = Object::getAttribute(Door,DOORQUESTNUMBER);
        uVar3 = TPlayer::GetQuestValue(this,uVar3);
        uVar4 = Object::getAttribute(Door,DOORQUESTVALUE);
        if (uVar3 != uVar4) {
            local_3c = (Object)Door->ObjectID;
            pcVar5 = GetInfo(&local_3c);
            SendMessage((this->super_TCreature).Connection,0x16,"%s.",pcVar5);
            return;
        }
        Object::getObjectType(local_2c);
        uVar3 = ObjectType::getAttribute((ObjectType *)local_2c,QUESTDOORTARGET);
        ObjectType::setTypeID((ObjectType *)&local_3c,uVar3);
        bVar1 = false;
        ObjectType::setTypeID((ObjectType *)local_2c,0);
        if ((local_3c.ObjectID == local_2c[0].ObjectID) ||
           (bVar2 = ObjectType::getFlag((ObjectType *)&local_3c,UNPASS), bVar2)) {
            bVar1 = true;
        }
        if (!bVar1) {
            ObjectType::setTypeID((ObjectType *)local_4c,local_3c.ObjectID);
            local_2c[0] = (Object)Door->ObjectID;
            Change(local_2c,(ObjectType *)local_4c,0);
            local_4c[0].ObjectID = NONE.ObjectID;
            Object::getContainer(local_2c);
            pl = (TPlayer *)(this->super_TCreature).CrObject.ObjectID;
            Move(0,(Object *)&pl,local_2c,-1,false,local_4c);
            return;
        }
        Object::getObjectType(local_4c);
        error(&DAT_080f9440,local_4c[0].ObjectID);
    }
    else {
LAB_0807a03f:
        pcVar5 = &DAT_080f94e0;
LAB_0807a038:
        error(pcVar5);
    }
    puVar6 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar6 = 0xffffffff;
LAB_08079fe8:
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar6,&RESULT::typeinfo,0);
}



void UseWeapon(ulong CreatureID,Object *Weapon,Object *Target)

{
    bool bVar1;
    TPlayer *pl;
    ulong uVar2;
    TPlayer *pTVar3;
    long lVar4;
    undefined4 *puVar5;
    char *Text;
    Object *pOVar6;
    Object local_4c [4];
    Object local_3c;
    ObjectType Dest;
    Object local_2c [7];
    
                    // try { // try from 0807a078 to 0807a2c9 has its CatchHandler @ 0807a2d5
    bVar1 = Object::exists(Weapon);
    if (bVar1) {
        Object::getObjectType(local_2c);
        bVar1 = ObjectType::getFlag((ObjectType *)local_2c,WEAPON);
        if (!bVar1) goto LAB_0807a2cc;
        Object::getObjectType(local_2c);
        uVar2 = ObjectType::getAttribute((ObjectType *)local_2c,WEAPONTYPE);
        bVar1 = false;
        if ((0 < (int)uVar2) && ((int)uVar2 < 4)) {
            bVar1 = true;
        }
        if (!bVar1) goto LAB_0807a2cc;
        bVar1 = Object::exists(Target);
        if (!bVar1) {
LAB_0807a2be:
            Text = &DAT_080f9560;
            goto LAB_0807a2c5;
        }
        Object::getObjectType(local_2c);
        bVar1 = ObjectType::getFlag((ObjectType *)local_2c,DESTROY);
        if (!bVar1) goto LAB_0807a2be;
        pTVar3 = GetPlayer(CreatureID);
        if (pTVar3 != (TPlayer *)0x0) {
            Object::getContainer(local_2c);
            pOVar6 = local_2c;
            Object::getObjectType(&local_3c);
            if (local_3c.ObjectID == 0) {
                local_3c = (Object)Target->ObjectID;
                GraphicalEffect(&local_3c,3);
                lVar4 = random();
                if (lVar4 == 1) {
                    Object::getObjectType(local_2c);
                    uVar2 = ObjectType::getAttribute((ObjectType *)local_2c,DESTROYTARGET);
                    ObjectType::setTypeID((ObjectType *)&local_3c,uVar2);
                    Object::getObjectType(local_2c);
                    bVar1 = ObjectType::getFlag((ObjectType *)local_2c,CONTAINER);
                    if (bVar1) {
                        ObjectType::setTypeID((ObjectType *)local_2c,0);
                        if ((local_3c.ObjectID == local_2c[0].ObjectID) ||
                           (bVar1 = ObjectType::getFlag((ObjectType *)&local_3c,CONTAINER), !bVar1))
                        {
                            uVar2 = 0;
                        }
                        else {
                            uVar2 = ObjectType::getAttribute((ObjectType *)&local_3c,CAPACITY);
                        }
                        local_4c[0] = (Object)Target->ObjectID;
                        Empty(local_4c,uVar2);
                    }
                    ObjectType::setTypeID((ObjectType *)local_4c,local_3c.ObjectID);
                    local_2c[0] = (Object)Target->ObjectID;
                    Change(local_2c,(ObjectType *)local_4c,0);
                }
                return;
            }
            puVar5 = (undefined4 *)__cxa_allocate_exception(4,pOVar6);
            *puVar5 = 1;
            goto LAB_0807a27f;
        }
        error("UseWeapon: Spieler %d existiert nicht.\n",CreatureID);
    }
    else {
LAB_0807a2cc:
        Text = &DAT_080f95c0;
LAB_0807a2c5:
        error(Text);
    }
    puVar5 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar5 = 0xffffffff;
LAB_0807a27f:
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar5,&RESULT::typeinfo,0);
}



void UseChangeObject(ulong CreatureID,Object *Obj)

{
    bool bVar1;
    bool bVar2;
    TPlayer *pl;
    TPlayer *pTVar3;
    ulong _TypeID;
    undefined4 *puVar4;
    Object *this;
    Object *Exclude;
    int local_88;
    int x;
    int y;
    int z;
    Object local_6c [4];
    Object local_5c [4];
    Object local_4c [4];
    Object local_3c [4];
    Object local_2c;
    ObjectType NewType;
    
                    // try { // try from 0807a30b to 0807a849 has its CatchHandler @ 0807a850
    bVar1 = Object::exists(Obj);
    if (bVar1) {
        Object::getObjectType(&local_2c);
        bVar1 = ObjectType::getFlag((ObjectType *)&local_2c,CHANGEUSE);
        if (bVar1) {
            pTVar3 = GetPlayer(CreatureID);
            if (pTVar3 != (TPlayer *)0x0) {
                Object::getObjectType(local_3c);
                _TypeID = ObjectType::getAttribute((ObjectType *)local_3c,CHANGETARGET);
                ObjectType::setTypeID((ObjectType *)&local_2c,_TypeID);
                bVar1 = false;
                Object::getObjectType(local_3c);
                bVar2 = ObjectType::getFlag((ObjectType *)local_3c,UNPASS);
                if (!bVar2) {
                    ObjectType::setTypeID((ObjectType *)local_3c,0);
                    ObjectType::setTypeID((ObjectType *)local_4c,local_3c[0].ObjectID);
                    if ((local_2c.ObjectID != local_4c[0].ObjectID) &&
                       (bVar2 = ObjectType::getFlag((ObjectType *)&local_2c,UNPASS), bVar2)) {
                        bVar1 = true;
                    }
                }
                if (bVar1) {
                    local_5c[0] = (Object)Obj->ObjectID;
                    local_4c[0].ObjectID = local_5c[0].ObjectID;
                    ClearField(local_5c,local_4c);
                }
                else {
                    bVar1 = false;
                    Object::getObjectType(local_5c);
                    bVar2 = ObjectType::getFlag((ObjectType *)local_5c,UNLAY);
                    if (!bVar2) {
                        ObjectType::setTypeID((ObjectType *)local_5c,0);
                        ObjectType::setTypeID((ObjectType *)local_4c,local_5c[0].ObjectID);
                        if ((local_2c.ObjectID != local_4c[0].ObjectID) &&
                           (bVar2 = ObjectType::getFlag((ObjectType *)&local_2c,UNLAY), bVar2)) {
                            bVar1 = true;
                        }
                    }
                    if (bVar1) {
                        local_4c[0] = (Object)Obj->ObjectID;
                        GetObjectCoordinates(local_4c,&local_88,&x,&y);
                        bVar1 = false;
                        bVar2 = CoordinateFlag();
                        if (bVar2) {
                            bVar1 = CoordinateFlag();
                            bVar1 = !bVar1;
                        }
                        if (bVar1) {
                            local_4c[0].ObjectID = NONE.ObjectID;
                            GetMapContainer((int)local_6c,local_88 + 1,x);
                            this = (Object *)&z;
                            Object::getNextObject(this);
                            Exclude = local_4c;
                        }
                        else {
                            bVar1 = false;
                            bVar2 = CoordinateFlag();
                            if (bVar2) {
                                bVar1 = CoordinateFlag();
                                bVar1 = !bVar1;
                            }
                            if (bVar1) {
                                x = x + 1;
                                z = NONE.ObjectID;
                            }
                            else {
                                bVar1 = false;
                                bVar2 = CoordinateFlag();
                                if (bVar2) {
                                    bVar1 = CoordinateFlag();
                                    bVar1 = !bVar1;
                                }
                                if (bVar1) {
                                    z = NONE.ObjectID;
                                    local_88 = local_88 + -1;
                                }
                                else {
                                    bVar1 = false;
                                    bVar2 = CoordinateFlag();
                                    if (bVar2) {
                                        bVar1 = CoordinateFlag();
                                        bVar1 = !bVar1;
                                    }
                                    if (!bVar1) goto LAB_0807a3d4;
                                    x = x + -1;
                                    z = NONE.ObjectID;
                                }
                            }
                            Exclude = (Object *)&z;
                            NONE.ObjectID = z;
                            GetMapContainer((int)local_6c,local_88,x);
                            Object::getNextObject(local_4c);
                            this = local_4c;
                        }
                        MoveAllObjects(this,local_6c,Exclude,true);
                    }
                }
LAB_0807a3d4:
                ObjectType::setTypeID((ObjectType *)&z,local_2c.ObjectID);
                local_6c[0] = (Object)Obj->ObjectID;
                Change(local_6c,(ObjectType *)&z,0);
                return;
            }
            error("UseChangeObject: Spieler %d existiert nicht.\n",CreatureID);
            goto LAB_0807a814;
        }
    }
    error("UseChangeObject: Objekt existiert nicht oder ist kein CHANGEUSE-Objekt.\n");
LAB_0807a814:
    puVar4 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar4 = 0xffffffff;
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar4,&RESULT::typeinfo,0);
}



void UseObject(ulong CreatureID,Object *Obj)

{
    bool bVar1;
    TCreature *cr;
    TCreature *pTVar2;
    undefined4 *puVar3;
    char *Text;
    Object local_5c [4];
    Object local_4c [4];
    Object local_3c [4];
    Object local_2c;
    Object User;
    
                    // try { // try from 0807a888 to 0807a967 has its CatchHandler @ 0807a985
    bVar1 = Object::exists(Obj);
    if (bVar1) {
        Object::getObjectType(&local_2c);
        bVar1 = ObjectType::getFlag((ObjectType *)&local_2c,USEEVENT);
        if (bVar1) {
            if (CreatureID == 0) {
                pTVar2 = (TCreature *)0x0;
            }
            else {
                pTVar2 = GetCreature(CreatureID);
            }
            if (pTVar2 == (TCreature *)0x0) {
                local_2c.ObjectID = NONE.ObjectID;
            }
            else {
                local_2c.ObjectID = (pTVar2->CrObject).ObjectID;
            }
            local_3c[0] = (Object)NONE.ObjectID;
            local_4c[0] = (Object)Obj->ObjectID;
            local_5c[0].ObjectID = local_2c.ObjectID;
            bVar1 = HandleEvent(EVENT_USE,local_5c,local_4c,local_3c);
            if (bVar1) {
                return;
            }
            puVar3 = (undefined4 *)__cxa_allocate_exception(4);
            *puVar3 = 0x1d;
            goto LAB_0807a92d;
        }
        Text = &DAT_080f96c0;
    }
    else {
        Text = &DAT_080f9700;
    }
    error(Text);
    puVar3 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar3 = 0xffffffff;
LAB_0807a92d:
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar3,&RESULT::typeinfo,0);
}



void UseObjects(ulong CreatureID,Object *Obj1,Object *Obj2)

{
    bool bVar1;
    TCreature *cr;
    TCreature *pTVar2;
    undefined4 *puVar3;
    char *Text;
    Object local_5c [4];
    Object local_4c [4];
    Object local_3c [4];
    Object local_2c;
    Object User;
    
                    // try { // try from 0807a9b8 to 0807aaa7 has its CatchHandler @ 0807aad0
    bVar1 = Object::exists(Obj1);
    if (bVar1) {
        bVar1 = Object::exists(Obj2);
        if (bVar1) {
            Object::getObjectType(&local_2c);
            bVar1 = ObjectType::getFlag((ObjectType *)&local_2c,USEEVENT);
            if (bVar1) {
                if (CreatureID == 0) {
                    pTVar2 = (TCreature *)0x0;
                }
                else {
                    pTVar2 = GetCreature(CreatureID);
                }
                local_5c[0].ObjectID = NONE.ObjectID;
                if (pTVar2 != (TCreature *)0x0) {
                    local_5c[0].ObjectID = (pTVar2->CrObject).ObjectID;
                }
                local_3c[0] = (Object)Obj2->ObjectID;
                local_4c[0] = (Object)Obj1->ObjectID;
                local_2c.ObjectID = local_5c[0].ObjectID;
                bVar1 = HandleEvent(EVENT_MULTIUSE,local_5c,local_4c,local_3c);
                if (bVar1) {
                    return;
                }
                puVar3 = (undefined4 *)__cxa_allocate_exception(4);
                *puVar3 = 0x1d;
                goto LAB_0807aa6d;
            }
            Text = &DAT_080f9740;
        }
        else {
            Text = &DAT_080f9780;
        }
    }
    else {
        Text = &DAT_080f97c0;
    }
    error(Text);
    puVar3 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar3 = 0xffffffff;
LAB_0807aa6d:
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar3,&RESULT::typeinfo,0);
}



void MovementEvent(Object *Obj,Object *Start,Object *Dest)

{
    bool bVar1;
    undefined4 *puVar2;
    char *Text;
    Object local_4c [4];
    Object local_3c [4];
    Object local_2c [7];
    
                    // try { // try from 0807ab0b to 0807aca1 has its CatchHandler @ 0807acc0
    bVar1 = Object::exists(Obj);
    if (bVar1) {
        bVar1 = Object::exists(Start);
        if (bVar1) {
            Object::getObjectType(local_2c);
            bVar1 = ObjectType::getFlag((ObjectType *)local_2c,CONTAINER);
            if (!bVar1) {
                Object::getObjectType(local_2c);
                bVar1 = ObjectType::getFlag((ObjectType *)local_2c,CHEST);
                if (!bVar1) goto LAB_0807acaa;
            }
            bVar1 = Object::exists(Dest);
            if (bVar1) {
                Object::getObjectType(local_2c);
                bVar1 = ObjectType::getFlag((ObjectType *)local_2c,CONTAINER);
                if (!bVar1) {
                    Object::getObjectType(local_2c);
                    bVar1 = ObjectType::getFlag((ObjectType *)local_2c,CHEST);
                    if (!bVar1) goto LAB_0807ac5d;
                }
                Object::getObjectType(local_2c);
                bVar1 = ObjectType::getFlag((ObjectType *)local_2c,MOVEMENTEVENT);
                if (!bVar1) {
                    return;
                }
                local_2c[0].ObjectID = NONE.ObjectID;
                local_3c[0] = (Object)Obj->ObjectID;
                local_4c[0].ObjectID = NONE.ObjectID;
                HandleEvent(EVENT_MOVEMENT,local_4c,local_3c,local_2c);
                bVar1 = Object::exists(Obj);
                if (bVar1) {
                    return;
                }
                puVar2 = (undefined4 *)__cxa_allocate_exception(4);
                *puVar2 = 0x1f;
                goto LAB_0807ac18;
            }
LAB_0807ac5d:
            Text = "MovementEvent: \"Dest\" ist kein Container.\n";
        }
        else {
LAB_0807acaa:
            Text = "MovementEvent: \"Start\" ist kein Container.\n";
        }
    }
    else {
        Text = &DAT_080f9880;
    }
    error(Text);
    puVar2 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar2 = 0xffffffff;
LAB_0807ac18:
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar2,&RESULT::typeinfo,0);
}



void SeparationEvent(Object *Obj,Object *Start)

{
    Object OVar1;
    bool bVar2;
    bool bVar3;
    undefined4 *puVar4;
    ulong uVar5;
    char *Text;
    Object local_6c;
    Object Obj2;
    Object local_5c;
    Object Help;
    Object local_4c;
    ObjectType Target;
    Object local_3c [4];
    Object local_2c;
    Object Obj2_1;
    
                    // try { // try from 0807acfb to 0807b14b has its CatchHandler @ 0807b160
    bVar2 = Object::exists(Obj);
    if (bVar2) {
        bVar2 = Object::exists(Start);
        if (bVar2) {
            Object::getObjectType(&local_2c);
            if (local_2c.ObjectID != 0) {
                return;
            }
            Object::getObjectType(&local_2c);
            bVar2 = ObjectType::getFlag((ObjectType *)&local_2c,SEPARATIONEVENT);
            if (bVar2) {
                local_3c[0] = (Object)Start->ObjectID;
                GetFirstContainerObject(&local_2c);
                OVar1.ObjectID = local_5c.ObjectID;
                do {
                    do {
                        local_5c.ObjectID = OVar1.ObjectID;
                        bVar2 = false;
                        local_3c[0].ObjectID = NONE.ObjectID;
                        local_4c.ObjectID = NONE.ObjectID;
                        if ((local_2c.ObjectID != NONE.ObjectID) &&
                           (bVar3 = Object::exists(&local_2c), bVar3)) {
                            bVar2 = true;
                        }
                        if (!bVar2) goto LAB_0807ad65;
                        local_4c.ObjectID = local_2c.ObjectID;
                        Object::getNextObject(&local_5c);
                        local_2c.ObjectID = local_5c.ObjectID;
                        local_3c[0].ObjectID = local_5c.ObjectID;
                        uVar5 = Obj->ObjectID;
                        OVar1.ObjectID = local_4c.ObjectID;
                    } while (uVar5 == local_4c.ObjectID);
                    if (uVar5 == local_5c.ObjectID) {
                        Object::getNextObject(&local_6c);
                        local_2c.ObjectID = local_6c.ObjectID;
                        uVar5 = Obj->ObjectID;
                    }
                    local_6c.ObjectID = local_4c.ObjectID;
                    local_3c[0].ObjectID = NONE.ObjectID;
                    local_5c.ObjectID = uVar5;
                    HandleEvent(EVENT_SEPARATION,local_3c,&local_5c,&local_6c);
                    bVar2 = Object::exists(Obj);
                    OVar1.ObjectID = local_5c.ObjectID;
                } while (bVar2);
            }
            else {
LAB_0807ad65:
                local_5c = (Object)Start->ObjectID;
                GetFirstContainerObject(&local_6c);
                do {
                    do {
                        bVar2 = false;
                        local_5c.ObjectID = NONE.ObjectID;
                        local_4c.ObjectID = NONE.ObjectID;
                        if ((local_6c.ObjectID != NONE.ObjectID) &&
                           (bVar3 = Object::exists(&local_6c), bVar3)) {
                            bVar2 = true;
                        }
                        if (!bVar2) {
                            return;
                        }
                        local_5c.ObjectID = local_6c.ObjectID;
                        Object::getNextObject(local_3c);
                        local_6c.ObjectID = local_3c[0].ObjectID;
                        local_4c = (Object)Obj->ObjectID;
                    } while (local_5c.ObjectID == local_4c.ObjectID);
                    if (local_3c[0].ObjectID == local_4c.ObjectID) {
                        Object::getNextObject(&local_2c);
                        local_3c[0].ObjectID = local_2c.ObjectID;
                    }
                    local_6c.ObjectID = local_3c[0].ObjectID;
                    Object::getObjectType(&local_4c);
                    if (local_4c.ObjectID == 99) {
                        Object::getObjectType(&local_4c);
                        bVar2 = ObjectType::getFlag((ObjectType *)&local_4c,LEVELDOOR);
                        if (!bVar2) {
                            Object::getObjectType(&local_4c);
                            bVar2 = ObjectType::getFlag((ObjectType *)&local_4c,QUESTDOOR);
                            if (!bVar2) goto LAB_0807ae44;
                        }
                        Object::getObjectType(local_3c);
                        bVar2 = ObjectType::getFlag((ObjectType *)local_3c,LEVELDOOR);
                        Object::getObjectType(local_3c);
                        uVar5 = ObjectType::getAttribute
                                          ((ObjectType *)local_3c,!bVar2 + LEVELDOORTARGET);
                        ObjectType::setTypeID((ObjectType *)&local_4c,uVar5);
                        bVar2 = false;
                        ObjectType::setTypeID((ObjectType *)local_3c,0);
                        if ((local_4c.ObjectID == local_3c[0].ObjectID) ||
                           (bVar3 = ObjectType::getFlag((ObjectType *)&local_4c,UNPASS), !bVar3)) {
                            bVar2 = true;
                        }
                        if (!bVar2) {
                            local_3c[0] = (Object)Obj->ObjectID;
                            local_2c.ObjectID = local_5c.ObjectID;
                            ClearField(&local_2c,local_3c);
                            ObjectType::setTypeID((ObjectType *)local_3c,local_4c.ObjectID);
                            local_2c.ObjectID = local_5c.ObjectID;
                            Change(&local_2c,(ObjectType *)local_3c,0);
                            return;
                        }
                        Object::getObjectType(&local_2c);
                        error(&DAT_080f98c0,local_2c.ObjectID);
                        goto LAB_0807afdc;
                    }
LAB_0807ae44:
                    Object::getObjectType(&local_4c);
                    bVar2 = ObjectType::getFlag((ObjectType *)&local_4c,SEPARATIONEVENT);
                    if (bVar2) {
                        local_4c = (Object)Obj->ObjectID;
                        local_3c[0].ObjectID = local_5c.ObjectID;
                        local_2c.ObjectID = NONE.ObjectID;
                        HandleEvent(EVENT_SEPARATION,&local_2c,local_3c,&local_4c);
                    }
                    bVar2 = Object::exists(Obj);
                } while (bVar2);
            }
            puVar4 = (undefined4 *)__cxa_allocate_exception(4);
            *puVar4 = 0x1f;
            goto LAB_0807ae92;
        }
        Text = &DAT_080f9920;
    }
    else {
        Text = &DAT_080f9960;
    }
    error(Text);
LAB_0807afdc:
    puVar4 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar4 = 0xffffffff;
LAB_0807ae92:
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar4,&RESULT::typeinfo,0);
}



void CollisionEvent(Object *Obj,Object *Dest)

{
    Object OVar1;
    bool bVar2;
    bool bVar3;
    undefined4 *puVar4;
    ulong uVar5;
    char *Text;
    Object *pOVar6;
    int local_9c;
    int dx_1;
    int dy_1;
    int dz_1;
    int x_1;
    int y_1;
    int z_1;
    int dx;
    int dy;
    int dz;
    int x;
    int y;
    int z;
    Object Obj2;
    Object local_5c;
    Object Help;
    Object local_4c;
    Object Obj2_1;
    Object local_3c;
    Object Help_1;
    Object local_2c [7];
    
                    // try { // try from 0807b19b to 0807b86b has its CatchHandler @ 0807b890
    bVar2 = Object::exists(Obj);
    if (bVar2) {
        bVar2 = Object::exists(Dest);
        if (bVar2) {
            Object::getObjectType(local_2c);
            if (local_2c[0].ObjectID != 0) {
                return;
            }
            Object::getObjectType(local_2c);
            bVar2 = ObjectType::getFlag((ObjectType *)local_2c,TELEPORTABSOLUTE);
            if (bVar2) {
LAB_0807b228:
                Object::getObjectType(local_2c);
                bVar2 = ObjectType::getFlag((ObjectType *)local_2c,TELEPORTABSOLUTE);
                if (bVar2) {
                    Object::getAttribute(Obj,ABSTELEPORTDESTINATION);
                    UnpackAbsoluteCoordinate();
                }
                else {
                    local_2c[0] = (Object)Obj->ObjectID;
                    GetObjectCoordinates(local_2c,&dz,&x,&y);
                    Object::getObjectType(local_2c);
                    ObjectType::getAttribute((ObjectType *)local_2c,RELTELEPORTDISPLACEMENT);
                    UnpackRelativeCoordinate();
                    dz = dz + z_1;
                    x = x + dx;
                    y = y + dy;
                }
                local_2c[0].ObjectID = NONE.ObjectID;
                GetMapContainer((int)&local_3c,dz,x);
                Object::getNextObject(&local_4c);
                MoveAllObjects(&local_4c,&local_3c,local_2c,true);
                Object::getObjectType(&local_4c);
                bVar2 = ObjectType::getFlag((ObjectType *)&local_4c,TELEPORTABSOLUTE);
                Object::getObjectType(&local_4c);
                ObjectType::getAttribute
                          ((ObjectType *)&local_4c,(uint)!bVar2 * 2 + ABSTELEPORTEFFECT);
                pOVar6 = (Object *)x;
                GraphicalEffect();
                bVar2 = Object::exists(Obj);
                if (bVar2) {
                    return;
                }
            }
            else {
                Object::getObjectType(local_2c);
                bVar2 = ObjectType::getFlag((ObjectType *)local_2c,TELEPORTRELATIVE);
                if (bVar2) goto LAB_0807b228;
                Object::getObjectType(&local_4c);
                bVar2 = ObjectType::getFlag((ObjectType *)&local_4c,COLLISIONEVENT);
                if (bVar2) {
                    local_3c = (Object)Dest->ObjectID;
                    GetFirstContainerObject(&local_4c);
                    OVar1.ObjectID = local_5c.ObjectID;
                    do {
                        do {
                            local_5c.ObjectID = OVar1.ObjectID;
                            bVar2 = false;
                            local_3c.ObjectID = NONE.ObjectID;
                            local_2c[0].ObjectID = NONE.ObjectID;
                            if ((local_4c.ObjectID != NONE.ObjectID) &&
                               (bVar3 = Object::exists(&local_4c), bVar3)) {
                                bVar2 = true;
                            }
                            if (!bVar2) goto LAB_0807b41e;
                            local_3c.ObjectID = local_4c.ObjectID;
                            Object::getNextObject(&local_5c);
                            local_4c.ObjectID = local_5c.ObjectID;
                            local_2c[0].ObjectID = local_5c.ObjectID;
                            uVar5 = Obj->ObjectID;
                            OVar1.ObjectID = local_3c.ObjectID;
                        } while (uVar5 == local_3c.ObjectID);
                        if (uVar5 == local_5c.ObjectID) {
                            Object::getNextObject((Object *)&z);
                            local_4c.ObjectID = z;
                            uVar5 = Obj->ObjectID;
                        }
                        z = local_3c.ObjectID;
                        local_2c[0].ObjectID = NONE.ObjectID;
                        pOVar6 = local_2c;
                        local_5c.ObjectID = uVar5;
                        HandleEvent(EVENT_COLLISION,local_2c,&local_5c,(Object *)&z);
                        bVar2 = Object::exists(Obj);
                        OVar1.ObjectID = local_5c.ObjectID;
                    } while (bVar2);
                }
                else {
LAB_0807b41e:
                    local_5c = (Object)Dest->ObjectID;
                    GetFirstContainerObject((Object *)&z);
                    do {
                        do {
                            bVar2 = false;
                            local_5c.ObjectID = NONE.ObjectID;
                            local_4c.ObjectID = NONE.ObjectID;
                            if ((z != NONE.ObjectID) &&
                               (bVar3 = Object::exists((Object *)&z), bVar3)) {
                                bVar2 = true;
                            }
                            if (!bVar2) {
                                return;
                            }
                            local_5c.ObjectID = z;
                            Object::getNextObject(&local_3c);
                            z = local_3c.ObjectID;
                            local_4c = (Object)Obj->ObjectID;
                        } while (local_5c.ObjectID == local_4c.ObjectID);
                        if (local_3c.ObjectID == local_4c.ObjectID) {
                            Object::getNextObject(local_2c);
                            local_3c.ObjectID = local_2c[0].ObjectID;
                        }
                        z = local_3c.ObjectID;
                        Object::getObjectType(&local_4c);
                        bVar2 = ObjectType::getFlag((ObjectType *)&local_4c,TELEPORTABSOLUTE);
                        if (bVar2) {
LAB_0807b4e5:
                            Object::getObjectType(&local_4c);
                            bVar2 = ObjectType::getFlag((ObjectType *)&local_4c,TELEPORTABSOLUTE);
                            if (bVar2) {
                                Object::getAttribute(&local_5c,ABSTELEPORTDESTINATION);
                                UnpackAbsoluteCoordinate();
                            }
                            else {
                                local_4c.ObjectID = local_5c.ObjectID;
                                GetObjectCoordinates(&local_4c,&dz_1,&x_1,&y_1);
                                Object::getObjectType(&local_4c);
                                ObjectType::getAttribute
                                          ((ObjectType *)&local_4c,RELTELEPORTDISPLACEMENT);
                                UnpackRelativeCoordinate();
                                dz_1 = dz_1 + local_9c;
                                x_1 = x_1 + dx_1;
                                y_1 = y_1 + dy_1;
                            }
                            local_4c = (Object)Obj->ObjectID;
                            GetMapContainer((int)&local_3c,dz_1,x_1);
                            MoveOneObject(&local_4c,&local_3c);
                            Object::getObjectType(&local_4c);
                            bVar2 = ObjectType::getFlag((ObjectType *)&local_4c,TELEPORTABSOLUTE);
                            Object::getObjectType(&local_4c);
                            ObjectType::getAttribute
                                      ((ObjectType *)&local_4c,(uint)!bVar2 * 2 + ABSTELEPORTEFFECT)
                            ;
                            pOVar6 = (Object *)x_1;
                            GraphicalEffect();
                        }
                        else {
                            Object::getObjectType(&local_4c);
                            bVar2 = ObjectType::getFlag((ObjectType *)&local_4c,TELEPORTRELATIVE);
                            if (bVar2) goto LAB_0807b4e5;
                            Object::getObjectType(&local_4c);
                            pOVar6 = (Object *)0xd;
                            bVar2 = ObjectType::getFlag((ObjectType *)&local_4c,COLLISIONEVENT);
                            if (bVar2) {
                                local_4c = (Object)Obj->ObjectID;
                                local_3c.ObjectID = local_5c.ObjectID;
                                local_2c[0].ObjectID = NONE.ObjectID;
                                pOVar6 = local_2c;
                                HandleEvent(EVENT_COLLISION,local_2c,&local_3c,&local_4c);
                            }
                        }
                        bVar2 = Object::exists(Obj);
                    } while (bVar2);
                }
            }
            puVar4 = (undefined4 *)__cxa_allocate_exception(4,pOVar6);
            *puVar4 = 0x1f;
            goto LAB_0807b364;
        }
        Text = &DAT_080f99a0;
    }
    else {
        Text = &DAT_080f99e0;
    }
    error(Text);
    puVar4 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar4 = 0xffffffff;
LAB_0807b364:
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar4,&RESULT::typeinfo,0);
}



// WARNING: Variable defined which should be unmapped: z

void LoadParameters(TReadScriptFile *Script,int *Parameters,int NumberOfParameters,...)

{
    bool bVar1;
    char cVar2;
    int iVar3;
    ulong uVar4;
    char *pcVar5;
    char *pcVar6;
    char *pcVar7;
    undefined1 uVar8;
    char *Ident;
    int local_24;
    int i;
    va_list va;
    int x;
    int y;
    int z;
    
    if (5 < NumberOfParameters) {
        error("LoadParameters: Zu viele Parameter (%d).\n",NumberOfParameters);
        TReadScriptFile::error(Script,"too many parameters");
    }
    if (NumberOfParameters != 0) {
        if ((Script->Token != SPECIAL) ||
           (cVar2 = TReadScriptFile::getSpecial(Script), cVar2 != '(')) {
                    // try { // try from 0807b8eb to 0807bcc7 has its CatchHandler @ 0807bcd0
            TReadScriptFile::error(Script,"\'(\' expected");
        }
        local_24 = 0;
        i = (int)&stack0x00000010;
        if (0 < NumberOfParameters) {
            do {
                if (0 < local_24) {
                    TReadScriptFile::readSymbol(Script,',');
                }
                uVar8 = *(int *)i == 0xb;
                switch(*(int *)i) {
                case 0:
                    pcVar5 = TReadScriptFile::readIdentifier(Script);
                    iVar3 = 5;
                    pcVar6 = pcVar5;
                    pcVar7 = "null";
                    do {
                        if (iVar3 == 0) break;
                        iVar3 = iVar3 + -1;
                        uVar8 = *pcVar6 == *pcVar7;
                        pcVar6 = pcVar6 + 1;
                        pcVar7 = pcVar7 + 1;
                    } while ((bool)uVar8);
                    if ((bool)uVar8) {
LAB_0807ba55:
                        Parameters[local_24] = 0;
                    }
                    else {
                        iVar3 = 5;
                        pcVar6 = pcVar5;
                        pcVar7 = "obj1";
                        do {
                            if (iVar3 == 0) break;
                            iVar3 = iVar3 + -1;
                            uVar8 = *pcVar6 == *pcVar7;
                            pcVar6 = pcVar6 + 1;
                            pcVar7 = pcVar7 + 1;
                        } while ((bool)uVar8);
                        if ((bool)uVar8) {
                            Parameters[local_24] = 1;
                        }
                        else {
                            iVar3 = 5;
                            pcVar6 = pcVar5;
                            pcVar7 = "obj2";
                            do {
                                if (iVar3 == 0) break;
                                iVar3 = iVar3 + -1;
                                uVar8 = *pcVar6 == *pcVar7;
                                pcVar6 = pcVar6 + 1;
                                pcVar7 = pcVar7 + 1;
                            } while ((bool)uVar8);
                            if ((bool)uVar8) {
                                Parameters[local_24] = 2;
                            }
                            else {
                                iVar3 = 5;
                                pcVar6 = pcVar5;
                                pcVar7 = "user";
                                do {
                                    if (iVar3 == 0) break;
                                    iVar3 = iVar3 + -1;
                                    uVar8 = *pcVar6 == *pcVar7;
                                    pcVar6 = pcVar6 + 1;
                                    pcVar7 = pcVar7 + 1;
                                } while ((bool)uVar8);
                                if ((bool)uVar8) {
                                    Parameters[local_24] = 3;
                                }
                                else {
                                    iVar3 = 5;
                                    pcVar6 = "temp";
                                    do {
                                        if (iVar3 == 0) break;
                                        iVar3 = iVar3 + -1;
                                        uVar8 = *pcVar5 == *pcVar6;
                                        pcVar5 = pcVar5 + 1;
                                        pcVar6 = pcVar6 + 1;
                                    } while ((bool)uVar8);
                                    if (!(bool)uVar8) {
                                        pcVar5 = "Object expected";
                                        goto LAB_0807ba48;
                                    }
                                    Parameters[local_24] = 4;
                                }
                            }
                        }
                    }
                    break;
                case 1:
                    iVar3 = TReadScriptFile::readNumber(Script);
                    Parameters[local_24] = iVar3;
                    bVar1 = ObjectTypeExists(iVar3);
                    if (!bVar1) {
                        pcVar5 = "Unknown object type";
LAB_0807ba48:
                        TReadScriptFile::error(Script,pcVar5);
                    }
                    break;
                case 2:
                    pcVar5 = TReadScriptFile::readIdentifier(Script);
                    iVar3 = GetFlagByName(pcVar5);
                    Parameters[local_24] = iVar3;
                    if (iVar3 == -1) {
                        pcVar5 = "Unknown flag";
                        goto LAB_0807ba48;
                    }
                    break;
                case 3:
                    pcVar5 = TReadScriptFile::readIdentifier(Script);
                    iVar3 = GetTypeAttributeByName(pcVar5);
                    Parameters[local_24] = iVar3;
                    if (iVar3 == -1) {
                        pcVar5 = "Unknown type attribute";
                        goto LAB_0807ba48;
                    }
                    break;
                case 4:
                    pcVar5 = TReadScriptFile::readIdentifier(Script);
                    iVar3 = GetInstanceAttributeByName(pcVar5);
                    Parameters[local_24] = iVar3;
                    if (iVar3 == -1) {
                        pcVar5 = "Unknown instance attribute";
                        goto LAB_0807ba48;
                    }
                    break;
                case 5:
                    TReadScriptFile::readCoordinate(Script);
                    uVar4 = PackAbsoluteCoordinate((int)va,x,y);
                    goto LAB_0807bb56;
                case 6:
                    TReadScriptFile::readCoordinate(Script);
                    uVar4 = PackRelativeCoordinate((int)va,x,y);
                    goto LAB_0807bb9a;
                case 7:
                    pcVar5 = TReadScriptFile::readIdentifier(Script);
                    iVar3 = 0x10;
                    pcVar6 = pcVar5;
                    pcVar7 = "premium_account";
                    do {
                        if (iVar3 == 0) break;
                        iVar3 = iVar3 + -1;
                        uVar8 = *pcVar6 == *pcVar7;
                        pcVar6 = pcVar6 + 1;
                        pcVar7 = pcVar7 + 1;
                    } while ((bool)uVar8);
                    if ((bool)uVar8) goto LAB_0807ba55;
                    iVar3 = 0x10;
                    pcVar6 = "special_moveuse";
                    do {
                        if (iVar3 == 0) break;
                        iVar3 = iVar3 + -1;
                        uVar8 = *pcVar5 == *pcVar6;
                        pcVar5 = pcVar5 + 1;
                        pcVar6 = pcVar6 + 1;
                    } while ((bool)uVar8);
                    if (!(bool)uVar8) {
                        pcVar5 = "Unknown right";
                        goto LAB_0807ba48;
                    }
                    Parameters[local_24] = 0x37;
                    break;
                case 8:
                    pcVar5 = TReadScriptFile::readIdentifier(Script);
                    iVar3 = GetSkillByName(pcVar5);
                    Parameters[local_24] = iVar3;
                    if (iVar3 == -1) {
                        pcVar5 = "Unknown skill";
                        goto LAB_0807ba48;
                    }
                    break;
                case 9:
                    uVar4 = TReadScriptFile::readNumber(Script);
LAB_0807bb9a:
                    Parameters[local_24] = uVar4;
                    break;
                case 10:
                    pcVar5 = TReadScriptFile::readString(Script);
                    uVar4 = AddDynamicString(pcVar5);
LAB_0807bb56:
                    Parameters[local_24] = uVar4;
                    break;
                case 0xb:
                    cVar2 = TReadScriptFile::readSpecial(Script);
                    Parameters[local_24] = (int)cVar2;
                    pcVar5 = strchr("<L=G>N",(int)cVar2);
                    if (pcVar5 == (char *)0x0) {
                        pcVar5 = "Unknown comparison operator";
                        goto LAB_0807ba48;
                    }
                }
                local_24 = local_24 + 1;
                i = i + 4;
            } while (local_24 < NumberOfParameters);
        }
        TReadScriptFile::readSymbol(Script,')');
        TReadScriptFile::nextToken(Script);
    }
    return;
}



void LoadCondition(TReadScriptFile *Script,TMoveUseCondition *Condition)

{
    char *pcVar1;
    int iVar2;
    char *pcVar3;
    undefined1 uVar4;
    char local_3c [4];
    char Ident [30];
    
    uVar4 = &stack0x00000000 == (undefined1 *)0x5c;
                    // try { // try from 0807bd05 to 0807c4e2 has its CatchHandler @ 0807c4e8
    pcVar1 = TReadScriptFile::getIdentifier(Script);
    strcpy(local_3c,pcVar1);
    TReadScriptFile::nextToken(Script);
    iVar2 = 0xb;
    pcVar1 = local_3c;
    pcVar3 = "isposition";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Condition->Condition = CONDITION_ISPOSITION;
        uVar4 = Condition->Parameters == (int *)0x0;
        LoadParameters(Script,Condition->Parameters,2);
    }
    iVar2 = 7;
    pcVar1 = local_3c;
    pcVar3 = "istype";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Condition->Condition = CONDITION_ISTYPE;
        uVar4 = Condition->Parameters == (int *)0x0;
        LoadParameters(Script,Condition->Parameters,2);
    }
    iVar2 = 0xb;
    pcVar1 = local_3c;
    pcVar3 = "iscreature";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Condition->Condition = CONDITION_ISCREATURE;
        uVar4 = Condition->Parameters == (int *)0x0;
        LoadParameters(Script,Condition->Parameters,1);
    }
    iVar2 = 9;
    pcVar1 = local_3c;
    pcVar3 = "isplayer";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Condition->Condition = CONDITION_ISPLAYER;
        uVar4 = Condition->Parameters == (int *)0x0;
        LoadParameters(Script,Condition->Parameters,1);
    }
    iVar2 = 8;
    pcVar1 = local_3c;
    pcVar3 = "hasflag";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Condition->Condition = CONDITION_HASFLAG;
        uVar4 = Condition->Parameters == (int *)0x0;
        LoadParameters(Script,Condition->Parameters,2);
    }
    iVar2 = 0x11;
    pcVar1 = local_3c;
    pcVar3 = "hastypeattribute";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Condition->Condition = CONDITION_HASTYPEATTRIBUTE;
        uVar4 = Condition->Parameters == (int *)0x0;
        LoadParameters(Script,Condition->Parameters,4);
    }
    iVar2 = 0x15;
    pcVar1 = local_3c;
    pcVar3 = "hasinstanceattribute";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Condition->Condition = CONDITION_HASINSTANCEATTRIBUTE;
        uVar4 = Condition->Parameters == (int *)0x0;
        LoadParameters(Script,Condition->Parameters,4);
    }
    iVar2 = 8;
    pcVar1 = local_3c;
    pcVar3 = "hastext";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Condition->Condition = CONDITION_HASTEXT;
        uVar4 = Condition->Parameters == (int *)0x0;
        LoadParameters(Script,Condition->Parameters,2);
    }
    iVar2 = 0xb;
    pcVar1 = local_3c;
    pcVar3 = "ispeaceful";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Condition->Condition = CONDITION_ISPEACEFUL;
        uVar4 = Condition->Parameters == (int *)0x0;
        LoadParameters(Script,Condition->Parameters,1);
    }
    iVar2 = 10;
    pcVar1 = local_3c;
    pcVar3 = "maylogout";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Condition->Condition = CONDITION_MAYLOGOUT;
        uVar4 = Condition->Parameters == (int *)0x0;
        LoadParameters(Script,Condition->Parameters,1);
    }
    iVar2 = 0xe;
    pcVar1 = local_3c;
    pcVar3 = "hasprofession";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Condition->Condition = CONDITION_HASPROFESSION;
        uVar4 = Condition->Parameters == (int *)0x0;
        LoadParameters(Script,Condition->Parameters,2);
    }
    iVar2 = 9;
    pcVar1 = local_3c;
    pcVar3 = "haslevel";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Condition->Condition = CONDITION_HASLEVEL;
        uVar4 = Condition->Parameters == (int *)0x0;
        LoadParameters(Script,Condition->Parameters,3);
    }
    iVar2 = 9;
    pcVar1 = local_3c;
    pcVar3 = "hasright";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Condition->Condition = CONDITION_HASRIGHT;
        uVar4 = Condition->Parameters == (int *)0x0;
        LoadParameters(Script,Condition->Parameters,2);
    }
    iVar2 = 0xe;
    pcVar1 = local_3c;
    pcVar3 = "hasquestvalue";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Condition->Condition = CONDITION_HASQUESTVALUE;
        uVar4 = Condition->Parameters == (int *)0x0;
        LoadParameters(Script,Condition->Parameters,4);
    }
    iVar2 = 10;
    pcVar1 = local_3c;
    pcVar3 = "testskill";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Condition->Condition = CONDITION_TESTSKILL;
        uVar4 = Condition->Parameters == (int *)0x0;
        LoadParameters(Script,Condition->Parameters,4);
    }
    iVar2 = 0xd;
    pcVar1 = local_3c;
    pcVar3 = "countobjects";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Condition->Condition = CONDITION_COUNTOBJECTS;
        uVar4 = Condition->Parameters == (int *)0x0;
        LoadParameters(Script,Condition->Parameters,3);
    }
    iVar2 = 0x12;
    pcVar1 = local_3c;
    pcVar3 = "countobjectsonmap";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Condition->Condition = CONDITION_COUNTOBJECTSONMAP;
        uVar4 = Condition->Parameters == (int *)0x0;
        LoadParameters(Script,Condition->Parameters,3);
    }
    iVar2 = 0xe;
    pcVar1 = local_3c;
    pcVar3 = "isobjectthere";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Condition->Condition = CONDITION_ISOBJECTTHERE;
        uVar4 = Condition->Parameters == (int *)0x0;
        LoadParameters(Script,Condition->Parameters,2);
    }
    iVar2 = 0x10;
    pcVar1 = local_3c;
    pcVar3 = "iscreaturethere";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Condition->Condition = CONDITION_ISCREATURETHERE;
        uVar4 = Condition->Parameters == (int *)0x0;
        LoadParameters(Script,Condition->Parameters,1);
    }
    iVar2 = 0xe;
    pcVar1 = local_3c;
    pcVar3 = "isplayerthere";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Condition->Condition = CONDITION_ISPLAYERTHERE;
        uVar4 = Condition->Parameters == (int *)0x0;
        LoadParameters(Script,Condition->Parameters,1);
    }
    iVar2 = 0x14;
    pcVar1 = local_3c;
    pcVar3 = "isobjectininventory";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Condition->Condition = CONDITION_ISOBJECTININVENTORY;
        uVar4 = Condition->Parameters == (int *)0x0;
        LoadParameters(Script,Condition->Parameters,3);
    }
    iVar2 = 0x11;
    pcVar1 = local_3c;
    pcVar3 = "isprotectionzone";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Condition->Condition = CONDITION_ISPROTECTIONZONE;
        uVar4 = Condition->Parameters == (int *)0x0;
        LoadParameters(Script,Condition->Parameters,1);
    }
    iVar2 = 8;
    pcVar1 = local_3c;
    pcVar3 = "ishouse";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Condition->Condition = CONDITION_ISHOUSE;
        uVar4 = Condition->Parameters == (int *)0x0;
        LoadParameters(Script,Condition->Parameters,1);
    }
    iVar2 = 0xd;
    pcVar1 = local_3c;
    pcVar3 = "ishouseowner";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Condition->Condition = CONDITION_ISHOUSEOWNER;
        uVar4 = Condition->Parameters == (int *)0x0;
        LoadParameters(Script,Condition->Parameters,2);
    }
    iVar2 = 10;
    pcVar1 = local_3c;
    pcVar3 = "isdressed";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Condition->Condition = CONDITION_ISDRESSED;
        uVar4 = Condition->Parameters == (int *)0x0;
        LoadParameters(Script,Condition->Parameters,1);
    }
    iVar2 = 7;
    pcVar1 = local_3c;
    pcVar3 = "random";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Condition->Condition = CONDITION_RANDOM;
        LoadParameters(Script,Condition->Parameters,1);
    }
    return;
}



void LoadAction(TReadScriptFile *Script,TMoveUseAction *Action)

{
    char *pcVar1;
    int iVar2;
    char *pcVar3;
    undefined1 uVar4;
    char local_3c [4];
    char Ident [30];
    
    uVar4 = &stack0x00000000 == (undefined1 *)0x5c;
                    // try { // try from 0807c515 to 0807d0d8 has its CatchHandler @ 0807d0e0
    pcVar1 = TReadScriptFile::getIdentifier(Script);
    strcpy(local_3c,pcVar1);
    TReadScriptFile::nextToken(Script);
    iVar2 = 0xc;
    pcVar1 = local_3c;
    pcVar3 = "createonmap";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_CREATEONMAP;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,3);
    }
    iVar2 = 7;
    pcVar1 = local_3c;
    pcVar3 = "create";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_CREATE;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,3);
    }
    iVar2 = 0xd;
    pcVar1 = local_3c;
    pcVar3 = "monsteronmap";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_MONSTERONMAP;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,2);
    }
    iVar2 = 8;
    pcVar1 = local_3c;
    pcVar3 = "monster";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_MONSTER;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,2);
    }
    iVar2 = 0xc;
    pcVar1 = local_3c;
    pcVar3 = "effectonmap";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_EFFECTONMAP;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,2);
    }
    iVar2 = 7;
    pcVar1 = local_3c;
    pcVar3 = "effect";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_EFFECT;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,2);
    }
    iVar2 = 10;
    pcVar1 = local_3c;
    pcVar3 = "textonmap";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_TEXTONMAP;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,3);
    }
    iVar2 = 5;
    pcVar1 = local_3c;
    pcVar3 = "text";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_TEXT;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,3);
    }
    iVar2 = 0xc;
    pcVar1 = local_3c;
    pcVar3 = "changeonmap";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_CHANGEONMAP;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,4);
    }
    iVar2 = 7;
    pcVar1 = local_3c;
    pcVar3 = "change";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_CHANGE;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,3);
    }
    iVar2 = 10;
    pcVar1 = local_3c;
    pcVar3 = "changerel";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_CHANGEREL;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,5);
    }
    iVar2 = 0xd;
    pcVar1 = local_3c;
    pcVar3 = "setattribute";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_SETATTRIBUTE;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,3);
    }
    iVar2 = 0x10;
    pcVar1 = local_3c;
    pcVar3 = "changeattribute";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_CHANGEATTRIBUTE;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,3);
    }
    iVar2 = 0xe;
    pcVar1 = local_3c;
    pcVar3 = "setquestvalue";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_SETQUESTVALUE;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,3);
    }
    iVar2 = 7;
    pcVar1 = local_3c;
    pcVar3 = "damage";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_DAMAGE;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,4);
    }
    iVar2 = 9;
    pcVar1 = local_3c;
    pcVar3 = "setstart";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_SETSTART;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,2);
    }
    iVar2 = 10;
    pcVar1 = local_3c;
    pcVar3 = "writename";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_WRITENAME;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,3);
    }
    iVar2 = 10;
    pcVar1 = local_3c;
    pcVar3 = "writetext";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_WRITETEXT;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,2);
    }
    iVar2 = 7;
    pcVar1 = local_3c;
    pcVar3 = "logout";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_LOGOUT;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,1);
    }
    iVar2 = 0xd;
    pcVar1 = local_3c;
    pcVar3 = "moveallonmap";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_MOVEALLONMAP;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,2);
    }
    iVar2 = 8;
    pcVar1 = local_3c;
    pcVar3 = "moveall";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_MOVEALL;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,2);
    }
    iVar2 = 0xb;
    pcVar1 = local_3c;
    pcVar3 = "moveallrel";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_MOVEALLREL;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,2);
    }
    iVar2 = 0xd;
    pcVar1 = local_3c;
    pcVar3 = "movetoponmap";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_MOVETOPONMAP;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,3);
    }
    iVar2 = 8;
    pcVar1 = local_3c;
    pcVar3 = "movetop";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_MOVETOP;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,2);
    }
    iVar2 = 0xb;
    pcVar1 = local_3c;
    pcVar3 = "movetoprel";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_MOVETOPREL;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,2);
    }
    iVar2 = 5;
    pcVar1 = local_3c;
    pcVar3 = "move";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_MOVE;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,2);
    }
    iVar2 = 8;
    pcVar1 = local_3c;
    pcVar3 = "moverel";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_MOVEREL;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,3);
    }
    iVar2 = 9;
    pcVar1 = local_3c;
    pcVar3 = "retrieve";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_RETRIEVE;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,3);
    }
    iVar2 = 0xf;
    pcVar1 = local_3c;
    pcVar3 = "deleteallonmap";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_DELETEALLONMAP;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,1);
    }
    iVar2 = 0xf;
    pcVar1 = local_3c;
    pcVar3 = "deletetoponmap";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_DELETETOPONMAP;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,2);
    }
    iVar2 = 0xc;
    pcVar1 = local_3c;
    pcVar3 = "deleteonmap";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_DELETEONMAP;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,2);
    }
    iVar2 = 7;
    pcVar1 = local_3c;
    pcVar3 = "delete";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_DELETE;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,1);
    }
    iVar2 = 0x12;
    pcVar1 = local_3c;
    pcVar3 = "deleteininventory";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_DELETEININVENTORY;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,3);
    }
    iVar2 = 0xc;
    pcVar1 = local_3c;
    pcVar3 = "description";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_DESCRIPTION;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,2);
    }
    iVar2 = 10;
    pcVar1 = local_3c;
    pcVar3 = "loaddepot";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_LOADDEPOT;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,4);
    }
    iVar2 = 10;
    pcVar1 = local_3c;
    pcVar3 = "savedepot";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_SAVEDEPOT;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,4);
    }
    iVar2 = 9;
    pcVar1 = local_3c;
    pcVar3 = "sendmail";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_SENDMAIL;
        uVar4 = Action->Parameters == (int *)0x0;
        LoadParameters(Script,Action->Parameters,1);
    }
    iVar2 = 4;
    pcVar1 = local_3c;
    pcVar3 = "nop";
    do {
        if (iVar2 == 0) break;
        iVar2 = iVar2 + -1;
        uVar4 = *pcVar1 == *pcVar3;
        pcVar1 = pcVar1 + 1;
        pcVar3 = pcVar3 + 1;
    } while ((bool)uVar4);
    if ((bool)uVar4) {
        Action->Action = ACTION_NOP;
        LoadParameters(Script,Action->Parameters,0);
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void LoadDataBase(void)

{
    TReadScriptFile *Script_00;
    char cVar1;
    int i;
    int iVar2;
    TMoveUseAction *Action;
    TMoveUseRule *pTVar3;
    TMoveUseCondition *Condition_00;
    int *piVar4;
    int EventType;
    int iVar5;
    TMoveUseCondition *Condition;
    char *pcVar6;
    undefined1 uVar7;
    char *pcVar8;
    char local_501c [4];
    char Ident [30];
    TReadScriptFile Script;
    undefined1 local_101c [4];
    char FileName [4096];
    
                    // try { // try from 0807d121 to 0807d151 has its CatchHandler @ 0807d510
    print();
    pcVar8 = DATAPATH;
    Action = (TMoveUseAction *)local_101c;
    sprintf((char *)Action,"%s/moveuse.dat");
    TReadScriptFile::TReadScriptFile((TReadScriptFile *)(Ident + 0x1c));
                    // try { // try from 0807d15f to 0807d4d5 has its CatchHandler @ 0807d4f1
    TReadScriptFile::open((TReadScriptFile *)(Ident + 0x1c),(char *)Action,(int)pcVar8);
    piVar4 = &MoveUseDatabases[0].NumberOfRules;
    iVar2 = 4;
    do {
        *piVar4 = 0;
        piVar4 = piVar4 + 0xc;
        iVar2 = iVar2 + -1;
    } while (-1 < iVar2);
LAB_0807d183:
    TReadScriptFile::nextToken((TReadScriptFile *)(Ident + 0x1c));
    do {
        uVar7 = stack0xffffb004 == 0;
        if ((bool)uVar7) {
            TReadScriptFile::close((TReadScriptFile *)(Ident + 0x1c),(int)Action);
            pcVar8 = "Move/Use-Datenbank mit %d/%d/%d/%d/%d Regeln gelesen.\n";
            print();
                    // try { // try from 0807d4df to 0807d4e3 has its CatchHandler @ 0807d510
            TReadScriptFile::~TReadScriptFile((TReadScriptFile *)(Ident + 0x1c),(int)pcVar8);
            return;
        }
        Action = (TMoveUseAction *)TReadScriptFile::getIdentifier((TReadScriptFile *)(Ident + 0x1c))
        ;
        strcpy(local_501c,(char *)Action);
        iVar2 = 6;
        pcVar8 = local_501c;
        pcVar6 = "begin";
        do {
            if (iVar2 == 0) break;
            iVar2 = iVar2 + -1;
            uVar7 = *pcVar8 == *pcVar6;
            pcVar8 = pcVar8 + 1;
            pcVar6 = pcVar6 + 1;
        } while ((bool)uVar7);
        if ((bool)uVar7) {
            TReadScriptFile::readString((TReadScriptFile *)(Ident + 0x1c));
            goto LAB_0807d183;
        }
        iVar2 = 4;
        pcVar8 = local_501c;
        pcVar6 = "end";
        do {
            if (iVar2 == 0) break;
            iVar2 = iVar2 + -1;
            uVar7 = *pcVar8 == *pcVar6;
            pcVar8 = pcVar8 + 1;
            pcVar6 = pcVar6 + 1;
        } while ((bool)uVar7);
        if ((bool)uVar7) goto LAB_0807d183;
        iVar2 = 4;
        pcVar8 = local_501c;
        pcVar6 = "use";
        do {
            if (iVar2 == 0) break;
            iVar2 = iVar2 + -1;
            uVar7 = *pcVar8 == *pcVar6;
            pcVar8 = pcVar8 + 1;
            pcVar6 = pcVar6 + 1;
        } while ((bool)uVar7);
        iVar5 = -1;
        iVar2 = 9;
        if ((bool)uVar7) {
            iVar5 = 0;
        }
        pcVar8 = local_501c;
        pcVar6 = "multiuse";
        do {
            if (iVar2 == 0) break;
            iVar2 = iVar2 + -1;
            uVar7 = *pcVar8 == *pcVar6;
            pcVar8 = pcVar8 + 1;
            pcVar6 = pcVar6 + 1;
        } while ((bool)uVar7);
        iVar2 = 9;
        if ((bool)uVar7) {
            iVar5 = 1;
        }
        pcVar8 = local_501c;
        pcVar6 = "movement";
        do {
            if (iVar2 == 0) break;
            iVar2 = iVar2 + -1;
            uVar7 = *pcVar8 == *pcVar6;
            pcVar8 = pcVar8 + 1;
            pcVar6 = pcVar6 + 1;
        } while ((bool)uVar7);
        iVar2 = 10;
        if ((bool)uVar7) {
            iVar5 = 2;
        }
        pcVar8 = local_501c;
        pcVar6 = "collision";
        do {
            if (iVar2 == 0) break;
            iVar2 = iVar2 + -1;
            uVar7 = *pcVar8 == *pcVar6;
            pcVar8 = pcVar8 + 1;
            pcVar6 = pcVar6 + 1;
        } while ((bool)uVar7);
        iVar2 = 0xb;
        if ((bool)uVar7) {
            iVar5 = 3;
        }
        pcVar8 = local_501c;
        pcVar6 = "separation";
        do {
            if (iVar2 == 0) break;
            iVar2 = iVar2 + -1;
            uVar7 = *pcVar8 == *pcVar6;
            pcVar8 = pcVar8 + 1;
            pcVar6 = pcVar6 + 1;
        } while ((bool)uVar7);
        if ((bool)uVar7) {
            iVar5 = 4;
        }
        if (iVar5 == -1) {
            TReadScriptFile::error((TReadScriptFile *)(Ident + 0x1c),"Unknown event type");
        }
        iVar2 = MoveUseDatabases[iVar5].NumberOfRules + 1;
        MoveUseDatabases[iVar5].NumberOfRules = iVar2;
        pTVar3 = vector<>::operator()(&MoveUseDatabases[iVar5].Rules,iVar2);
        pTVar3->FirstCondition = NumberOfMoveUseConditions + 1;
        TReadScriptFile::readSymbol((TReadScriptFile *)(Ident + 0x1c),',');
        do {
            TReadScriptFile::nextToken((TReadScriptFile *)(Ident + 0x1c));
            NumberOfMoveUseConditions = NumberOfMoveUseConditions + 1;
            Condition_00 = vector<>::operator()(&MoveUseConditions,NumberOfMoveUseConditions);
            Condition_00->Modifier = MODIFIER_NORMAL;
            if (stack0xffffb004 == 6) {
                cVar1 = TReadScriptFile::getSpecial((TReadScriptFile *)(Ident + 0x1c));
                if (cVar1 == '!') {
                    Condition_00->Modifier = MODIFIER_INVERT;
                }
                else {
                    if ((stack0xffffb004 != 6) ||
                       (cVar1 = TReadScriptFile::getSpecial((TReadScriptFile *)(Ident + 0x1c)),
                       cVar1 != '~')) goto LAB_0807d301;
                    Condition_00->Modifier = MODIFIER_TRUE;
                }
                TReadScriptFile::nextToken((TReadScriptFile *)(Ident + 0x1c));
            }
LAB_0807d301:
            LoadCondition((TReadScriptFile *)(Ident + 0x1c),Condition_00);
            if (stack0xffffb004 != 6) goto LAB_0807d33a;
            cVar1 = TReadScriptFile::getSpecial((TReadScriptFile *)(Ident + 0x1c));
        } while (cVar1 == ',');
        if ((stack0xffffb004 != 6) ||
           (cVar1 = TReadScriptFile::getSpecial((TReadScriptFile *)(Ident + 0x1c)), cVar1 != 'I')) {
LAB_0807d33a:
            TReadScriptFile::error((TReadScriptFile *)(Ident + 0x1c),"\'->\' expected");
        }
        pTVar3->LastCondition = NumberOfMoveUseConditions;
        TReadScriptFile::nextToken((TReadScriptFile *)(Ident + 0x1c));
        pTVar3->FirstAction = NumberOfMoveUseActions + 1;
        while( true ) {
            NumberOfMoveUseActions = NumberOfMoveUseActions + 1;
            Action = vector<>::operator()(&MoveUseActions,NumberOfMoveUseActions);
            Script_00 = (TReadScriptFile *)(Ident + 0x1c);
            LoadAction(Script_00,Action);
            if ((stack0xffffb004 != 6) ||
               (cVar1 = TReadScriptFile::getSpecial(Script_00), cVar1 != ',')) break;
            TReadScriptFile::nextToken(Script_00);
        }
        if (stack0xffffb004 == 3) {
            TReadScriptFile::nextToken((TReadScriptFile *)(Ident + 0x1c));
        }
        pTVar3->LastAction = NumberOfMoveUseActions;
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void InitMoveUse(void)

{
    NumberOfMoveUseConditions = 0;
    NumberOfMoveUseActions = 0;
                    // try { // try from 0807d534 to 0807d538 has its CatchHandler @ 0807d545
    LoadDataBase();
    DelayedMails = 0;
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ExitMoveUse(void)

{
    TDelayedMail *pTVar1;
    int i;
    int i_00;
    int iVar2;
    
    if ((0 < DelayedMails) && (i_00 = 0, 0 < DelayedMails)) {
        do {
            iVar2 = i_00 + 1;
            pTVar1 = vector<>::operator()(&DelayedMail,i_00);
            error("ExitMoveUse: Paket an %ld wurde nicht zugestellt.\n",pTVar1->CharacterID);
            i_00 = iVar2;
        } while (iVar2 < DelayedMails);
    }
    return;
}



void __tcf_0(void *param_1)

{
    if (MoveUseConditions.entry == (TMoveUseCondition *)0x0) {
        return;
    }
    operator_delete__(MoveUseConditions.entry);
    return;
}



void __tcf_1(void *param_1)

{
    if (MoveUseActions.entry == (TMoveUseAction *)0x0) {
        return;
    }
    operator_delete__(MoveUseActions.entry);
    return;
}



void __tcf_2(void *param_1)

{
    TMoveUseRule *pTVar1;
    TMoveUseDatabase *pTVar2;
    TMoveUseDatabase *pTVar3;
    
    pTVar2 = (TMoveUseDatabase *)&DAT_081c0710;
    while (pTVar2 != MoveUseDatabases) {
        pTVar3 = pTVar2 + -1;
        pTVar1 = pTVar2[-1].Rules.entry;
        pTVar2 = pTVar3;
        if (pTVar1 != (TMoveUseRule *)0x0) {
            operator_delete__(pTVar1);
        }
    }
    return;
}



void __tcf_3(void *param_1)

{
    if (DelayedMail.entry == (TDelayedMail *)0x0) {
        return;
    }
    operator_delete__(DelayedMail.entry);
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__I_MoveUseConditions(void)

{
    __static_initialization_and_destruction_0(1,0xffff);
    return;
}

void __static_initialization_and_destruction_0(int __initialize_p,int __priority)

{
    if ((__priority == 0xffff) && (__initialize_p == 1)) {
        NONE.ObjectID = 0;
    }
    return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__I_SpellSyllable(void)

{
    __static_initialization_and_destruction_0(1,0xffff);
    return;
}



// DWARF original prototype: void
// ~basic_stringbuf(basic_stringbuf<char,std::char_traits<char>,std::allocator<char>_> * this, int
// __in_chrg)

void __thiscall basic_stringbuf<>::~basic_stringbuf(basic_stringbuf<> *this,int __in_chrg)

{
    int *piVar1;
    int iVar2;
    int iVar3;
    size_t __size;
    
    *(undefined4 *)this = 0x8128a08;
    iVar3 = *(int *)(this + 0x50);
    LOCK();
    piVar1 = (int *)(iVar3 + -4);
    iVar2 = *piVar1;
    *piVar1 = *piVar1 + -1;
    UNLOCK();
    if (iVar2 < 1) {
                    // try { // try from 0808deb4 to 0808deb8 has its CatchHandler @ 0808debb
        std::__default_alloc_template<true,0>::deallocate
                  ((void *)(iVar3 + -0xc),*(int *)(iVar3 + -8) + 0xd);
    }
    *(undefined4 *)this = 0x81289c8;
    this[0x10] = (basic_stringbuf<>)0x0;
    *(undefined4 *)(this + 8) = 0;
    *(undefined4 *)(this + 0xc) = 0;
    *(undefined4 *)(this + 0x2c) = 0;
    std::locale::~locale((locale *)(this + 0x30));
    return;
}



// DWARF original name: _S_construct<const char*>

char * basic_string<>::_S_construct<>(void)

{
    undefined1 uVar1;
    uint *puVar2;
    uint *__dest;
    _Rep *__r;
    uint __n;
    void *in_stack_00000004;
    void *in_stack_00000008;
    allocator *in_stack_0000000c;
    
    __n = (int)in_stack_00000008 - (int)in_stack_00000004;
    if (in_stack_00000004 == in_stack_00000008) {
        LOCK();
        std::string::_S_empty_rep_storage._8_4_ = std::string::_S_empty_rep_storage._8_4_ + 1;
        UNLOCK();
        __dest = (uint *)(std::string::_S_empty_rep_storage + 0xc);
    }
    else {
        if (in_stack_00000004 == (void *)0x0) {
            std::__throw_logic_error("attempt to create string with null pointer");
        }
        puVar2 = (uint *)std::string::_Rep::_S_create(__n,in_stack_0000000c);
        __dest = puVar2 + 3;
        memcpy(__dest,in_stack_00000004,__n);
        uVar1 = std::string::_Rep::_S_terminal;
        *puVar2 = __n;
        *(undefined1 *)(__n + 0xc + (int)puVar2) = uVar1;
    }
    return (char *)__dest;
}



void __static_initialization_and_destruction_0(int __initialize_p,int __priority)

{
    undefined4 *puVar1;
    TParty *this;
    int iVar2;
    TChannel *this_00;
    int local_18;
    
    if (__priority == 0xffff) {
        if (__initialize_p == 1) {
            NONE.ObjectID = 0;
            TChannel::TChannel(&Channel.init);
            Channel.max = 0x12;
            Channel.space = 0x13;
            Channel.min = 0;
            Channel.start = 0;
            Channel.block = 10;
            Channel.initialized = false;
                    // try { // try from 0808e13b to 0808e13f has its CatchHandler @ 0808e23b
            puVar1 = (undefined4 *)operator_new__(0x808);
            *puVar1 = 0x13;
            local_18 = 0x12;
            this_00 = (TChannel *)(puVar1 + 1);
            do {
                    // try { // try from 0808e158 to 0808e15c has its CatchHandler @ 0808e1a5
                TChannel::TChannel(this_00);
                local_18 = local_18 + -1;
                this_00 = this_00 + 1;
            } while (local_18 != -1);
            Channel.entry = (TChannel *)(puVar1 + 1);
            __cxa_atexit(__tcf_0,0,&__dso_handle);
        }
        if (__initialize_p == 1) {
            Statements.Entry = (TStatement *)operator_new__(0x7000);
            Statements.Size = 0x400;
            Statements.Head = -1;
            Statements.Tail = 0;
            __cxa_atexit(__tcf_1,0,&__dso_handle);
            Listeners.Entry = (TListener *)operator_new__(0x2000);
            Listeners.Size = 0x400;
            Listeners.Head = -1;
            Listeners.Tail = 0;
            __cxa_atexit(__tcf_2,0,&__dso_handle);
            TParty::TParty(&Party.init);
            Party.min = 0;
            Party.max = 100;
            Party.start = 0;
            Party.space = 0x65;
            Party.block = 0x32;
            Party.initialized = false;
                    // try { // try from 0808e009 to 0808e00d has its CatchHandler @ 0808e2b2
            puVar1 = (undefined4 *)operator_new__(0x1e00);
            *puVar1 = 0x65;
            iVar2 = 100;
            this = (TParty *)(puVar1 + 1);
            do {
                    // try { // try from 0808e021 to 0808e025 has its CatchHandler @ 0808e240
                TParty::TParty(this);
                iVar2 = iVar2 + -1;
                this = this + 1;
            } while (iVar2 != -1);
            Party.entry = (TParty *)(puVar1 + 1);
            __cxa_atexit(__tcf_3,0,&__dso_handle);
        }
    }
    return;
}

void __tcf_0(void *param_1)

{
    ulong *puVar1;
    TChannel *pTVar2;
    TChannel *pTVar3;
    
    if (Channel.entry != (TChannel *)0x0) {
        pTVar2 = Channel.entry + Channel.entry[-1].InvitedPlayers;
        while (Channel.entry != pTVar2) {
            pTVar3 = pTVar2 + -1;
            puVar1 = pTVar2[-1].InvitedPlayer.entry;
            if (puVar1 != (ulong *)0x0) {
                operator_delete__(puVar1);
            }
            puVar1 = pTVar2[-1].Subscriber.entry;
            pTVar2 = pTVar3;
            if (puVar1 != (ulong *)0x0) {
                operator_delete__(puVar1);
            }
        }
        operator_delete__(&Channel.entry[-1].InvitedPlayers);
    }
    if (Channel.init.InvitedPlayer.entry != (ulong *)0x0) {
        operator_delete__(Channel.init.InvitedPlayer.entry);
    }
    if (Channel.init.Subscriber.entry != (ulong *)0x0) {
        operator_delete__(Channel.init.Subscriber.entry);
        return;
    }
    return;
}



void __tcf_1(void *param_1)

{
    if (Statements.Entry == (TStatement *)0x0) {
        return;
    }
    operator_delete__(Statements.Entry);
    return;
}



void __tcf_2(void *param_1)

{
    if (Listeners.Entry == (TListener *)0x0) {
        return;
    }
    operator_delete__(Listeners.Entry);
    return;
}



void __tcf_3(void *param_1)

{
    ulong *puVar1;
    TParty *pTVar2;
    TParty *pTVar3;
    
    if (Party.entry != (TParty *)0x0) {
        pTVar2 = Party.entry + Party.entry[-1].InvitedPlayers;
        while (Party.entry != pTVar2) {
            pTVar3 = pTVar2 + -1;
            puVar1 = pTVar2[-1].InvitedPlayer.entry;
            if (puVar1 != (ulong *)0x0) {
                operator_delete__(puVar1);
            }
            puVar1 = pTVar2[-1].Member.entry;
            pTVar2 = pTVar3;
            if (puVar1 != (ulong *)0x0) {
                operator_delete__(puVar1);
            }
        }
        operator_delete__(&Party.entry[-1].InvitedPlayers);
    }
    if (Party.init.InvitedPlayer.entry != (ulong *)0x0) {
        operator_delete__(Party.init.InvitedPlayer.entry);
    }
    if (Party.init.Member.entry != (ulong *)0x0) {
        operator_delete__(Party.init.Member.entry);
        return;
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__I_Channel(void)

{
    __static_initialization_and_destruction_0(1,0xffff);
    return;
}

void __static_initialization_and_destruction_0(int __initialize_p,int __priority)

{
    vector<> *pvVar1;
    priority_queue_entry<> *ppVar2;
    vector<> *pvVar3;
    priority_queue_entry<> *ppVar4;
    int i;
    int iVar5;
    TRaceData *this;
    int local_14;
    
    if (__priority == 0xffff) {
        if (__initialize_p == 1) {
            NONE.ObjectID = 0;
            CreatureList.initialized = true;
            CreatureList.max = 10000;
            CreatureList.space = 0x2711;
            CreatureList.block = 1000;
            CreatureList.start = 0;
            CreatureList.min = 0;
            CreatureList.init = (TCreature *)0x0;
            CreatureList.entry = (TCreature **)operator_new__(0x9c44);
            iVar5 = 0;
            if (0 < CreatureList.space) {
                do {
                    CreatureList.entry[iVar5] = (TCreature *)0x0;
                    iVar5 = iVar5 + 1;
                } while (iVar5 < CreatureList.space);
            }
            __cxa_atexit(__tcf_0,0,&__dso_handle);
        }
        if (__initialize_p == 1) {
            local_14 = 0x1ff;
            this = RaceData;
            do {
                    // try { // try from 0809dd7f to 0809dd83 has its CatchHandler @ 0809de53
                TRaceData::TRaceData(this);
                local_14 = local_14 + -1;
                this = this + 1;
            } while (local_14 != -1);
            __cxa_atexit(__tcf_1,0,&__dso_handle);
        }
        if (__initialize_p == 1) {
            pvVar3 = (vector<> *)operator_new(0x24);
            pvVar3->min = 1;
            pvVar3->max = 5000;
            pvVar3->start = 1;
            pvVar3->space = 5000;
            pvVar3->block = 1000;
            pvVar3->initialized = false;
                    // try { // try from 0809dd38 to 0809dd3c has its CatchHandler @ 0809dee5
            ppVar4 = (priority_queue_entry<> *)operator_new__(40000);
            pvVar3->entry = ppVar4;
            ToDoQueue.Entries = 0;
            ToDoQueue.Entry = pvVar3;
            __cxa_atexit(__tcf_2,0,&__dso_handle);
            pvVar1 = (vector<> *)operator_new(0x24);
            pvVar1->min = 1;
            pvVar1->max = 100;
            pvVar1->start = 1;
            pvVar1->space = 100;
            pvVar1->block = 100;
            pvVar1->initialized = false;
                    // try { // try from 0809dcc6 to 0809dcca has its CatchHandler @ 0809df01
            ppVar2 = (priority_queue_entry<> *)operator_new__(800);
            pvVar1->entry = ppVar2;
            AttackWaveQueue.Entries = 0;
            AttackWaveQueue.Entry = pvVar1;
            __cxa_atexit(__tcf_3,0,&__dso_handle);
        }
    }
    return;
}

void __tcf_0(void *param_1)

{
    if (CreatureList.entry == (TCreature **)0x0) {
        return;
    }
    operator_delete__(CreatureList.entry);
    return;
}



void __tcf_1(void *param_1)

{
    int *piVar1;
    int *piVar2;
    ulong *puVar3;
    
    puVar3 = &NextCreatureID;
    piVar1 = KilledCreatures + 0x24;
    while ((TRaceData *)puVar3 != RaceData) {
        piVar2 = piVar1 + -0x54;
        puVar3 = (ulong *)((int)puVar3 + -0x150);
        if ((void *)piVar1[-0x2d] != (void *)0x0) {
            operator_delete__((void *)piVar1[-0x2d]);
        }
        if ((void *)piVar1[-0x40] != (void *)0x0) {
            operator_delete__((void *)piVar1[-0x40]);
        }
        if ((void *)piVar1[-0x4b] != (void *)0x0) {
            operator_delete__((void *)piVar1[-0x4b]);
        }
        piVar1 = piVar2;
        if ((void *)*piVar2 != (void *)0x0) {
            operator_delete__((void *)*piVar2);
        }
    }
    return;
}



void __tcf_2(void *param_1)

{
    vector<> *pvVar1;
    
    pvVar1 = ToDoQueue.Entry;
    if (ToDoQueue.Entry != (vector<> *)0x0) {
        if ((ToDoQueue.Entry)->entry != (priority_queue_entry<> *)0x0) {
            operator_delete__((ToDoQueue.Entry)->entry);
        }
        operator_delete(pvVar1);
        return;
    }
    return;
}



void __tcf_3(void *param_1)

{
    vector<> *pvVar1;
    
    pvVar1 = AttackWaveQueue.Entry;
    if (AttackWaveQueue.Entry != (vector<> *)0x0) {
        if ((AttackWaveQueue.Entry)->entry != (priority_queue_entry<> *)0x0) {
            operator_delete__((AttackWaveQueue.Entry)->entry);
        }
        operator_delete(pvVar1);
        return;
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__I_HashList(void)

{
    __static_initialization_and_destruction_0(1,0xffff);
    return;
}

void __static_initialization_and_destruction_0(int __initialize_p,int __priority)

{
    int i;
    int iVar1;
    
    if (__priority == 0xffff) {
        if (__initialize_p == 1) {
            NONE.ObjectID = 0;
            PlayerList.initialized = true;
            PlayerList.max = 100;
            PlayerList.space = 0x65;
            PlayerList.block = 10;
            PlayerList.start = 0;
            PlayerList.min = 0;
            PlayerList.init = (TPlayer *)0x0;
            PlayerList.entry = (TPlayer **)operator_new__(0x194);
            iVar1 = 0;
            if (0 < PlayerList.space) {
                do {
                    PlayerList.entry[iVar1] = (TPlayer *)0x0;
                    iVar1 = iVar1 + 1;
                } while (iVar1 < PlayerList.space);
            }
            __cxa_atexit(__tcf_0,0,&__dso_handle);
        }
        if (__initialize_p == 1) {
            Semaphore::Semaphore(&PlayerMutex,1);
            __cxa_atexit(__tcf_1,0,&__dso_handle);
            Semaphore::Semaphore(&PlayerDataPoolMutex,1);
            __cxa_atexit(__tcf_2,0,&__dso_handle);
            PlayerIndexInternalNodes.Units = (list<> *)operator_new(8);
            (PlayerIndexInternalNodes.Units)->firstNode = (listnode<> *)0x0;
            (PlayerIndexInternalNodes.Units)->lastNode = (listnode<> *)0x0;
            PlayerIndexInternalNodes.firstFreeItem = (storeitem<> *)0x0;
            __cxa_atexit(__tcf_3,0,&__dso_handle);
            PlayerIndexLeafNodes.Units = (list<> *)operator_new(8);
            (PlayerIndexLeafNodes.Units)->firstNode = (listnode<> *)0x0;
            (PlayerIndexLeafNodes.Units)->lastNode = (listnode<> *)0x0;
            PlayerIndexLeafNodes.firstFreeItem = (storeitem<> *)0x0;
            __cxa_atexit(__tcf_4,0,&__dso_handle);
        }
    }
    return;
}

void __tcf_0(void *param_1)

{
    if (PlayerList.entry == (TPlayer **)0x0) {
        return;
    }
    operator_delete__(PlayerList.entry);
    return;
}



void __tcf_1(void *param_1)

{
    int in_stack_00000008;
    
    Semaphore::~Semaphore(&PlayerMutex,in_stack_00000008);
    return;
}



void __tcf_2(void *param_1)

{
    int in_stack_00000008;
    
    Semaphore::~Semaphore(&PlayerDataPoolMutex,in_stack_00000008);
    return;
}



void __tcf_3(void *param_1)

{
    listnode<> *plVar1;
    list<> *plVar2;
    listnode<> *plVar3;
    
    plVar2 = PlayerIndexInternalNodes.Units;
    if (PlayerIndexInternalNodes.Units != (list<> *)0x0) {
        plVar1 = (PlayerIndexInternalNodes.Units)->firstNode;
        while (plVar1 != (listnode<> *)0x0) {
            plVar3 = plVar1->prev;
            if (plVar3 == (listnode<> *)0x0) {
                plVar2->firstNode = plVar1->next;
                plVar3 = plVar1->prev;
            }
            else {
                plVar3->next = plVar1->next;
            }
            if (plVar1->next == (listnode<> *)0x0) {
                plVar2->lastNode = plVar3;
            }
            else {
                plVar1->next->prev = plVar3;
            }
            operator_delete(plVar1);
            plVar1 = plVar2->firstNode;
        }
        operator_delete(plVar2);
        return;
    }
    return;
}



void __tcf_4(void *param_1)

{
    listnode<> *plVar1;
    list<> *plVar2;
    listnode<> *plVar3;
    
    plVar2 = PlayerIndexLeafNodes.Units;
    if (PlayerIndexLeafNodes.Units != (list<> *)0x0) {
        plVar1 = (PlayerIndexLeafNodes.Units)->firstNode;
        while (plVar1 != (listnode<> *)0x0) {
            plVar3 = plVar1->prev;
            if (plVar3 == (listnode<> *)0x0) {
                plVar2->firstNode = plVar1->next;
                plVar3 = plVar1->prev;
            }
            else {
                plVar3->next = plVar1->next;
            }
            if (plVar1->next == (listnode<> *)0x0) {
                plVar2->lastNode = plVar3;
            }
            else {
                plVar1->next->prev = plVar3;
            }
            operator_delete(plVar1);
            plVar1 = plVar2->firstNode;
        }
        operator_delete(plVar2);
        return;
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__I_PlayerList(void)

{
    __static_initialization_and_destruction_0(1,0xffff);
    return;
}

void __static_initialization_and_destruction_0(int __initialize_p,int __priority)

{
    int i;
    int iVar1;
    
    if (__priority == 0xffff) {
        if (__initialize_p == 1) {
            NONE.ObjectID = 0;
            NonplayerList.initialized = true;
            NonplayerList.max = 10000;
            NonplayerList.min = 0;
            NonplayerList.space = 0x2711;
            NonplayerList.init = (TNonplayer *)0x0;
            NonplayerList.start = 0;
            NonplayerList.block = 1000;
            NonplayerList.entry = (TNonplayer **)operator_new__(0x9c44);
            iVar1 = 0;
            if (0 < NonplayerList.space) {
                do {
                    NonplayerList.entry[iVar1] = (TNonplayer *)0x0;
                    iVar1 = iVar1 + 1;
                } while (iVar1 < NonplayerList.space);
            }
            __cxa_atexit(__tcf_0,0,&__dso_handle);
        }
        if (__initialize_p == 1) {
            Monsterhome.initialized = false;
            Monsterhome.space = 5000;
            Monsterhome.min = 1;
            Monsterhome.max = 5000;
            Monsterhome.start = 1;
            Monsterhome.block = 1000;
            Monsterhome.entry = (TMonsterhome *)operator_new__(180000);
            __cxa_atexit(__tcf_1,0,&__dso_handle);
        }
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

TNode * NewNode(void)

{
    TNode *Node;
    TNode *pTVar1;
    int in_stack_00000004;
    TNode *in_stack_00000008;
    TNode *in_stack_0000000c;
    
    pTVar1 = store<TNode,256>::getFreeItem(NodeTable);
    pTVar1->Type = in_stack_00000004;
    pTVar1->Left = in_stack_00000008;
    pTVar1->Right = in_stack_0000000c;
    return pTVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

TNode * NewNode(void)

{
    TNode *Node;
    TNode *pTVar1;
    int in_stack_00000004;
    int in_stack_00000008;
    
    pTVar1 = store<TNode,256>::getFreeItem(NodeTable);
    pTVar1->Type = in_stack_00000004;
    pTVar1->Left = (TNode *)0x0;
    pTVar1->Right = (TNode *)0x0;
    pTVar1->Data = in_stack_00000008;
    return pTVar1;
}



void DeleteNode(TNode *Node)

{
    store<TNode,256> *psVar1;
    
    if (Node != (TNode *)0x0) {
        DeleteNode(Node->Left);
        DeleteNode(Node->Right);
        psVar1 = NodeTable;
        Node->Type = (int)NodeTable->firstFreeItem;
        psVar1->firstFreeItem = (storeitem<TNode> *)Node;
    }
    return;
}



// DWARF original prototype: bool set(TCondition * this, int Type, void * Data)

bool __thiscall TCondition::set(TCondition *this,int Type,void *Data)

{
    ulong uVar1;
    int iVar2;
    char *pcVar3;
    char *pcVar4;
    bool bVar5;
    
    if ((Type != 5) && (Data == (void *)0x0)) {
        error("TCondition::set: Data ist NULL.\n");
        this->Type = 0;
        return false;
    }
    this->Type = Type;
    bVar5 = Type == 5;
    switch(Type) {
    default:
        error(&DAT_08104a80,Type);
        return false;
    case 1:
        uVar1 = AddDynamicString((char *)Data);
        this->Text = uVar1;
        break;
    case 2:
        this->Property = 0;
        iVar2 = 8;
        pcVar3 = (char *)Data;
        pcVar4 = "address";
        do {
            if (iVar2 == 0) break;
            iVar2 = iVar2 + -1;
            bVar5 = *pcVar3 == *pcVar4;
            pcVar3 = pcVar3 + 1;
            pcVar4 = pcVar4 + 1;
        } while (bVar5);
        if (bVar5) {
            this->Property = 1;
        }
        iVar2 = 5;
        pcVar3 = (char *)Data;
        pcVar4 = "busy";
        do {
            if (iVar2 == 0) break;
            iVar2 = iVar2 + -1;
            bVar5 = *pcVar3 == *pcVar4;
            pcVar3 = pcVar3 + 1;
            pcVar4 = pcVar4 + 1;
        } while (bVar5);
        if (bVar5) {
            this->Property = 2;
        }
        iVar2 = 7;
        pcVar3 = (char *)Data;
        pcVar4 = "vanish";
        do {
            if (iVar2 == 0) break;
            iVar2 = iVar2 + -1;
            bVar5 = *pcVar3 == *pcVar4;
            pcVar3 = pcVar3 + 1;
            pcVar4 = pcVar4 + 1;
        } while (bVar5);
        if (bVar5) {
            this->Property = 3;
        }
        iVar2 = 5;
        pcVar3 = (char *)Data;
        pcVar4 = "male";
        do {
            if (iVar2 == 0) break;
            iVar2 = iVar2 + -1;
            bVar5 = *pcVar3 == *pcVar4;
            pcVar3 = pcVar3 + 1;
            pcVar4 = pcVar4 + 1;
        } while (bVar5);
        if (bVar5) {
            this->Property = 4;
        }
        iVar2 = 7;
        pcVar3 = (char *)Data;
        pcVar4 = "female";
        do {
            if (iVar2 == 0) break;
            iVar2 = iVar2 + -1;
            bVar5 = *pcVar3 == *pcVar4;
            pcVar3 = pcVar3 + 1;
            pcVar4 = pcVar4 + 1;
        } while (bVar5);
        if (bVar5) {
            this->Property = 5;
        }
        iVar2 = 7;
        pcVar3 = (char *)Data;
        pcVar4 = "knight";
        do {
            if (iVar2 == 0) break;
            iVar2 = iVar2 + -1;
            bVar5 = *pcVar3 == *pcVar4;
            pcVar3 = pcVar3 + 1;
            pcVar4 = pcVar4 + 1;
        } while (bVar5);
        if (bVar5) {
            this->Property = 6;
        }
        iVar2 = 8;
        pcVar3 = (char *)Data;
        pcVar4 = "paladin";
        do {
            if (iVar2 == 0) break;
            iVar2 = iVar2 + -1;
            bVar5 = *pcVar3 == *pcVar4;
            pcVar3 = pcVar3 + 1;
            pcVar4 = pcVar4 + 1;
        } while (bVar5);
        if (bVar5) {
            this->Property = 7;
        }
        iVar2 = 9;
        pcVar3 = (char *)Data;
        pcVar4 = "sorcerer";
        do {
            if (iVar2 == 0) break;
            iVar2 = iVar2 + -1;
            bVar5 = *pcVar3 == *pcVar4;
            pcVar3 = pcVar3 + 1;
            pcVar4 = pcVar4 + 1;
        } while (bVar5);
        if (bVar5) {
            this->Property = 8;
        }
        iVar2 = 6;
        pcVar3 = (char *)Data;
        pcVar4 = "druid";
        do {
            if (iVar2 == 0) break;
            iVar2 = iVar2 + -1;
            bVar5 = *pcVar3 == *pcVar4;
            pcVar3 = pcVar3 + 1;
            pcVar4 = pcVar4 + 1;
        } while (bVar5);
        if (bVar5) {
            this->Property = 9;
        }
        iVar2 = 8;
        pcVar3 = (char *)Data;
        pcVar4 = "premium";
        do {
            if (iVar2 == 0) break;
            iVar2 = iVar2 + -1;
            bVar5 = *pcVar3 == *pcVar4;
            pcVar3 = pcVar3 + 1;
            pcVar4 = pcVar4 + 1;
        } while (bVar5);
        if (bVar5) {
            this->Property = 10;
        }
        iVar2 = 9;
        pcVar3 = (char *)Data;
        pcVar4 = "promoted";
        do {
            if (iVar2 == 0) break;
            iVar2 = iVar2 + -1;
            bVar5 = *pcVar3 == *pcVar4;
            pcVar3 = pcVar3 + 1;
            pcVar4 = pcVar4 + 1;
        } while (bVar5);
        if (bVar5) {
            this->Property = 0xb;
        }
        iVar2 = 8;
        pcVar3 = (char *)Data;
        pcVar4 = "pzblock";
        do {
            if (iVar2 == 0) break;
            iVar2 = iVar2 + -1;
            bVar5 = *pcVar3 == *pcVar4;
            pcVar3 = pcVar3 + 1;
            pcVar4 = pcVar4 + 1;
        } while (bVar5);
        if (bVar5) {
            this->Property = 0xc;
        }
        iVar2 = 7;
        pcVar3 = (char *)Data;
        pcVar4 = "nonpvp";
        do {
            if (iVar2 == 0) break;
            iVar2 = iVar2 + -1;
            bVar5 = *pcVar3 == *pcVar4;
            pcVar3 = pcVar3 + 1;
            pcVar4 = pcVar4 + 1;
        } while (bVar5);
        if (bVar5) {
            this->Property = 0xd;
        }
        iVar2 = 0xc;
        pcVar3 = "pvpenforced";
        do {
                    // WARNING: Load size is inaccurate
            if (iVar2 == 0) break;
            iVar2 = iVar2 + -1;
            bVar5 = *Data == *pcVar3;
            Data = (char *)((int)Data + 1);
            pcVar3 = pcVar3 + 1;
        } while (bVar5);
        if (bVar5) {
            this->Property = 0xe;
        }
        if (this->Property == 0) {
            return false;
        }
        return true;
    case 3:
                    // WARNING: Load size is inaccurate
        this->Number = *Data;
        break;
    case 4:
        this->Expression = (TNode *)Data;
        break;
    case 5:
        break;
    }
    return true;
}



// DWARF original prototype: void clear(TCondition * this)

void __thiscall TCondition::clear(TCondition *this)

{
    storeitem<TNode> *psVar1;
    store<TNode,256> *psVar2;
    int iVar3;
    
    iVar3 = this->Type;
    if ((iVar3 == 4) &&
       (psVar1 = (storeitem<TNode> *)this->Expression, psVar1 != (storeitem<TNode> *)0x0)) {
        DeleteNode((psVar1->data).Left);
        DeleteNode((psVar1->data).Right);
        psVar2 = NodeTable;
        psVar1->next = NodeTable->firstFreeItem;
        psVar2->firstFreeItem = psVar1;
        iVar3 = this->Type;
    }
    if (iVar3 == 1) {
        DeleteDynamicString(this->Text);
    }
    this->Type = 0;
    return;
}



// DWARF original prototype: bool set(TAction * this, int Type, void * Data, void * Data2, void *
// Data3, void * Data4)

bool __thiscall TAction::set(TAction *this)

{
    int iVar1;
    ulong uVar2;
    int in_stack_00000008;
    int *in_stack_0000000c;
    TNode *in_stack_00000010;
    TNode *in_stack_00000014;
    TNode *in_stack_00000018;
    
    this->Type = in_stack_00000008;
    switch(in_stack_00000008) {
    default:
        error(&DAT_08104b00);
        return false;
    case 1:
        uVar2 = AddDynamicString((char *)in_stack_0000000c);
        this->Text = uVar2;
        break;
    case 2:
    case 3:
    case 5:
        iVar1 = *in_stack_0000000c;
        this->Expression = in_stack_00000010;
        this->Number = iVar1;
        break;
    case 4:
    case 8:
        iVar1 = *in_stack_0000000c;
        this->Expression2 = in_stack_00000014;
        this->Expression = in_stack_00000010;
        this->Number = iVar1;
        break;
    case 6:
    case 7:
        this->Number = *in_stack_0000000c;
        break;
    case 9:
        break;
    case 10:
        iVar1 = *in_stack_0000000c;
        this->Expression2 = in_stack_00000014;
        this->Expression = in_stack_00000010;
        this->Number = iVar1;
        this->Expression3 = in_stack_00000018;
    }
    return true;
}



// DWARF original prototype: void clear(TAction * this)

void __thiscall TAction::clear(TAction *this)

{
    storeitem<TNode> *psVar1;
    store<TNode,256> *psVar2;
    int iVar3;
    
    iVar3 = this->Type;
    if ((((iVar3 - 2U < 4) || (iVar3 == 8)) || (iVar3 == 10)) &&
       (psVar1 = (storeitem<TNode> *)this->Expression, psVar1 != (storeitem<TNode> *)0x0)) {
        DeleteNode((psVar1->data).Left);
        DeleteNode((psVar1->data).Right);
        psVar2 = NodeTable;
        psVar1->next = NodeTable->firstFreeItem;
        psVar2->firstFreeItem = psVar1;
        iVar3 = this->Type;
    }
    if (((iVar3 == 4) || (iVar3 == 8)) || (iVar3 == 10)) {
        psVar1 = (storeitem<TNode> *)this->Expression2;
        if (psVar1 != (storeitem<TNode> *)0x0) {
            DeleteNode((psVar1->data).Left);
            DeleteNode((psVar1->data).Right);
            psVar2 = NodeTable;
            psVar1->next = NodeTable->firstFreeItem;
            psVar2->firstFreeItem = psVar1;
            iVar3 = this->Type;
        }
        if ((iVar3 == 10) &&
           (psVar1 = (storeitem<TNode> *)this->Expression3, psVar1 != (storeitem<TNode> *)0x0)) {
            DeleteNode((psVar1->data).Left);
            DeleteNode((psVar1->data).Right);
            psVar2 = NodeTable;
            psVar1->next = NodeTable->firstFreeItem;
            psVar2->firstFreeItem = psVar1;
            iVar3 = this->Type;
        }
    }
    if (iVar3 == 1) {
        DeleteDynamicString(this->Text);
    }
    this->Type = 0;
    return;
}



// DWARF original prototype: void TBehaviour(TBehaviour * this)

void __thiscall TBehaviour::TBehaviour(TBehaviour *this)

{
    vector<TCondition>::vector(&this->Condition,0,5,5);
                    // try { // try from 080b051d to 080b0521 has its CatchHandler @ 080b0540
    vector<TAction>::vector(&this->Action,0,5,5);
    this->Conditions = 0;
    this->Actions = 0;
    return;
}



// DWARF original prototype: void TBehaviour(TBehaviour * this)

void __thiscall TBehaviour::TBehaviour(TBehaviour *this)

{
    vector<TCondition>::vector(&this->Condition,0,5,5);
                    // try { // try from 080b05ad to 080b05b1 has its CatchHandler @ 080b05d0
    vector<TAction>::vector(&this->Action,0,5,5);
    this->Conditions = 0;
    this->Actions = 0;
    return;
}



// DWARF original prototype: void ~TBehaviour(TBehaviour * this, int __in_chrg)

void __thiscall TBehaviour::~TBehaviour(TBehaviour *this,int __in_chrg)

{
    TAction *pTVar1;
    TCondition *pTVar2;
    int i;
    int iVar3;
    int iVar4;
    
    iVar3 = 0;
    if (0 < this->Conditions) {
        do {
            iVar4 = iVar3 + 1;
            pTVar2 = vector<TCondition>::operator()(&this->Condition,iVar3);
            TCondition::clear(pTVar2);
            iVar3 = iVar4;
        } while (iVar4 < this->Conditions);
    }
    if (0 < this->Actions) {
        iVar3 = 0;
        do {
            iVar4 = iVar3 + 1;
            pTVar1 = vector<TAction>::operator()(&this->Action,iVar3);
            TAction::clear(pTVar1);
            iVar3 = iVar4;
        } while (iVar4 < this->Actions);
    }
    pTVar1 = (this->Action).entry;
    if (pTVar1 != (TAction *)0x0) {
        operator_delete__(pTVar1);
    }
    pTVar2 = (this->Condition).entry;
    if (pTVar2 != (TCondition *)0x0) {
        operator_delete__(pTVar2);
        return;
    }
    return;
}



// DWARF original prototype: void ~TBehaviour(TBehaviour * this, int __in_chrg)

void __thiscall TBehaviour::~TBehaviour(TBehaviour *this,int __in_chrg)

{
    TAction *pTVar1;
    TCondition *pTVar2;
    int i;
    int iVar3;
    int iVar4;
    
    iVar3 = 0;
    if (0 < this->Conditions) {
        do {
            iVar4 = iVar3 + 1;
            pTVar2 = vector<TCondition>::operator()(&this->Condition,iVar3);
            TCondition::clear(pTVar2);
            iVar3 = iVar4;
        } while (iVar4 < this->Conditions);
    }
    if (0 < this->Actions) {
        iVar3 = 0;
        do {
            iVar4 = iVar3 + 1;
            pTVar1 = vector<TAction>::operator()(&this->Action,iVar3);
            TAction::clear(pTVar1);
            iVar3 = iVar4;
        } while (iVar4 < this->Actions);
    }
    pTVar1 = (this->Action).entry;
    if (pTVar1 != (TAction *)0x0) {
        operator_delete__(pTVar1);
    }
    pTVar2 = (this->Condition).entry;
    if (pTVar2 != (TCondition *)0x0) {
        operator_delete__(pTVar2);
        return;
    }
    return;
}



// DWARF original prototype: bool addCondition(TBehaviour * this, int Type, void * Data)

bool __thiscall TBehaviour::addCondition(TBehaviour *this)

{
    bool bVar1;
    TCondition *this_00;
    int in_stack_00000008;
    void *in_stack_0000000c;
    
    this_00 = vector<TCondition>::operator()(&this->Condition,this->Conditions);
    bVar1 = TCondition::set(this_00,in_stack_00000008,in_stack_0000000c);
    if (bVar1) {
        this->Conditions = this->Conditions + 1;
    }
    return bVar1;
}



// DWARF original prototype: bool addAction(TBehaviour * this, int Type, void * Data, void * Data2,
// void * Data3, void * Data4)

bool __thiscall TBehaviour::addAction(TBehaviour *this)

{
    bool bVar1;
    TAction *this_00;
    
    this_00 = vector<TAction>::operator()(&this->Action,this->Actions);
    bVar1 = TAction::set(this_00);
    if (bVar1) {
        this->Actions = this->Actions + 1;
    }
    return bVar1;
}



// WARNING: Variable defined which should be unmapped: Nr
// DWARF original prototype: void TBehaviourDatabase(TBehaviourDatabase * this, TReadScriptFile *
// Script)

void __thiscall
TBehaviourDatabase::TBehaviourDatabase(TBehaviourDatabase *this,TReadScriptFile *Script)

{
    char cVar1;
    bool bVar2;
    TNode *Node;
    TNode *pTVar3;
    TNode *pTVar4;
    TBehaviour *pTVar5;
    TCondition *pTVar6;
    TAction *pTVar7;
    undefined4 uVar8;
    TOKEN TVar9;
    int iVar10;
    bool Success;
    char *pcVar11;
    TNode *Right;
    char *pcVar12;
    undefined1 uVar13;
    char *pcVar14;
    TNode *local_4c;
    TNode *Left_6;
    TNode *local_44;
    TNode *Left_10;
    TNode *Left_8;
    TNode *Left_16;
    TNode *Left_14;
    TNode *Left_12;
    TNode *Left_4;
    undefined4 local_28;
    int Type;
    TNode *Left_2;
    int Operator;
    TNode *Left;
    int Data;
    int Nr;
    
                    // try { // try from 080b07f7 to 080b07fb has its CatchHandler @ 080b1d30
    vector<TBehaviour>::vector(&this->Behaviour,0,0x32,0x19);
    this->Behaviours = 0;
                    // try { // try from 080b0815 to 080b0824 has its CatchHandler @ 080b1d20
    TReadScriptFile::readSymbol(Script,'{');
    TReadScriptFile::nextToken(Script);
LAB_080b0825:
    TVar9 = Script->Token;
    if (TVar9 != SPECIAL) goto LAB_080b0833;
    cVar1 = TReadScriptFile::getSpecial(Script);
    if (cVar1 == '}') {
        return;
    }
    TVar9 = Script->Token;
    if (TVar9 != SPECIAL) goto LAB_080b0833;
    cVar1 = TReadScriptFile::getSpecial(Script);
    if (cVar1 != 'I') {
LAB_080b0ae0:
        TVar9 = Script->Token;
LAB_080b0833:
        bVar2 = false;
        if (TVar9 == STRING) {
            pTVar5 = vector<TBehaviour>::operator()(&this->Behaviour,this->Behaviours);
            pcVar14 = TReadScriptFile::getString(Script);
            pTVar6 = vector<TCondition>::operator()(&pTVar5->Condition,pTVar5->Conditions);
            bVar2 = TCondition::set(pTVar6,1,pcVar14);
            if (bVar2) {
                pTVar5->Conditions = pTVar5->Conditions + 1;
            }
            TVar9 = Script->Token;
        }
        if (TVar9 == IDENTIFIER) {
            pTVar5 = vector<TBehaviour>::operator()(&this->Behaviour,this->Behaviours);
            pcVar14 = TReadScriptFile::getIdentifier(Script);
            pTVar6 = vector<TCondition>::operator()(&pTVar5->Condition,pTVar5->Conditions);
            bVar2 = TCondition::set(pTVar6,2,pcVar14);
            if (bVar2) {
                pTVar5->Conditions = pTVar5->Conditions + 1;
            }
            TVar9 = Script->Token;
        }
        if (TVar9 == SPECIAL) {
            cVar1 = TReadScriptFile::getSpecial(Script);
            if (cVar1 == '!') {
                pTVar5 = vector<TBehaviour>::operator()(&this->Behaviour,this->Behaviours);
                pTVar6 = vector<TCondition>::operator()(&pTVar5->Condition,pTVar5->Conditions);
                bVar2 = TCondition::set(pTVar6,5,(void *)0x0);
                if (bVar2) {
                    pTVar5->Conditions = pTVar5->Conditions + 1;
                }
                TVar9 = Script->Token;
            }
            else {
                TVar9 = Script->Token;
            }
            if ((TVar9 == SPECIAL) && (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == '%')) {
                Data = TReadScriptFile::readNumber(Script);
                if (2 < Data - 1U) {
                    TReadScriptFile::error(Script,"illegal ordinal number");
                }
                pTVar5 = vector<TBehaviour>::operator()(&this->Behaviour,this->Behaviours);
                pTVar6 = vector<TCondition>::operator()(&pTVar5->Condition,pTVar5->Conditions);
                bVar2 = TCondition::set(pTVar6,3,&Data);
                if (bVar2) {
                    pTVar5->Conditions = pTVar5->Conditions + 1;
                }
            }
        }
        if (!bVar2) {
                    // try { // try from 080b0865 to 080b08ad has its CatchHandler @ 080b1bd0
            Operator = (int)readValue(this,Script);
            while (TVar9 = Script->Token, TVar9 == SPECIAL) {
                cVar1 = TReadScriptFile::getSpecial(Script);
                if (cVar1 != '*') {
                    TVar9 = Script->Token;
                    break;
                }
                TReadScriptFile::nextToken(Script);
                pTVar3 = readValue(this,Script);
                pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
                pTVar4->Type = 9;
                pTVar4->Left = (TNode *)Operator;
                pTVar4->Right = pTVar3;
                Operator = (int)pTVar4;
            }
            do {
                if (TVar9 != SPECIAL) goto LAB_080b093c;
                    // try { // try from 080b08cf to 080b0921 has its CatchHandler @ 080b1c4a
                cVar1 = TReadScriptFile::getSpecial(Script);
                if ((cVar1 != '+') && (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 != '-')) {
                    if (Script->Token == SPECIAL) goto LAB_080b094f;
                    goto LAB_080b093c;
                }
                cVar1 = TReadScriptFile::getSpecial(Script);
                TReadScriptFile::nextToken(Script);
                pTVar3 = readFactor(this,Script);
                pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
                pTVar4->Type = (cVar1 != '+') + 7;
                pTVar4->Right = pTVar3;
                pTVar4->Left = (TNode *)Operator;
                TVar9 = Script->Token;
                Operator = (int)pTVar4;
            } while( true );
        }
        TReadScriptFile::nextToken(Script);
        goto LAB_080b0ac1;
    }
    goto LAB_080b0b09;
LAB_080b093c:
                    // try { // try from 080b094a to 080b0986 has its CatchHandler @ 080b1d20
    TReadScriptFile::error(Script,"relational operator expected");
LAB_080b094f:
    Left_2 = (TNode *)0x0;
    cVar1 = TReadScriptFile::getSpecial(Script);
    switch(cVar1) {
    case '<':
        Left_2 = (TNode *)0x1;
        break;
    case '=':
        Left_2 = (TNode *)0x3;
        break;
    case '>':
        Left_2 = (TNode *)0x2;
        break;
    default:
        TReadScriptFile::error(Script,"relational operator expected");
        break;
    case 'G':
        Left_2 = (TNode *)0x6;
        break;
    case 'L':
        Left_2 = (TNode *)0x5;
        break;
    case 'N':
        Left_2 = (TNode *)0x4;
    }
    TReadScriptFile::nextToken(Script);
                    // try { // try from 080b0994 to 080b09d9 has its CatchHandler @ 080b1c5b
    Type = (int)readValue(this,Script);
    while (TVar9 = Script->Token, TVar9 == SPECIAL) {
        cVar1 = TReadScriptFile::getSpecial(Script);
        if (cVar1 != '*') {
            TVar9 = Script->Token;
            break;
        }
        TReadScriptFile::nextToken(Script);
        pTVar3 = readValue(this,Script);
        pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
        pTVar4->Type = 9;
        pTVar4->Left = (TNode *)Type;
        pTVar4->Right = pTVar3;
        Type = (int)pTVar4;
    }
                    // try { // try from 080b09fb to 080b0a4d has its CatchHandler @ 080b1c70
    while ((TVar9 == SPECIAL &&
           ((cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == '+' ||
            (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == '-'))))) {
        cVar1 = TReadScriptFile::getSpecial(Script);
        TReadScriptFile::nextToken(Script);
        pTVar3 = readFactor(this,Script);
        pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
        pTVar4->Type = (cVar1 != '+') + 7;
        pTVar4->Right = pTVar3;
        pTVar4->Left = (TNode *)Type;
        TVar9 = Script->Token;
        Type = (int)pTVar4;
    }
                    // try { // try from 080b0a68 to 080b0f5a has its CatchHandler @ 080b1d20
    pTVar3 = store<TNode,256>::getFreeItem(NodeTable);
    pTVar3->Type = (int)Left_2;
    pTVar3->Left = (TNode *)Operator;
    pTVar3->Right = (TNode *)Type;
    pTVar5 = vector<TBehaviour>::operator()(&this->Behaviour,this->Behaviours);
    pTVar6 = vector<TCondition>::operator()(&pTVar5->Condition,pTVar5->Conditions);
    bVar2 = TCondition::set(pTVar6,4,pTVar3);
    if (bVar2) {
        pTVar5->Conditions = pTVar5->Conditions + 1;
    }
LAB_080b0ac1:
    if (Script->Token != SPECIAL) goto LAB_080b0af6;
    cVar1 = TReadScriptFile::getSpecial(Script);
    if (cVar1 != ',') goto LAB_080b0aea;
    TReadScriptFile::nextToken(Script);
    goto LAB_080b0ae0;
LAB_080b0aea:
    if ((Script->Token != SPECIAL) || (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 != 'I')) {
LAB_080b0af6:
        TReadScriptFile::error(Script,"\'->\' expected");
    }
LAB_080b0b09:
    TReadScriptFile::nextToken(Script);
    TVar9 = Script->Token;
    if (TVar9 == STRING) {
        pTVar5 = vector<TBehaviour>::operator()(&this->Behaviour,this->Behaviours);
        TReadScriptFile::getString(Script);
        pTVar7 = vector<TAction>::operator()(&pTVar5->Action,pTVar5->Actions);
        bVar2 = TAction::set(pTVar7);
        if (bVar2) {
            pTVar5->Actions = pTVar5->Actions + 1;
        }
        goto LAB_080b0be1;
    }
    uVar13 = TVar9 == IDENTIFIER;
    if ((bool)uVar13) {
        pcVar14 = TReadScriptFile::getIdentifier(Script);
        local_28 = 0xffffffff;
        iVar10 = 6;
        pcVar11 = pcVar14;
        pcVar12 = "topic";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 2;
        }
        iVar10 = 6;
        pcVar11 = pcVar14;
        pcVar12 = "price";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 2;
        }
        iVar10 = 7;
        pcVar11 = pcVar14;
        pcVar12 = "amount";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 2;
        }
        iVar10 = 5;
        pcVar11 = pcVar14;
        pcVar12 = "type";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 2;
        }
        iVar10 = 5;
        pcVar11 = pcVar14;
        pcVar12 = "data";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 2;
        }
        iVar10 = 3;
        pcVar11 = pcVar14;
        pcVar12 = "hp";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 3;
        }
        iVar10 = 8;
        pcVar11 = pcVar14;
        pcVar12 = "burning";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 8;
        }
        iVar10 = 7;
        pcVar11 = pcVar14;
        pcVar12 = "poison";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 8;
        }
        iVar10 = 0xe;
        pcVar11 = pcVar14;
        pcVar12 = "setquestvalue";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 4;
        }
        iVar10 = 9;
        pcVar11 = pcVar14;
        pcVar12 = "effectme";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 5;
        }
        iVar10 = 10;
        pcVar11 = pcVar14;
        pcVar12 = "effectopp";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 5;
        }
        iVar10 = 0xb;
        pcVar11 = pcVar14;
        pcVar12 = "profession";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 5;
        }
        iVar10 = 0xb;
        pcVar11 = pcVar14;
        pcVar12 = "teachspell";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 5;
        }
        iVar10 = 7;
        pcVar11 = pcVar14;
        pcVar12 = "summon";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 5;
        }
        iVar10 = 7;
        pcVar11 = pcVar14;
        pcVar12 = "create";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 5;
        }
        iVar10 = 7;
        pcVar11 = pcVar14;
        pcVar12 = "delete";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 5;
        }
        iVar10 = 0xc;
        pcVar11 = pcVar14;
        pcVar12 = "createmoney";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 6;
        }
        iVar10 = 0xc;
        pcVar11 = pcVar14;
        pcVar12 = "deletemoney";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 6;
        }
        iVar10 = 6;
        pcVar11 = pcVar14;
        pcVar12 = "queue";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 6;
        }
        iVar10 = 9;
        pcVar11 = pcVar14;
        pcVar12 = "teleport";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 10;
        }
        iVar10 = 0xe;
        pcVar11 = pcVar14;
        pcVar12 = "startposition";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 10;
        }
        iVar10 = 5;
        pcVar11 = pcVar14;
        pcVar12 = "idle";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 7;
        }
        iVar10 = 4;
        pcVar11 = "nop";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar14 == *pcVar11;
            pcVar14 = pcVar14 + 1;
            pcVar11 = pcVar11 + 1;
        } while ((bool)uVar13);
        uVar8 = 0;
        if (!(bool)uVar13) {
            uVar8 = local_28;
        }
        switch(uVar8) {
        case 0:
            goto switchD_080b0f21_caseD_0;
        default:
            pcVar14 = "unknown identifier";
            goto LAB_080b0b38;
        case 2:
        case 3:
            TReadScriptFile::readSymbol(Script,'=');
            TReadScriptFile::nextToken(Script);
            pTVar5 = vector<TBehaviour>::operator()(&this->Behaviour,this->Behaviours);
                    // try { // try from 080b0f68 to 080b0fb0 has its CatchHandler @ 080b1c72
            Left_12 = readValue(this,Script);
            while (TVar9 = Script->Token, TVar9 == SPECIAL) {
                cVar1 = TReadScriptFile::getSpecial(Script);
                if (cVar1 != '*') {
                    TVar9 = Script->Token;
                    break;
                }
                TReadScriptFile::nextToken(Script);
                pTVar3 = readValue(this,Script);
                pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
                pTVar4->Type = 9;
                pTVar4->Left = Left_12;
                pTVar4->Right = pTVar3;
                Left_12 = pTVar4;
            }
                    // try { // try from 080b0fd2 to 080b1024 has its CatchHandler @ 080b1c87
            while ((TVar9 == SPECIAL &&
                   ((cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == '+' ||
                    (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == '-'))))) {
                cVar1 = TReadScriptFile::getSpecial(Script);
                TReadScriptFile::nextToken(Script);
                pTVar3 = readFactor(this,Script);
                pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
                pTVar4->Type = (cVar1 != '+') + 7;
                pTVar4->Right = pTVar3;
                pTVar4->Left = Left_12;
                TVar9 = Script->Token;
                Left_12 = pTVar4;
            }
                    // try { // try from 080b1049 to 080b10cb has its CatchHandler @ 080b1d20
            pTVar7 = vector<TAction>::operator()(&pTVar5->Action,pTVar5->Actions);
            bVar2 = TAction::set(pTVar7);
            if (bVar2) {
                pTVar5->Actions = pTVar5->Actions + 1;
            }
            goto LAB_080b0b43;
        case 4:
        case 8:
            TReadScriptFile::readSymbol(Script,'(');
            TReadScriptFile::nextToken(Script);
                    // try { // try from 080b12a9 to 080b12f1 has its CatchHandler @ 080b1cd1
            Left_10 = readValue(this,Script);
            while (TVar9 = Script->Token, TVar9 == SPECIAL) {
                cVar1 = TReadScriptFile::getSpecial(Script);
                if (cVar1 != '*') {
                    TVar9 = Script->Token;
                    break;
                }
                TReadScriptFile::nextToken(Script);
                pTVar3 = readValue(this,Script);
                pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
                pTVar4->Type = 9;
                pTVar4->Left = Left_10;
                pTVar4->Right = pTVar3;
                Left_10 = pTVar4;
            }
            do {
                if (TVar9 != SPECIAL) goto LAB_080b1384;
                    // try { // try from 080b1313 to 080b1365 has its CatchHandler @ 080b1ce6
                cVar1 = TReadScriptFile::getSpecial(Script);
                if ((cVar1 != '+') && (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 != '-')) {
                    if ((Script->Token == SPECIAL) &&
                       (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == ','))
                    goto LAB_080b1397;
                    goto LAB_080b1384;
                }
                cVar1 = TReadScriptFile::getSpecial(Script);
                TReadScriptFile::nextToken(Script);
                pTVar3 = readFactor(this,Script);
                pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
                pTVar4->Type = (cVar1 != '+') + 7;
                pTVar4->Right = pTVar3;
                pTVar4->Left = Left_10;
                TVar9 = Script->Token;
                Left_10 = pTVar4;
            } while( true );
        case 5:
            TReadScriptFile::readSymbol(Script,'(');
            TReadScriptFile::nextToken(Script);
            pTVar5 = vector<TBehaviour>::operator()(&this->Behaviour,this->Behaviours);
                    // try { // try from 080b10dc to 080b1124 has its CatchHandler @ 080b1d05
            local_4c = readValue(this,Script);
            while (TVar9 = Script->Token, TVar9 == SPECIAL) {
                cVar1 = TReadScriptFile::getSpecial(Script);
                if (cVar1 != '*') {
                    TVar9 = Script->Token;
                    break;
                }
                TReadScriptFile::nextToken(Script);
                pTVar3 = readValue(this,Script);
                pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
                pTVar4->Type = 9;
                pTVar4->Left = local_4c;
                pTVar4->Right = pTVar3;
                local_4c = pTVar4;
            }
                    // try { // try from 080b1146 to 080b1198 has its CatchHandler @ 080b1c4a
            while ((TVar9 == SPECIAL &&
                   ((cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == '+' ||
                    (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == '-'))))) {
                cVar1 = TReadScriptFile::getSpecial(Script);
                TReadScriptFile::nextToken(Script);
                pTVar3 = readFactor(this,Script);
                pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
                pTVar4->Type = (cVar1 != '+') + 7;
                pTVar4->Right = pTVar3;
                pTVar4->Left = local_4c;
                TVar9 = Script->Token;
                local_4c = pTVar4;
            }
                    // try { // try from 080b11bd to 080b129b has its CatchHandler @ 080b1d20
            pTVar7 = vector<TAction>::operator()(&pTVar5->Action,pTVar5->Actions);
            bVar2 = TAction::set(pTVar7);
            if (bVar2) {
                pTVar5->Actions = pTVar5->Actions + 1;
            }
            if ((Script->Token != SPECIAL) ||
               (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 != ')')) {
                TReadScriptFile::error(Script,") expected");
            }
            goto LAB_080b0be1;
        case 6:
        case 7:
            pTVar5 = vector<TBehaviour>::operator()(&this->Behaviour,this->Behaviours);
            pTVar7 = vector<TAction>::operator()(&pTVar5->Action,pTVar5->Actions);
            goto LAB_080b0bcc;
        case 10:
            TReadScriptFile::readSymbol(Script,'(');
            TReadScriptFile::nextToken(Script);
                    // try { // try from 080b1538 to 080b1580 has its CatchHandler @ 080b1c89
            Left_14 = readValue(this,Script);
            while (TVar9 = Script->Token, TVar9 == SPECIAL) {
                cVar1 = TReadScriptFile::getSpecial(Script);
                if (cVar1 != '*') {
                    TVar9 = Script->Token;
                    break;
                }
                TReadScriptFile::nextToken(Script);
                pTVar3 = readValue(this,Script);
                pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
                pTVar4->Type = 9;
                pTVar4->Left = Left_14;
                pTVar4->Right = pTVar3;
                Left_14 = pTVar4;
            }
            do {
                if (TVar9 != SPECIAL) goto LAB_080b1613;
                    // try { // try from 080b15a2 to 080b15f4 has its CatchHandler @ 080b1c9e
                cVar1 = TReadScriptFile::getSpecial(Script);
                if ((cVar1 != '+') && (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 != '-')) {
                    if ((Script->Token == SPECIAL) &&
                       (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == ','))
                    goto LAB_080b1626;
                    goto LAB_080b1613;
                }
                cVar1 = TReadScriptFile::getSpecial(Script);
                TReadScriptFile::nextToken(Script);
                pTVar3 = readFactor(this,Script);
                pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
                pTVar4->Type = (cVar1 != '+') + 7;
                pTVar4->Right = pTVar3;
                pTVar4->Left = Left_14;
                TVar9 = Script->Token;
                Left_14 = pTVar4;
            } while( true );
        }
    }
    if ((TVar9 == SPECIAL) && (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == '*')) {
        iVar10 = this->Behaviours;
        if (iVar10 == 0) {
            TReadScriptFile::error(Script,"no previous pattern");
            iVar10 = this->Behaviours;
        }
        pTVar5 = vector<TBehaviour>::operator()(&this->Behaviour,iVar10);
        pTVar7 = vector<TAction>::operator()(&pTVar5->Action,pTVar5->Actions);
        goto LAB_080b0bcc;
    }
    pcVar14 = "illegal action";
LAB_080b0b38:
    TReadScriptFile::error(Script,pcVar14);
    goto LAB_080b0b43;
LAB_080b1613:
                    // try { // try from 080b1621 to 080b1630 has its CatchHandler @ 080b1d20
    TReadScriptFile::error(Script,", expected");
LAB_080b1626:
    TReadScriptFile::nextToken(Script);
                    // try { // try from 080b163e to 080b1686 has its CatchHandler @ 080b1ca0
    Left_16 = readValue(this,Script);
    while (TVar9 = Script->Token, TVar9 == SPECIAL) {
        cVar1 = TReadScriptFile::getSpecial(Script);
        if (cVar1 != '*') {
            TVar9 = Script->Token;
            break;
        }
        TReadScriptFile::nextToken(Script);
        pTVar3 = readValue(this,Script);
        pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
        pTVar4->Type = 9;
        pTVar4->Left = Left_16;
        pTVar4->Right = pTVar3;
        Left_16 = pTVar4;
    }
    do {
        if (TVar9 != SPECIAL) break;
                    // try { // try from 080b16a8 to 080b16fa has its CatchHandler @ 080b1cb5
        cVar1 = TReadScriptFile::getSpecial(Script);
        if ((cVar1 != '+') && (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 != '-')) {
            if ((Script->Token == SPECIAL) &&
               (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == ',')) goto LAB_080b172c;
            break;
        }
        cVar1 = TReadScriptFile::getSpecial(Script);
        TReadScriptFile::nextToken(Script);
        pTVar3 = readFactor(this,Script);
        pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
        pTVar4->Type = (cVar1 != '+') + 7;
        pTVar4->Right = pTVar3;
        pTVar4->Left = Left_16;
        TVar9 = Script->Token;
        Left_16 = pTVar4;
    } while( true );
                    // try { // try from 080b1727 to 080b1736 has its CatchHandler @ 080b1d20
    TReadScriptFile::error(Script,", expected");
LAB_080b172c:
    TReadScriptFile::nextToken(Script);
                    // try { // try from 080b1744 to 080b178c has its CatchHandler @ 080b1cb7
    Left_8 = readValue(this,Script);
    while (TVar9 = Script->Token, TVar9 == SPECIAL) {
        cVar1 = TReadScriptFile::getSpecial(Script);
        if (cVar1 != '*') {
            TVar9 = Script->Token;
            break;
        }
        TReadScriptFile::nextToken(Script);
        pTVar3 = readValue(this,Script);
        pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
        pTVar4->Type = 9;
        pTVar4->Left = Left_8;
        pTVar4->Right = pTVar3;
        Left_8 = pTVar4;
    }
    do {
        if (TVar9 != SPECIAL) break;
                    // try { // try from 080b17ae to 080b1800 has its CatchHandler @ 080b1ccc
        cVar1 = TReadScriptFile::getSpecial(Script);
        if ((cVar1 != '+') && (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 != '-')) {
            if ((Script->Token == SPECIAL) &&
               (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == ')')) goto LAB_080b182e;
            break;
        }
        cVar1 = TReadScriptFile::getSpecial(Script);
        TReadScriptFile::nextToken(Script);
        pTVar3 = readFactor(this,Script);
        pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
        pTVar4->Type = (cVar1 != '+') + 7;
        pTVar4->Right = pTVar3;
        pTVar4->Left = Left_8;
        TVar9 = Script->Token;
        Left_8 = pTVar4;
    } while( true );
                    // try { // try from 080b1829 to 080b1bb7 has its CatchHandler @ 080b1d20
    TReadScriptFile::error(Script,") expected");
LAB_080b182e:
    pTVar5 = vector<TBehaviour>::operator()(&this->Behaviour,this->Behaviours);
    pTVar7 = vector<TAction>::operator()(&pTVar5->Action,pTVar5->Actions);
    bVar2 = TAction::set(pTVar7);
    if (bVar2) {
        pTVar5->Actions = pTVar5->Actions + 1;
    }
switchD_080b0f21_caseD_0:
    goto LAB_080b0be1;
LAB_080b1384:
                    // try { // try from 080b1392 to 080b13a1 has its CatchHandler @ 080b1d20
    TReadScriptFile::error(Script,", expected");
LAB_080b1397:
    TReadScriptFile::nextToken(Script);
                    // try { // try from 080b13af to 080b13f7 has its CatchHandler @ 080b1ceb
    local_44 = readValue(this,Script);
    while (TVar9 = Script->Token, TVar9 == SPECIAL) {
        cVar1 = TReadScriptFile::getSpecial(Script);
        if (cVar1 != '*') {
            TVar9 = Script->Token;
            break;
        }
        TReadScriptFile::nextToken(Script);
        pTVar3 = readValue(this,Script);
        pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
        pTVar4->Type = 9;
        pTVar4->Left = local_44;
        pTVar4->Right = pTVar3;
        local_44 = pTVar4;
    }
    do {
        if (TVar9 != SPECIAL) break;
                    // try { // try from 080b1419 to 080b146b has its CatchHandler @ 080b1d00
        cVar1 = TReadScriptFile::getSpecial(Script);
        if ((cVar1 != '+') && (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 != '-')) {
            if ((Script->Token == SPECIAL) &&
               (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == ')')) goto LAB_080b1499;
            break;
        }
        cVar1 = TReadScriptFile::getSpecial(Script);
        TReadScriptFile::nextToken(Script);
        pTVar3 = readFactor(this,Script);
        pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
        pTVar4->Type = (cVar1 != '+') + 7;
        pTVar4->Right = pTVar3;
        pTVar4->Left = local_44;
        TVar9 = Script->Token;
        local_44 = pTVar4;
    } while( true );
                    // try { // try from 080b1494 to 080b152a has its CatchHandler @ 080b1d20
    TReadScriptFile::error(Script,") expected");
LAB_080b1499:
    pTVar5 = vector<TBehaviour>::operator()(&this->Behaviour,this->Behaviours);
    pTVar7 = vector<TAction>::operator()(&pTVar5->Action,pTVar5->Actions);
LAB_080b0bcc:
    bVar2 = TAction::set(pTVar7);
    if (bVar2) {
        pTVar5->Actions = pTVar5->Actions + 1;
    }
LAB_080b0be1:
    TReadScriptFile::nextToken(Script);
LAB_080b0b43:
    if ((Script->Token != SPECIAL) || (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 != ','))
    goto LAB_080b0b57;
    goto LAB_080b0b09;
LAB_080b0b57:
    this->Behaviours = this->Behaviours + 1;
    goto LAB_080b0825;
}



// WARNING: Variable defined which should be unmapped: Nr
// DWARF original prototype: void TBehaviourDatabase(TBehaviourDatabase * this, TReadScriptFile *
// Script)

void __thiscall
TBehaviourDatabase::TBehaviourDatabase(TBehaviourDatabase *this,TReadScriptFile *Script)

{
    char cVar1;
    bool bVar2;
    TNode *Node;
    TNode *pTVar3;
    TNode *pTVar4;
    TBehaviour *pTVar5;
    TCondition *pTVar6;
    TAction *pTVar7;
    undefined4 uVar8;
    TOKEN TVar9;
    int iVar10;
    bool Success;
    char *pcVar11;
    TNode *Right;
    char *pcVar12;
    undefined1 uVar13;
    char *pcVar14;
    TNode *local_4c;
    TNode *Left_6;
    TNode *local_44;
    TNode *Left_10;
    TNode *Left_8;
    TNode *Left_16;
    TNode *Left_14;
    TNode *Left_12;
    TNode *Left_4;
    undefined4 local_28;
    int Type;
    TNode *Left_2;
    int Operator;
    TNode *Left;
    int Data;
    int Nr;
    
                    // try { // try from 080b1d77 to 080b1d7b has its CatchHandler @ 080b32b0
    vector<TBehaviour>::vector(&this->Behaviour,0,0x32,0x19);
    this->Behaviours = 0;
                    // try { // try from 080b1d95 to 080b1da4 has its CatchHandler @ 080b32a0
    TReadScriptFile::readSymbol(Script,'{');
    TReadScriptFile::nextToken(Script);
LAB_080b1da5:
    TVar9 = Script->Token;
    if (TVar9 != SPECIAL) goto LAB_080b1db3;
    cVar1 = TReadScriptFile::getSpecial(Script);
    if (cVar1 == '}') {
        return;
    }
    TVar9 = Script->Token;
    if (TVar9 != SPECIAL) goto LAB_080b1db3;
    cVar1 = TReadScriptFile::getSpecial(Script);
    if (cVar1 != 'I') {
LAB_080b2060:
        TVar9 = Script->Token;
LAB_080b1db3:
        bVar2 = false;
        if (TVar9 == STRING) {
            pTVar5 = vector<TBehaviour>::operator()(&this->Behaviour,this->Behaviours);
            pcVar14 = TReadScriptFile::getString(Script);
            pTVar6 = vector<TCondition>::operator()(&pTVar5->Condition,pTVar5->Conditions);
            bVar2 = TCondition::set(pTVar6,1,pcVar14);
            if (bVar2) {
                pTVar5->Conditions = pTVar5->Conditions + 1;
            }
            TVar9 = Script->Token;
        }
        if (TVar9 == IDENTIFIER) {
            pTVar5 = vector<TBehaviour>::operator()(&this->Behaviour,this->Behaviours);
            pcVar14 = TReadScriptFile::getIdentifier(Script);
            pTVar6 = vector<TCondition>::operator()(&pTVar5->Condition,pTVar5->Conditions);
            bVar2 = TCondition::set(pTVar6,2,pcVar14);
            if (bVar2) {
                pTVar5->Conditions = pTVar5->Conditions + 1;
            }
            TVar9 = Script->Token;
        }
        if (TVar9 == SPECIAL) {
            cVar1 = TReadScriptFile::getSpecial(Script);
            if (cVar1 == '!') {
                pTVar5 = vector<TBehaviour>::operator()(&this->Behaviour,this->Behaviours);
                pTVar6 = vector<TCondition>::operator()(&pTVar5->Condition,pTVar5->Conditions);
                bVar2 = TCondition::set(pTVar6,5,(void *)0x0);
                if (bVar2) {
                    pTVar5->Conditions = pTVar5->Conditions + 1;
                }
                TVar9 = Script->Token;
            }
            else {
                TVar9 = Script->Token;
            }
            if ((TVar9 == SPECIAL) && (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == '%')) {
                Data = TReadScriptFile::readNumber(Script);
                if (2 < Data - 1U) {
                    TReadScriptFile::error(Script,"illegal ordinal number");
                }
                pTVar5 = vector<TBehaviour>::operator()(&this->Behaviour,this->Behaviours);
                pTVar6 = vector<TCondition>::operator()(&pTVar5->Condition,pTVar5->Conditions);
                bVar2 = TCondition::set(pTVar6,3,&Data);
                if (bVar2) {
                    pTVar5->Conditions = pTVar5->Conditions + 1;
                }
            }
        }
        if (!bVar2) {
                    // try { // try from 080b1de5 to 080b1e2d has its CatchHandler @ 080b3150
            Operator = (int)readValue(this,Script);
            while (TVar9 = Script->Token, TVar9 == SPECIAL) {
                cVar1 = TReadScriptFile::getSpecial(Script);
                if (cVar1 != '*') {
                    TVar9 = Script->Token;
                    break;
                }
                TReadScriptFile::nextToken(Script);
                pTVar3 = readValue(this,Script);
                pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
                pTVar4->Type = 9;
                pTVar4->Left = (TNode *)Operator;
                pTVar4->Right = pTVar3;
                Operator = (int)pTVar4;
            }
            do {
                if (TVar9 != SPECIAL) goto LAB_080b1ebc;
                    // try { // try from 080b1e4f to 080b1ea1 has its CatchHandler @ 080b31ca
                cVar1 = TReadScriptFile::getSpecial(Script);
                if ((cVar1 != '+') && (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 != '-')) {
                    if (Script->Token == SPECIAL) goto LAB_080b1ecf;
                    goto LAB_080b1ebc;
                }
                cVar1 = TReadScriptFile::getSpecial(Script);
                TReadScriptFile::nextToken(Script);
                pTVar3 = readFactor(this,Script);
                pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
                pTVar4->Type = (cVar1 != '+') + 7;
                pTVar4->Right = pTVar3;
                pTVar4->Left = (TNode *)Operator;
                TVar9 = Script->Token;
                Operator = (int)pTVar4;
            } while( true );
        }
        TReadScriptFile::nextToken(Script);
        goto LAB_080b2041;
    }
    goto LAB_080b2089;
LAB_080b1ebc:
                    // try { // try from 080b1eca to 080b1f06 has its CatchHandler @ 080b32a0
    TReadScriptFile::error(Script,"relational operator expected");
LAB_080b1ecf:
    Left_2 = (TNode *)0x0;
    cVar1 = TReadScriptFile::getSpecial(Script);
    switch(cVar1) {
    case '<':
        Left_2 = (TNode *)0x1;
        break;
    case '=':
        Left_2 = (TNode *)0x3;
        break;
    case '>':
        Left_2 = (TNode *)0x2;
        break;
    default:
        TReadScriptFile::error(Script,"relational operator expected");
        break;
    case 'G':
        Left_2 = (TNode *)0x6;
        break;
    case 'L':
        Left_2 = (TNode *)0x5;
        break;
    case 'N':
        Left_2 = (TNode *)0x4;
    }
    TReadScriptFile::nextToken(Script);
                    // try { // try from 080b1f14 to 080b1f59 has its CatchHandler @ 080b31db
    Type = (int)readValue(this,Script);
    while (TVar9 = Script->Token, TVar9 == SPECIAL) {
        cVar1 = TReadScriptFile::getSpecial(Script);
        if (cVar1 != '*') {
            TVar9 = Script->Token;
            break;
        }
        TReadScriptFile::nextToken(Script);
        pTVar3 = readValue(this,Script);
        pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
        pTVar4->Type = 9;
        pTVar4->Left = (TNode *)Type;
        pTVar4->Right = pTVar3;
        Type = (int)pTVar4;
    }
                    // try { // try from 080b1f7b to 080b1fcd has its CatchHandler @ 080b31f0
    while ((TVar9 == SPECIAL &&
           ((cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == '+' ||
            (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == '-'))))) {
        cVar1 = TReadScriptFile::getSpecial(Script);
        TReadScriptFile::nextToken(Script);
        pTVar3 = readFactor(this,Script);
        pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
        pTVar4->Type = (cVar1 != '+') + 7;
        pTVar4->Right = pTVar3;
        pTVar4->Left = (TNode *)Type;
        TVar9 = Script->Token;
        Type = (int)pTVar4;
    }
                    // try { // try from 080b1fe8 to 080b24da has its CatchHandler @ 080b32a0
    pTVar3 = store<TNode,256>::getFreeItem(NodeTable);
    pTVar3->Type = (int)Left_2;
    pTVar3->Left = (TNode *)Operator;
    pTVar3->Right = (TNode *)Type;
    pTVar5 = vector<TBehaviour>::operator()(&this->Behaviour,this->Behaviours);
    pTVar6 = vector<TCondition>::operator()(&pTVar5->Condition,pTVar5->Conditions);
    bVar2 = TCondition::set(pTVar6,4,pTVar3);
    if (bVar2) {
        pTVar5->Conditions = pTVar5->Conditions + 1;
    }
LAB_080b2041:
    if (Script->Token != SPECIAL) goto LAB_080b2076;
    cVar1 = TReadScriptFile::getSpecial(Script);
    if (cVar1 != ',') goto LAB_080b206a;
    TReadScriptFile::nextToken(Script);
    goto LAB_080b2060;
LAB_080b206a:
    if ((Script->Token != SPECIAL) || (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 != 'I')) {
LAB_080b2076:
        TReadScriptFile::error(Script,"\'->\' expected");
    }
LAB_080b2089:
    TReadScriptFile::nextToken(Script);
    TVar9 = Script->Token;
    if (TVar9 == STRING) {
        pTVar5 = vector<TBehaviour>::operator()(&this->Behaviour,this->Behaviours);
        TReadScriptFile::getString(Script);
        pTVar7 = vector<TAction>::operator()(&pTVar5->Action,pTVar5->Actions);
        bVar2 = TAction::set(pTVar7);
        if (bVar2) {
            pTVar5->Actions = pTVar5->Actions + 1;
        }
        goto LAB_080b2161;
    }
    uVar13 = TVar9 == IDENTIFIER;
    if ((bool)uVar13) {
        pcVar14 = TReadScriptFile::getIdentifier(Script);
        local_28 = 0xffffffff;
        iVar10 = 6;
        pcVar11 = pcVar14;
        pcVar12 = "topic";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 2;
        }
        iVar10 = 6;
        pcVar11 = pcVar14;
        pcVar12 = "price";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 2;
        }
        iVar10 = 7;
        pcVar11 = pcVar14;
        pcVar12 = "amount";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 2;
        }
        iVar10 = 5;
        pcVar11 = pcVar14;
        pcVar12 = "type";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 2;
        }
        iVar10 = 5;
        pcVar11 = pcVar14;
        pcVar12 = "data";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 2;
        }
        iVar10 = 3;
        pcVar11 = pcVar14;
        pcVar12 = "hp";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 3;
        }
        iVar10 = 8;
        pcVar11 = pcVar14;
        pcVar12 = "burning";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 8;
        }
        iVar10 = 7;
        pcVar11 = pcVar14;
        pcVar12 = "poison";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 8;
        }
        iVar10 = 0xe;
        pcVar11 = pcVar14;
        pcVar12 = "setquestvalue";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 4;
        }
        iVar10 = 9;
        pcVar11 = pcVar14;
        pcVar12 = "effectme";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 5;
        }
        iVar10 = 10;
        pcVar11 = pcVar14;
        pcVar12 = "effectopp";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 5;
        }
        iVar10 = 0xb;
        pcVar11 = pcVar14;
        pcVar12 = "profession";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 5;
        }
        iVar10 = 0xb;
        pcVar11 = pcVar14;
        pcVar12 = "teachspell";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 5;
        }
        iVar10 = 7;
        pcVar11 = pcVar14;
        pcVar12 = "summon";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 5;
        }
        iVar10 = 7;
        pcVar11 = pcVar14;
        pcVar12 = "create";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 5;
        }
        iVar10 = 7;
        pcVar11 = pcVar14;
        pcVar12 = "delete";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 5;
        }
        iVar10 = 0xc;
        pcVar11 = pcVar14;
        pcVar12 = "createmoney";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 6;
        }
        iVar10 = 0xc;
        pcVar11 = pcVar14;
        pcVar12 = "deletemoney";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 6;
        }
        iVar10 = 6;
        pcVar11 = pcVar14;
        pcVar12 = "queue";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 6;
        }
        iVar10 = 9;
        pcVar11 = pcVar14;
        pcVar12 = "teleport";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 10;
        }
        iVar10 = 0xe;
        pcVar11 = pcVar14;
        pcVar12 = "startposition";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 10;
        }
        iVar10 = 5;
        pcVar11 = pcVar14;
        pcVar12 = "idle";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar11 == *pcVar12;
            pcVar11 = pcVar11 + 1;
            pcVar12 = pcVar12 + 1;
        } while ((bool)uVar13);
        if ((bool)uVar13) {
            local_28 = 7;
        }
        iVar10 = 4;
        pcVar11 = "nop";
        do {
            if (iVar10 == 0) break;
            iVar10 = iVar10 + -1;
            uVar13 = *pcVar14 == *pcVar11;
            pcVar14 = pcVar14 + 1;
            pcVar11 = pcVar11 + 1;
        } while ((bool)uVar13);
        uVar8 = 0;
        if (!(bool)uVar13) {
            uVar8 = local_28;
        }
        switch(uVar8) {
        case 0:
            goto switchD_080b24a1_caseD_0;
        default:
            pcVar14 = "unknown identifier";
            goto LAB_080b20b8;
        case 2:
        case 3:
            TReadScriptFile::readSymbol(Script,'=');
            TReadScriptFile::nextToken(Script);
            pTVar5 = vector<TBehaviour>::operator()(&this->Behaviour,this->Behaviours);
                    // try { // try from 080b24e8 to 080b2530 has its CatchHandler @ 080b31f2
            Left_12 = readValue(this,Script);
            while (TVar9 = Script->Token, TVar9 == SPECIAL) {
                cVar1 = TReadScriptFile::getSpecial(Script);
                if (cVar1 != '*') {
                    TVar9 = Script->Token;
                    break;
                }
                TReadScriptFile::nextToken(Script);
                pTVar3 = readValue(this,Script);
                pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
                pTVar4->Type = 9;
                pTVar4->Left = Left_12;
                pTVar4->Right = pTVar3;
                Left_12 = pTVar4;
            }
                    // try { // try from 080b2552 to 080b25a4 has its CatchHandler @ 080b3207
            while ((TVar9 == SPECIAL &&
                   ((cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == '+' ||
                    (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == '-'))))) {
                cVar1 = TReadScriptFile::getSpecial(Script);
                TReadScriptFile::nextToken(Script);
                pTVar3 = readFactor(this,Script);
                pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
                pTVar4->Type = (cVar1 != '+') + 7;
                pTVar4->Right = pTVar3;
                pTVar4->Left = Left_12;
                TVar9 = Script->Token;
                Left_12 = pTVar4;
            }
                    // try { // try from 080b25c9 to 080b264b has its CatchHandler @ 080b32a0
            pTVar7 = vector<TAction>::operator()(&pTVar5->Action,pTVar5->Actions);
            bVar2 = TAction::set(pTVar7);
            if (bVar2) {
                pTVar5->Actions = pTVar5->Actions + 1;
            }
            goto LAB_080b20c3;
        case 4:
        case 8:
            TReadScriptFile::readSymbol(Script,'(');
            TReadScriptFile::nextToken(Script);
                    // try { // try from 080b2829 to 080b2871 has its CatchHandler @ 080b3251
            Left_10 = readValue(this,Script);
            while (TVar9 = Script->Token, TVar9 == SPECIAL) {
                cVar1 = TReadScriptFile::getSpecial(Script);
                if (cVar1 != '*') {
                    TVar9 = Script->Token;
                    break;
                }
                TReadScriptFile::nextToken(Script);
                pTVar3 = readValue(this,Script);
                pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
                pTVar4->Type = 9;
                pTVar4->Left = Left_10;
                pTVar4->Right = pTVar3;
                Left_10 = pTVar4;
            }
            do {
                if (TVar9 != SPECIAL) goto LAB_080b2904;
                    // try { // try from 080b2893 to 080b28e5 has its CatchHandler @ 080b3266
                cVar1 = TReadScriptFile::getSpecial(Script);
                if ((cVar1 != '+') && (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 != '-')) {
                    if ((Script->Token == SPECIAL) &&
                       (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == ','))
                    goto LAB_080b2917;
                    goto LAB_080b2904;
                }
                cVar1 = TReadScriptFile::getSpecial(Script);
                TReadScriptFile::nextToken(Script);
                pTVar3 = readFactor(this,Script);
                pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
                pTVar4->Type = (cVar1 != '+') + 7;
                pTVar4->Right = pTVar3;
                pTVar4->Left = Left_10;
                TVar9 = Script->Token;
                Left_10 = pTVar4;
            } while( true );
        case 5:
            TReadScriptFile::readSymbol(Script,'(');
            TReadScriptFile::nextToken(Script);
            pTVar5 = vector<TBehaviour>::operator()(&this->Behaviour,this->Behaviours);
                    // try { // try from 080b265c to 080b26a4 has its CatchHandler @ 080b3285
            local_4c = readValue(this,Script);
            while (TVar9 = Script->Token, TVar9 == SPECIAL) {
                cVar1 = TReadScriptFile::getSpecial(Script);
                if (cVar1 != '*') {
                    TVar9 = Script->Token;
                    break;
                }
                TReadScriptFile::nextToken(Script);
                pTVar3 = readValue(this,Script);
                pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
                pTVar4->Type = 9;
                pTVar4->Left = local_4c;
                pTVar4->Right = pTVar3;
                local_4c = pTVar4;
            }
                    // try { // try from 080b26c6 to 080b2718 has its CatchHandler @ 080b31ca
            while ((TVar9 == SPECIAL &&
                   ((cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == '+' ||
                    (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == '-'))))) {
                cVar1 = TReadScriptFile::getSpecial(Script);
                TReadScriptFile::nextToken(Script);
                pTVar3 = readFactor(this,Script);
                pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
                pTVar4->Type = (cVar1 != '+') + 7;
                pTVar4->Right = pTVar3;
                pTVar4->Left = local_4c;
                TVar9 = Script->Token;
                local_4c = pTVar4;
            }
                    // try { // try from 080b273d to 080b281b has its CatchHandler @ 080b32a0
            pTVar7 = vector<TAction>::operator()(&pTVar5->Action,pTVar5->Actions);
            bVar2 = TAction::set(pTVar7);
            if (bVar2) {
                pTVar5->Actions = pTVar5->Actions + 1;
            }
            if ((Script->Token != SPECIAL) ||
               (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 != ')')) {
                TReadScriptFile::error(Script,") expected");
            }
            goto LAB_080b2161;
        case 6:
        case 7:
            pTVar5 = vector<TBehaviour>::operator()(&this->Behaviour,this->Behaviours);
            pTVar7 = vector<TAction>::operator()(&pTVar5->Action,pTVar5->Actions);
            goto LAB_080b214c;
        case 10:
            TReadScriptFile::readSymbol(Script,'(');
            TReadScriptFile::nextToken(Script);
                    // try { // try from 080b2ab8 to 080b2b00 has its CatchHandler @ 080b3209
            Left_14 = readValue(this,Script);
            while (TVar9 = Script->Token, TVar9 == SPECIAL) {
                cVar1 = TReadScriptFile::getSpecial(Script);
                if (cVar1 != '*') {
                    TVar9 = Script->Token;
                    break;
                }
                TReadScriptFile::nextToken(Script);
                pTVar3 = readValue(this,Script);
                pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
                pTVar4->Type = 9;
                pTVar4->Left = Left_14;
                pTVar4->Right = pTVar3;
                Left_14 = pTVar4;
            }
            do {
                if (TVar9 != SPECIAL) goto LAB_080b2b93;
                    // try { // try from 080b2b22 to 080b2b74 has its CatchHandler @ 080b321e
                cVar1 = TReadScriptFile::getSpecial(Script);
                if ((cVar1 != '+') && (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 != '-')) {
                    if ((Script->Token == SPECIAL) &&
                       (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == ','))
                    goto LAB_080b2ba6;
                    goto LAB_080b2b93;
                }
                cVar1 = TReadScriptFile::getSpecial(Script);
                TReadScriptFile::nextToken(Script);
                pTVar3 = readFactor(this,Script);
                pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
                pTVar4->Type = (cVar1 != '+') + 7;
                pTVar4->Right = pTVar3;
                pTVar4->Left = Left_14;
                TVar9 = Script->Token;
                Left_14 = pTVar4;
            } while( true );
        }
    }
    if ((TVar9 == SPECIAL) && (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == '*')) {
        iVar10 = this->Behaviours;
        if (iVar10 == 0) {
            TReadScriptFile::error(Script,"no previous pattern");
            iVar10 = this->Behaviours;
        }
        pTVar5 = vector<TBehaviour>::operator()(&this->Behaviour,iVar10);
        pTVar7 = vector<TAction>::operator()(&pTVar5->Action,pTVar5->Actions);
        goto LAB_080b214c;
    }
    pcVar14 = "illegal action";
LAB_080b20b8:
    TReadScriptFile::error(Script,pcVar14);
    goto LAB_080b20c3;
LAB_080b2b93:
                    // try { // try from 080b2ba1 to 080b2bb0 has its CatchHandler @ 080b32a0
    TReadScriptFile::error(Script,", expected");
LAB_080b2ba6:
    TReadScriptFile::nextToken(Script);
                    // try { // try from 080b2bbe to 080b2c06 has its CatchHandler @ 080b3220
    Left_16 = readValue(this,Script);
    while (TVar9 = Script->Token, TVar9 == SPECIAL) {
        cVar1 = TReadScriptFile::getSpecial(Script);
        if (cVar1 != '*') {
            TVar9 = Script->Token;
            break;
        }
        TReadScriptFile::nextToken(Script);
        pTVar3 = readValue(this,Script);
        pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
        pTVar4->Type = 9;
        pTVar4->Left = Left_16;
        pTVar4->Right = pTVar3;
        Left_16 = pTVar4;
    }
    do {
        if (TVar9 != SPECIAL) break;
                    // try { // try from 080b2c28 to 080b2c7a has its CatchHandler @ 080b3235
        cVar1 = TReadScriptFile::getSpecial(Script);
        if ((cVar1 != '+') && (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 != '-')) {
            if ((Script->Token == SPECIAL) &&
               (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == ',')) goto LAB_080b2cac;
            break;
        }
        cVar1 = TReadScriptFile::getSpecial(Script);
        TReadScriptFile::nextToken(Script);
        pTVar3 = readFactor(this,Script);
        pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
        pTVar4->Type = (cVar1 != '+') + 7;
        pTVar4->Right = pTVar3;
        pTVar4->Left = Left_16;
        TVar9 = Script->Token;
        Left_16 = pTVar4;
    } while( true );
                    // try { // try from 080b2ca7 to 080b2cb6 has its CatchHandler @ 080b32a0
    TReadScriptFile::error(Script,", expected");
LAB_080b2cac:
    TReadScriptFile::nextToken(Script);
                    // try { // try from 080b2cc4 to 080b2d0c has its CatchHandler @ 080b3237
    Left_8 = readValue(this,Script);
    while (TVar9 = Script->Token, TVar9 == SPECIAL) {
        cVar1 = TReadScriptFile::getSpecial(Script);
        if (cVar1 != '*') {
            TVar9 = Script->Token;
            break;
        }
        TReadScriptFile::nextToken(Script);
        pTVar3 = readValue(this,Script);
        pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
        pTVar4->Type = 9;
        pTVar4->Left = Left_8;
        pTVar4->Right = pTVar3;
        Left_8 = pTVar4;
    }
    do {
        if (TVar9 != SPECIAL) break;
                    // try { // try from 080b2d2e to 080b2d80 has its CatchHandler @ 080b324c
        cVar1 = TReadScriptFile::getSpecial(Script);
        if ((cVar1 != '+') && (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 != '-')) {
            if ((Script->Token == SPECIAL) &&
               (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == ')')) goto LAB_080b2dae;
            break;
        }
        cVar1 = TReadScriptFile::getSpecial(Script);
        TReadScriptFile::nextToken(Script);
        pTVar3 = readFactor(this,Script);
        pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
        pTVar4->Type = (cVar1 != '+') + 7;
        pTVar4->Right = pTVar3;
        pTVar4->Left = Left_8;
        TVar9 = Script->Token;
        Left_8 = pTVar4;
    } while( true );
                    // try { // try from 080b2da9 to 080b3137 has its CatchHandler @ 080b32a0
    TReadScriptFile::error(Script,") expected");
LAB_080b2dae:
    pTVar5 = vector<TBehaviour>::operator()(&this->Behaviour,this->Behaviours);
    pTVar7 = vector<TAction>::operator()(&pTVar5->Action,pTVar5->Actions);
    bVar2 = TAction::set(pTVar7);
    if (bVar2) {
        pTVar5->Actions = pTVar5->Actions + 1;
    }
switchD_080b24a1_caseD_0:
    goto LAB_080b2161;
LAB_080b2904:
                    // try { // try from 080b2912 to 080b2921 has its CatchHandler @ 080b32a0
    TReadScriptFile::error(Script,", expected");
LAB_080b2917:
    TReadScriptFile::nextToken(Script);
                    // try { // try from 080b292f to 080b2977 has its CatchHandler @ 080b326b
    local_44 = readValue(this,Script);
    while (TVar9 = Script->Token, TVar9 == SPECIAL) {
        cVar1 = TReadScriptFile::getSpecial(Script);
        if (cVar1 != '*') {
            TVar9 = Script->Token;
            break;
        }
        TReadScriptFile::nextToken(Script);
        pTVar3 = readValue(this,Script);
        pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
        pTVar4->Type = 9;
        pTVar4->Left = local_44;
        pTVar4->Right = pTVar3;
        local_44 = pTVar4;
    }
    do {
        if (TVar9 != SPECIAL) break;
                    // try { // try from 080b2999 to 080b29eb has its CatchHandler @ 080b3280
        cVar1 = TReadScriptFile::getSpecial(Script);
        if ((cVar1 != '+') && (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 != '-')) {
            if ((Script->Token == SPECIAL) &&
               (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == ')')) goto LAB_080b2a19;
            break;
        }
        cVar1 = TReadScriptFile::getSpecial(Script);
        TReadScriptFile::nextToken(Script);
        pTVar3 = readFactor(this,Script);
        pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
        pTVar4->Type = (cVar1 != '+') + 7;
        pTVar4->Right = pTVar3;
        pTVar4->Left = local_44;
        TVar9 = Script->Token;
        local_44 = pTVar4;
    } while( true );
                    // try { // try from 080b2a14 to 080b2aaa has its CatchHandler @ 080b32a0
    TReadScriptFile::error(Script,") expected");
LAB_080b2a19:
    pTVar5 = vector<TBehaviour>::operator()(&this->Behaviour,this->Behaviours);
    pTVar7 = vector<TAction>::operator()(&pTVar5->Action,pTVar5->Actions);
LAB_080b214c:
    bVar2 = TAction::set(pTVar7);
    if (bVar2) {
        pTVar5->Actions = pTVar5->Actions + 1;
    }
LAB_080b2161:
    TReadScriptFile::nextToken(Script);
LAB_080b20c3:
    if ((Script->Token != SPECIAL) || (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 != ','))
    goto LAB_080b20d7;
    goto LAB_080b2089;
LAB_080b20d7:
    this->Behaviours = this->Behaviours + 1;
    goto LAB_080b1da5;
}



// WARNING: Variable defined which should be unmapped: Left
// DWARF original prototype: TNode * readValue(TBehaviourDatabase * this, TReadScriptFile * Script)

TNode * __thiscall TBehaviourDatabase::readValue(TBehaviourDatabase *this,TReadScriptFile *Script)

{
    char cVar1;
    TNode *Node_1;
    TNode *pTVar2;
    TNode *pTVar3;
    TOKEN TVar4;
    int iVar5;
    TNode *Left_1;
    TNode *Right;
    char *pcVar6;
    undefined1 uVar7;
    char *pcVar8;
    TNode *local_2c;
    TNode *Node;
    TNode *Left_10;
    TNode *Left_8;
    TNode *Left_6;
    TNode *Left_4;
    TNode *Left_2;
    TNode *Left;
    
    local_2c = (TNode *)0x0;
    TVar4 = Script->Token;
    if (TVar4 == NUMBER) {
        iVar5 = TReadScriptFile::getNumber(Script);
        local_2c = store<TNode,256>::getFreeItem(NodeTable);
        local_2c->Type = 0xb;
LAB_080b3db2:
        local_2c->Data = iVar5;
        local_2c->Left = (TNode *)0x0;
        local_2c->Right = (TNode *)0x0;
        goto LAB_080b3310;
    }
    if ((int)TVar4 < 3) {
        uVar7 = TVar4 == IDENTIFIER;
        if (!(bool)uVar7) goto LAB_080b3300;
        pcVar8 = TReadScriptFile::getIdentifier(Script);
        iVar5 = 6;
        pcVar6 = "topic";
        do {
            if (iVar5 == 0) break;
            iVar5 = iVar5 + -1;
            uVar7 = *pcVar8 == *pcVar6;
            pcVar8 = pcVar8 + 1;
            pcVar6 = pcVar6 + 1;
        } while ((bool)uVar7);
        if ((bool)uVar7) {
            local_2c = store<TNode,256>::getFreeItem(NodeTable);
            local_2c->Type = 0xc;
            local_2c->Data = 0;
            local_2c->Left = (TNode *)0x0;
            local_2c->Right = (TNode *)0x0;
        }
        pcVar8 = TReadScriptFile::getIdentifier(Script);
        iVar5 = 6;
        pcVar6 = "price";
        do {
            if (iVar5 == 0) break;
            iVar5 = iVar5 + -1;
            uVar7 = *pcVar8 == *pcVar6;
            pcVar8 = pcVar8 + 1;
            pcVar6 = pcVar6 + 1;
        } while ((bool)uVar7);
        if ((bool)uVar7) {
            local_2c = store<TNode,256>::getFreeItem(NodeTable);
            local_2c->Type = 0xd;
            local_2c->Data = 0;
            local_2c->Left = (TNode *)0x0;
            local_2c->Right = (TNode *)0x0;
        }
        pcVar8 = TReadScriptFile::getIdentifier(Script);
        iVar5 = 7;
        pcVar6 = "amount";
        do {
            if (iVar5 == 0) break;
            iVar5 = iVar5 + -1;
            uVar7 = *pcVar8 == *pcVar6;
            pcVar8 = pcVar8 + 1;
            pcVar6 = pcVar6 + 1;
        } while ((bool)uVar7);
        if ((bool)uVar7) {
            local_2c = store<TNode,256>::getFreeItem(NodeTable);
            local_2c->Type = 0xe;
            local_2c->Data = 0;
            local_2c->Left = (TNode *)0x0;
            local_2c->Right = (TNode *)0x0;
        }
        pcVar8 = TReadScriptFile::getIdentifier(Script);
        iVar5 = 6;
        pcVar6 = "level";
        do {
            if (iVar5 == 0) break;
            iVar5 = iVar5 + -1;
            uVar7 = *pcVar8 == *pcVar6;
            pcVar8 = pcVar8 + 1;
            pcVar6 = pcVar6 + 1;
        } while ((bool)uVar7);
        if ((bool)uVar7) {
            local_2c = store<TNode,256>::getFreeItem(NodeTable);
            local_2c->Type = 0xf;
            local_2c->Data = 0;
            local_2c->Left = (TNode *)0x0;
            local_2c->Right = (TNode *)0x0;
        }
        pcVar8 = TReadScriptFile::getIdentifier(Script);
        iVar5 = 9;
        pcVar6 = "maglevel";
        do {
            if (iVar5 == 0) break;
            iVar5 = iVar5 + -1;
            uVar7 = *pcVar8 == *pcVar6;
            pcVar8 = pcVar8 + 1;
            pcVar6 = pcVar6 + 1;
        } while ((bool)uVar7);
        if ((bool)uVar7) {
            local_2c = store<TNode,256>::getFreeItem(NodeTable);
            local_2c->Type = 0xf;
            local_2c->Data = 1;
            local_2c->Left = (TNode *)0x0;
            local_2c->Right = (TNode *)0x0;
        }
        pcVar8 = TReadScriptFile::getIdentifier(Script);
        iVar5 = 3;
        pcVar6 = "hp";
        do {
            if (iVar5 == 0) break;
            iVar5 = iVar5 + -1;
            uVar7 = *pcVar8 == *pcVar6;
            pcVar8 = pcVar8 + 1;
            pcVar6 = pcVar6 + 1;
        } while ((bool)uVar7);
        if ((bool)uVar7) {
            local_2c = store<TNode,256>::getFreeItem(NodeTable);
            local_2c->Type = 0xf;
            local_2c->Data = 2;
            local_2c->Left = (TNode *)0x0;
            local_2c->Right = (TNode *)0x0;
        }
        pcVar8 = TReadScriptFile::getIdentifier(Script);
        iVar5 = 8;
        pcVar6 = "burning";
        do {
            if (iVar5 == 0) break;
            iVar5 = iVar5 + -1;
            uVar7 = *pcVar8 == *pcVar6;
            pcVar8 = pcVar8 + 1;
            pcVar6 = pcVar6 + 1;
        } while ((bool)uVar7);
        if ((bool)uVar7) {
            local_2c = store<TNode,256>::getFreeItem(NodeTable);
            local_2c->Type = 0xf;
            local_2c->Data = 0x12;
            local_2c->Left = (TNode *)0x0;
            local_2c->Right = (TNode *)0x0;
        }
        pcVar8 = TReadScriptFile::getIdentifier(Script);
        iVar5 = 7;
        pcVar6 = "poison";
        do {
            if (iVar5 == 0) break;
            iVar5 = iVar5 + -1;
            uVar7 = *pcVar8 == *pcVar6;
            pcVar8 = pcVar8 + 1;
            pcVar6 = pcVar6 + 1;
        } while ((bool)uVar7);
        if ((bool)uVar7) {
            local_2c = store<TNode,256>::getFreeItem(NodeTable);
            local_2c->Type = 0xf;
            local_2c->Data = 0x11;
            local_2c->Left = (TNode *)0x0;
            local_2c->Right = (TNode *)0x0;
        }
        pcVar8 = TReadScriptFile::getIdentifier(Script);
        iVar5 = 6;
        pcVar6 = "count";
        do {
            if (iVar5 == 0) break;
            iVar5 = iVar5 + -1;
            uVar7 = *pcVar8 == *pcVar6;
            pcVar8 = pcVar8 + 1;
            pcVar6 = pcVar6 + 1;
        } while ((bool)uVar7);
        if ((bool)uVar7) {
            TReadScriptFile::readSymbol(Script,'(');
            TReadScriptFile::nextToken(Script);
                    // try { // try from 080b347a to 080b34b9 has its CatchHandler @ 080b3de7
            Left_2 = readValue(this,Script);
            while (TVar4 = Script->Token, TVar4 == SPECIAL) {
                cVar1 = TReadScriptFile::getSpecial(Script);
                if (cVar1 != '*') {
                    TVar4 = Script->Token;
                    break;
                }
                TReadScriptFile::nextToken(Script);
                pTVar2 = readValue(this,Script);
                pTVar3 = store<TNode,256>::getFreeItem(NodeTable);
                pTVar3->Type = 9;
                pTVar3->Left = Left_2;
                pTVar3->Right = pTVar2;
                Left_2 = pTVar3;
            }
                    // try { // try from 080b34d5 to 080b3522 has its CatchHandler @ 080b3e00
            while ((TVar4 == SPECIAL &&
                   ((cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == '+' ||
                    (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == '-'))))) {
                cVar1 = TReadScriptFile::getSpecial(Script);
                TReadScriptFile::nextToken(Script);
                pTVar2 = readFactor(this,Script);
                pTVar3 = store<TNode,256>::getFreeItem(NodeTable);
                pTVar3->Type = (cVar1 != '+') + 7;
                pTVar3->Right = pTVar2;
                pTVar3->Left = Left_2;
                TVar4 = Script->Token;
                Left_2 = pTVar3;
            }
                    // try { // try from 080b353d to 080b360e has its CatchHandler @ 080b3e50
            local_2c = store<TNode,256>::getFreeItem(NodeTable);
            local_2c->Type = 0x10;
        }
        else {
            pcVar8 = TReadScriptFile::getIdentifier(Script);
            iVar5 = 0xb;
            pcVar6 = "countmoney";
            do {
                if (iVar5 == 0) break;
                iVar5 = iVar5 + -1;
                uVar7 = *pcVar8 == *pcVar6;
                pcVar8 = pcVar8 + 1;
                pcVar6 = pcVar6 + 1;
            } while ((bool)uVar7);
            if ((bool)uVar7) {
                local_2c = store<TNode,256>::getFreeItem(NodeTable);
                local_2c->Type = 0x11;
                local_2c->Data = 0;
                local_2c->Left = (TNode *)0x0;
                local_2c->Right = (TNode *)0x0;
            }
            pcVar8 = TReadScriptFile::getIdentifier(Script);
            iVar5 = 5;
            pcVar6 = "type";
            do {
                if (iVar5 == 0) break;
                iVar5 = iVar5 + -1;
                uVar7 = *pcVar8 == *pcVar6;
                pcVar8 = pcVar8 + 1;
                pcVar6 = pcVar6 + 1;
            } while ((bool)uVar7);
            if ((bool)uVar7) {
                local_2c = store<TNode,256>::getFreeItem(NodeTable);
                local_2c->Type = 0x12;
                local_2c->Data = 0;
                local_2c->Left = (TNode *)0x0;
                local_2c->Right = (TNode *)0x0;
            }
            pcVar8 = TReadScriptFile::getIdentifier(Script);
            iVar5 = 5;
            pcVar6 = "data";
            do {
                if (iVar5 == 0) break;
                iVar5 = iVar5 + -1;
                uVar7 = *pcVar8 == *pcVar6;
                pcVar8 = pcVar8 + 1;
                pcVar6 = pcVar6 + 1;
            } while ((bool)uVar7);
            if ((bool)uVar7) {
                local_2c = store<TNode,256>::getFreeItem(NodeTable);
                local_2c->Type = 0x13;
                local_2c->Data = 0;
                local_2c->Left = (TNode *)0x0;
                local_2c->Right = (TNode *)0x0;
            }
            pcVar8 = TReadScriptFile::getIdentifier(Script);
            iVar5 = 0xb;
            pcVar6 = "spellknown";
            do {
                if (iVar5 == 0) break;
                iVar5 = iVar5 + -1;
                uVar7 = *pcVar8 == *pcVar6;
                pcVar8 = pcVar8 + 1;
                pcVar6 = pcVar6 + 1;
            } while ((bool)uVar7);
            if ((bool)uVar7) {
                TReadScriptFile::readSymbol(Script,'(');
                TReadScriptFile::nextToken(Script);
                    // try { // try from 080b3619 to 080b3658 has its CatchHandler @ 080b3e0b
                Left_4 = readValue(this,Script);
                while (TVar4 = Script->Token, TVar4 == SPECIAL) {
                    cVar1 = TReadScriptFile::getSpecial(Script);
                    if (cVar1 != '*') {
                        TVar4 = Script->Token;
                        break;
                    }
                    TReadScriptFile::nextToken(Script);
                    pTVar2 = readValue(this,Script);
                    pTVar3 = store<TNode,256>::getFreeItem(NodeTable);
                    pTVar3->Type = 9;
                    pTVar3->Left = Left_4;
                    pTVar3->Right = pTVar2;
                    Left_4 = pTVar3;
                }
                    // try { // try from 080b3674 to 080b36c1 has its CatchHandler @ 080b3e16
                while ((TVar4 == SPECIAL &&
                       ((cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == '+' ||
                        (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == '-'))))) {
                    cVar1 = TReadScriptFile::getSpecial(Script);
                    TReadScriptFile::nextToken(Script);
                    pTVar2 = readFactor(this,Script);
                    pTVar3 = store<TNode,256>::getFreeItem(NodeTable);
                    pTVar3->Type = (cVar1 != '+') + 7;
                    pTVar3->Right = pTVar2;
                    pTVar3->Left = Left_4;
                    TVar4 = Script->Token;
                    Left_4 = pTVar3;
                }
                    // try { // try from 080b36dc to 080b3725 has its CatchHandler @ 080b3e50
                local_2c = store<TNode,256>::getFreeItem(NodeTable);
                local_2c->Type = 0x14;
                Left_2 = Left_4;
            }
            else {
                pcVar8 = TReadScriptFile::getIdentifier(Script);
                iVar5 = 0xb;
                pcVar6 = "spelllevel";
                do {
                    if (iVar5 == 0) break;
                    iVar5 = iVar5 + -1;
                    uVar7 = *pcVar8 == *pcVar6;
                    pcVar8 = pcVar8 + 1;
                    pcVar6 = pcVar6 + 1;
                } while ((bool)uVar7);
                if ((bool)uVar7) {
                    TReadScriptFile::readSymbol(Script,'(');
                    TReadScriptFile::nextToken(Script);
                    // try { // try from 080b3730 to 080b376f has its CatchHandler @ 080b3e18
                    Left_6 = readValue(this,Script);
                    while (TVar4 = Script->Token, TVar4 == SPECIAL) {
                        cVar1 = TReadScriptFile::getSpecial(Script);
                        if (cVar1 != '*') {
                            TVar4 = Script->Token;
                            break;
                        }
                        TReadScriptFile::nextToken(Script);
                        pTVar2 = readValue(this,Script);
                        pTVar3 = store<TNode,256>::getFreeItem(NodeTable);
                        pTVar3->Type = 9;
                        pTVar3->Left = Left_6;
                        pTVar3->Right = pTVar2;
                        Left_6 = pTVar3;
                    }
                    // try { // try from 080b378b to 080b37d8 has its CatchHandler @ 080b3e23
                    while ((TVar4 == SPECIAL &&
                           ((cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == '+' ||
                            (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == '-'))))) {
                        cVar1 = TReadScriptFile::getSpecial(Script);
                        TReadScriptFile::nextToken(Script);
                        pTVar2 = readFactor(this,Script);
                        pTVar3 = store<TNode,256>::getFreeItem(NodeTable);
                        pTVar3->Type = (cVar1 != '+') + 7;
                        pTVar3->Right = pTVar2;
                        pTVar3->Left = Left_6;
                        TVar4 = Script->Token;
                        Left_6 = pTVar3;
                    }
                    // try { // try from 080b37f3 to 080b383c has its CatchHandler @ 080b3e50
                    local_2c = store<TNode,256>::getFreeItem(NodeTable);
                    local_2c->Type = 0x15;
                    Left_2 = Left_6;
                }
                else {
                    pcVar8 = TReadScriptFile::getIdentifier(Script);
                    iVar5 = 7;
                    pcVar6 = "random";
                    do {
                        if (iVar5 == 0) break;
                        iVar5 = iVar5 + -1;
                        uVar7 = *pcVar8 == *pcVar6;
                        pcVar8 = pcVar8 + 1;
                        pcVar6 = pcVar6 + 1;
                    } while ((bool)uVar7);
                    if ((bool)uVar7) {
                        TReadScriptFile::readSymbol(Script,'(');
                        TReadScriptFile::nextToken(Script);
                    // try { // try from 080b3847 to 080b3886 has its CatchHandler @ 080b3e25
                        Left_8 = readValue(this,Script);
                        while (TVar4 = Script->Token, TVar4 == SPECIAL) {
                            cVar1 = TReadScriptFile::getSpecial(Script);
                            if (cVar1 != '*') {
                                TVar4 = Script->Token;
                                break;
                            }
                            TReadScriptFile::nextToken(Script);
                            pTVar2 = readValue(this,Script);
                            pTVar3 = store<TNode,256>::getFreeItem(NodeTable);
                            pTVar3->Type = 9;
                            pTVar3->Left = Left_8;
                            pTVar3->Right = pTVar2;
                            Left_8 = pTVar3;
                        }
                        do {
                            if (TVar4 != SPECIAL) goto LAB_080b390b;
                    // try { // try from 080b38a2 to 080b38ef has its CatchHandler @ 080b3e30
                            cVar1 = TReadScriptFile::getSpecial(Script);
                            if ((cVar1 != '+') &&
                               (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 != '-')) {
                                if ((Script->Token == SPECIAL) &&
                                   (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == ','))
                                goto LAB_080b391b;
                                goto LAB_080b390b;
                            }
                            cVar1 = TReadScriptFile::getSpecial(Script);
                            TReadScriptFile::nextToken(Script);
                            pTVar2 = readFactor(this,Script);
                            pTVar3 = store<TNode,256>::getFreeItem(NodeTable);
                            pTVar3->Type = (cVar1 != '+') + 7;
                            pTVar3->Right = pTVar2;
                            pTVar3->Left = Left_8;
                            TVar4 = Script->Token;
                            Left_8 = pTVar3;
                        } while( true );
                    }
                    pcVar8 = TReadScriptFile::getIdentifier(Script);
                    iVar5 = 0xb;
                    pcVar6 = "questvalue";
                    do {
                        if (iVar5 == 0) break;
                        iVar5 = iVar5 + -1;
                        uVar7 = *pcVar8 == *pcVar6;
                        pcVar8 = pcVar8 + 1;
                        pcVar6 = pcVar6 + 1;
                    } while ((bool)uVar7);
                    if (!(bool)uVar7) goto LAB_080b3310;
                    TReadScriptFile::readSymbol(Script,'(');
                    TReadScriptFile::nextToken(Script);
                    // try { // try from 080b3a88 to 080b3ac7 has its CatchHandler @ 080b3e3f
                    Node = readValue(this,Script);
                    while (TVar4 = Script->Token, TVar4 == SPECIAL) {
                        cVar1 = TReadScriptFile::getSpecial(Script);
                        if (cVar1 != '*') {
                            TVar4 = Script->Token;
                            break;
                        }
                        TReadScriptFile::nextToken(Script);
                        pTVar2 = readValue(this,Script);
                        pTVar3 = store<TNode,256>::getFreeItem(NodeTable);
                        pTVar3->Type = 9;
                        pTVar3->Left = Node;
                        pTVar3->Right = pTVar2;
                        Node = pTVar3;
                    }
                    // try { // try from 080b3ae3 to 080b3b30 has its CatchHandler @ 080b3e00
                    while ((TVar4 == SPECIAL &&
                           ((cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == '+' ||
                            (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == '-'))))) {
                        cVar1 = TReadScriptFile::getSpecial(Script);
                        TReadScriptFile::nextToken(Script);
                        pTVar2 = readFactor(this,Script);
                        pTVar3 = store<TNode,256>::getFreeItem(NodeTable);
                        pTVar3->Type = (cVar1 != '+') + 7;
                        pTVar3->Right = pTVar2;
                        pTVar3->Left = Node;
                        TVar4 = Script->Token;
                        Node = pTVar3;
                    }
                    // try { // try from 080b3b4b to 080b3dde has its CatchHandler @ 080b3e50
                    local_2c = store<TNode,256>::getFreeItem(NodeTable);
                    local_2c->Type = 0x17;
                    Left_2 = Node;
                }
            }
        }
        local_2c->Left = Left_2;
        local_2c->Right = (TNode *)0x0;
        if ((Script->Token == SPECIAL) &&
           (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == ')')) goto LAB_080b3310;
        pcVar8 = ") expected";
    }
    else {
        if (TVar4 == SPECIAL) {
            cVar1 = TReadScriptFile::getSpecial(Script);
            if (cVar1 != '%') {
                TReadScriptFile::error(Script,"illegal character");
            }
            iVar5 = TReadScriptFile::readNumber(Script);
            local_2c = store<TNode,256>::getFreeItem(NodeTable);
            local_2c->Type = 10;
            goto LAB_080b3db2;
        }
LAB_080b3300:
        pcVar8 = "illegal value";
    }
                    // try { // try from 080b330b to 080b346f has its CatchHandler @ 080b3e50
    TReadScriptFile::error(Script,pcVar8);
LAB_080b3310:
    if (local_2c == (TNode *)0x0) {
        TReadScriptFile::error(Script,"unknown value");
    }
    TReadScriptFile::nextToken(Script);
    return local_2c;
LAB_080b390b:
                    // try { // try from 080b3916 to 080b3922 has its CatchHandler @ 080b3e50
    TReadScriptFile::error(Script,", expected");
LAB_080b391b:
    TReadScriptFile::nextToken(Script);
                    // try { // try from 080b392d to 080b396c has its CatchHandler @ 080b3e32
    Left_10 = readValue(this,Script);
    while (TVar4 = Script->Token, TVar4 == SPECIAL) {
        cVar1 = TReadScriptFile::getSpecial(Script);
        if (cVar1 != '*') {
            TVar4 = Script->Token;
            break;
        }
        TReadScriptFile::nextToken(Script);
        pTVar2 = readValue(this,Script);
        pTVar3 = store<TNode,256>::getFreeItem(NodeTable);
        pTVar3->Type = 9;
        pTVar3->Left = Left_10;
        pTVar3->Right = pTVar2;
        Left_10 = pTVar3;
    }
    do {
        if (TVar4 != SPECIAL) break;
                    // try { // try from 080b3988 to 080b39d5 has its CatchHandler @ 080b3e3d
        cVar1 = TReadScriptFile::getSpecial(Script);
        if ((cVar1 != '+') && (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 != '-')) {
            if ((Script->Token == SPECIAL) &&
               (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 == ')')) goto LAB_080b39fd;
            break;
        }
        cVar1 = TReadScriptFile::getSpecial(Script);
        TReadScriptFile::nextToken(Script);
        pTVar2 = readFactor(this,Script);
        pTVar3 = store<TNode,256>::getFreeItem(NodeTable);
        pTVar3->Type = (cVar1 != '+') + 7;
        pTVar3->Right = pTVar2;
        pTVar3->Left = Left_10;
        TVar4 = Script->Token;
        Left_10 = pTVar3;
    } while( true );
                    // try { // try from 080b39f8 to 080b3a7d has its CatchHandler @ 080b3e50
    TReadScriptFile::error(Script,") expected");
LAB_080b39fd:
    local_2c = store<TNode,256>::getFreeItem(NodeTable);
    local_2c->Type = 0x16;
    local_2c->Left = Left_8;
    local_2c->Right = Left_10;
    goto LAB_080b3310;
}



// WARNING: Variable defined which should be unmapped: Right
// DWARF original prototype: TNode * readFactor(TBehaviourDatabase * this, TReadScriptFile * Script)

TNode * __thiscall TBehaviourDatabase::readFactor(TBehaviourDatabase *this,TReadScriptFile *Script)

{
    char cVar1;
    TNode *Node;
    TNode *pTVar2;
    TNode *pTVar3;
    TNode *pTVar4;
    TNode *Left;
    TNode *Right;
    
                    // try { // try from 080b3e7c to 080b3eb7 has its CatchHandler @ 080b3ed8
    pTVar2 = readValue(this,Script);
    while( true ) {
        if (Script->Token != SPECIAL) {
            return pTVar2;
        }
        cVar1 = TReadScriptFile::getSpecial(Script);
        if (cVar1 != '*') break;
        TReadScriptFile::nextToken(Script);
        pTVar3 = readValue(this,Script);
        pTVar4 = store<TNode,256>::getFreeItem(NodeTable);
        pTVar4->Type = 9;
        pTVar4->Left = pTVar2;
        pTVar4->Right = pTVar3;
        pTVar2 = pTVar4;
    }
    return pTVar2;
}



// WARNING: Variable defined which should be unmapped: Right
// DWARF original prototype: TNode * readTerm(TBehaviourDatabase * this, TReadScriptFile * Script)

TNode * __thiscall TBehaviourDatabase::readTerm(TBehaviourDatabase *this,TReadScriptFile *Script)

{
    char cVar1;
    char cVar2;
    TNode *Node;
    TNode *pTVar3;
    TNode *pTVar4;
    TNode *pTVar5;
    TOKEN TVar6;
    TNode *pTVar7;
    TNode *Left;
    TNode *Right_1;
    TNode *Left_2;
    int Operator;
    TNode *Right;
    
                    // try { // try from 080b3f0c to 080b3f49 has its CatchHandler @ 080b4030
    pTVar3 = readValue(this,Script);
    while( true ) {
        TVar6 = Script->Token;
        pTVar4 = pTVar3;
        if (TVar6 != SPECIAL) goto LAB_080b3f5d;
        cVar1 = TReadScriptFile::getSpecial(Script);
        if (cVar1 != '*') break;
        TReadScriptFile::nextToken(Script);
        pTVar4 = readValue(this,Script);
        pTVar5 = store<TNode,256>::getFreeItem(NodeTable);
        pTVar5->Type = 9;
        pTVar5->Left = pTVar3;
        pTVar5->Right = pTVar4;
        pTVar3 = pTVar5;
    }
    while( true ) {
        TVar6 = Script->Token;
        pTVar4 = pTVar3;
LAB_080b3f5d:
        if (TVar6 != SPECIAL) break;
                    // try { // try from 080b3f69 to 080b3fa0 has its CatchHandler @ 080b4048
        cVar1 = TReadScriptFile::getSpecial(Script);
        if ((cVar1 != '+') && (cVar1 = TReadScriptFile::getSpecial(Script), cVar1 != '-')) {
            return pTVar4;
        }
        cVar1 = TReadScriptFile::getSpecial(Script);
        TReadScriptFile::nextToken(Script);
                    // try { // try from 080b3fa8 to 080b3fe4 has its CatchHandler @ 080b4030
        pTVar5 = readValue(this,Script);
        while ((Script->Token == SPECIAL &&
               (cVar2 = TReadScriptFile::getSpecial(Script), cVar2 == '*'))) {
            TReadScriptFile::nextToken(Script);
            pTVar3 = readValue(this,Script);
            pTVar7 = store<TNode,256>::getFreeItem(NodeTable);
            pTVar7->Type = 9;
            pTVar7->Left = pTVar5;
            pTVar7->Right = pTVar3;
            pTVar5 = pTVar7;
        }
                    // try { // try from 080b4001 to 080b4005 has its CatchHandler @ 080b4048
        pTVar3 = store<TNode,256>::getFreeItem(NodeTable);
        pTVar3->Left = pTVar4;
        pTVar3->Type = (cVar1 != '+') + 7;
        pTVar3->Right = pTVar5;
    }
    return pTVar4;
}



// DWARF original prototype: int evaluate(TBehaviourDatabase * this, TNPC * npc, TNode * Node, int *
// Number)

int __thiscall
TBehaviourDatabase::evaluate(TBehaviourDatabase *this,TNPC *npc,TNode *Node,int *Number)

{
    TSkill *pTVar1;
    bool bVar2;
    TPlayer *this_00;
    uint uVar3;
    int iVar4;
    int iVar5;
    TPlayer *Opp;
    char *pcVar6;
    ObjectType local_2c [7];
    
    if (Node == (TNode *)0x0) {
        pcVar6 = "TBehaviourDatabase::evaluate: Knoten existiert nicht.\n";
LAB_080b4560:
        error(pcVar6);
        goto LAB_080b4130;
    }
    if (Number == (int *)0x0) {
        pcVar6 = "TBehaviourDatabase::evaluate: Zahlen existieren nicht.\n";
        goto LAB_080b4560;
    }
    if (npc == (TNPC *)0x0) {
        pcVar6 = "TBehaviourDatabase::evaluate: NPC existiert nicht.\n";
        goto LAB_080b4560;
    }
    this_00 = GetPlayer(npc->Interlocutor);
    if (this_00 == (TPlayer *)0x0) {
        pcVar6 = &DAT_08104c40;
        goto LAB_080b4560;
    }
    iVar5 = Node->Type;
    switch(iVar5) {
    default:
        pcVar6 = &DAT_08104b40;
        goto LAB_080b412b;
    case 1:
        iVar5 = evaluate(this,npc,Node->Left,Number);
        iVar4 = evaluate(this,npc,Node->Right,Number);
        bVar2 = iVar5 < iVar4;
        goto LAB_080b4100;
    case 2:
        iVar5 = evaluate(this,npc,Node->Left,Number);
        iVar4 = evaluate(this,npc,Node->Right,Number);
        bVar2 = iVar4 < iVar5;
        goto LAB_080b4100;
    case 3:
        iVar5 = evaluate(this,npc,Node->Left,Number);
        iVar4 = evaluate(this,npc,Node->Right,Number);
        bVar2 = iVar5 == iVar4;
        goto LAB_080b4100;
    case 4:
        iVar5 = evaluate(this,npc,Node->Left,Number);
        iVar4 = evaluate(this,npc,Node->Right,Number);
        bVar2 = iVar5 == iVar4;
        goto LAB_080b41fb;
    case 5:
        iVar5 = evaluate(this,npc,Node->Left,Number);
        iVar4 = evaluate(this,npc,Node->Right,Number);
        bVar2 = iVar5 <= iVar4;
        goto LAB_080b4100;
    case 6:
        iVar5 = evaluate(this,npc,Node->Left,Number);
        iVar4 = evaluate(this,npc,Node->Right,Number);
        bVar2 = iVar4 <= iVar5;
        goto LAB_080b4100;
    case 7:
        iVar5 = evaluate(this,npc,Node->Left,Number);
        iVar4 = evaluate(this,npc,Node->Right,Number);
        uVar3 = iVar4 + iVar5;
        break;
    case 8:
        iVar5 = evaluate(this,npc,Node->Left,Number);
        iVar4 = evaluate(this,npc,Node->Right,Number);
        uVar3 = iVar5 - iVar4;
        break;
    case 9:
        iVar5 = evaluate(this,npc,Node->Left,Number);
        iVar4 = evaluate(this,npc,Node->Right,Number);
        uVar3 = iVar4 * iVar5;
        break;
    case 10:
        iVar5 = Node->Data;
        if (iVar5 - 1U < 3) {
            if (-1 < Number[iVar5 + -1]) {
                return Number[iVar5 + -1];
            }
            pcVar6 = "TBehaviourDatabase::evaluate: Zahl-Parameter %d nicht belegt.\n";
        }
        else {
            pcVar6 = &DAT_08104bc0;
        }
        goto LAB_080b412b;
    case 0xb:
        uVar3 = Node->Data;
        break;
    case 0xc:
        uVar3 = npc->Topic;
        break;
    case 0xd:
        uVar3 = npc->Price;
        break;
    case 0xe:
        uVar3 = npc->Amount;
        break;
    case 0xf:
        iVar5 = Node->Data;
        if (-1 < iVar5) {
            if (iVar5 < 3) {
                iVar5 = TSkill::Get((this_00->super_TCreature).super_TSkillBase.Skills[iVar5]);
                return iVar5;
            }
            if (iVar5 - 0x11U < 2) {
                pTVar1 = (this_00->super_TCreature).super_TSkillBase.Skills[iVar5];
                iVar5 = (*pTVar1->_vptr_TSkill[0xd])(pTVar1);
                return iVar5;
            }
        }
        pcVar6 = &DAT_08104c00;
LAB_080b412b:
        error(pcVar6,iVar5);
LAB_080b4130:
        uVar3 = 0;
        break;
    case 0x10:
        iVar5 = evaluate(this,npc,Node->Left,Number);
        ObjectType::setTypeID(local_2c,iVar5);
        uVar3 = CountInventoryObjects(npc->Interlocutor,local_2c,npc->Data);
        break;
    case 0x11:
        uVar3 = CountInventoryMoney(npc->Interlocutor);
        break;
    case 0x12:
        uVar3 = npc->TypeID;
        break;
    case 0x13:
        uVar3 = npc->Data;
        break;
    case 0x14:
        iVar5 = evaluate(this,npc,Node->Left,Number);
        bVar2 = TPlayer::SpellKnown(this_00,iVar5);
        bVar2 = !bVar2;
LAB_080b41fb:
        bVar2 = !bVar2;
LAB_080b4100:
        uVar3 = (uint)bVar2;
        break;
    case 0x15:
        iVar5 = evaluate(this,npc,Node->Left,Number);
        uVar3 = GetSpellLevel(iVar5);
        break;
    case 0x16:
        evaluate(this,npc,Node->Right,Number);
        evaluate(this,npc,Node->Left,Number);
        uVar3 = random();
        break;
    case 0x17:
        iVar5 = evaluate(this,npc,Node->Left,Number);
        uVar3 = TPlayer::GetQuestValue(this_00,iVar5);
    }
    return uVar3;
}



// DWARF original prototype: void react(TBehaviourDatabase * this, TNPC * npc, char * Text,
// SITUATION Situation)

void __thiscall
TBehaviourDatabase::react(TBehaviourDatabase *this,TNPC *npc,char *Text,SITUATION Situation)

{
    char cVar1;
    TSkill *pTVar2;
    byte bVar3;
    uchar uVar4;
    RESULT r_1;
    TPlayer *this_00;
    TBehaviour *pTVar5;
    TAction *pTVar6;
    size_t sVar7;
    ulong uVar8;
    TMonster *this_01;
    int iVar9;
    int iVar10;
    int iVar11;
    TCondition *pTVar12;
    undefined4 uVar13;
    uint *puVar14;
    uint *puVar15;
    RESULT r;
    uint uVar16;
    uint uVar17;
    TPlayer *pTVar18;
    int Value3;
    TAction *A;
    uint uVar19;
    int Value;
    bool bVar20;
    bool bVar21;
    char *pcVar22;
    char *pcVar23;
    ObjectType *Type;
    TNPC *pTVar24;
    int Crystal;
    int Value2;
    char *AText;
    int j;
    TBehaviour *B;
    int TalkDelay;
    int iStack_1cc;
    bool StartToDo;
    int j_1;
    bool fulfilled;
    TBehaviour *B_1;
    int i;
    int bestPattern;
    int maxConditions;
    TPlayer *Opp;
    int local_1ac;
    int local_1a8;
    int local_1a4;
    int Hour;
    int Minute;
    char Help [50];
    char acStack_15f [3];
    uint local_15c;
    char Response [300];
    int local_2c;
    int Numbers [3];
    
    if (npc == (TNPC *)0x0) {
        pcVar22 = "TBehaviourDatabase::react: NPC existiert nicht.\n";
    }
    else {
        if (Text != (char *)0x0) {
            this_00 = GetPlayer(npc->Interlocutor);
            if (this_00 == (TPlayer *)0x0) {
                error(&DAT_08105220,Text,Situation);
                return;
            }
            local_2c = -1;
            Numbers[0] = -1;
            bestPattern = -1;
            i = -1;
            Numbers[1] = -1;
            B_1 = (TBehaviour *)0x0;
            if (0 < this->Behaviours) {
                do {
                    pTVar5 = vector<TBehaviour>::operator()(&this->Behaviour,(int)B_1);
                    iStack_1cc = 0;
                    bVar21 = true;
                    iVar9 = pTVar5->Conditions;
                    pcVar22 = Text;
                    if (iVar9 < 1) {
LAB_080b5354:
                        if ((bVar21) && (bestPattern < iVar9)) {
                            i = (int)B_1;
                            bestPattern = iVar9;
                        }
                    }
                    else {
                        do {
                            pTVar12 = vector<TCondition>::operator()(&pTVar5->Condition,iStack_1cc);
                            switch(pTVar12->Type) {
                            case 1:
                                pcVar23 = GetDynamicString(pTVar12->Text);
                                pcVar23 = SearchForWord(pcVar23,pcVar22);
                                if (pcVar23 == (char *)0x0) {
LAB_080b5379:
                                    bVar21 = false;
                                }
                                else {
                                    pcVar22 = GetDynamicString(pTVar12->Text);
                                    sVar7 = strlen(pcVar22);
                                    pcVar22 = pcVar23 + sVar7;
                                }
                                break;
                            case 2:
                                iVar9 = pTVar12->Property;
                                if (((iVar9 == 1) && (Situation != ADDRESS)) &&
                                   (Situation != ADDRESSQUEUE)) {
                                    bVar21 = false;
                                }
                                if ((iVar9 == 2) && (Situation != BUSY)) {
                                    bVar21 = false;
                                }
                                if ((iVar9 == 3) && (Situation != VANISH)) {
                                    bVar21 = false;
                                }
                                if ((iVar9 == 4) && ((this_00->super_TCreature).Sex != 1)) {
                                    bVar21 = false;
                                }
                                if ((iVar9 == 5) && ((this_00->super_TCreature).Sex != 2)) {
                                    bVar21 = false;
                                }
                                if (iVar9 == 6) {
                                    uVar4 = TPlayer::GetEffectiveProfession(this_00);
                                    if (uVar4 != '\x01') {
                                        bVar21 = false;
                                    }
                                    iVar9 = pTVar12->Property;
                                }
                                if (iVar9 == 7) {
                                    uVar4 = TPlayer::GetEffectiveProfession(this_00);
                                    if (uVar4 != '\x02') {
                                        bVar21 = false;
                                    }
                                    iVar9 = pTVar12->Property;
                                }
                                if (iVar9 == 8) {
                                    uVar4 = TPlayer::GetEffectiveProfession(this_00);
                                    if (uVar4 != '\x03') {
                                        bVar21 = false;
                                    }
                                    iVar9 = pTVar12->Property;
                                }
                                if (iVar9 == 9) {
                                    uVar4 = TPlayer::GetEffectiveProfession(this_00);
                                    if (uVar4 != '\x04') {
                                        bVar21 = false;
                                    }
                                    iVar9 = pTVar12->Property;
                                }
                                if (iVar9 == 10) {
                                    bVar20 = CheckRight((this_00->super_TCreature).ID,
                                                        PREMIUM_ACCOUNT);
                                    if (!bVar20) {
                                        bVar21 = false;
                                    }
                                    iVar9 = pTVar12->Property;
                                }
                                if (iVar9 == 0xb) {
                                    bVar3 = TPlayer::GetRealProfession(this_00);
                                    if (bVar3 < 10) {
                                        bVar21 = false;
                                    }
                                    iVar9 = pTVar12->Property;
                                }
                                if ((iVar9 == 0xc) &&
                                   ((this_00->super_TCreature).EarliestProtectionZoneRound <=
                                    RoundNr)) {
                                    bVar21 = false;
                                }
                                if ((iVar9 == 0xd) && (WorldType != NON_PVP)) {
                                    bVar21 = false;
                                }
                                if ((iVar9 == 0xe) && (WorldType != PVP_ENFORCED))
                                goto LAB_080b5379;
                                break;
                            case 3:
                                pcVar23 = SearchForNumber(pTVar12->Number,pcVar22);
                                if (pcVar23 == (char *)0x0) goto LAB_080b5379;
                                iVar9 = pTVar12->Number;
                                uVar13 = __strtol_internal(pcVar23,0,10,0);
                                *(undefined4 *)(Response + iVar9 * 4 + 0x128) = uVar13;
                                if (500 < *(int *)(Response + pTVar12->Number * 4 + 0x128)) {
                                    pcVar22 = Response + pTVar12->Number * 4 + 0x128;
                                    pcVar22[0] = -0xc;
                                    pcVar22[1] = '\x01';
                                    pcVar22[2] = '\0';
                                    pcVar22[3] = '\0';
                                }
                                pcVar22 = pcVar23 + 1;
                                break;
                            case 4:
                                iVar9 = evaluate(this,npc,pTVar12->Expression,&local_2c);
                                if (iVar9 == 0) goto LAB_080b5379;
                                break;
                            case 5:
                                i = (int)B_1;
                                goto LAB_080b4622;
                            }
                            iStack_1cc = iStack_1cc + 1;
                            iVar9 = pTVar5->Conditions;
                            if (iVar9 <= iStack_1cc) goto LAB_080b5354;
                        } while (bVar21);
                    }
                    B_1 = (TBehaviour *)((int)&(B_1->Condition).min + 1);
                } while ((int)B_1 < this->Behaviours);
            }
            if (bestPattern == -1) {
                return;
            }
LAB_080b4622:
            if (Situation != BUSY) {
                npc->Topic = 0;
            }
            bVar21 = false;
            B = (TBehaviour *)0x3e8;
LAB_080b4645:
            pTVar5 = vector<TBehaviour>::operator()(&this->Behaviour,i);
            AText = (char *)0x0;
            if (pTVar5->Actions < 1) {
LAB_080b479b:
                if (!bVar21) {
                    return;
                }
                TCreature::ToDoWait((TCreature *)npc,(int)B);
                TCreature::ToDoStart((TCreature *)npc);
                if (Situation == BUSY) {
                    return;
                }
                npc->LastTalk = (int)B / 1000 + RoundNr;
                return;
            }
            do {
                pTVar24 = (TNPC *)AText;
                pTVar6 = vector<TAction>::operator()(&pTVar5->Action,(int)AText);
                switch(pTVar6->Type) {
                case 1:
                    puVar15 = &local_15c;
                    for (iVar9 = 0x4b; iVar9 != 0; iVar9 = iVar9 + -1) {
                        *puVar15 = 0;
                        puVar15 = puVar15 + 1;
                    }
                    pcVar22 = GetDynamicString(pTVar6->Text);
                    for (uVar19 = 0; sVar7 = strlen(pcVar22), uVar19 < sVar7; uVar19 = uVar19 + 1) {
                        if (pcVar22[uVar19] == '%') {
                            uVar19 = uVar19 + 1;
                            cVar1 = pcVar22[uVar19];
                            if (cVar1 == 'N') {
                                strcpy((char *)&Minute,(this_00->super_TCreature).Name);
                            }
                            else if (cVar1 < 'O') {
                                if (cVar1 == 'A') {
                                    iVar9 = npc->Amount;
LAB_080b4856:
                                    sprintf((char *)&Minute,"%d",iVar9);
                                }
                                else {
LAB_080b4814:
                                    Minute = Minute & 0xffffff00;
                                }
                            }
                            else {
                                if (cVar1 == 'P') {
                                    iVar9 = npc->Price;
                                    goto LAB_080b4856;
                                }
                                if (cVar1 != 'T') goto LAB_080b4814;
                                GetTime(&local_1a4,&Hour);
                                if (local_1a4 < 0xc) {
                                    pcVar23 = "%d:%.2d am";
                                }
                                else {
                                    pcVar23 = "%d:%.2d pm";
                                }
                                sprintf((char *)&Minute,pcVar23,(local_1a4 + 0xb) % 0xc + 1,Hour);
                            }
                            strcat((char *)&local_15c,(char *)&Minute);
                        }
                        else {
                            puVar15 = &local_15c;
                            do {
                                puVar14 = puVar15;
                                uVar16 = *puVar14 + 0xfefefeff & ~*puVar14;
                                uVar17 = uVar16 & 0x80808080;
                                puVar15 = puVar14 + 1;
                            } while (uVar17 == 0);
                            bVar20 = (uVar16 & 0x8080) == 0;
                            if (bVar20) {
                                uVar17 = uVar17 >> 0x10;
                            }
                            if (bVar20) {
                                puVar15 = (uint *)((int)puVar14 + 6);
                            }
                            acStack_15f
                            [(int)puVar15 +
                             (-(int)&local_15c - (uint)CARRY1((byte)uVar17,(byte)uVar17))] =
                                 pcVar22[uVar19];
                        }
                        if (Response[0xfc] != '\0') goto LAB_080b4755;
                    }
                    if (Response[0xfc] == '\0') {
                        TCreature::ToDoWait((TCreature *)npc,(int)B);
                        TCreature::ToDoTalk((TCreature *)npc);
                        puVar15 = &local_15c;
                        do {
                            puVar14 = puVar15;
                            uVar17 = *puVar14 + 0xfefefeff & ~*puVar14;
                            uVar19 = uVar17 & 0x80808080;
                            puVar15 = puVar14 + 1;
                        } while (uVar19 == 0);
                        bVar21 = (uVar17 & 0x8080) == 0;
                        if (bVar21) {
                            uVar19 = uVar19 >> 0x10;
                        }
                        if (bVar21) {
                            puVar15 = (uint *)((int)puVar14 + 6);
                        }
                        B = (TBehaviour *)
                            ((int)&B[0x1c].Action +
                            ((int)puVar15 +
                             ((-3 - (uint)CARRY1((byte)uVar19,(byte)uVar19)) - (int)&local_15c) >> 1
                            ) * 100 + 0x1c);
LAB_080b49eb:
                        bVar21 = true;
                    }
                    else {
LAB_080b4755:
                        Response[0x10] = '\0';
                        puVar15 = &local_15c;
                        pcVar22 = 
                        "TBehaviourDatabase::react: Text von NPC %s wird zu lang (%s...).\n";
LAB_080b4779:
                        error(pcVar22,(npc->super_TNonplayer).super_TCreature.Name,puVar15);
                    }
                    break;
                case 2:
                    pTVar24 = npc;
                    uVar8 = evaluate(this,npc,pTVar6->Expression,&local_2c);
                    switch(pTVar6->Number) {
                    default:
                        pcVar22 = &DAT_08104dc0;
                        goto LAB_080b4a67;
                    case 1:
                        npc->Topic = uVar8;
                        break;
                    case 2:
                        npc->Price = uVar8;
                        break;
                    case 3:
                        npc->Amount = uVar8;
                        break;
                    case 4:
                        npc->TypeID = uVar8;
                        break;
                    case 6:
                        npc->Data = uVar8;
                    }
                    break;
                case 3:
                    pTVar24 = npc;
                    iVar9 = evaluate(this,npc,pTVar6->Expression,&local_2c);
                    if (pTVar6->Number != 2) {
                        pcVar22 = &DAT_08104e00;
                        goto LAB_080b4a67;
                    }
                    (*(this_00->super_TCreature).super_TSkillBase.Skills[2]->_vptr_TSkill[2])
                              ((this_00->super_TCreature).super_TSkillBase.Skills[2],iVar9);
                    iVar9 = TSkill::Get((this_00->super_TCreature).super_TSkillBase.Skills[2]);
                    if (iVar9 < 1) {
                        error(&DAT_08104e40,(npc->super_TNonplayer).super_TCreature.Name);
                        (*(this_00->super_TCreature)._vptr_TCreature[2])(this_00);
                    }
                    break;
                case 4:
                    iVar9 = evaluate(this,npc,pTVar6->Expression,&local_2c);
                    pTVar24 = npc;
                    iVar10 = evaluate(this,npc,pTVar6->Expression2,&local_2c);
                    if (pTVar6->Number != 3) {
                        pcVar22 = &DAT_08104e80;
                        goto LAB_080b4a67;
                    }
                    TPlayer::SetQuestValue(this_00,iVar9,iVar10);
                    break;
                case 5:
                    pTVar24 = npc;
                    iVar9 = evaluate(this,npc,pTVar6->Expression,&local_2c);
                    switch(pTVar6->Number) {
                    default:
                        pcVar22 = &DAT_08104ec0;
                        goto LAB_080b4a67;
                    case 1:
                        pTVar18 = (TPlayer *)npc;
                        goto LAB_080b4bb8;
                    case 2:
                        pTVar18 = this_00;
LAB_080b4bb8:
                        Minute = (pTVar18->super_TCreature).CrObject.ObjectID;
                        GraphicalEffect((Object *)&Minute,iVar9);
                        break;
                    case 3:
                        TPlayer::SetProfession(this_00,(uchar)iVar9);
                        break;
                    case 4:
                        TPlayer::LearnSpell(this_00,iVar9);
                        break;
                    case 5:
                        Opp = (TPlayer *)(npc->super_TNonplayer).super_TCreature.posx;
                        local_1ac = (npc->super_TNonplayer).super_TCreature.posy;
                        local_1a8 = (npc->super_TNonplayer).super_TCreature.posz;
                        if (iVar9 - 1U < 0x1ff) {
                            if (RaceData[iVar9].Name[0] != '\0') {
                                SearchFreeField((int *)&Opp,&local_1ac,&local_1a8,2,0,false);
                                this_01 = (TMonster *)operator_new(0x32c);
                    // try { // try from 080b4cfc to 080b4d00 has its CatchHandler @ 080b5666
                                TMonster::TMonster(this_01);
                                GraphicalEffect();
                                break;
                            }
                            pcVar22 = &DAT_08104f00;
                        }
                        else {
                            pcVar22 = &DAT_08104f40;
                        }
                        error(pcVar22,iVar9);
                        break;
                    case 6:
                        Type = (ObjectType *)&Minute;
                        ObjectType::setTypeID((ObjectType *)&Minute,iVar9);
                        iVar9 = npc->Amount;
LAB_080b4d73:
                        TNPC::GiveTo(npc,Type,iVar9);
                        break;
                    case 7:
                        ObjectType::setTypeID((ObjectType *)&Minute,iVar9);
                        iVar9 = npc->Amount;
                        if (iVar9 != 0) {
                            pcVar22 = ObjectType::getName((ObjectType *)&Minute);
                            Log("npc","%s <- %ld: %d %s\n",
                                (npc->super_TNonplayer).super_TCreature.Name,npc->Interlocutor,iVar9
                                ,pcVar22);
                    // try { // try from 080b4e01 to 080b4e28 has its CatchHandler @ 080b5678
                            ObjectType::setTypeID((ObjectType *)(Help + 0xc),Minute);
                            DeleteAtCreature(npc->Interlocutor,(ObjectType *)(Help + 0xc),iVar9,
                                             npc->Data);
                        }
                    }
                    break;
                case 6:
                    iVar9 = pTVar6->Number;
                    if (iVar9 != 2) {
                        if (iVar9 < 3) {
                            if (iVar9 == 1) {
                                iVar10 = npc->Price;
                                iVar9 = iVar10 % 100;
                                Type = (ObjectType *)(Help + 0xc);
                                GetSpecialObject((SPECIALMEANING)Type);
                                TNPC::GiveTo(npc,Type,iVar10 / 10000);
                                GetSpecialObject((SPECIALMEANING)Type);
                                TNPC::GiveTo(npc,Type,(iVar10 % 10000) / 100);
                                GetSpecialObject((SPECIALMEANING)Type);
                                goto LAB_080b4d73;
                            }
                        }
                        else if (iVar9 == 3) {
                            if (Situation != BUSY) {
                                error(&DAT_08104fc0);
                            }
                            TNPC::Enqueue(npc,npc->Interlocutor,Text);
                            break;
                        }
                        pcVar22 = &DAT_08104f80;
                        goto LAB_080b4a67;
                    }
                    TNPC::GetMoney(npc,npc->Price);
                    break;
                case 7:
                    if (!bVar21) {
                        (npc->super_TNonplayer).State = pTVar6->Number;
                        if (Situation == ADDRESSQUEUE) {
                            pcVar22 = 
                            "TBehaviourDatabase::react: NPC %s reagiert nicht auf Anrede %s.\n";
                            puVar15 = (uint *)Text;
                            goto LAB_080b4779;
                        }
                        goto LAB_080b49eb;
                    }
                    iVar9 = pTVar6->Number;
                    if (iVar9 == 1) {
                        (npc->super_TNonplayer).State = LEAVING;
                        iVar9 = pTVar6->Number;
                    }
                    TCreature::ToDoChangeState((TCreature *)npc,iVar9);
                    break;
                case 8:
                    iVar9 = evaluate(this,npc,pTVar6->Expression,&local_2c);
                    pTVar24 = npc;
                    evaluate(this,npc,pTVar6->Expression2,&local_2c);
                    if (1 < pTVar6->Number - 0x11U) {
                        pcVar22 = &DAT_08105080;
                        goto LAB_080b4a67;
                    }
                    if ((iVar9 == 0) ||
                       (pTVar2 = (this_00->super_TCreature).super_TSkillBase.Skills[pTVar6->Number],
                       iVar10 = (*pTVar2->_vptr_TSkill[0xd])(pTVar2), iVar10 < iVar9)) {
                        TSkillBase::SetTimer(&(this_00->super_TCreature).super_TSkillBase);
                        if (pTVar6->Number == 0x12) {
                            (this_00->super_TCreature).FireDamageOrigin = 0;
                        }
                        else {
                            (this_00->super_TCreature).PoisonDamageOrigin = 0;
                        }
                    }
                    break;
                case 9:
                    if (i != 0) goto LAB_080b50d7;
                    pcVar22 = "TBehaviourDatabase::react (9): Kein vorheriges Muster.\n";
LAB_080b4a67:
                    error(pcVar22,pTVar24);
                    break;
                case 10:
                    iVar9 = evaluate(this,npc,pTVar6->Expression,&local_2c);
                    iVar10 = evaluate(this,npc,pTVar6->Expression2,&local_2c);
                    pTVar24 = npc;
                    iVar11 = evaluate(this,npc,pTVar6->Expression3,&local_2c);
                    if (pTVar6->Number != 1) {
                        if (pTVar6->Number == 2) {
                            pTVar24 = (TNPC *)&DAT_08105140;
                            print();
                            if ((this_00->super_TCreature).Type == PLAYER) {
                                (this_00->super_TCreature).startx = iVar9;
                                (this_00->super_TCreature).startz = iVar11;
                                (this_00->super_TCreature).starty = iVar10;
                                TPlayer::SaveData(this_00);
                                break;
                            }
                            pcVar22 = &DAT_08105180;
                        }
                        else {
                            pcVar22 = &DAT_08105100;
                        }
                        goto LAB_080b4a67;
                    }
                    print();
                    Help[0xc] = (undefined1)::NONE.ObjectID;
                    Help[0xd] = ::NONE.ObjectID._1_1_;
                    Help[0xe] = ::NONE.ObjectID._2_1_;
                    Help[0xf] = ::NONE.ObjectID._3_1_;
                    // try { // try from 080b5218 to 080b5265 has its CatchHandler @ 080b56be
                    GetMapContainer((int)&Minute,iVar9,iVar10);
                    Help._28_4_ = (this_00->super_TCreature).CrObject.ObjectID;
                    Move(0,(Object *)(Help + 0x1c),(Object *)&Minute,-1,false,(Object *)(Help + 0xc)
                        );
                }
                AText = AText + 1;
                if (pTVar5->Actions <= (int)AText) goto LAB_080b479b;
            } while( true );
        }
        pcVar22 = &DAT_08105280;
    }
    error(pcVar22);
    return;
LAB_080b50d7:
    i = i + -1;
    goto LAB_080b4645;
}



void StartMonsterhomeTimer(int nr)

{
    TMonsterhome *pTVar1;
    long lVar2;
    int NumberOfPlayers;
    TMonsterhome *MH;
    int PlayerAdjustedTime;
    
    if ((nr < 1) || (Monsterhomes < nr)) {
        error(&DAT_08105380,nr);
    }
    else {
        pTVar1 = vector<>::operator()(&Monsterhome,nr);
        if (0 < pTVar1->Timer) {
            error(&DAT_081053c0);
            return;
        }
        if (pTVar1->ActMonsters < pTVar1->MaxMonsters) {
            GetNumberOfPlayers();
            lVar2 = random();
            pTVar1->Timer = lVar2;
        }
        else {
            error("StartMonsterhomeTimer: Maximale Monsterzahl schon erreicht.\n");
            error("# Monsterhome mit Rasse %d an [%d,%d,%d]\n",pTVar1->Race,pTVar1->x,pTVar1->y,
                  pTVar1->z);
        }
    }
    return;
}



// WARNING: Removing unreachable block (ram,0x080b5ba0)
// WARNING: Unknown calling convention -- yet parameter storage is locked

void LoadMonsterhomes(void)

{
    bool bVar1;
    int r;
    int iVar2;
    TMonsterhome *pTVar3;
    TMonster *this;
    int *piVar4;
    int Race;
    TMonsterhome *MH;
    char *Text;
    char *pcVar5;
    int local_5024;
    int j;
    int i;
    int local_5018;
    int local_5014;
    int local_5010;
    int x;
    int y;
    int z;
    int local_5000;
    undefined1 local_4ffc [4];
    TReadScriptFile Script;
    char local_101c [4];
    char FileName [4096];
    
                    // try { // try from 080b5821 to 080b5851 has its CatchHandler @ 080b5c40
    print();
    pcVar5 = DATAPATH;
    sprintf(local_101c,"%s/monster.db");
    TReadScriptFile::TReadScriptFile((TReadScriptFile *)local_4ffc);
                    // try { // try from 080b5859 to 080b5955 has its CatchHandler @ 080b5c33
    TReadScriptFile::open((TReadScriptFile *)local_4ffc,local_101c,(int)pcVar5);
    Monsterhomes = 0;
    while (iVar2 = TReadScriptFile::readNumber((TReadScriptFile *)local_4ffc), iVar2 != 0) {
        Monsterhomes = Monsterhomes + 1;
        pTVar3 = vector<>::operator()(&Monsterhome,Monsterhomes);
        pTVar3->Race = iVar2;
        iVar2 = TReadScriptFile::readNumber((TReadScriptFile *)local_4ffc);
        pTVar3->x = iVar2;
        iVar2 = TReadScriptFile::readNumber((TReadScriptFile *)local_4ffc);
        pTVar3->y = iVar2;
        iVar2 = TReadScriptFile::readNumber((TReadScriptFile *)local_4ffc);
        pTVar3->z = iVar2;
        bVar1 = IsOnMap(pTVar3->x,pTVar3->y,iVar2);
        if (!bVar1) {
            print();
        }
        iVar2 = TReadScriptFile::readNumber((TReadScriptFile *)local_4ffc);
        pTVar3->Radius = iVar2;
        iVar2 = TReadScriptFile::readNumber((TReadScriptFile *)local_4ffc);
        pTVar3->MaxMonsters = iVar2;
        pTVar3->ActMonsters = 0;
        iVar2 = TReadScriptFile::readNumber((TReadScriptFile *)local_4ffc);
        pTVar3->RegenerationTime = iVar2;
        pTVar3->Timer = 0;
    }
    pcVar5 = "%d Monsterhomes geladen.\n";
    print();
    TReadScriptFile::close((TReadScriptFile *)local_4ffc,(int)pcVar5);
    j = 1;
    if (0 < Monsterhomes) {
        do {
            pcVar5 = (char *)j;
                    // try { // try from 080b5994 to 080b5b4d has its CatchHandler @ 080b5c33
            pTVar3 = vector<>::operator()(&Monsterhome,j);
            local_5024 = 0;
            iVar2 = pTVar3->MaxMonsters;
            if (0 < iVar2) {
                do {
                    local_5010 = pTVar3->x;
                    x = pTVar3->y;
                    y = pTVar3->z;
                    if (local_5024 == 0) {
                        local_5000 = 1;
                        piVar4 = &local_5000;
                        if (pTVar3->Radius < 1) {
                            piVar4 = &pTVar3->Radius;
                        }
                        iVar2 = *piVar4;
                    }
                    else {
                        z = 10;
                        piVar4 = &z;
                        if (pTVar3->Radius < 10) {
                            piVar4 = &pTVar3->Radius;
                        }
                        iVar2 = -*piVar4;
                    }
                    pcVar5 = (char *)&x;
                    bVar1 = SearchSpawnField(&local_5010,(int *)pcVar5,&y,iVar2,false);
                    if (bVar1) {
                        pcVar5 = (char *)pTVar3->Race;
                        i = local_5010;
                        local_5018 = x;
                        local_5014 = y;
                        if ((int)pcVar5 - 1U < 0x1ff) {
                            if (RaceData[(int)pcVar5].Name[0] == '\0') {
                                Text = &DAT_08104f00;
                                goto LAB_080b5a8b;
                            }
                            SearchFreeField(&i,&local_5018,&local_5014,2,0,false);
                            this = (TMonster *)operator_new(0x32c);
                    // try { // try from 080b5b91 to 080b5b95 has its CatchHandler @ 080b5c04
                            TMonster::TMonster(this);
                        }
                        else {
                            Text = &DAT_08104f40;
LAB_080b5a8b:
                            error(Text);
                        }
                        pTVar3->ActMonsters = pTVar3->ActMonsters + 1;
                    }
                    local_5024 = local_5024 + 1;
                    iVar2 = pTVar3->MaxMonsters;
                } while (local_5024 < iVar2);
            }
            if (pTVar3->Timer < 1) {
                if (pTVar3->ActMonsters < iVar2) {
                    StartMonsterhomeTimer(j);
                }
            }
            else {
                pcVar5 = (char *)pTVar3->Race;
                error(&DAT_08105500,pcVar5,pTVar3->x,pTVar3->y,pTVar3->z);
            }
            j = j + 1;
        } while (j <= Monsterhomes);
    }
                    // try { // try from 080b5971 to 080b5975 has its CatchHandler @ 080b5c40
    TReadScriptFile::~TReadScriptFile((TReadScriptFile *)local_4ffc,(int)pcVar5);
    return;
}



// WARNING: Removing unreachable block (ram,0x080b5f11)
// WARNING: Unknown calling convention -- yet parameter storage is locked

void ProcessMonsterhomes(void)

{
    bool bVar1;
    int r;
    TMonsterhome *pTVar2;
    int iVar3;
    int *piVar4;
    ulong id;
    TCreature *pTVar5;
    uint uVar6;
    TMonster *this;
    int iVar7;
    TCreature *cr;
    uint uVar8;
    TMonsterhome *MH;
    int i;
    int i_00;
    char *Text;
    int local_78;
    int local_74;
    int local_70;
    int local_6c;
    int x;
    int y;
    int z;
    int local_5c [3];
    int MaxRadius;
    undefined1 local_4c [4];
    TFindCreatures Search;
    
    i_00 = 1;
    if (0 < Monsterhomes) {
        do {
            pTVar2 = vector<>::operator()(&Monsterhome,i_00);
            if ((pTVar2->Timer != 0) &&
               (iVar3 = pTVar2->Timer + -1, pTVar2->Timer = iVar3, iVar3 < 1)) {
                local_6c = pTVar2->x;
                x = pTVar2->y;
                y = pTVar2->z;
                MaxRadius = 10;
                piVar4 = &MaxRadius;
                if (pTVar2->Radius < 10) {
                    piVar4 = &pTVar2->Radius;
                }
                local_5c[2] = *piVar4;
                iVar3 = 1;
                TFindCreatures::TFindCreatures
                          ((TFindCreatures *)local_4c,local_5c[2] + 9,local_5c[2] + 7,local_6c,x,1);
LAB_080b5d00:
                while (id = TFindCreatures::getNext((TFindCreatures *)local_4c), id != 0) {
                    pTVar5 = GetCreature(id);
                    if (pTVar5 == (TCreature *)0x0) {
                        error("ProcessMonsterhomes: Kreatur existiert nicht.\n");
                        break;
                    }
                    if (pTVar5->posz < 8) goto LAB_080b5d8f;
                    if ((y - pTVar5->posz) + 2U < 5) goto LAB_080b5d39;
                }
                if (pTVar2->ActMonsters == 0) {
                    z = 1;
                    piVar4 = &z;
                    if (pTVar2->Radius < 1) {
                        piVar4 = &pTVar2->Radius;
                    }
                    iVar7 = *piVar4;
                }
                else {
                    iVar7 = -local_5c[2];
                }
                if ((-1 < local_5c[2]) &&
                   (bVar1 = SearchSpawnField(&local_6c,&x,&y,iVar7,false), bVar1)) {
                    iVar7 = pTVar2->Race;
                    local_78 = local_6c;
                    local_74 = x;
                    local_70 = y;
                    if (iVar7 - 1U < 0x1ff) {
                        if (RaceData[iVar7].Name[0] == '\0') {
                            Text = &DAT_08104f00;
                            goto LAB_080b5e43;
                        }
                        SearchFreeField(&local_78,&local_74,&local_70,2,0,false);
                        this = (TMonster *)operator_new(0x32c);
                        iVar3 = i_00;
                    // try { // try from 080b5f02 to 080b5f06 has its CatchHandler @ 080b5f53
                        TMonster::TMonster(this);
                    }
                    else {
                        Text = &DAT_08104f40;
LAB_080b5e43:
                        error(Text,iVar7);
                    }
                    pTVar2->ActMonsters = pTVar2->ActMonsters + 1;
                    if (0 < pTVar2->Timer) {
                        error(&DAT_08105580,pTVar2->Race,local_6c,x,y,iVar3);
                        goto LAB_080b5c95;
                    }
                }
                if (pTVar2->ActMonsters < pTVar2->MaxMonsters) {
                    StartMonsterhomeTimer(i_00);
                }
            }
LAB_080b5c95:
            i_00 = i_00 + 1;
        } while (i_00 <= Monsterhomes);
    }
    return;
LAB_080b5d8f:
    if (y < 8) {
LAB_080b5d39:
        uVar8 = pTVar5->posx - local_6c;
        if (0x7fffffff < uVar8) {
            uVar8 = -uVar8;
        }
        uVar6 = pTVar5->posy - x;
        local_5c[1] = uVar8 - 9;
        if (0x7fffffff < uVar6) {
            uVar6 = -uVar6;
        }
        local_5c[0] = uVar6 - 7;
        piVar4 = local_5c;
        if ((int)(uVar6 - 7) <= (int)(uVar8 - 9)) {
            piVar4 = local_5c + 1;
        }
        if (local_5c[2] <= *piVar4) {
            piVar4 = local_5c + 2;
        }
        local_5c[2] = *piVar4;
    }
    goto LAB_080b5d00;
}



void NotifyMonsterhomeOfDeath(int nr)

{
    TMonsterhome *pTVar1;
    int iVar2;
    TMonsterhome *MH;
    
    if ((nr < 1) || (Monsterhomes < nr)) {
        error(&DAT_081055e0,nr);
    }
    else {
        pTVar1 = vector<>::operator()(&Monsterhome,nr);
        if (pTVar1->ActMonsters < 1) {
            error("NotifyMonsterhomeOfDeath: Monsterhome hat keine lebenden Kreaturen.\n");
            return;
        }
        iVar2 = pTVar1->ActMonsters + -1;
        pTVar1->ActMonsters = iVar2;
        if (iVar2 < pTVar1->MaxMonsters) {
            if (pTVar1->Timer == 0) {
                StartMonsterhomeTimer(nr);
                return;
            }
        }
        else {
            error("NotifyMonsterhomeOfDeath: Monsterhome %d hatte zu viele Monster (%d statt %d).\n"
                  ,nr,pTVar1->ActMonsters + 1,pTVar1->MaxMonsters);
        }
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

bool MonsterhomeInRange(void)

{
    TMonsterhome *pTVar1;
    uint uVar2;
    TMonsterhome *MH;
    bool bVar3;
    int in_stack_00000004;
    int in_stack_00000008;
    int in_stack_0000000c;
    int in_stack_00000010;
    
    bVar3 = true;
    if (in_stack_00000004 != 0) {
        if ((in_stack_00000004 < 1) || (Monsterhomes < in_stack_00000004)) {
            error(&DAT_081056e0);
            bVar3 = false;
        }
        else {
            pTVar1 = vector<>::operator()(&Monsterhome,in_stack_00000004);
            uVar2 = in_stack_00000010 - pTVar1->z;
            if (0x7fffffff < uVar2) {
                uVar2 = -uVar2;
            }
            bVar3 = false;
            if ((int)uVar2 < 3) {
                uVar2 = in_stack_00000008 - pTVar1->x;
                if (0x7fffffff < uVar2) {
                    uVar2 = -uVar2;
                }
                bVar3 = false;
                if ((int)uVar2 <= pTVar1->Radius) {
                    uVar2 = in_stack_0000000c - pTVar1->y;
                    if (0x7fffffff < uVar2) {
                        uVar2 = -uVar2;
                    }
                    bVar3 = (int)uVar2 <= pTVar1->Radius;
                }
            }
        }
    }
    return bVar3;
}



// DWARF original prototype: void TNonplayer(TNonplayer * this)

void __thiscall TNonplayer::TNonplayer(TNonplayer *this)

{
    TCreature::TCreature(&this->super_TCreature);
    (this->super_TCreature)._vptr_TCreature = (_func_int_varargs **)&PTR__TNonplayer_08127d28;
    this->State = SLEEPING;
    return;
}



// DWARF original prototype: void TNonplayer(TNonplayer * this)

void __thiscall TNonplayer::TNonplayer(TNonplayer *this)

{
    TCreature::TCreature(&this->super_TCreature);
    (this->super_TCreature)._vptr_TCreature = (_func_int_varargs **)&PTR__TNonplayer_08127d28;
    this->State = SLEEPING;
    return;
}



// DWARF original prototype: void ~TNonplayer(TNonplayer * this, int __in_chrg)

void __thiscall TNonplayer::~TNonplayer(TNonplayer *this,int __in_chrg)

{
    TNonplayer **ppTVar1;
    TNonplayer **ppTVar2;
    int i;
    int i_00;
    bool bVar3;
    int in_stack_ffffffe8;
    
    i_00 = 0;
    bVar3 = 0 < FirstFreeNonplayer;
    (this->super_TCreature)._vptr_TCreature = (_func_int_varargs **)&PTR__TNonplayer_08127d28;
    if (bVar3) {
        do {
            in_stack_ffffffe8 = i_00;
            ppTVar1 = vector<>::operator()(&NonplayerList,i_00);
            if (*ppTVar1 == this) {
                ppTVar1 = vector<>::operator()(&NonplayerList,i_00);
                ppTVar2 = vector<>::operator()(&NonplayerList,FirstFreeNonplayer + -1);
                *ppTVar1 = *ppTVar2;
                in_stack_ffffffe8 = FirstFreeNonplayer + -1;
                ppTVar1 = vector<>::operator()(&NonplayerList,in_stack_ffffffe8);
                FirstFreeNonplayer = FirstFreeNonplayer + -1;
                *ppTVar1 = (TNonplayer *)0x0;
                goto LAB_080b6169;
            }
            i_00 = i_00 + 1;
        } while (i_00 < FirstFreeNonplayer);
    }
    error("TNonplayer::DelInList: Kreatur nicht gefunden.\n");
LAB_080b6169:
    TCreature::~TCreature(&this->super_TCreature,in_stack_ffffffe8);
    return;
}



// DWARF original prototype: void ~TNonplayer(TNonplayer * this, int __in_chrg)

void __thiscall TNonplayer::~TNonplayer(TNonplayer *this,int __in_chrg)

{
    TNonplayer **ppTVar1;
    TNonplayer **ppTVar2;
    int i;
    int i_00;
    bool bVar3;
    int in_stack_ffffffe8;
    
    i_00 = 0;
    bVar3 = 0 < FirstFreeNonplayer;
    (this->super_TCreature)._vptr_TCreature = (_func_int_varargs **)&PTR__TNonplayer_08127d28;
    if (bVar3) {
        do {
            in_stack_ffffffe8 = i_00;
            ppTVar1 = vector<>::operator()(&NonplayerList,i_00);
            if (*ppTVar1 == this) {
                ppTVar1 = vector<>::operator()(&NonplayerList,i_00);
                ppTVar2 = vector<>::operator()(&NonplayerList,FirstFreeNonplayer + -1);
                *ppTVar1 = *ppTVar2;
                in_stack_ffffffe8 = FirstFreeNonplayer + -1;
                ppTVar1 = vector<>::operator()(&NonplayerList,in_stack_ffffffe8);
                FirstFreeNonplayer = FirstFreeNonplayer + -1;
                *ppTVar1 = (TNonplayer *)0x0;
                goto LAB_080b6219;
            }
            i_00 = i_00 + 1;
        } while (i_00 < FirstFreeNonplayer);
    }
    error("TNonplayer::DelInList: Kreatur nicht gefunden.\n");
LAB_080b6219:
    TCreature::~TCreature(&this->super_TCreature,in_stack_ffffffe8);
    return;
}



// DWARF original prototype: void ~TNonplayer(TNonplayer * this, int __in_chrg)

void __thiscall TNonplayer::~TNonplayer(TNonplayer *this,int __in_chrg)

{
    TNonplayer **ppTVar1;
    TNonplayer **ppTVar2;
    int i;
    int i_00;
    bool bVar3;
    int in_stack_ffffffe8;
    
    i_00 = 0;
    bVar3 = 0 < FirstFreeNonplayer;
    (this->super_TCreature)._vptr_TCreature = (_func_int_varargs **)&PTR__TNonplayer_08127d28;
    if (bVar3) {
        do {
            in_stack_ffffffe8 = i_00;
            ppTVar1 = vector<>::operator()(&NonplayerList,i_00);
            if (*ppTVar1 == this) {
                ppTVar1 = vector<>::operator()(&NonplayerList,i_00);
                ppTVar2 = vector<>::operator()(&NonplayerList,FirstFreeNonplayer + -1);
                *ppTVar1 = *ppTVar2;
                in_stack_ffffffe8 = FirstFreeNonplayer + -1;
                ppTVar1 = vector<>::operator()(&NonplayerList,in_stack_ffffffe8);
                FirstFreeNonplayer = FirstFreeNonplayer + -1;
                *ppTVar1 = (TNonplayer *)0x0;
                goto LAB_080b62c9;
            }
            i_00 = i_00 + 1;
        } while (i_00 < FirstFreeNonplayer);
    }
    error("TNonplayer::DelInList: Kreatur nicht gefunden.\n");
LAB_080b62c9:
    TCreature::~TCreature(&this->super_TCreature,in_stack_ffffffe8);
    operator_delete(this);
    return;
}



// DWARF original prototype: void SetInList(TNonplayer * this)

void __thiscall TNonplayer::SetInList(TNonplayer *this)

{
    TNonplayer **ppTVar1;
    
    TCreature::SetInCrList(&this->super_TCreature);
    ppTVar1 = vector<>::operator()(&NonplayerList,FirstFreeNonplayer);
    *ppTVar1 = this;
    FirstFreeNonplayer = FirstFreeNonplayer + 1;
    return;
}



// DWARF original prototype: void DelInList(TNonplayer * this)

void __thiscall TNonplayer::DelInList(TNonplayer *this)

{
    TNonplayer **ppTVar1;
    TNonplayer **ppTVar2;
    int i;
    int i_00;
    
    i_00 = 0;
    if (0 < FirstFreeNonplayer) {
        do {
            ppTVar1 = vector<>::operator()(&NonplayerList,i_00);
            if (*ppTVar1 == this) {
                ppTVar1 = vector<>::operator()(&NonplayerList,i_00);
                ppTVar2 = vector<>::operator()(&NonplayerList,FirstFreeNonplayer + -1);
                *ppTVar1 = *ppTVar2;
                ppTVar1 = vector<>::operator()(&NonplayerList,FirstFreeNonplayer + -1);
                *ppTVar1 = (TNonplayer *)0x0;
                FirstFreeNonplayer = FirstFreeNonplayer + -1;
                return;
            }
            i_00 = i_00 + 1;
        } while (i_00 < FirstFreeNonplayer);
    }
    error("TNonplayer::DelInList: Kreatur nicht gefunden.\n");
    return;
}



// DWARF original prototype: void TNPC(TNPC * this, char * FileName)

void __thiscall TNPC::TNPC(TNPC *this,char *FileName)

{
    anon_union_4_2_730cd3ca_for_TOutfit_2 aVar1;
    bool bVar2;
    int GoStrength;
    char *pcVar3;
    TBehaviourDatabase *this_00;
    undefined4 *puVar4;
    TOutfit *this_01;
    TNonplayer **ppTVar5;
    int iVar6;
    TSkillBase *this_02;
    char *pcVar7;
    char *pcVar8;
    undefined1 uVar9;
    int *__oflag;
    int *piVar10;
    char local_401c [4];
    char Ident [30];
    TReadScriptFile Script;
    
                    // try { // try from 080b643b to 080b643f has its CatchHandler @ 080b6ae0
    TCreature::TCreature((TCreature *)this);
    (this->super_TNonplayer).State = SLEEPING;
    (this->super_TNonplayer).super_TCreature._vptr_TCreature =
         (_func_int_varargs **)&PTR__TNPC_08127ce8;
                    // try { // try from 080b6477 to 080b647b has its CatchHandler @ 080b6ad8
    vector<>::vector(&this->QueuedPlayers,0,9,10);
    piVar10 = (int *)0xa;
                    // try { // try from 080b64a5 to 080b64a9 has its CatchHandler @ 080b6ad2
    vector<>::vector(&this->QueuedAddresses,0,9,10);
    __oflag = (int *)FileName;
                    // try { // try from 080b64bd to 080b6560 has its CatchHandler @ 080b6acc
    print();
    (this->super_TNonplayer).super_TCreature.Type = NPC;
    (this->super_TNonplayer).super_TCreature.Sex = 1;
    (this->super_TNonplayer).super_TCreature.Race = 0;
    (this->super_TNonplayer).super_TCreature.Outfit.OutfitID = 0;
    (this->super_TNonplayer).super_TCreature.Outfit.field_1 =
         (anon_union_4_2_730cd3ca_for_TOutfit_2)0x0;
    (this->super_TNonplayer).super_TCreature.posz = 0xff;
    this->Behaviour = (TBehaviourDatabase *)0x0;
    this->Topic = 0;
    this->Amount = 1;
    this->Price = 0;
    this->TypeID = 0;
    this->Data = 0;
    (this->super_TNonplayer).super_TCreature.Name[0] = '\0';
    this->LastTalk = 0;
    this->QueueLength = 0;
    (this->super_TNonplayer).super_TCreature.Direction = 2;
    TReadScriptFile::TReadScriptFile((TReadScriptFile *)(Ident + 0x1c));
                    // try { // try from 080b656e to 080b66f8 has its CatchHandler @ 080b6ac6
    TReadScriptFile::open((TReadScriptFile *)(Ident + 0x1c),FileName,(int)__oflag);
    while( true ) {
        TReadScriptFile::nextToken((TReadScriptFile *)(Ident + 0x1c));
        if (stack0xffffc004 == 0) break;
        uVar9 = stack0xffffc004 == 1;
        if (!(bool)uVar9) {
            TReadScriptFile::error((TReadScriptFile *)(Ident + 0x1c),"identifier expected");
        }
        pcVar3 = TReadScriptFile::getIdentifier((TReadScriptFile *)(Ident + 0x1c));
        strcpy(local_401c,pcVar3);
        FileName = (char *)0x3d;
        TReadScriptFile::readSymbol((TReadScriptFile *)(Ident + 0x1c),'=');
        iVar6 = 5;
        pcVar3 = local_401c;
        pcVar7 = "name";
        do {
            if (iVar6 == 0) break;
            iVar6 = iVar6 + -1;
            uVar9 = *pcVar3 == *pcVar7;
            pcVar3 = pcVar3 + 1;
            pcVar7 = pcVar7 + 1;
        } while ((bool)uVar9);
        if ((bool)uVar9) {
            FileName = TReadScriptFile::readString((TReadScriptFile *)(Ident + 0x1c));
            pcVar3 = (this->super_TNonplayer).super_TCreature.Name;
            uVar9 = pcVar3 == (char *)0x0;
            strcpy(pcVar3,FileName);
        }
        iVar6 = 4;
        pcVar3 = local_401c;
        pcVar7 = "sex";
        do {
            if (iVar6 == 0) break;
            iVar6 = iVar6 + -1;
            uVar9 = *pcVar3 == *pcVar7;
            pcVar3 = pcVar3 + 1;
            pcVar7 = pcVar7 + 1;
        } while ((bool)uVar9);
        if ((bool)uVar9) {
            pcVar3 = TReadScriptFile::readIdentifier((TReadScriptFile *)(Ident + 0x1c));
            (this->super_TNonplayer).super_TCreature.Sex = 0xff;
            iVar6 = 5;
            pcVar7 = pcVar3;
            pcVar8 = "male";
            do {
                if (iVar6 == 0) break;
                iVar6 = iVar6 + -1;
                uVar9 = *pcVar7 == *pcVar8;
                pcVar7 = pcVar7 + 1;
                pcVar8 = pcVar8 + 1;
            } while ((bool)uVar9);
            if ((bool)uVar9) {
                (this->super_TNonplayer).super_TCreature.Sex = 1;
            }
            iVar6 = 7;
            pcVar7 = "female";
            do {
                if (iVar6 == 0) break;
                iVar6 = iVar6 + -1;
                uVar9 = *pcVar3 == *pcVar7;
                pcVar3 = pcVar3 + 1;
                pcVar7 = pcVar7 + 1;
            } while ((bool)uVar9);
            if ((bool)uVar9) {
                (this->super_TNonplayer).super_TCreature.Sex = 2;
            }
            uVar9 = (this->super_TNonplayer).super_TCreature.Sex == 0xff;
            if ((bool)uVar9) {
                FileName = "unknown constant";
                TReadScriptFile::error((TReadScriptFile *)(Ident + 0x1c),"unknown constant");
            }
        }
        iVar6 = 5;
        pcVar3 = local_401c;
        pcVar7 = "race";
        do {
            if (iVar6 == 0) break;
            iVar6 = iVar6 + -1;
            uVar9 = *pcVar3 == *pcVar7;
            pcVar3 = pcVar3 + 1;
            pcVar7 = pcVar7 + 1;
        } while ((bool)uVar9);
        if ((bool)uVar9) {
            FileName = (char *)TReadScriptFile::readNumber((TReadScriptFile *)(Ident + 0x1c));
            this_02 = &(this->super_TNonplayer).super_TCreature.super_TSkillBase;
            uVar9 = this_02 == (TSkillBase *)0x0;
            (this->super_TNonplayer).super_TCreature.Race = (int)FileName;
            TSkillBase::SetSkills(this_02,(int)FileName);
        }
        iVar6 = 7;
        pcVar3 = local_401c;
        pcVar7 = "outfit";
        do {
            if (iVar6 == 0) break;
            iVar6 = iVar6 + -1;
            uVar9 = *pcVar3 == *pcVar7;
            pcVar3 = pcVar3 + 1;
            pcVar7 = pcVar7 + 1;
        } while ((bool)uVar9);
        if ((bool)uVar9) {
            FileName = Ident + 0x1c;
            this_01 = &(this->super_TNonplayer).super_TCreature.Outfit;
            uVar9 = this_01 == (TOutfit *)0x0;
            TOutfit::load(this_01,(TReadScriptFile *)FileName);
        }
        iVar6 = 5;
        pcVar3 = local_401c;
        pcVar7 = "home";
        do {
            if (iVar6 == 0) break;
            iVar6 = iVar6 + -1;
            uVar9 = *pcVar3 == *pcVar7;
            pcVar3 = pcVar3 + 1;
            pcVar7 = pcVar7 + 1;
        } while ((bool)uVar9);
        if ((bool)uVar9) {
            TReadScriptFile::readCoordinate((TReadScriptFile *)(Ident + 0x1c));
            piVar10 = &(this->super_TNonplayer).super_TCreature.startz;
            __oflag = &(this->super_TNonplayer).super_TCreature.starty;
            FileName = (char *)&(this->super_TNonplayer).super_TCreature.startx;
            uVar9 = (int *)FileName == (int *)0x0;
            TReadScriptFile::getCoordinate((TReadScriptFile *)(Ident + 0x1c));
        }
        iVar6 = 7;
        pcVar3 = local_401c;
        pcVar7 = "radius";
        do {
            if (iVar6 == 0) break;
            iVar6 = iVar6 + -1;
            uVar9 = *pcVar3 == *pcVar7;
            pcVar3 = pcVar3 + 1;
            pcVar7 = pcVar7 + 1;
        } while ((bool)uVar9);
        if ((bool)uVar9) {
            iVar6 = TReadScriptFile::readNumber((TReadScriptFile *)(Ident + 0x1c));
            (this->super_TNonplayer).super_TCreature.Radius = iVar6;
        }
        iVar6 = 0xb;
        pcVar3 = local_401c;
        pcVar7 = "gostrength";
        do {
            if (iVar6 == 0) break;
            iVar6 = iVar6 + -1;
            uVar9 = *pcVar3 == *pcVar7;
            pcVar3 = pcVar3 + 1;
            pcVar7 = pcVar7 + 1;
        } while ((bool)uVar9);
        if ((bool)uVar9) {
            uVar9 = (this->super_TNonplayer).super_TCreature.Race == 0;
            if ((bool)uVar9) {
                puVar4 = (undefined4 *)__cxa_allocate_exception(4,FileName,__oflag,piVar10);
                *puVar4 = "gostrength before race in npc-script-file";
                goto LAB_080b6737;
            }
            iVar6 = TReadScriptFile::readNumber((TReadScriptFile *)(Ident + 0x1c));
            (this->super_TNonplayer).super_TCreature.super_TSkillBase.Skills[4]->Act = iVar6;
            (this->super_TNonplayer).super_TCreature.super_TSkillBase.Skills[4]->Max = iVar6;
        }
        iVar6 = 10;
        pcVar3 = local_401c;
        pcVar7 = "behaviour";
        do {
            if (iVar6 == 0) break;
            iVar6 = iVar6 + -1;
            uVar9 = *pcVar3 == *pcVar7;
            pcVar3 = pcVar3 + 1;
            pcVar7 = pcVar7 + 1;
        } while ((bool)uVar9);
        if ((bool)uVar9) {
            if (this->Behaviour != (TBehaviourDatabase *)0x0) {
                puVar4 = (undefined4 *)__cxa_allocate_exception(4,FileName,__oflag,piVar10);
                *puVar4 = "behaviour database specified twice for NPC";
                goto LAB_080b6737;
            }
            this_00 = (TBehaviourDatabase *)operator_new(0x8c);
            FileName = Ident + 0x1c;
                    // try { // try from 080b670c to 080b6710 has its CatchHandler @ 080b6a60
            TBehaviourDatabase::TBehaviourDatabase(this_00,(TReadScriptFile *)FileName);
            this->Behaviour = this_00;
        }
    }
    TReadScriptFile::close((TReadScriptFile *)(Ident + 0x1c),(int)FileName);
    if ((this->super_TNonplayer).super_TCreature.Name[0] == '\0') {
        puVar4 = (undefined4 *)__cxa_allocate_exception(4);
        *puVar4 = "no name specified for NPC";
LAB_080b6737:
                    // WARNING: Subroutine does not return
                    // try { // try from 080b674a to 080b696e has its CatchHandler @ 080b6ac6
        __cxa_throw(puVar4,char_const*::typeinfo,0);
    }
    iVar6 = (this->super_TNonplayer).super_TCreature.posz;
    if (iVar6 == 0xff) {
        puVar4 = (undefined4 *)__cxa_allocate_exception(4);
        *puVar4 = "no startpoint specified for NPC";
        goto LAB_080b6737;
    }
    if (this->Behaviour == (TBehaviourDatabase *)0x0) {
        puVar4 = (undefined4 *)__cxa_allocate_exception(4);
        *puVar4 = "no behaviour database specified for NPC";
        goto LAB_080b6737;
    }
    bVar2 = IsOnMap((this->super_TNonplayer).super_TCreature.posx,
                    (this->super_TNonplayer).super_TCreature.posy,iVar6);
    if (bVar2) {
        aVar1 = (this->super_TNonplayer).super_TCreature.Outfit.field_1;
        (this->super_TNonplayer).super_TCreature.OrgOutfit.OutfitID =
             (this->super_TNonplayer).super_TCreature.Outfit.OutfitID;
        (this->super_TNonplayer).super_TCreature.OrgOutfit.field_1 = aVar1;
                    // try { // try from 080b69b0 to 080b6a0c has its CatchHandler @ 080b6ac6
        TCreature::SetID((TCreature *)this,0);
        TCreature::SetInCrList((TCreature *)this);
        pcVar3 = (char *)FirstFreeNonplayer;
        ppTVar5 = vector<>::operator()(&NonplayerList,FirstFreeNonplayer);
        FirstFreeNonplayer = FirstFreeNonplayer + 1;
        *ppTVar5 = &this->super_TNonplayer;
        bVar2 = TCreature::SetOnMap((TCreature *)this);
        if (bVar2) {
            TCreature::ToDoYield((TCreature *)this);
            goto LAB_080b6978;
        }
        pcVar3 = "WARNUNG: Kann NPC \'%s\' nicht setzen.\n";
    }
    else {
        pcVar3 = &DAT_08105800;
    }
    print();
LAB_080b6978:
                    // try { // try from 080b6978 to 080b697c has its CatchHandler @ 080b6acc
    TReadScriptFile::~TReadScriptFile((TReadScriptFile *)(Ident + 0x1c),(int)pcVar3);
    return;
}



// DWARF original prototype: void TNPC(TNPC * this, char * FileName)

void __thiscall TNPC::TNPC(TNPC *this,char *FileName)

{
    anon_union_4_2_730cd3ca_for_TOutfit_2 aVar1;
    bool bVar2;
    int GoStrength;
    char *pcVar3;
    TBehaviourDatabase *this_00;
    undefined4 *puVar4;
    TOutfit *this_01;
    TNonplayer **ppTVar5;
    int iVar6;
    TSkillBase *this_02;
    char *pcVar7;
    char *pcVar8;
    undefined1 uVar9;
    int *__oflag;
    int *piVar10;
    char local_401c [4];
    char Ident [30];
    TReadScriptFile Script;
    
                    // try { // try from 080b6b0b to 080b6b0f has its CatchHandler @ 080b71b0
    TCreature::TCreature((TCreature *)this);
    (this->super_TNonplayer).State = SLEEPING;
    (this->super_TNonplayer).super_TCreature._vptr_TCreature =
         (_func_int_varargs **)&PTR__TNPC_08127ce8;
                    // try { // try from 080b6b47 to 080b6b4b has its CatchHandler @ 080b71a8
    vector<>::vector(&this->QueuedPlayers,0,9,10);
    piVar10 = (int *)0xa;
                    // try { // try from 080b6b75 to 080b6b79 has its CatchHandler @ 080b71a2
    vector<>::vector(&this->QueuedAddresses,0,9,10);
    __oflag = (int *)FileName;
                    // try { // try from 080b6b8d to 080b6c30 has its CatchHandler @ 080b719c
    print();
    (this->super_TNonplayer).super_TCreature.Type = NPC;
    (this->super_TNonplayer).super_TCreature.Sex = 1;
    (this->super_TNonplayer).super_TCreature.Outfit.OutfitID = 0;
    (this->super_TNonplayer).super_TCreature.Race = 0;
    (this->super_TNonplayer).super_TCreature.Outfit.field_1 =
         (anon_union_4_2_730cd3ca_for_TOutfit_2)0x0;
    (this->super_TNonplayer).super_TCreature.posz = 0xff;
    this->Topic = 0;
    this->Behaviour = (TBehaviourDatabase *)0x0;
    this->Amount = 1;
    this->Price = 0;
    this->TypeID = 0;
    this->Data = 0;
    (this->super_TNonplayer).super_TCreature.Name[0] = '\0';
    this->LastTalk = 0;
    this->QueueLength = 0;
    (this->super_TNonplayer).super_TCreature.Direction = 2;
    TReadScriptFile::TReadScriptFile((TReadScriptFile *)(Ident + 0x1c));
                    // try { // try from 080b6c3e to 080b6dc8 has its CatchHandler @ 080b7196
    TReadScriptFile::open((TReadScriptFile *)(Ident + 0x1c),FileName,(int)__oflag);
    while( true ) {
        TReadScriptFile::nextToken((TReadScriptFile *)(Ident + 0x1c));
        if (stack0xffffc004 == 0) break;
        uVar9 = stack0xffffc004 == 1;
        if (!(bool)uVar9) {
            TReadScriptFile::error((TReadScriptFile *)(Ident + 0x1c),"identifier expected");
        }
        pcVar3 = TReadScriptFile::getIdentifier((TReadScriptFile *)(Ident + 0x1c));
        strcpy(local_401c,pcVar3);
        FileName = (char *)0x3d;
        TReadScriptFile::readSymbol((TReadScriptFile *)(Ident + 0x1c),'=');
        iVar6 = 5;
        pcVar3 = local_401c;
        pcVar7 = "name";
        do {
            if (iVar6 == 0) break;
            iVar6 = iVar6 + -1;
            uVar9 = *pcVar3 == *pcVar7;
            pcVar3 = pcVar3 + 1;
            pcVar7 = pcVar7 + 1;
        } while ((bool)uVar9);
        if ((bool)uVar9) {
            FileName = TReadScriptFile::readString((TReadScriptFile *)(Ident + 0x1c));
            pcVar3 = (this->super_TNonplayer).super_TCreature.Name;
            uVar9 = pcVar3 == (char *)0x0;
            strcpy(pcVar3,FileName);
        }
        iVar6 = 4;
        pcVar3 = local_401c;
        pcVar7 = "sex";
        do {
            if (iVar6 == 0) break;
            iVar6 = iVar6 + -1;
            uVar9 = *pcVar3 == *pcVar7;
            pcVar3 = pcVar3 + 1;
            pcVar7 = pcVar7 + 1;
        } while ((bool)uVar9);
        if ((bool)uVar9) {
            pcVar3 = TReadScriptFile::readIdentifier((TReadScriptFile *)(Ident + 0x1c));
            iVar6 = 5;
            (this->super_TNonplayer).super_TCreature.Sex = 0xff;
            pcVar7 = pcVar3;
            pcVar8 = "male";
            do {
                if (iVar6 == 0) break;
                iVar6 = iVar6 + -1;
                uVar9 = *pcVar7 == *pcVar8;
                pcVar7 = pcVar7 + 1;
                pcVar8 = pcVar8 + 1;
            } while ((bool)uVar9);
            if ((bool)uVar9) {
                (this->super_TNonplayer).super_TCreature.Sex = 1;
            }
            iVar6 = 7;
            pcVar7 = "female";
            do {
                if (iVar6 == 0) break;
                iVar6 = iVar6 + -1;
                uVar9 = *pcVar3 == *pcVar7;
                pcVar3 = pcVar3 + 1;
                pcVar7 = pcVar7 + 1;
            } while ((bool)uVar9);
            if ((bool)uVar9) {
                (this->super_TNonplayer).super_TCreature.Sex = 2;
            }
            uVar9 = (this->super_TNonplayer).super_TCreature.Sex == 0xff;
            if ((bool)uVar9) {
                FileName = "unknown constant";
                TReadScriptFile::error((TReadScriptFile *)(Ident + 0x1c),"unknown constant");
            }
        }
        iVar6 = 5;
        pcVar3 = local_401c;
        pcVar7 = "race";
        do {
            if (iVar6 == 0) break;
            iVar6 = iVar6 + -1;
            uVar9 = *pcVar3 == *pcVar7;
            pcVar3 = pcVar3 + 1;
            pcVar7 = pcVar7 + 1;
        } while ((bool)uVar9);
        if ((bool)uVar9) {
            FileName = (char *)TReadScriptFile::readNumber((TReadScriptFile *)(Ident + 0x1c));
            this_02 = &(this->super_TNonplayer).super_TCreature.super_TSkillBase;
            uVar9 = this_02 == (TSkillBase *)0x0;
            (this->super_TNonplayer).super_TCreature.Race = (int)FileName;
            TSkillBase::SetSkills(this_02,(int)FileName);
        }
        iVar6 = 7;
        pcVar3 = local_401c;
        pcVar7 = "outfit";
        do {
            if (iVar6 == 0) break;
            iVar6 = iVar6 + -1;
            uVar9 = *pcVar3 == *pcVar7;
            pcVar3 = pcVar3 + 1;
            pcVar7 = pcVar7 + 1;
        } while ((bool)uVar9);
        if ((bool)uVar9) {
            FileName = Ident + 0x1c;
            this_01 = &(this->super_TNonplayer).super_TCreature.Outfit;
            uVar9 = this_01 == (TOutfit *)0x0;
            TOutfit::load(this_01,(TReadScriptFile *)FileName);
        }
        iVar6 = 5;
        pcVar3 = local_401c;
        pcVar7 = "home";
        do {
            if (iVar6 == 0) break;
            iVar6 = iVar6 + -1;
            uVar9 = *pcVar3 == *pcVar7;
            pcVar3 = pcVar3 + 1;
            pcVar7 = pcVar7 + 1;
        } while ((bool)uVar9);
        if ((bool)uVar9) {
            TReadScriptFile::readCoordinate((TReadScriptFile *)(Ident + 0x1c));
            piVar10 = &(this->super_TNonplayer).super_TCreature.startz;
            __oflag = &(this->super_TNonplayer).super_TCreature.starty;
            FileName = (char *)&(this->super_TNonplayer).super_TCreature.startx;
            uVar9 = (int *)FileName == (int *)0x0;
            TReadScriptFile::getCoordinate((TReadScriptFile *)(Ident + 0x1c));
        }
        iVar6 = 7;
        pcVar3 = local_401c;
        pcVar7 = "radius";
        do {
            if (iVar6 == 0) break;
            iVar6 = iVar6 + -1;
            uVar9 = *pcVar3 == *pcVar7;
            pcVar3 = pcVar3 + 1;
            pcVar7 = pcVar7 + 1;
        } while ((bool)uVar9);
        if ((bool)uVar9) {
            iVar6 = TReadScriptFile::readNumber((TReadScriptFile *)(Ident + 0x1c));
            (this->super_TNonplayer).super_TCreature.Radius = iVar6;
        }
        iVar6 = 0xb;
        pcVar3 = local_401c;
        pcVar7 = "gostrength";
        do {
            if (iVar6 == 0) break;
            iVar6 = iVar6 + -1;
            uVar9 = *pcVar3 == *pcVar7;
            pcVar3 = pcVar3 + 1;
            pcVar7 = pcVar7 + 1;
        } while ((bool)uVar9);
        if ((bool)uVar9) {
            uVar9 = (this->super_TNonplayer).super_TCreature.Race == 0;
            if ((bool)uVar9) {
                puVar4 = (undefined4 *)__cxa_allocate_exception(4,FileName,__oflag,piVar10);
                *puVar4 = "gostrength before race in npc-script-file";
                goto LAB_080b6e07;
            }
            iVar6 = TReadScriptFile::readNumber((TReadScriptFile *)(Ident + 0x1c));
            (this->super_TNonplayer).super_TCreature.super_TSkillBase.Skills[4]->Act = iVar6;
            (this->super_TNonplayer).super_TCreature.super_TSkillBase.Skills[4]->Max = iVar6;
        }
        iVar6 = 10;
        pcVar3 = local_401c;
        pcVar7 = "behaviour";
        do {
            if (iVar6 == 0) break;
            iVar6 = iVar6 + -1;
            uVar9 = *pcVar3 == *pcVar7;
            pcVar3 = pcVar3 + 1;
            pcVar7 = pcVar7 + 1;
        } while ((bool)uVar9);
        if ((bool)uVar9) {
            if (this->Behaviour != (TBehaviourDatabase *)0x0) {
                puVar4 = (undefined4 *)__cxa_allocate_exception(4,FileName,__oflag,piVar10);
                *puVar4 = "behaviour database specified twice for NPC";
                goto LAB_080b6e07;
            }
            this_00 = (TBehaviourDatabase *)operator_new(0x8c);
            FileName = Ident + 0x1c;
                    // try { // try from 080b6ddc to 080b6de0 has its CatchHandler @ 080b7130
            TBehaviourDatabase::TBehaviourDatabase(this_00,(TReadScriptFile *)FileName);
            this->Behaviour = this_00;
        }
    }
    TReadScriptFile::close((TReadScriptFile *)(Ident + 0x1c),(int)FileName);
    if ((this->super_TNonplayer).super_TCreature.Name[0] == '\0') {
        puVar4 = (undefined4 *)__cxa_allocate_exception(4);
        *puVar4 = "no name specified for NPC";
LAB_080b6e07:
                    // WARNING: Subroutine does not return
                    // try { // try from 080b6e1a to 080b703e has its CatchHandler @ 080b7196
        __cxa_throw(puVar4,char_const*::typeinfo,0);
    }
    iVar6 = (this->super_TNonplayer).super_TCreature.posz;
    if (iVar6 == 0xff) {
        puVar4 = (undefined4 *)__cxa_allocate_exception(4);
        *puVar4 = "no startpoint specified for NPC";
        goto LAB_080b6e07;
    }
    if (this->Behaviour == (TBehaviourDatabase *)0x0) {
        puVar4 = (undefined4 *)__cxa_allocate_exception(4);
        *puVar4 = "no behaviour database specified for NPC";
        goto LAB_080b6e07;
    }
    bVar2 = IsOnMap((this->super_TNonplayer).super_TCreature.posx,
                    (this->super_TNonplayer).super_TCreature.posy,iVar6);
    if (bVar2) {
        aVar1 = (this->super_TNonplayer).super_TCreature.Outfit.field_1;
        (this->super_TNonplayer).super_TCreature.OrgOutfit.OutfitID =
             (this->super_TNonplayer).super_TCreature.Outfit.OutfitID;
        (this->super_TNonplayer).super_TCreature.OrgOutfit.field_1 = aVar1;
                    // try { // try from 080b7080 to 080b70dc has its CatchHandler @ 080b7196
        TCreature::SetID((TCreature *)this,0);
        TCreature::SetInCrList((TCreature *)this);
        pcVar3 = (char *)FirstFreeNonplayer;
        ppTVar5 = vector<>::operator()(&NonplayerList,FirstFreeNonplayer);
        FirstFreeNonplayer = FirstFreeNonplayer + 1;
        *ppTVar5 = &this->super_TNonplayer;
        bVar2 = TCreature::SetOnMap((TCreature *)this);
        if (bVar2) {
            TCreature::ToDoYield((TCreature *)this);
            goto LAB_080b7048;
        }
        pcVar3 = "WARNUNG: Kann NPC \'%s\' nicht setzen.\n";
    }
    else {
        pcVar3 = &DAT_08105800;
    }
    print();
LAB_080b7048:
                    // try { // try from 080b7048 to 080b704c has its CatchHandler @ 080b719c
    TReadScriptFile::~TReadScriptFile((TReadScriptFile *)(Ident + 0x1c),(int)pcVar3);
    return;
}



// DWARF original prototype: void ~TNPC(TNPC * this, int __in_chrg)

void __thiscall TNPC::~TNPC(TNPC *this,int __in_chrg)

{
    TBehaviourDatabase *pTVar1;
    TBehaviour *pTVar2;
    ulong *puVar3;
    TBehaviour *pTVar4;
    int in_stack_ffffffe8;
    
    (this->super_TNonplayer).super_TCreature._vptr_TCreature =
         (_func_int_varargs **)&PTR__TNPC_08127ce8;
    pTVar1 = this->Behaviour;
    if (pTVar1 != (TBehaviourDatabase *)0x0) {
        pTVar4 = (pTVar1->Behaviour).entry;
        if (pTVar4 != (TBehaviour *)0x0) {
            pTVar4 = pTVar4 + pTVar4[-1].Actions;
            while (pTVar2 = (pTVar1->Behaviour).entry, pTVar2 != pTVar4) {
                pTVar4 = pTVar4 + -1;
                TBehaviour::~TBehaviour(pTVar4,in_stack_ffffffe8);
            }
            operator_delete__(&pTVar2[-1].Actions);
        }
        TBehaviour::~TBehaviour(&(pTVar1->Behaviour).init,in_stack_ffffffe8);
        operator_delete(pTVar1);
    }
    puVar3 = (this->QueuedAddresses).entry;
    if (puVar3 != (ulong *)0x0) {
        operator_delete__(puVar3);
    }
    puVar3 = (this->QueuedPlayers).entry;
    if (puVar3 != (ulong *)0x0) {
        operator_delete__(puVar3);
    }
    TNonplayer::~TNonplayer(&this->super_TNonplayer,in_stack_ffffffe8);
    return;
}



// DWARF original prototype: void ~TNPC(TNPC * this, int __in_chrg)

void __thiscall TNPC::~TNPC(TNPC *this,int __in_chrg)

{
    TBehaviourDatabase *pTVar1;
    TBehaviour *pTVar2;
    ulong *puVar3;
    TBehaviour *pTVar4;
    int in_stack_ffffffe8;
    
    (this->super_TNonplayer).super_TCreature._vptr_TCreature =
         (_func_int_varargs **)&PTR__TNPC_08127ce8;
    pTVar1 = this->Behaviour;
    if (pTVar1 != (TBehaviourDatabase *)0x0) {
        pTVar4 = (pTVar1->Behaviour).entry;
        if (pTVar4 != (TBehaviour *)0x0) {
            pTVar4 = pTVar4 + pTVar4[-1].Actions;
            while (pTVar2 = (pTVar1->Behaviour).entry, pTVar2 != pTVar4) {
                pTVar4 = pTVar4 + -1;
                TBehaviour::~TBehaviour(pTVar4,in_stack_ffffffe8);
            }
            operator_delete__(&pTVar2[-1].Actions);
        }
        TBehaviour::~TBehaviour(&(pTVar1->Behaviour).init,in_stack_ffffffe8);
        operator_delete(pTVar1);
    }
    puVar3 = (this->QueuedAddresses).entry;
    if (puVar3 != (ulong *)0x0) {
        operator_delete__(puVar3);
    }
    puVar3 = (this->QueuedPlayers).entry;
    if (puVar3 != (ulong *)0x0) {
        operator_delete__(puVar3);
    }
    TNonplayer::~TNonplayer(&this->super_TNonplayer,in_stack_ffffffe8);
    return;
}



// DWARF original prototype: void ~TNPC(TNPC * this, int __in_chrg)

void __thiscall TNPC::~TNPC(TNPC *this,int __in_chrg)

{
    TBehaviourDatabase *pTVar1;
    TBehaviour *pTVar2;
    ulong *puVar3;
    TBehaviour *pTVar4;
    int in_stack_ffffffe8;
    
    (this->super_TNonplayer).super_TCreature._vptr_TCreature =
         (_func_int_varargs **)&PTR__TNPC_08127ce8;
    pTVar1 = this->Behaviour;
    if (pTVar1 != (TBehaviourDatabase *)0x0) {
        pTVar4 = (pTVar1->Behaviour).entry;
        if (pTVar4 != (TBehaviour *)0x0) {
            pTVar4 = pTVar4 + pTVar4[-1].Actions;
            while (pTVar2 = (pTVar1->Behaviour).entry, pTVar2 != pTVar4) {
                pTVar4 = pTVar4 + -1;
                TBehaviour::~TBehaviour(pTVar4,in_stack_ffffffe8);
            }
            operator_delete__(&pTVar2[-1].Actions);
        }
        TBehaviour::~TBehaviour(&(pTVar1->Behaviour).init,in_stack_ffffffe8);
        operator_delete(pTVar1);
    }
    puVar3 = (this->QueuedAddresses).entry;
    if (puVar3 != (ulong *)0x0) {
        operator_delete__(puVar3);
    }
    puVar3 = (this->QueuedPlayers).entry;
    if (puVar3 != (ulong *)0x0) {
        operator_delete__(puVar3);
    }
    TNonplayer::~TNonplayer(&this->super_TNonplayer,in_stack_ffffffe8);
    operator_delete(this);
    return;
}



// DWARF original prototype: void TalkStimulus(TNPC * this, ulong Speaker, char * Text)

void __thiscall TNPC::TalkStimulus(TNPC *this,ulong Speaker,char *Text)

{
    ulong uVar1;
    uchar Dir;
    TCreature *Opp;
    TCreature *pTVar2;
    int iVar3;
    int dy;
    int iVar4;
    int iVar5;
    int iVar6;
    
    if (Speaker != (this->super_TNonplayer).super_TCreature.ID) {
        if (Text == (char *)0x0) {
            this = (TNPC *)&DAT_08105920;
LAB_080b757a:
            error((char *)this);
            return;
        }
        if (((this->super_TNonplayer).State == TALKING) || (this->QueueLength != 0)) {
            uVar1 = this->Interlocutor;
            if (Speaker == uVar1) {
                this->LastTalk = RoundNr;
                TBehaviourDatabase::react(this->Behaviour,this,Text,DEFAULT);
            }
            else {
                this->Interlocutor = Speaker;
                TBehaviourDatabase::react(this->Behaviour,this,Text,BUSY);
                this->Interlocutor = uVar1;
            }
        }
        else {
            TCreature::ToDoClear((TCreature *)this);
            (this->super_TNonplayer).State = TALKING;
            uVar1 = RoundNr;
            this->Interlocutor = Speaker;
            this->LastTalk = uVar1;
            TBehaviourDatabase::react(this->Behaviour,this,Text,ADDRESS);
            if ((this->super_TNonplayer).State == TALKING) {
                pTVar2 = GetCreature(this->Interlocutor);
                if (pTVar2 != (TCreature *)0x0) {
                    iVar5 = pTVar2->posx - (this->super_TNonplayer).super_TCreature.posx;
                    iVar4 = pTVar2->posy - (this->super_TNonplayer).super_TCreature.posy;
                    iVar3 = -iVar5;
                    if (-1 < iVar5) {
                        iVar3 = iVar5;
                    }
                    iVar6 = -iVar4;
                    if (-1 < iVar4) {
                        iVar6 = iVar4;
                    }
                    if (iVar3 < iVar6) {
                        Dir = ((char)~(byte)((uint)iVar4 >> 0x18) >> 7) * -2;
                    }
                    else {
                        Dir = (char)(iVar5 >> 0x1f) * -2 + '\x01';
                    }
                    TCreature::Rotate((TCreature *)this,Dir);
                    return;
                }
                this = (TNPC *)&DAT_081058e0;
                goto LAB_080b757a;
            }
        }
    }
    return;
}



// DWARF original prototype: void IdleStimulus(TNPC * this)

void __thiscall TNPC::IdleStimulus(TNPC *this)

{
    vector<> *this_00;
    vector<> *this_01;
    uchar Dir;
    int dir;
    ulong *puVar1;
    TCreature *pTVar2;
    ulong uVar3;
    int iVar4;
    ulong *puVar5;
    char *Text;
    STATE SVar6;
    int dy;
    int destX;
    int iVar7;
    int destY;
    int iVar8;
    int Try;
    int iVar9;
    undefined1 local_4c [4];
    TFindCreatures Search;
    
    SVar6 = (this->super_TNonplayer).State;
    if (SVar6 == TALKING) {
        if (RoundNr <= this->LastTalk + 0x1e) {
            TCreature::ToDoWait((TCreature *)this,2000);
LAB_080b7808:
            TCreature::ToDoStart((TCreature *)this);
            return;
        }
        TBehaviourDatabase::react(this->Behaviour,this,"",VANISH);
        (this->super_TNonplayer).State = IDLE;
        SVar6 = IDLE;
    }
    if (SVar6 == IDLE) {
        if (0 < this->QueueLength) {
            this_00 = &this->QueuedPlayers;
            this_01 = &this->QueuedAddresses;
            do {
                (this->super_TNonplayer).State = TALKING;
                TCreature::ToDoClear((TCreature *)this);
                puVar1 = vector<>::operator()(this_00,0);
                uVar3 = *puVar1;
                this->Interlocutor = uVar3;
                pTVar2 = GetCreature(uVar3);
                if (pTVar2 == (TCreature *)0x0) {
                    error(&DAT_08105960);
                    (this->super_TNonplayer).State = IDLE;
                }
                else {
                    puVar1 = vector<>::operator()(this_01,0);
                    Text = GetDynamicString(*puVar1);
                    TBehaviourDatabase::react(this->Behaviour,this,Text,ADDRESSQUEUE);
                }
                puVar1 = vector<>::operator()(this_01,0);
                DeleteDynamicString(*puVar1);
                iVar9 = this->QueueLength;
                iVar7 = 1;
                if (1 < iVar9) {
                    do {
                        puVar1 = vector<>::operator()(this_00,iVar7 + -1);
                        puVar5 = vector<>::operator()(this_00,iVar7);
                        *puVar1 = *puVar5;
                        puVar1 = vector<>::operator()(this_01,iVar7 + -1);
                        iVar8 = iVar7 + 1;
                        puVar5 = vector<>::operator()(this_01,iVar7);
                        *puVar1 = *puVar5;
                        iVar9 = this->QueueLength;
                        iVar7 = iVar8;
                    } while (iVar8 < iVar9);
                }
                SVar6 = (this->super_TNonplayer).State;
                this->QueueLength = iVar9 + -1;
                if (SVar6 == TALKING) {
                    pTVar2 = GetCreature(this->Interlocutor);
                    if (pTVar2 == (TCreature *)0x0) {
                        error(&DAT_081058e0);
                    }
                    else {
                        iVar8 = pTVar2->posx - (this->super_TNonplayer).super_TCreature.posx;
                        iVar7 = pTVar2->posy - (this->super_TNonplayer).super_TCreature.posy;
                        iVar9 = -iVar8;
                        if (-1 < iVar8) {
                            iVar9 = iVar8;
                        }
                        iVar4 = -iVar7;
                        if (-1 < iVar7) {
                            iVar4 = iVar7;
                        }
                        if (iVar9 < iVar4) {
                            Dir = ((char)~(byte)((uint)iVar7 >> 0x18) >> 7) * -2;
                        }
                        else {
                            Dir = (char)(iVar8 >> 0x1f) * -2 + '\x01';
                        }
                        TCreature::Rotate((TCreature *)this,Dir);
                    }
                    this->LastTalk = RoundNr;
                    return;
                }
            } while (0 < iVar9 + -1);
        }
        if ((this->super_TNonplayer).super_TCreature.LockToDo == false) {
            TFindCreatures::TFindCreatures
                      ((TFindCreatures *)local_4c,10,10,(this->super_TNonplayer).super_TCreature.ID,
                       1);
            iVar9 = 0;
            uVar3 = TFindCreatures::getNext((TFindCreatures *)local_4c);
            if (uVar3 == 0) {
                (this->super_TNonplayer).State = SLEEPING;
            }
            else {
                do {
                    iVar9 = iVar9 + 1;
                    iVar7 = (this->super_TNonplayer).super_TCreature.posx;
                    iVar8 = (this->super_TNonplayer).super_TCreature.posy;
                    if (10 < iVar9) {
                        TCreature::ToDoWait((TCreature *)this,2000);
                        goto LAB_080b7808;
                    }
                    iVar4 = rand();
                    iVar4 = iVar4 % 4;
                    if (iVar4 == 1) {
                        iVar7 = iVar7 + 1;
                    }
                    else if (iVar4 < 2) {
                        if (iVar4 == 0) {
                            iVar7 = iVar7 + -1;
                        }
                    }
                    else if (iVar4 == 2) {
                        iVar8 = iVar8 + -1;
                    }
                    else if (iVar4 == 3) {
                        iVar8 = iVar8 + 1;
                    }
                    iVar4 = (*(this->super_TNonplayer).super_TCreature._vptr_TCreature[3])
                                      (this,iVar7,iVar8,
                                       (this->super_TNonplayer).super_TCreature.posz,1,0);
                } while ((char)iVar4 == '\0');
                    // try { // try from 080b77aa to 080b77cc has its CatchHandler @ 080b79ac
                TCreature::ToDoGo((TCreature *)this,iVar7,iVar8,
                                  (this->super_TNonplayer).super_TCreature.posz,true,0x7fffffff);
                TCreature::ToDoWait((TCreature *)this,2000);
                TCreature::ToDoStart((TCreature *)this);
            }
        }
    }
    return;
}



// WARNING: Variable defined which should be unmapped: this_local
// DWARF original prototype: void CreatureMoveStimulus(TNPC * this, ulong CreatureID, int Type)

void __thiscall TNPC::CreatureMoveStimulus(TNPC *this,ulong CreatureID,int Type)

{
    uchar Dir;
    TCreature *Opp;
    vector<> *this_00;
    ulong *puVar1;
    TCreature *pTVar2;
    uint uVar3;
    ulong uVar4;
    TCreature *pTVar5;
    int iVar6;
    vector<> *this_01;
    ulong *puVar7;
    int dy;
    int iVar8;
    int dx;
    int iVar9;
    TCreature *cr;
    int j;
    int iVar10;
    int local_20;
    int i;
    int Type_local;
    ulong CreatureID_local;
    TNPC *this_local;
    
    if ((0 < this->QueueLength) && (local_20 = 0, 0 < this->QueueLength)) {
        this_00 = &this->QueuedPlayers;
        do {
            puVar1 = vector<>::operator()(this_00,local_20);
            if ((CreatureID == *puVar1) ||
               (CreatureID == (this->super_TNonplayer).super_TCreature.ID)) {
                puVar1 = vector<>::operator()(this_00,local_20);
                pTVar2 = GetCreature(*puVar1);
                if (Type != 0) {
                    uVar3 = pTVar2->posx - (this->super_TNonplayer).super_TCreature.posx;
                    if (0x7fffffff < uVar3) {
                        uVar3 = -uVar3;
                    }
                    if ((int)uVar3 < 5) {
                        uVar3 = pTVar2->posy - (this->super_TNonplayer).super_TCreature.posy;
                        if (0x7fffffff < uVar3) {
                            uVar3 = -uVar3;
                        }
                        if (((int)uVar3 < 4) &&
                           (pTVar2->posz == (this->super_TNonplayer).super_TCreature.posz))
                        goto LAB_080b7a5c;
                    }
                }
                this_01 = &this->QueuedAddresses;
                puVar1 = vector<>::operator()(this_01,local_20);
                DeleteDynamicString(*puVar1);
                iVar6 = this->QueueLength;
                iVar8 = local_20 + 1;
                if (local_20 + 1 < iVar6) {
                    do {
                        puVar1 = vector<>::operator()(this_00,iVar8 + -1);
                        puVar7 = vector<>::operator()(this_00,iVar8);
                        *puVar1 = *puVar7;
                        puVar1 = vector<>::operator()(this_01,iVar8 + -1);
                        iVar9 = iVar8 + 1;
                        puVar7 = vector<>::operator()(this_01,iVar8);
                        *puVar1 = *puVar7;
                        iVar6 = this->QueueLength;
                        iVar8 = iVar9;
                    } while (iVar9 < iVar6);
                }
                this->QueueLength = iVar6 + -1;
                local_20 = local_20 + -1;
            }
LAB_080b7a5c:
            local_20 = local_20 + 1;
        } while (local_20 < this->QueueLength);
    }
    if ((this->super_TNonplayer).State - TALKING < 2) {
        if ((CreatureID == this->Interlocutor) ||
           (CreatureID == (this->super_TNonplayer).super_TCreature.ID)) {
            pTVar2 = GetCreature(this->Interlocutor);
            if (pTVar2 == (TCreature *)0x0) {
                error(&DAT_081059e0);
                (this->super_TNonplayer).State = IDLE;
                goto LAB_080b7ac2;
            }
            if (Type != 0) {
                pTVar5 = GetCreature(this->Interlocutor);
                if (pTVar5 == (TCreature *)0x0) {
                    error(&DAT_081058e0);
                }
                else {
                    iVar9 = pTVar5->posx - (this->super_TNonplayer).super_TCreature.posx;
                    iVar8 = pTVar5->posy - (this->super_TNonplayer).super_TCreature.posy;
                    iVar6 = -iVar9;
                    if (-1 < iVar9) {
                        iVar6 = iVar9;
                    }
                    iVar10 = -iVar8;
                    if (-1 < iVar8) {
                        iVar10 = iVar8;
                    }
                    if (iVar6 < iVar10) {
                        Dir = ((char)~(byte)((uint)iVar8 >> 0x18) >> 7) * -2;
                    }
                    else {
                        Dir = (char)(iVar9 >> 0x1f) * -2 + '\x01';
                    }
                    TCreature::Rotate((TCreature *)this,Dir);
                }
            }
            if ((this->super_TNonplayer).State != LEAVING) {
                if (Type != 0) {
                    uVar3 = pTVar2->posx - (this->super_TNonplayer).super_TCreature.posx;
                    if (0x7fffffff < uVar3) {
                        uVar3 = -uVar3;
                    }
                    if ((int)uVar3 < 5) {
                        uVar3 = pTVar2->posy - (this->super_TNonplayer).super_TCreature.posy;
                        if (0x7fffffff < uVar3) {
                            uVar3 = -uVar3;
                        }
                        if (((int)uVar3 < 4) &&
                           (pTVar2->posz == (this->super_TNonplayer).super_TCreature.posz))
                        goto LAB_080b7b9c;
                    }
                }
                TBehaviourDatabase::react(this->Behaviour,this,"",VANISH);
                (this->super_TNonplayer).State = IDLE;
                TCreature::ToDoYield((TCreature *)this);
            }
            uVar4 = (this->super_TNonplayer).super_TCreature.ID;
            goto LAB_080b7b8e;
        }
    }
    else {
LAB_080b7b9c:
        uVar4 = (this->super_TNonplayer).super_TCreature.ID;
LAB_080b7b8e:
        if (CreatureID == uVar4) {
            return;
        }
    }
    if (((this->super_TNonplayer).State != SLEEPING) || (Type == 0)) {
        return;
    }
    (this->super_TNonplayer).State = IDLE;
LAB_080b7ac2:
    TCreature::ToDoYield((TCreature *)this);
    return;
}



// DWARF original prototype: void DamageStimulus(TNPC * this, ulong param_1, int param_2, int
// param_3)

void __thiscall TNPC::DamageStimulus(TNPC *this,ulong param_1,int param_2,int param_3)

{
    return;
}



// DWARF original prototype: bool MovePossible(TNPC * this, int x, int y, int z, bool param_4, bool
// param_5)

bool __thiscall TNPC::MovePossible(TNPC *this,int x,int y,int z,bool param_4,bool param_5)

{
    int iVar1;
    bool bVar2;
    bool bVar3;
    uint uVar4;
    
    bVar3 = false;
                    // try { // try from 080b7dbd to 080b7e8a has its CatchHandler @ 080b7ea0
    bVar2 = CoordinateFlag();
    if (bVar2) {
        bVar3 = CoordinateFlag();
        bVar3 = !bVar3;
    }
    if ((bVar3) && (bVar3 = CoordinateFlag(), !bVar3)) {
        uVar4 = x - (this->super_TNonplayer).super_TCreature.startx;
        if (0x7fffffff < uVar4) {
            uVar4 = -uVar4;
        }
        iVar1 = (this->super_TNonplayer).super_TCreature.Radius;
        if ((int)uVar4 <= iVar1) {
            uVar4 = y - (this->super_TNonplayer).super_TCreature.starty;
            if (0x7fffffff < uVar4) {
                uVar4 = -uVar4;
            }
            if (((int)uVar4 <= iVar1) && (z == (this->super_TNonplayer).super_TCreature.startz)) {
                bVar3 = IsHouse(x,y,z);
                return !bVar3;
            }
        }
    }
    return false;
}



// DWARF original prototype: void GiveTo(TNPC * this, ObjectType * Type, int Amount)

void __thiscall TNPC::GiveTo(TNPC *this,ObjectType *Type,int Amount)

{
    bool bVar1;
    char *pcVar2;
    RESULT r;
    int i;
    int *piVar3;
    int iVar4;
    int local_44 [2];
    ObjectType local_3c [4];
    ObjectType local_2c [7];
    
    if (Amount != 0) {
        bVar1 = false;
        ObjectType::setTypeID(local_2c,0);
        if ((Type->TypeID == local_2c[0].TypeID) ||
           (pcVar2 = ObjectType::getName(Type), pcVar2 == (char *)0x0)) {
            bVar1 = true;
        }
        if (bVar1) {
            error("TNPC::GiveTo: %s will Objekte vom Typ %d erschaffen.\n",
                  (this->super_TNonplayer).super_TCreature.Name,Type->TypeID);
        }
        else {
            pcVar2 = ObjectType::getName(Type);
            Log("npc","%s -> %ld: %d %s\n",(this->super_TNonplayer).super_TCreature.Name,
                this->Interlocutor,Amount,pcVar2);
                    // try { // try from 080b7f85 to 080b8057 has its CatchHandler @ 080b8083
            bVar1 = ObjectType::getFlag(Type,CUMULATIVE);
            if (bVar1) {
                for (; 0 < Amount; Amount = Amount - *piVar3) {
                    local_44[1] = 100;
                    ObjectType::setTypeID(local_3c,Type->TypeID);
                    CreateAtCreature((ulong)local_2c,(ObjectType *)this->Interlocutor,
                                     (ulong)local_3c);
                    local_44[0] = 100;
                    piVar3 = local_44;
                    if (Amount < 0x65) {
                        piVar3 = &Amount;
                    }
                }
            }
            else {
                iVar4 = 0;
                if (0 < Amount) {
                    do {
                        ObjectType::setTypeID(local_2c,Type->TypeID);
                        CreateAtCreature((ulong)local_3c,(ObjectType *)this->Interlocutor,
                                         (ulong)local_2c);
                        iVar4 = iVar4 + 1;
                    } while (iVar4 < Amount);
                }
            }
        }
    }
    return;
}



// DWARF original prototype: void GetFrom(TNPC * this, ObjectType * Type, int Amount)

void __thiscall TNPC::GetFrom(TNPC *this,ObjectType *Type,int Amount)

{
    char *pcVar1;
    RESULT r;
    ObjectType local_2c [7];
    
    if (Amount != 0) {
        pcVar1 = ObjectType::getName(Type);
        Log("npc","%s <- %ld: %d %s\n",(this->super_TNonplayer).super_TCreature.Name,
            this->Interlocutor,Amount,pcVar1);
                    // try { // try from 080b814f to 080b8176 has its CatchHandler @ 080b8180
        ObjectType::setTypeID(local_2c,Type->TypeID);
        DeleteAtCreature(this->Interlocutor,local_2c,Amount,this->Data);
    }
    return;
}



// DWARF original prototype: void GiveMoney(TNPC * this, int Amount)

void __thiscall TNPC::GiveMoney(TNPC *this,int Amount)

{
    int Crystal;
    int Platinum;
    
    GetSpecialObject((SPECIALMEANING)&Platinum);
    GiveTo(this,(ObjectType *)&Platinum,Amount / 10000);
    GetSpecialObject((SPECIALMEANING)&Platinum);
    GiveTo(this,(ObjectType *)&Platinum,(Amount % 10000) / 100);
    GetSpecialObject((SPECIALMEANING)&Platinum);
    GiveTo(this,(ObjectType *)&Platinum,Amount % 100);
    return;
}



// DWARF original prototype: void GetMoney(TNPC * this, int Amount)

void __thiscall TNPC::GetMoney(TNPC *this,int Amount)

{
    int local_28;
    int Gold;
    int Platinum;
    int Crystal;
    
    GetSpecialObject((SPECIALMEANING)&Crystal);
    Platinum = CountInventoryObjects(this->Interlocutor,(ObjectType *)&Crystal,0);
    GetSpecialObject((SPECIALMEANING)&Crystal);
    Gold = CountInventoryObjects(this->Interlocutor,(ObjectType *)&Crystal,0);
    GetSpecialObject((SPECIALMEANING)&Crystal);
    local_28 = CountInventoryObjects(this->Interlocutor,(ObjectType *)&Crystal,0);
    CalculateChange(Amount,&local_28,&Gold,&Platinum);
    if (0 < local_28) {
        GetSpecialObject((SPECIALMEANING)&Crystal);
        GetFrom(this,(ObjectType *)&Crystal,local_28);
    }
    if (0 < Gold) {
        GetSpecialObject((SPECIALMEANING)&Crystal);
        GetFrom(this,(ObjectType *)&Crystal,Gold);
    }
    if (0 < Platinum) {
        GetSpecialObject((SPECIALMEANING)&Crystal);
        GetFrom(this,(ObjectType *)&Crystal,Platinum);
    }
    if (local_28 < 0) {
        GetSpecialObject((SPECIALMEANING)&Crystal);
        GiveTo(this,(ObjectType *)&Crystal,-local_28);
    }
    if (Gold < 0) {
        GetSpecialObject((SPECIALMEANING)&Crystal);
        GiveTo(this,(ObjectType *)&Crystal,-Gold);
    }
    return;
}



// WARNING: Variable defined which should be unmapped: Interlocutor_local
// DWARF original prototype: void Enqueue(TNPC * this, ulong Interlocutor, char * Text)

void __thiscall TNPC::Enqueue(TNPC *this,ulong Interlocutor,char *Text)

{
    ulong *puVar1;
    int i_00;
    ulong uVar2;
    int i;
    int i_01;
    char *Text_local;
    ulong Interlocutor_local;
    
    if (Interlocutor == 0) {
        this = (TNPC *)&DAT_08105ac0;
    }
    else {
        if (Text != (char *)0x0) {
            i_00 = this->QueueLength;
            i_01 = 0;
            if (0 < i_00) {
                do {
                    puVar1 = vector<>::operator()(&this->QueuedPlayers,i_01);
                    if (*puVar1 == Interlocutor) {
                        return;
                    }
                    i_00 = this->QueueLength;
                    i_01 = i_01 + 1;
                } while (i_01 < i_00);
            }
            puVar1 = vector<>::operator()(&this->QueuedPlayers,i_00);
            *puVar1 = Interlocutor;
            uVar2 = AddDynamicString(Text);
            puVar1 = vector<>::operator()(&this->QueuedAddresses,this->QueueLength);
            *puVar1 = uVar2;
            this->QueueLength = this->QueueLength + 1;
            return;
        }
        this = (TNPC *)s_TNPC__Enqueue__Text_ist_NULL__08105aa0;
    }
    error((char *)this);
    return;
}



// DWARF original prototype: void TurnToInterlocutor(TNPC * this)

void __thiscall TNPC::TurnToInterlocutor(TNPC *this)

{
    uchar Dir;
    TCreature *Opp;
    TCreature *pTVar1;
    int iVar2;
    int dy;
    int iVar3;
    int iVar4;
    int dx;
    int iVar5;
    
    pTVar1 = GetCreature(this->Interlocutor);
    if (pTVar1 != (TCreature *)0x0) {
        iVar5 = pTVar1->posx - (this->super_TNonplayer).super_TCreature.posx;
        iVar3 = pTVar1->posy - (this->super_TNonplayer).super_TCreature.posy;
        iVar4 = -iVar5;
        if (-1 < iVar5) {
            iVar4 = iVar5;
        }
        iVar2 = -iVar3;
        if (-1 < iVar3) {
            iVar2 = iVar3;
        }
        if (iVar4 < iVar2) {
            Dir = ((char)~(byte)((uint)iVar3 >> 0x18) >> 7) * -2;
        }
        else {
            Dir = (char)(iVar5 >> 0x1f) * -2 + '\x01';
        }
        TCreature::Rotate((TCreature *)this,Dir);
        return;
    }
    error(&DAT_081058e0);
    return;
}



// DWARF original prototype: void ChangeState(TNPC * this, STATE NewState, bool Stimulus)

void __thiscall TNPC::ChangeState(TNPC *this,STATE NewState,bool Stimulus)

{
    (this->super_TNonplayer).State = NewState;
    if (!Stimulus) {
        return;
    }
    TCreature::ToDoYield((TCreature *)this);
    return;
}



void ChangeNPCState(TCreature *npc,int NewState,bool Stimulus)

{
    if (npc == (TCreature *)0x0) {
        npc = (TCreature *)s_ChangeNPCState__npc_ist_NULL__08105b40;
    }
    else {
        if (npc->Type == NPC) {
            npc[1]._vptr_TCreature = (_func_int_varargs **)NewState;
            if (!Stimulus) {
                return;
            }
            TCreature::ToDoYield(npc);
            return;
        }
        npc = (TCreature *)s_ChangeNPCState__npc_ist_kein_NPC_08105b00;
    }
    error((char *)npc);
    return;
}



// DWARF original prototype: void TMonster(TMonster * this, int Race, int x, int y, int z, int Home,
// ulong Father)

void __thiscall TMonster::TMonster(TMonster *this)

{
    int iVar1;
    anon_union_4_2_730cd3ca_for_TOutfit_2 aVar2;
    bool bVar3;
    TCreature *pTVar4;
    TNonplayer **ppTVar5;
    TItemData *this_00;
    long lVar6;
    long lVar7;
    TCombat *this_01;
    int in_stack_00000008;
    int in_stack_0000000c;
    int in_stack_00000010;
    int in_stack_00000014;
    int in_stack_00000018;
    ulong in_stack_0000001c;
    char *Text;
    Object *this_02;
    int local_88;
    int j;
    int Repeat;
    int i;
    Object local_6c [4];
    Object local_5c [4];
    Object local_4c;
    Object Obj;
    ulong local_3c [4];
    Object local_2c;
    Object Bag;
    
    TCreature::TCreature((TCreature *)this);
    (this->super_TNonplayer).super_TCreature.Type = MONSTER;
    (this->super_TNonplayer).State = IDLE;
    (this->super_TNonplayer).super_TCreature._vptr_TCreature =
         (_func_int_varargs **)&PTR__TMonster_08127ca8;
    (this->super_TNonplayer).super_TCreature.Race = in_stack_00000008;
    (this->super_TNonplayer).super_TCreature.startx = in_stack_0000000c;
    (this->super_TNonplayer).super_TCreature.posx = in_stack_0000000c;
    this->Home = in_stack_00000018;
    (this->super_TNonplayer).super_TCreature.starty = in_stack_00000010;
    (this->super_TNonplayer).super_TCreature.posy = in_stack_00000010;
    (this->super_TNonplayer).super_TCreature.startz = in_stack_00000014;
    (this->super_TNonplayer).super_TCreature.posz = in_stack_00000014;
    this->Target = 0;
    this->Master = in_stack_0000001c;
    do {
        if (this->Master == 0) {
LAB_080b873a:
            if (RaceData[in_stack_00000008].Article[0] == '\0') {
                strcpy((this->super_TNonplayer).super_TCreature.Name,
                       RaceData[in_stack_00000008].Name);
            }
            else {
                snprintf((this->super_TNonplayer).super_TCreature.Name,0x1e,"%s %s",
                         in_stack_00000008 * 0x150 + 0x81c477e,RaceData + in_stack_00000008);
            }
            TSkillBase::SetSkills
                      (&(this->super_TNonplayer).super_TCreature.super_TSkillBase,in_stack_00000008)
            ;
            iVar1 = RaceData[in_stack_00000008].Outfit.OutfitID;
            aVar2 = RaceData[in_stack_00000008].Outfit.field_1;
            (this->super_TNonplayer).super_TCreature.Outfit.OutfitID = iVar1;
            (this->super_TNonplayer).super_TCreature.Outfit.field_1 = aVar2;
            (this->super_TNonplayer).super_TCreature.OrgOutfit.OutfitID = iVar1;
            (this->super_TNonplayer).super_TCreature.OrgOutfit.field_1 = aVar2;
            TCreature::SetID((TCreature *)this,0);
            TCreature::SetInCrList((TCreature *)this);
            ppTVar5 = vector<>::operator()(&NonplayerList,FirstFreeNonplayer);
            FirstFreeNonplayer = FirstFreeNonplayer + 1;
            *ppTVar5 = &this->super_TNonplayer;
            bVar3 = TCreature::SetOnMap((TCreature *)this);
            if (bVar3) {
                if ((this->Master == 0) && (0 < RaceData[in_stack_00000008].Items)) {
                    // try { // try from 080b8836 to 080b8904 has its CatchHandler @ 080b8c3e
                    GetSpecialObject((SPECIALMEANING)local_3c);
                    GetBodyContainer((ulong)&local_4c,(this->super_TNonplayer).super_TCreature.ID);
                    Create(&local_2c,(ObjectType *)&local_4c,(ulong)local_3c);
                    Repeat = 1;
                    if (0 < RaceData[in_stack_00000008].Items) {
                        do {
                            this_00 = vector<TItemData>::operator()
                                                (&RaceData[in_stack_00000008].Item,Repeat);
                            lVar6 = random();
                            if (lVar6 <= this_00->Probability) {
                                lVar7 = random();
                                j = 1;
                                bVar3 = ObjectType::getFlag(&this_00->Type,CUMULATIVE);
                                lVar6 = lVar7;
                                if (!bVar3) {
                                    lVar6 = 0;
                                    j = lVar7;
                                }
                                local_88 = 0;
                                if (0 < j) {
                                    do {
                                        local_4c.ObjectID = 0;
                                        bVar3 = ObjectType::getFlag(&this_00->Type,WEAPON);
                                        if (((((bVar3) ||
                                              (bVar3 = ObjectType::getFlag(&this_00->Type,SHIELD),
                                              bVar3)) ||
                                             (bVar3 = ObjectType::getFlag(&this_00->Type,BOW), bVar3
                                             )) || ((bVar3 = ObjectType::getFlag(&this_00->Type,
                                                                                 THROW), bVar3 ||
                                                    (bVar3 = ObjectType::getFlag(&this_00->Type,WAND
                                                                                ), bVar3)))) ||
                                           ((bVar3 = ObjectType::getFlag(&this_00->Type,WEAROUT),
                                            bVar3 || ((bVar3 = ObjectType::getFlag(&this_00->Type,
                                                                                   EXPIRE), bVar3 ||
                                                      (bVar3 = ObjectType::getFlag(&this_00->Type,
                                                                                   EXPIRESTOP),
                                                      bVar3)))))) {
                    // try { // try from 080b8a02 to 080b8a2d has its CatchHandler @ 080b8bd5
                                            ObjectType::setTypeID
                                                      ((ObjectType *)local_6c,(this_00->Type).TypeID
                                                      );
                                            lVar7 = 0;
                                            this_02 = local_6c;
                                            i = local_2c.ObjectID;
                                            Create(local_5c,(ObjectType *)&i,(ulong)this_02);
                                            local_4c.ObjectID = local_5c[0].ObjectID;
                                            local_3c[0] = local_5c[0].ObjectID;
                                        }
                                        else {
                                            this_02 = local_5c;
                                            ObjectType::setTypeID
                                                      ((ObjectType *)this_02,(this_00->Type).TypeID)
                                            ;
                                            lVar7 = lVar6;
                                            CreateAtCreature((ulong)local_6c,
                                                             (ObjectType *)
                                                             (this->super_TNonplayer).
                                                             super_TCreature.ID,(ulong)this_02);
                                            i = local_6c[0].ObjectID;
                                            local_4c.ObjectID = i;
                                        }
                    // try { // try from 080b8a44 to 080b8b6d has its CatchHandler @ 080b8c3e
                                        Object::getContainer((Object *)&i);
                                        Object::getObjectType(local_6c);
                                        if (local_6c[0].ObjectID == 0) {
                                            error(&DAT_08105bc0,in_stack_00000008,this_02,lVar7);
                                            local_6c[0].ObjectID = local_4c.ObjectID;
                                            Delete(local_6c,-1);
                                        }
                                        local_88 = local_88 + 1;
                                    } while (local_88 < j);
                                }
                            }
                            Repeat = Repeat + 1;
                        } while (Repeat <= RaceData[in_stack_00000008].Items);
                    }
                    local_6c[0].ObjectID = local_2c.ObjectID;
                    GetFirstContainerObject((Object *)&i);
                    local_5c[0].ObjectID = ::NONE.ObjectID;
                    if (i == ::NONE.ObjectID) {
                        local_4c.ObjectID = local_2c.ObjectID;
                    // try { // try from 080b8970 to 080b89ed has its CatchHandler @ 080b8c3e
                        Delete(&local_4c,-1);
                    }
                }
                this_01 = &(this->super_TNonplayer).super_TCreature.Combat;
                    // try { // try from 080b8921 to 080b8953 has its CatchHandler @ 080b8c50
                TCombat::CheckCombatValues(this_01);
                TCombat::SetAttackMode(this_01,'\x02');
                TCreature::ToDoWait((TCreature *)this,0);
                TCreature::ToDoStart((TCreature *)this);
            }
            else {
                Text = "TMonster::TMonster: Kann Monster nicht auf die Karte setzen.\n";
LAB_080b8b89:
                    // try { // try from 080b8b89 to 080b8b8d has its CatchHandler @ 080b8c50
                error(Text);
            }
            return;
        }
                    // try { // try from 080b86e6 to 080b87f7 has its CatchHandler @ 080b8c50
        pTVar4 = GetCreature(this->Master);
        if (pTVar4 == (TCreature *)0x0) {
            Text = "TMonster::TMonster: Master existiert nicht.\n";
            goto LAB_080b8b89;
        }
        if ((pTVar4->Type != MONSTER) || (pTVar4[1].super_TSkillBase.Skills[1] == (TSkill *)0x0)) {
            pTVar4->SummonedCreatures = pTVar4->SummonedCreatures + 1;
            (this->super_TNonplayer).super_TCreature.LifeEndRound = pTVar4->LifeEndRound;
            goto LAB_080b873a;
        }
        error(&DAT_08105b60);
        this->Master = (ulong)pTVar4[1].super_TSkillBase.Skills[1];
    } while( true );
}



// DWARF original prototype: void TMonster(TMonster * this, int Race, int x, int y, int z, int Home,
// ulong Father)

void __thiscall TMonster::TMonster(TMonster *this)

{
    int iVar1;
    anon_union_4_2_730cd3ca_for_TOutfit_2 aVar2;
    bool bVar3;
    TCreature *pTVar4;
    TNonplayer **ppTVar5;
    TItemData *this_00;
    long lVar6;
    long lVar7;
    TCombat *this_01;
    int in_stack_00000008;
    int in_stack_0000000c;
    int in_stack_00000010;
    int in_stack_00000014;
    int in_stack_00000018;
    ulong in_stack_0000001c;
    char *Text;
    Object *this_02;
    int local_88;
    int j;
    int Repeat;
    int i;
    Object local_6c [4];
    Object local_5c [4];
    Object local_4c;
    Object Obj;
    ulong local_3c [4];
    Object local_2c;
    Object Bag;
    
    TCreature::TCreature((TCreature *)this);
    (this->super_TNonplayer).super_TCreature.Type = MONSTER;
    (this->super_TNonplayer).State = IDLE;
    (this->super_TNonplayer).super_TCreature._vptr_TCreature =
         (_func_int_varargs **)&PTR__TMonster_08127ca8;
    (this->super_TNonplayer).super_TCreature.Race = in_stack_00000008;
    (this->super_TNonplayer).super_TCreature.startx = in_stack_0000000c;
    (this->super_TNonplayer).super_TCreature.posx = in_stack_0000000c;
    this->Home = in_stack_00000018;
    (this->super_TNonplayer).super_TCreature.starty = in_stack_00000010;
    (this->super_TNonplayer).super_TCreature.posy = in_stack_00000010;
    (this->super_TNonplayer).super_TCreature.startz = in_stack_00000014;
    (this->super_TNonplayer).super_TCreature.posz = in_stack_00000014;
    this->Target = 0;
    this->Master = in_stack_0000001c;
    do {
        if (this->Master == 0) {
LAB_080b8d5a:
            if (RaceData[in_stack_00000008].Article[0] == '\0') {
                strcpy((this->super_TNonplayer).super_TCreature.Name,
                       RaceData[in_stack_00000008].Name);
            }
            else {
                snprintf((this->super_TNonplayer).super_TCreature.Name,0x1e,"%s %s",
                         in_stack_00000008 * 0x150 + 0x81c477e,RaceData + in_stack_00000008);
            }
            TSkillBase::SetSkills
                      (&(this->super_TNonplayer).super_TCreature.super_TSkillBase,in_stack_00000008)
            ;
            iVar1 = RaceData[in_stack_00000008].Outfit.OutfitID;
            aVar2 = RaceData[in_stack_00000008].Outfit.field_1;
            (this->super_TNonplayer).super_TCreature.Outfit.OutfitID = iVar1;
            (this->super_TNonplayer).super_TCreature.Outfit.field_1 = aVar2;
            (this->super_TNonplayer).super_TCreature.OrgOutfit.OutfitID = iVar1;
            (this->super_TNonplayer).super_TCreature.OrgOutfit.field_1 = aVar2;
            TCreature::SetID((TCreature *)this,0);
            TCreature::SetInCrList((TCreature *)this);
            ppTVar5 = vector<>::operator()(&NonplayerList,FirstFreeNonplayer);
            FirstFreeNonplayer = FirstFreeNonplayer + 1;
            *ppTVar5 = &this->super_TNonplayer;
            bVar3 = TCreature::SetOnMap((TCreature *)this);
            if (bVar3) {
                if ((this->Master == 0) && (0 < RaceData[in_stack_00000008].Items)) {
                    // try { // try from 080b8e56 to 080b8f24 has its CatchHandler @ 080b925e
                    GetSpecialObject((SPECIALMEANING)local_3c);
                    GetBodyContainer((ulong)&local_4c,(this->super_TNonplayer).super_TCreature.ID);
                    Create(&local_2c,(ObjectType *)&local_4c,(ulong)local_3c);
                    Repeat = 1;
                    if (0 < RaceData[in_stack_00000008].Items) {
                        do {
                            this_00 = vector<TItemData>::operator()
                                                (&RaceData[in_stack_00000008].Item,Repeat);
                            lVar6 = random();
                            if (lVar6 <= this_00->Probability) {
                                lVar7 = random();
                                j = 1;
                                bVar3 = ObjectType::getFlag(&this_00->Type,CUMULATIVE);
                                lVar6 = lVar7;
                                if (!bVar3) {
                                    lVar6 = 0;
                                    j = lVar7;
                                }
                                local_88 = 0;
                                if (0 < j) {
                                    do {
                                        local_4c.ObjectID = 0;
                                        bVar3 = ObjectType::getFlag(&this_00->Type,WEAPON);
                                        if (((((bVar3) ||
                                              (bVar3 = ObjectType::getFlag(&this_00->Type,SHIELD),
                                              bVar3)) ||
                                             (bVar3 = ObjectType::getFlag(&this_00->Type,BOW), bVar3
                                             )) || ((bVar3 = ObjectType::getFlag(&this_00->Type,
                                                                                 THROW), bVar3 ||
                                                    (bVar3 = ObjectType::getFlag(&this_00->Type,WAND
                                                                                ), bVar3)))) ||
                                           ((bVar3 = ObjectType::getFlag(&this_00->Type,WEAROUT),
                                            bVar3 || ((bVar3 = ObjectType::getFlag(&this_00->Type,
                                                                                   EXPIRE), bVar3 ||
                                                      (bVar3 = ObjectType::getFlag(&this_00->Type,
                                                                                   EXPIRESTOP),
                                                      bVar3)))))) {
                    // try { // try from 080b9022 to 080b904d has its CatchHandler @ 080b91f5
                                            ObjectType::setTypeID
                                                      ((ObjectType *)local_6c,(this_00->Type).TypeID
                                                      );
                                            lVar7 = 0;
                                            this_02 = local_6c;
                                            i = local_2c.ObjectID;
                                            Create(local_5c,(ObjectType *)&i,(ulong)this_02);
                                            local_4c.ObjectID = local_5c[0].ObjectID;
                                            local_3c[0] = local_5c[0].ObjectID;
                                        }
                                        else {
                                            this_02 = local_5c;
                                            ObjectType::setTypeID
                                                      ((ObjectType *)this_02,(this_00->Type).TypeID)
                                            ;
                                            lVar7 = lVar6;
                                            CreateAtCreature((ulong)local_6c,
                                                             (ObjectType *)
                                                             (this->super_TNonplayer).
                                                             super_TCreature.ID,(ulong)this_02);
                                            i = local_6c[0].ObjectID;
                                            local_4c.ObjectID = i;
                                        }
                    // try { // try from 080b9064 to 080b918d has its CatchHandler @ 080b925e
                                        Object::getContainer((Object *)&i);
                                        Object::getObjectType(local_6c);
                                        if (local_6c[0].ObjectID == 0) {
                                            error(&DAT_08105bc0,in_stack_00000008,this_02,lVar7);
                                            local_6c[0].ObjectID = local_4c.ObjectID;
                                            Delete(local_6c,-1);
                                        }
                                        local_88 = local_88 + 1;
                                    } while (local_88 < j);
                                }
                            }
                            Repeat = Repeat + 1;
                        } while (Repeat <= RaceData[in_stack_00000008].Items);
                    }
                    local_6c[0].ObjectID = local_2c.ObjectID;
                    GetFirstContainerObject((Object *)&i);
                    local_5c[0].ObjectID = ::NONE.ObjectID;
                    if (i == ::NONE.ObjectID) {
                        local_4c.ObjectID = local_2c.ObjectID;
                    // try { // try from 080b8f90 to 080b900d has its CatchHandler @ 080b925e
                        Delete(&local_4c,-1);
                    }
                }
                this_01 = &(this->super_TNonplayer).super_TCreature.Combat;
                    // try { // try from 080b8f41 to 080b8f73 has its CatchHandler @ 080b9270
                TCombat::CheckCombatValues(this_01);
                TCombat::SetAttackMode(this_01,'\x02');
                TCreature::ToDoWait((TCreature *)this,0);
                TCreature::ToDoStart((TCreature *)this);
            }
            else {
                Text = "TMonster::TMonster: Kann Monster nicht auf die Karte setzen.\n";
LAB_080b91a9:
                    // try { // try from 080b91a9 to 080b91ad has its CatchHandler @ 080b9270
                error(Text);
            }
            return;
        }
                    // try { // try from 080b8d06 to 080b8e17 has its CatchHandler @ 080b9270
        pTVar4 = GetCreature(this->Master);
        if (pTVar4 == (TCreature *)0x0) {
            Text = "TMonster::TMonster: Master existiert nicht.\n";
            goto LAB_080b91a9;
        }
        if ((pTVar4->Type != MONSTER) || (pTVar4[1].super_TSkillBase.Skills[1] == (TSkill *)0x0)) {
            pTVar4->SummonedCreatures = pTVar4->SummonedCreatures + 1;
            (this->super_TNonplayer).super_TCreature.LifeEndRound = pTVar4->LifeEndRound;
            goto LAB_080b8d5a;
        }
        error(&DAT_08105b60);
        this->Master = (ulong)pTVar4[1].super_TSkillBase.Skills[1];
    } while( true );
}



// DWARF original prototype: void ~TMonster(TMonster * this, int __in_chrg)

void __thiscall TMonster::~TMonster(TMonster *this,int __in_chrg)

{
    bool bVar1;
    TCreature *pTVar2;
    TCreature *master;
    ulong in_stack_ffffffe8;
    
    bVar1 = (this->super_TNonplayer).super_TCreature.IsDead;
    (this->super_TNonplayer).super_TCreature._vptr_TCreature =
         (_func_int_varargs **)&PTR__TMonster_08127ca8;
    if (bVar1 == false) {
        in_stack_ffffffe8 = (this->super_TNonplayer).super_TCreature.posy;
        GraphicalEffect();
    }
    else if (this->Master == 0) {
        in_stack_ffffffe8 = RaceData[(this->super_TNonplayer).super_TCreature.Race].ExperiencePoints
        ;
        TCombat::DistributeExperiencePoints
                  (&(this->super_TNonplayer).super_TCreature.Combat,in_stack_ffffffe8);
    }
    if (this->Home != 0) {
        NotifyMonsterhomeOfDeath(this->Home);
    }
    if (this->Master != 0) {
        pTVar2 = GetCreature(this->Master);
        if ((pTVar2 != (TCreature *)0x0) && (0 < pTVar2->SummonedCreatures)) {
            pTVar2->SummonedCreatures = pTVar2->SummonedCreatures + -1;
        }
    }
    TNonplayer::~TNonplayer(&this->super_TNonplayer,in_stack_ffffffe8);
    return;
}



// DWARF original prototype: void ~TMonster(TMonster * this, int __in_chrg)

void __thiscall TMonster::~TMonster(TMonster *this,int __in_chrg)

{
    bool bVar1;
    TCreature *pTVar2;
    TCreature *master;
    ulong in_stack_ffffffe8;
    
    bVar1 = (this->super_TNonplayer).super_TCreature.IsDead;
    (this->super_TNonplayer).super_TCreature._vptr_TCreature =
         (_func_int_varargs **)&PTR__TMonster_08127ca8;
    if (bVar1 == false) {
        in_stack_ffffffe8 = (this->super_TNonplayer).super_TCreature.posy;
        GraphicalEffect();
    }
    else if (this->Master == 0) {
        in_stack_ffffffe8 = RaceData[(this->super_TNonplayer).super_TCreature.Race].ExperiencePoints
        ;
        TCombat::DistributeExperiencePoints
                  (&(this->super_TNonplayer).super_TCreature.Combat,in_stack_ffffffe8);
    }
    if (this->Home != 0) {
        NotifyMonsterhomeOfDeath(this->Home);
    }
    if (this->Master != 0) {
        pTVar2 = GetCreature(this->Master);
        if ((pTVar2 != (TCreature *)0x0) && (0 < pTVar2->SummonedCreatures)) {
            pTVar2->SummonedCreatures = pTVar2->SummonedCreatures + -1;
        }
    }
    TNonplayer::~TNonplayer(&this->super_TNonplayer,in_stack_ffffffe8);
    return;
}



// DWARF original prototype: void ~TMonster(TMonster * this, int __in_chrg)

void __thiscall TMonster::~TMonster(TMonster *this,int __in_chrg)

{
    bool bVar1;
    TCreature *pTVar2;
    TCreature *master;
    ulong in_stack_ffffffe8;
    
    bVar1 = (this->super_TNonplayer).super_TCreature.IsDead;
    (this->super_TNonplayer).super_TCreature._vptr_TCreature =
         (_func_int_varargs **)&PTR__TMonster_08127ca8;
    if (bVar1 == false) {
        in_stack_ffffffe8 = (this->super_TNonplayer).super_TCreature.posy;
        GraphicalEffect();
    }
    else if (this->Master == 0) {
        in_stack_ffffffe8 = RaceData[(this->super_TNonplayer).super_TCreature.Race].ExperiencePoints
        ;
        TCombat::DistributeExperiencePoints
                  (&(this->super_TNonplayer).super_TCreature.Combat,in_stack_ffffffe8);
    }
    if (this->Home != 0) {
        NotifyMonsterhomeOfDeath(this->Home);
    }
    if (this->Master != 0) {
        pTVar2 = GetCreature(this->Master);
        if ((pTVar2 != (TCreature *)0x0) && (0 < pTVar2->SummonedCreatures)) {
            pTVar2->SummonedCreatures = pTVar2->SummonedCreatures + -1;
        }
    }
    TNonplayer::~TNonplayer(&this->super_TNonplayer,in_stack_ffffffe8);
    operator_delete(this);
    return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// DWARF original prototype: void IdleStimulus(TMonster * this)

void __thiscall TMonster::IdleStimulus(TMonster *this)

{
    TSkill *id;
    TOutfit _Outfit;
    bool bVar1;
    bool bVar2;
    int dir;
    TCreature *pTVar3;
    uint uVar4;
    int iVar5;
    int iVar6;
    uint uVar7;
    uint uVar8;
    uint uVar9;
    TSpellData *pTVar10;
    long lVar11;
    ulong uVar12;
    TCreature *pTVar13;
    ulong *puVar14;
    char *pcVar15;
    TCreature *master;
    STATE SVar16;
    int *piVar17;
    uint uVar18;
    int dy_1;
    int destX;
    TCombat *this_00;
    ulong uVar19;
    int destY;
    int iVar20;
    TDamageImpact *this_01;
    int Try;
    TMonster *i;
    int iVar21;
    uint uVar22;
    TMonster *pTVar23;
    TCreature *target;
    TCreature *target_1;
    int Strategy;
    int TieBreaker;
    int Goodness;
    int iStack_74;
    bool Sleep;
    int local_70;
    int local_6c;
    int x;
    int y;
    int z;
    int x_1;
    int y_1;
    int z_1;
    TOutfit HelpOutfit;
    TFindCreatures Search;
    
    if ((this->super_TNonplayer).super_TCreature.LockToDo != false) {
        return;
    }
    if ((this->super_TNonplayer).super_TCreature.LoggingOut != false) {
        return;
    }
    uVar18 = (this->super_TNonplayer).super_TCreature.LifeEndRound;
    if ((uVar18 != 0) && (uVar18 <= RoundNr)) {
        print();
        TCreature::StartLogout((TCreature *)this,true,true);
        goto LAB_080b97c3;
    }
    if (this->Master != 0) {
        pTVar3 = GetCreature(this->Master);
        if (pTVar3 == (TCreature *)0x0) {
            if (0x3fffffff < this->Master) {
                pcVar15 = (this->super_TNonplayer).super_TCreature.Name;
                print();
                (*(this->super_TNonplayer).super_TCreature.super_TSkillBase.Skills[2]->_vptr_TSkill
                  [2])((this->super_TNonplayer).super_TCreature.super_TSkillBase.Skills[2],0,pcVar15
                      );
                (*(this->super_TNonplayer).super_TCreature._vptr_TCreature[2])(this);
                goto LAB_080b961e;
            }
            print();
LAB_080b9665:
            TCreature::StartLogout((TCreature *)this,true,true);
        }
        else {
            uVar18 = this->Master;
            if ((uVar18 < 0x40000000) && (pTVar3->SummonedCreatures == 0)) {
                print();
                TCreature::StartLogout((TCreature *)this,true,true);
                goto LAB_080bac12;
            }
            if (pTVar3 == (TCreature *)0x0) {
                iVar5 = (this->super_TNonplayer).super_TCreature.posz;
                iVar20 = _DAT_00000278;
LAB_080b96b4:
                if ((iVar5 == iVar20) || (uVar18 < 0x40000000)) {
                    if ((pTVar3 == (TCreature *)0x0) || ((pTVar3->Combat).Following != false)) {
                        uVar12 = 0;
                    }
                    else {
                        uVar12 = (pTVar3->Combat).AttackDest;
                    }
                    this->Target = uVar12;
                    if ((uVar12 == 0) || (uVar12 == (this->super_TNonplayer).super_TCreature.ID)) {
                        this->Target = uVar18;
                    }
                    goto LAB_080b96fc;
                }
            }
            else {
                iVar5 = (this->super_TNonplayer).super_TCreature.posz;
                uVar4 = iVar5 - pTVar3->posz;
                if (0x7fffffff < uVar4) {
                    uVar4 = -uVar4;
                }
                if ((int)uVar4 < 2) {
                    uVar4 = (this->super_TNonplayer).super_TCreature.posx - pTVar3->posx;
                    if (0x7fffffff < uVar4) {
                        uVar4 = -uVar4;
                    }
                    if ((int)uVar4 < 0x1f) {
                        uVar4 = (this->super_TNonplayer).super_TCreature.posy - pTVar3->posy;
                        if (0x7fffffff < uVar4) {
                            uVar4 = -uVar4;
                        }
                        iVar20 = pTVar3->posz;
                        if ((int)uVar4 < 0x1f) goto LAB_080b96b4;
                    }
                }
                if (uVar18 < 0x40000000) {
                    print();
                    goto LAB_080b9665;
                }
            }
            (*(this->super_TNonplayer).super_TCreature.super_TSkillBase.Skills[2]->_vptr_TSkill[2])
                      ((this->super_TNonplayer).super_TCreature.super_TSkillBase.Skills[2],0);
            (*(this->super_TNonplayer).super_TCreature._vptr_TCreature[2])(this);
            print();
        }
LAB_080b961e:
        (this->super_TNonplayer).State = SLEEPING;
        return;
    }
    bVar1 = MonsterhomeInRange();
    if (!bVar1) {
        vector<>::operator()(&Monsterhome,this->Home);
        vector<>::operator()(&Monsterhome,this->Home);
        vector<>::operator()(&Monsterhome,this->Home);
        print();
        TCreature::StartLogout((TCreature *)this,true,true);
LAB_080bac12:
        (this->super_TNonplayer).State = SLEEPING;
        return;
    }
LAB_080b96fc:
    if (this->Target == 0) {
        iVar5 = (this->super_TNonplayer).super_TCreature.Race;
    }
    else {
        pTVar3 = GetCreature(this->Target);
        if (pTVar3 == (TCreature *)0x0) {
LAB_080baa94:
            this->Target = 0;
        }
        else {
            uVar18 = (this->super_TNonplayer).super_TCreature.posx - pTVar3->posx;
            if (0x7fffffff < uVar18) {
                uVar18 = -uVar18;
            }
            if (10 < (int)uVar18) goto LAB_080baa94;
            uVar18 = (this->super_TNonplayer).super_TCreature.posy - pTVar3->posy;
            if (0x7fffffff < uVar18) {
                uVar18 = -uVar18;
            }
            if ((10 < (int)uVar18) ||
               ((this->super_TNonplayer).super_TCreature.posz != pTVar3->posz)) goto LAB_080baa94;
        }
        if (pTVar3 == (TCreature *)0x0) {
            iVar5 = (this->super_TNonplayer).super_TCreature.Race;
        }
        else {
            bVar1 = IsProtectionZone();
            if (bVar1) {
                this->Target = 0;
            }
            bVar1 = IsHouse(pTVar3->posx,pTVar3->posy,pTVar3->posz);
            if (bVar1) {
                this->Target = 0;
            }
            iVar5 = (this->super_TNonplayer).super_TCreature.Race;
            if (RaceData[iVar5].SeeInvisible == false) {
                bVar1 = false;
                if (((pTVar3->Outfit).OutfitID == 0) && ((pTVar3->Outfit).field_1.ObjectType == 0))
                {
                    bVar1 = true;
                }
                if (bVar1) {
                    this->Target = 0;
                }
            }
        }
        if (this->Master == 0) {
            lVar11 = random();
            if (lVar11 < RaceData[iVar5].LoseTarget) {
                this->Target = 0;
                iVar5 = (this->super_TNonplayer).super_TCreature.Race;
            }
            else {
                iVar5 = (this->super_TNonplayer).super_TCreature.Race;
            }
        }
    }
    SVar16 = (this->super_TNonplayer).State;
    if ((SVar16 != PANIC) && (SVar16 != UNDERATTACK)) {
        (this->super_TNonplayer).State = IDLE;
    }
    if ((0 < RaceData[iVar5].Talks) && (iVar5 = rand(), iVar5 == (iVar5 / 0x32) * 0x32)) {
        iVar5 = rand();
        puVar14 = vector<>::operator()
                            (&RaceData[(this->super_TNonplayer).super_TCreature.Race].Talk,
                             iVar5 % RaceData[(this->super_TNonplayer).super_TCreature.Race].Talks +
                             1);
        pcVar15 = GetDynamicString(*puVar14);
        if (*pcVar15 == '#') {
            pcVar15 = pcVar15 + 3;
            iVar5 = 0x11;
            uVar12 = (this->super_TNonplayer).super_TCreature.ID;
        }
        else {
            iVar5 = 0x10;
            uVar12 = (this->super_TNonplayer).super_TCreature.ID;
        }
                    // try { // try from 080baa0a to 080baa0e has its CatchHandler @ 080bade6
        Talk(uVar12,iVar5,(char *)0x0,pcVar15,false);
    }
    uVar12 = this->Target;
    if (uVar12 == 0) {
        bVar1 = true;
        if (this->Master == 0) {
            TieBreaker = -0x80000000;
            iVar5 = 0;
            Strategy = 0;
            target_1 = (TCreature *)0x0;
            lVar11 = random();
            do {
                piVar17 = RaceData[(this->super_TNonplayer).super_TCreature.Race].Strategy + iVar5;
                if (lVar11 < *piVar17) break;
                target_1 = (TCreature *)((int)&target_1->_vptr_TCreature + 1);
                iVar5 = iVar5 + 1;
                lVar11 = lVar11 - *piVar17;
            } while (iVar5 < 3);
            TFindCreatures::TFindCreatures
                      ((TFindCreatures *)&HelpOutfit.field_1,0xc,0xc,
                       (this->super_TNonplayer).super_TCreature.ID,5);
            uVar12 = TFindCreatures::getNext((TFindCreatures *)&HelpOutfit.field_1);
            if (uVar12 == 0) {
                uVar12 = this->Target;
            }
            else {
                do {
                    pTVar3 = GetCreature(uVar12);
                    if (pTVar3 == (TCreature *)0x0) {
                        error("TMonster::IdleStimulus: Kreatur existiert nicht.\n");
                        uVar12 = this->Target;
                        goto LAB_080b9794;
                    }
                    if ((pTVar3->Type != MONSTER) ||
                       (((id = pTVar3[1].super_TSkillBase.Skills[1], id != (TSkill *)0x0 &&
                         (pTVar13 = GetCreature((ulong)id), pTVar13 != (TCreature *)0x0)) &&
                        (pTVar13->Type == PLAYER)))) {
                        iVar5 = pTVar3->posz;
                        if (iVar5 < 8) {
                            iVar20 = (this->super_TNonplayer).super_TCreature.posz;
                            if (iVar20 < 8) {
LAB_080ba913:
                                bVar1 = false;
                            }
                        }
                        else {
                            iVar20 = (this->super_TNonplayer).super_TCreature.posz;
                            if ((iVar20 - iVar5) + 2U < 5) goto LAB_080ba913;
                        }
                        if ((iVar20 == iVar5) &&
                           ((pTVar3->Type != PLAYER ||
                            (bVar2 = CheckRight(pTVar3->ID,IGNORED_BY_MONSTERS), !bVar2)))) {
                            if (RaceData[(this->super_TNonplayer).super_TCreature.Race].SeeInvisible
                                == false) {
                                bVar2 = false;
                                if (((pTVar3->Outfit).OutfitID == 0) &&
                                   ((pTVar3->Outfit).field_1.ObjectType == 0)) {
                                    bVar2 = true;
                                }
                                if (bVar2) goto LAB_080ba73a;
                            }
                            bVar2 = IsProtectionZone();
                            if ((!bVar2) &&
                               (bVar2 = IsHouse(pTVar3->posx,pTVar3->posy,pTVar3->posz), !bVar2)) {
                                uVar18 = (this->super_TNonplayer).super_TCreature.posx -
                                         pTVar3->posx;
                                if (0x7fffffff < uVar18) {
                                    uVar18 = -uVar18;
                                }
                                uVar4 = (this->super_TNonplayer).super_TCreature.posy - pTVar3->posy
                                ;
                                if (0x7fffffff < uVar4) {
                                    uVar4 = -uVar4;
                                }
                                if (((int)uVar18 < 0xb) && ((int)uVar4 < 0xb)) {
                                    if (target_1 == (TCreature *)0x1) {
                                        iVar5 = TSkill::Get((pTVar3->super_TSkillBase).Skills[2]);
LAB_080ba8dc:
                                        uVar19 = -iVar5;
                                    }
                                    else if ((int)target_1 < 2) {
                                        if (target_1 == (TCreature *)0x0) {
                                            iVar5 = uVar4 + uVar18;
                                            goto LAB_080ba8dc;
                                        }
LAB_080ba860:
                                        uVar19 = 0;
                                        error("TMonster::IdleStimulus: Unbekannte Strategie %d.\n",
                                              target_1);
                                    }
                                    else if (target_1 == (TCreature *)0x2) {
                                        uVar19 = TCombat::GetDamageByCreature
                                                           (&(this->super_TNonplayer).
                                                             super_TCreature.Combat,pTVar3->ID);
                                    }
                                    else {
                                        uVar19 = 0;
                                        if (target_1 != (TCreature *)0x3) goto LAB_080ba860;
                                    }
                                    lVar11 = random();
                                    if ((TieBreaker < (int)uVar19) ||
                                       ((uVar19 == TieBreaker && (Strategy < lVar11)))) {
                                        this->Target = uVar12;
                                        Strategy = lVar11;
                                        TieBreaker = uVar19;
                                    }
                                }
                            }
                        }
                    }
LAB_080ba73a:
                    uVar12 = TFindCreatures::getNext((TFindCreatures *)&HelpOutfit.field_1);
                } while (uVar12 != 0);
                uVar12 = this->Target;
            }
        }
LAB_080b9794:
        if (uVar12 == 0) {
            if (bVar1) {
                SVar16 = (this->super_TNonplayer).State;
                if ((SVar16 != UNDERATTACK) && (SVar16 != PANIC)) {
                    if (this->Master == 0) {
LAB_080b97c3:
                        (this->super_TNonplayer).State = SLEEPING;
                        return;
                    }
                    TCreature::ToDoWait((TCreature *)this,1000);
                    goto LAB_080b97e9;
                }
            }
            else {
                SVar16 = (this->super_TNonplayer).State;
            }
        }
        else {
            SVar16 = (this->super_TNonplayer).State;
        }
        if ((uVar12 == 0) && (SVar16 == PANIC)) {
            SVar16 = IDLE;
            (this->super_TNonplayer).State = IDLE;
        }
        if (SVar16 == UNDERATTACK) {
            (this->super_TNonplayer).State = IDLE;
        }
    }
    iVar5 = (this->super_TNonplayer).super_TCreature.Race;
    if (0 < RaceData[iVar5].Spells) {
        if (uVar12 == 0) {
            target = (TCreature *)0x0;
        }
        else {
            target = GetCreature(uVar12);
            iVar5 = (this->super_TNonplayer).super_TCreature.Race;
        }
        i = (TMonster *)0x1;
        if (RaceData[iVar5].Spells < 1) {
            uVar12 = this->Target;
        }
        else {
            do {
                pTVar23 = i;
                pTVar10 = vector<TSpellData>::operator()(&RaceData[iVar5].Spell,(int)i);
                iVar5 = rand();
                if (iVar5 % pTVar10->Delay == 0) {
                    if ((this->Master == 0) &&
                       (iVar5 = TSkill::Get((this->super_TNonplayer).super_TCreature.
                                            super_TSkillBase.Skills[2]),
                       iVar5 <= RaceData[(this->super_TNonplayer).super_TCreature.Race].
                                FleeThreshold)) {
                        pTVar23 = (TMonster *)0x3;
                        lVar11 = random();
                        if (lVar11 != 1) goto LAB_080ba242;
                    }
                    this_01 = (TDamageImpact *)0x0;
                    switch(pTVar10->Impact) {
                    case IMPACT_DAMAGE:
                        this_01 = (TDamageImpact *)operator_new(0x14);
                    // try { // try from 080ba1ca to 080ba1f0 has its CatchHandler @ 080bae1e
                        iVar5 = ComputeDamage((TCreature *)this,0,pTVar10->ImpactParam2,
                                              pTVar10->ImpactParam3);
                        pTVar23 = this;
                        TDamageImpact::TDamageImpact
                                  (this_01,(TCreature *)this,pTVar10->ImpactParam1,iVar5,true);
                        break;
                    case IMPACT_FIELD:
                        this_01 = (TDamageImpact *)operator_new(0xc);
                        pTVar23 = this;
                    // try { // try from 080ba3a9 to 080ba3ad has its CatchHandler @ 080bae30
                        TFieldImpact::TFieldImpact
                                  ((TFieldImpact *)this_01,(TCreature *)this,pTVar10->ImpactParam1);
                        break;
                    case IMPACT_HEALING:
                        this_01 = (TDamageImpact *)operator_new(0xc);
                    // try { // try from 080ba3dd to 080ba3f4 has its CatchHandler @ 080bae32
                        iVar5 = ComputeDamage((TCreature *)this,0,pTVar10->ImpactParam1,
                                              pTVar10->ImpactParam2);
                        pTVar23 = this;
                        THealingImpact::THealingImpact
                                  ((THealingImpact *)this_01,(TCreature *)this,iVar5);
                        break;
                    case IMPACT_SPEED:
                        this_01 = (TDamageImpact *)operator_new(0x10);
                    // try { // try from 080ba424 to 080ba442 has its CatchHandler @ 080bae34
                        ComputeDamage((TCreature *)this,0,pTVar10->ImpactParam1,
                                      pTVar10->ImpactParam2);
                        pTVar23 = this;
                        TSpeedImpact::TSpeedImpact((TSpeedImpact *)this_01);
                        break;
                    case IMPACT_DRUNKEN:
                        this_01 = (TDamageImpact *)operator_new(0x10);
                    // try { // try from 080ba472 to 080ba490 has its CatchHandler @ 080bae36
                        iVar5 = ComputeDamage((TCreature *)this,0,pTVar10->ImpactParam1,
                                              pTVar10->ImpactParam2);
                        pTVar23 = this;
                        TDrunkenImpact::TDrunkenImpact
                                  ((TDrunkenImpact *)this_01,(TCreature *)this,iVar5,
                                   pTVar10->ImpactParam3);
                        break;
                    case IMPACT_STRENGTH:
                        this_01 = (TDamageImpact *)operator_new(0x14);
                    // try { // try from 080ba4c0 to 080ba4e5 has its CatchHandler @ 080bae38
                        ComputeDamage((TCreature *)this,0,pTVar10->ImpactParam2,
                                      pTVar10->ImpactParam3);
                        pTVar23 = this;
                        TStrengthImpact::TStrengthImpact((TStrengthImpact *)this_01);
                        break;
                    case IMPACT_OUTFIT:
                        z_1 = pTVar10->ImpactParam1;
                        uVar18 = pTVar10->ImpactParam2;
                        if (0x7fffffff < uVar18) {
                            uVar18 = uVar18 + 0xff;
                        }
                        uVar4 = pTVar10->ImpactParam3;
                        if (0x7fffffff < uVar4) {
                            uVar4 = uVar4 + 0xff;
                        }
                        HelpOutfit.OutfitID =
                             CONCAT13((char)(uVar4 >> 8),
                                      CONCAT12((char)pTVar10->ImpactParam3,
                                               CONCAT11((char)(uVar18 >> 8),
                                                        (char)pTVar10->ImpactParam2)));
                        this_01 = (TDamageImpact *)operator_new(0x14);
                        _Outfit.field_1 = (anon_union_4_2_730cd3ca_for_TOutfit_2)HelpOutfit.OutfitID
                        ;
                        _Outfit.OutfitID = z_1;
                        pTVar23 = this;
                    // try { // try from 080ba554 to 080ba558 has its CatchHandler @ 080bae3a
                        TOutfitImpact::TOutfitImpact
                                  ((TOutfitImpact *)this_01,(TCreature *)this,_Outfit,
                                   pTVar10->ImpactParam4);
                        break;
                    case IMPACT_SUMMON:
                        if (this->Master == 0) {
                            this_01 = (TDamageImpact *)operator_new(0x10);
                            pTVar23 = this;
                    // try { // try from 080ba595 to 080ba599 has its CatchHandler @ 080bae1e
                            TSummonImpact::TSummonImpact
                                      ((TSummonImpact *)this_01,(TCreature *)this,
                                       pTVar10->ImpactParam1,pTVar10->ImpactParam2);
                        }
                    }
                    if (this_01 != (TDamageImpact *)0x0) {
                        iVar5 = (*(this_01->super_TImpact)._vptr_TImpact[2])(this_01,pTVar23);
                        if (((char)iVar5 == '\0') ||
                           ((this->Target != 0 && (this->Target != this->Master)))) {
                            switch(pTVar10->Shape) {
                            case SHAPE_ACTOR:
                                ActorShapeSpell((TCreature *)this,&this_01->super_TImpact,
                                                pTVar10->ShapeParam1);
                                break;
                            case SHAPE_VICTIM:
                                if (target != (TCreature *)0x0) {
                                    TCreature::Rotate((TCreature *)this,target);
                                    VictimShapeSpell((TCreature *)this,target,pTVar10->ShapeParam1,
                                                     pTVar10->ShapeParam2,&this_01->super_TImpact,
                                                     pTVar10->ShapeParam3);
                                }
                                break;
                            case SHAPE_ORIGIN:
                                OriginShapeSpell((TCreature *)this,pTVar10->ShapeParam1,
                                                 &this_01->super_TImpact,pTVar10->ShapeParam2);
                                break;
                            case SHAPE_DESTINATION:
                                if (target != (TCreature *)0x0) {
                                    TCreature::Rotate((TCreature *)this,target);
                                    DestinationShapeSpell
                                              ((TCreature *)this,target,pTVar10->ShapeParam1,
                                               pTVar10->ShapeParam2,pTVar10->ShapeParam3,
                                               &this_01->super_TImpact,pTVar10->ShapeParam4);
                                }
                                break;
                            case SHAPE_ANGLE:
                                if (target != (TCreature *)0x0) {
                                    TCreature::Rotate((TCreature *)this,target);
                                }
                                AngleShapeSpell((TCreature *)this,pTVar10->ShapeParam1,
                                                pTVar10->ShapeParam2,&this_01->super_TImpact,
                                                pTVar10->ShapeParam3);
                            }
                        }
                        operator_delete(this_01);
                    }
                }
LAB_080ba242:
                i = (TMonster *)((int)&(i->super_TNonplayer).super_TCreature._vptr_TCreature + 1);
                iVar5 = (this->super_TNonplayer).super_TCreature.Race;
            } while ((int)i <= RaceData[iVar5].Spells);
            uVar12 = this->Target;
        }
    }
    if (uVar12 == 0) {
        iVar5 = (this->super_TNonplayer).super_TCreature.posx;
        iVar20 = (this->super_TNonplayer).super_TCreature.posy;
    }
    else {
        pTVar3 = GetCreature(uVar12);
        if (pTVar3 == (TCreature *)0x0) {
            error("TMonster::IdleStimulus: Kreatur existiert nicht.\n");
            this->Target = 0;
LAB_080ba0e7:
            iVar5 = (this->super_TNonplayer).super_TCreature.posx;
            iVar20 = (this->super_TNonplayer).super_TCreature.posy;
        }
        else {
            uVar12 = this->Master;
            if (uVar12 == 0) {
                iVar5 = TSkill::Get((this->super_TNonplayer).super_TCreature.super_TSkillBase.Skills
                                    [2]);
                if (iVar5 <= RaceData[(this->super_TNonplayer).super_TCreature.Race].FleeThreshold)
                {
                    bVar1 = SearchFlightField();
                    if (bVar1) {
                        TCreature::ToDoGo((TCreature *)this,z,x_1,y_1,true,0x7fffffff);
                        goto LAB_080b97e9;
                    }
                    goto LAB_080ba0e7;
                }
                uVar12 = this->Master;
            }
            if (this->Target != uVar12) {
                    // try { // try from 080b99d7 to 080ba124 has its CatchHandler @ 080bae3c
                iVar5 = TSkill::Get((this->super_TNonplayer).super_TCreature.super_TSkillBase.Skills
                                    [0xb]);
                if (iVar5 < 1) {
                    SVar16 = (this->super_TNonplayer).State;
                }
                else {
                    SVar16 = (this->super_TNonplayer).State;
                    if (SVar16 != PANIC) {
                        SVar16 = ATTACKING;
                        (this->super_TNonplayer).State = ATTACKING;
                    }
                }
                if (SVar16 - ATTACKING < 2) {
                    this_00 = &(this->super_TNonplayer).super_TCreature.Combat;
                    TCombat::SetAttackDest(this_00,this->Target,false);
                    TCombat::SetChaseMode(this_00,'\0');
                }
                if (((RaceData[(this->super_TNonplayer).super_TCreature.Race].DistanceFighting ==
                      false) || (this->Target == this->Master)) ||
                   (bVar1 = ThrowPossible((this->super_TNonplayer).super_TCreature.posx,
                                          (this->super_TNonplayer).super_TCreature.posy,
                                          (this->super_TNonplayer).super_TCreature.posz,pTVar3->posx
                                          ,pTVar3->posy,pTVar3->posz,0), !bVar1)) {
                    TCombat::SetChaseMode(&(this->super_TNonplayer).super_TCreature.Combat,'\x01');
                    iVar5 = (this->super_TNonplayer).super_TCreature.posx;
                    if (((iVar5 - pTVar3->posx) + 1U < 3) &&
                       (iVar20 = (this->super_TNonplayer).super_TCreature.posy,
                       (iVar20 - pTVar3->posy) + 1U < 3)) {
                        iVar21 = rand();
                        iVar21 = iVar21 % 5;
                        if (iVar21 == 1) {
                            iVar5 = iVar5 + 1;
                        }
                        else if (iVar21 < 2) {
                            if (iVar21 == 0) {
                                iVar5 = iVar5 + -1;
                            }
                        }
                        else if (iVar21 == 2) {
                            iVar20 = iVar20 + -1;
                        }
                        else if (iVar21 == 3) {
                            iVar20 = iVar20 + 1;
                        }
                        if (((iVar21 < 4) &&
                            (iVar21 = (*(this->super_TNonplayer).super_TCreature._vptr_TCreature[3])
                                                (this,iVar5,iVar20,
                                                 (this->super_TNonplayer).super_TCreature.posz,1,0),
                            (char)iVar21 != '\0')) &&
                           (((iVar5 - pTVar3->posx) + 1U < 3 && ((iVar20 - pTVar3->posy) + 1U < 3)))
                           ) {
                            TCreature::ToDoGo((TCreature *)this,iVar5,iVar20,
                                              (this->super_TNonplayer).super_TCreature.posz,true,
                                              0x7fffffff);
                        }
                        SVar16 = (this->super_TNonplayer).State;
                        if (SVar16 == PANIC) {
                            SVar16 = ATTACKING;
                            (this->super_TNonplayer).State = ATTACKING;
                        }
                    }
                    else {
                        SVar16 = (this->super_TNonplayer).State;
                        if (1 < SVar16 - ATTACKING) {
                            iVar5 = 3;
                            goto LAB_080b9ba0;
                        }
                    }
                }
                else {
                    HelpOutfit.field_1 =
                         (anon_union_4_2_730cd3ca_for_TOutfit_2)(pTVar3->CrObject).ObjectID;
                    Search.endy = (this->super_TNonplayer).super_TCreature.CrObject.ObjectID;
                    iVar5 = ObjectDistance((Object *)&Search.endy,(Object *)&HelpOutfit.field_1);
                    if (iVar5 < 4) {
                        bVar1 = SearchFlightField();
                        if (!bVar1) {
                            TCreature::ToDoWait((TCreature *)this,1000);
                            SVar16 = (this->super_TNonplayer).State;
                            goto LAB_080b9afc;
                        }
                        TCreature::ToDoGo((TCreature *)this,local_6c,x,y,true,0x7fffffff);
                    }
                    else if (iVar5 == 4) {
                        iVar5 = (this->super_TNonplayer).super_TCreature.posx;
                        iVar20 = (this->super_TNonplayer).super_TCreature.posy;
                        iVar21 = rand();
                        iVar21 = iVar21 % 5;
                        if (iVar21 == 1) {
                            iVar5 = iVar5 + 1;
                        }
                        else if (iVar21 < 2) {
                            if (iVar21 == 0) {
                                iVar5 = iVar5 + -1;
                            }
                        }
                        else if (iVar21 == 2) {
                            iVar20 = iVar20 + -1;
                        }
                        else if (iVar21 == 3) {
                            iVar20 = iVar20 + 1;
                        }
                        if ((iVar21 < 4) &&
                           (iVar21 = (*(this->super_TNonplayer).super_TCreature._vptr_TCreature[3])
                                               (this,iVar5,iVar20,
                                                (this->super_TNonplayer).super_TCreature.posz,1,0),
                           (char)iVar21 != '\0')) {
                            iVar21 = iVar5 - pTVar3->posx;
                            local_70 = -iVar21;
                            if (-1 < iVar21) {
                                local_70 = iVar21;
                            }
                            iVar21 = iVar20 - pTVar3->posy;
                            iStack_74 = -iVar21;
                            if (-1 < iVar21) {
                                iStack_74 = iVar21;
                            }
                            piVar17 = &stack0xffffff8c;
                            if (iStack_74 <= local_70) {
                                piVar17 = &local_70;
                            }
                            if (*piVar17 == 4) {
                                TCreature::ToDoGo((TCreature *)this,iVar5,iVar20,
                                                  (this->super_TNonplayer).super_TCreature.posz,true
                                                  ,0x7fffffff);
                            }
                        }
                        TCreature::ToDoWait((TCreature *)this,1000);
                    }
                    else {
                        iVar5 = iVar5 + -4;
LAB_080b9ba0:
                        TCreature::ToDoGo((TCreature *)this,pTVar3->posx,pTVar3->posy,pTVar3->posz,
                                          false,iVar5);
                    }
                    SVar16 = (this->super_TNonplayer).State;
                }
LAB_080b9afc:
                if (SVar16 - ATTACKING < 2) {
                    pTVar3 = GetCreature(this->Target);
                    TCreature::Rotate((TCreature *)this,pTVar3);
                    if ((this->Master == 0) ||
                       (uVar12 = (this->super_TNonplayer).super_TCreature.Combat.AttackDest,
                       uVar12 != this->Master)) {
                        TCreature::ToDoAttack((TCreature *)this);
                    }
                    else {
                        error("TMonster::IdleStimulus: %s greift Master %lu an (St=%d, T: %lu).\n",
                              (this->super_TNonplayer).super_TCreature.Name,uVar12,
                              (this->super_TNonplayer).State,this->Target);
                    }
                }
                else {
                    TCreature::ToDoWait((TCreature *)this,1000);
                }
                goto LAB_080b97e9;
            }
            iVar5 = (this->super_TNonplayer).super_TCreature.posx;
            iVar20 = (this->super_TNonplayer).super_TCreature.posy;
            uVar22 = pTVar3->posx - iVar5;
            uVar4 = pTVar3->posy - iVar20;
            uVar7 = -uVar22;
            uVar18 = uVar7;
            if (-1 < (int)uVar22) {
                uVar18 = uVar22;
            }
            uVar8 = -uVar4;
            uVar9 = uVar8;
            if (-1 < (int)uVar4) {
                uVar9 = uVar4;
            }
            if (1 < (int)(uVar18 + uVar9)) {
                uVar18 = uVar7;
                if (-1 < (int)uVar22) {
                    uVar18 = uVar22;
                }
                uVar9 = uVar8;
                if (-1 < (int)uVar4) {
                    uVar9 = uVar4;
                }
                if (uVar18 + uVar9 == 2) {
                    TCreature::ToDoWait((TCreature *)this,1000);
                }
                else {
                    if (0x7fffffff < uVar22) {
                        uVar22 = uVar7;
                    }
                    if (0x7fffffff < uVar4) {
                        uVar4 = uVar8;
                    }
                    if (uVar4 + uVar22 == 3) {
                        TCreature::ToDoWait((TCreature *)this,1000);
                    }
                    TCreature::ToDoGo((TCreature *)this,pTVar3->posx,pTVar3->posy,pTVar3->posz,false
                                      ,3);
                }
                TCreature::ToDoStart((TCreature *)this);
                return;
            }
        }
    }
    iVar21 = 0;
    while (iVar21 = iVar21 + 1, iVar21 < 0xb) {
        iVar6 = rand();
        iVar6 = iVar6 % 4;
        if (iVar6 == 1) {
            iVar5 = iVar5 + 1;
        }
        else if (iVar6 < 2) {
            if (iVar6 == 0) {
                iVar5 = iVar5 + -1;
            }
        }
        else if (iVar6 == 2) {
            iVar20 = iVar20 + -1;
        }
        else if (iVar6 == 3) {
            iVar20 = iVar20 + 1;
        }
                    // try { // try from 080b98ef to 080b98f1 has its CatchHandler @ 080baea0
        iVar6 = (*(this->super_TNonplayer).super_TCreature._vptr_TCreature[3])
                          (this,iVar5,iVar20,(this->super_TNonplayer).super_TCreature.posz,1,0);
        if ((char)iVar6 != '\0') {
                    // try { // try from 080b9932 to 080b9951 has its CatchHandler @ 080baeca
            TCreature::ToDoGo((TCreature *)this,iVar5,iVar20,
                              (this->super_TNonplayer).super_TCreature.posz,true,0x7fffffff);
            TCreature::ToDoWait((TCreature *)this,1000);
            TCreature::ToDoStart((TCreature *)this);
            return;
        }
        iVar5 = (this->super_TNonplayer).super_TCreature.posx;
        iVar20 = (this->super_TNonplayer).super_TCreature.posy;
    }
    TCreature::ToDoWait((TCreature *)this,1000);
LAB_080b97e9:
    TCreature::ToDoStart((TCreature *)this);
    return;
}



// DWARF original prototype: void CreatureMoveStimulus(TMonster * this, ulong CreatureID, int Type)

void __thiscall TMonster::CreatureMoveStimulus(TMonster *this,ulong CreatureID,int Type)

{
    TSkill *id;
    TCreature *cr;
    TCreature *pTVar1;
    
    if (CreatureID == (this->super_TNonplayer).super_TCreature.ID) {
        if (((this->super_TNonplayer).State == SLEEPING) && (Type != 0)) {
            (this->super_TNonplayer).State = IDLE;
            TCreature::ToDoYield((TCreature *)this);
            return;
        }
        return;
    }
    if (((this->super_TNonplayer).State == SLEEPING) && (Type != 0)) {
        pTVar1 = GetCreature(CreatureID);
        if (pTVar1 == (TCreature *)0x0) {
            error("TMonster::CreatureMoveStimulus: Kreatur %d existiert nicht.\n");
            return;
        }
        if (pTVar1->Type == NPC) {
            return;
        }
        if (pTVar1->Type == MONSTER) {
            id = pTVar1[1].super_TSkillBase.Skills[1];
            if (id == (TSkill *)0x0) {
                return;
            }
            pTVar1 = GetCreature((ulong)id);
            if (pTVar1 == (TCreature *)0x0) {
                return;
            }
            if (pTVar1->Type != PLAYER) {
                return;
            }
        }
        (this->super_TNonplayer).State = IDLE;
        TCreature::ToDoYield((TCreature *)this);
    }
    TCreature::CreatureMoveStimulus((TCreature *)this,CreatureID,Type);
    return;
}



// DWARF original prototype: void DamageStimulus(TMonster * this, ulong Attacker, int Damage, int
// param_3)

void __thiscall TMonster::DamageStimulus(TMonster *this,ulong Attacker,int Damage,int param_3)

{
    STATE SVar1;
    
    if ((Attacker != 0) && (Damage != 0)) {
        SVar1 = (this->super_TNonplayer).State;
        if (SVar1 == SLEEPING) {
            (this->super_TNonplayer).State = (uint)(this->Target == 0) * 4 + UNDERATTACK;
            TCreature::ToDoYield((TCreature *)this);
            return;
        }
        if (SVar1 == IDLE) {
            (this->super_TNonplayer).State = UNDERATTACK;
        }
        if (this->Target == 0) {
            (this->super_TNonplayer).State = PANIC;
        }
    }
    return;
}



// WARNING: Type propagation algorithm not settling
// DWARF original prototype: bool MovePossible(TMonster * this, int x, int y, int z, bool Execute,
// bool param_5)

bool __thiscall TMonster::MovePossible(TMonster *this,int x,int y,int z,bool Execute,bool param_5)

{
    bool bVar1;
    bool bVar2;
    TCreature *master_1;
    int iVar3;
    TCreature *pTVar4;
    undefined4 *puVar5;
    ulong uVar6;
    TMonster *pTVar7;
    uint uVar8;
    TCreature *master;
    int *piVar9;
    STATE SVar10;
    uint uVar11;
    TCreature *Obstacle;
    ulong *puVar12;
    Object *local_64;
    int local_60;
    int Try;
    int iStack_54;
    bool Execute_local;
    int local_50;
    Object local_4c [4];
    Object local_3c [4];
    ulong local_2c;
    Object Obj;
    
    iVar3 = (this->super_TNonplayer).super_TCreature.posz;
    if (iVar3 == z) {
        SVar10 = (this->super_TNonplayer).State;
        if (1 < SVar10 - ATTACKING) {
            bVar1 = MonsterhomeInRange();
            if (!bVar1) {
                return false;
            }
            SVar10 = (this->super_TNonplayer).State;
        }
        if (1 < SVar10 - ATTACKING) {
            iVar3 = x - (this->super_TNonplayer).super_TCreature.startx;
            local_50 = -iVar3;
            if (-1 < iVar3) {
                local_50 = iVar3;
            }
            iVar3 = y - (this->super_TNonplayer).super_TCreature.starty;
            iStack_54 = -iVar3;
            if (-1 < iVar3) {
                iStack_54 = iVar3;
            }
            piVar9 = &stack0xffffffac;
            if (iStack_54 <= local_50) {
                piVar9 = &local_50;
            }
            if ((this->super_TNonplayer).super_TCreature.Radius < *piVar9) {
                return false;
            }
        }
        if (-1 < (this->super_TNonplayer).super_TCreature.super_TSkillBase.Skills[4]->Act) {
            bVar1 = IsProtectionZone();
            if (bVar1) {
                return false;
            }
            bVar1 = IsHouse(x,y,z);
            if (bVar1) {
                return false;
            }
            if (((((Execute) && (this->Master != 0)) &&
                 (SVar10 = (this->super_TNonplayer).State, SVar10 != ATTACKING)) &&
                ((SVar10 != PANIC &&
                 (pTVar4 = GetCreature(this->Master), pTVar4 != (TCreature *)0x0)))) &&
               (pTVar4->posz == (this->super_TNonplayer).super_TCreature.posz)) {
                uVar11 = pTVar4->posx - (this->super_TNonplayer).super_TCreature.posx;
                if (0x7fffffff < uVar11) {
                    uVar11 = -uVar11;
                }
                uVar8 = pTVar4->posy - (this->super_TNonplayer).super_TCreature.posy;
                if (0x7fffffff < uVar8) {
                    uVar8 = -uVar8;
                }
                if (1 < (int)(uVar11 + uVar8)) {
                    uVar11 = pTVar4->posx - x;
                    if (0x7fffffff < uVar11) {
                        uVar11 = -uVar11;
                    }
                    uVar8 = pTVar4->posy - y;
                    if (0x7fffffff < uVar8) {
                        uVar8 = -uVar8;
                    }
                    if ((int)(uVar11 + uVar8) < 2) {
                        return false;
                    }
                }
            }
            local_60 = 0;
LAB_080bb1d4:
            local_60 = local_60 + 1;
            if (local_60 < 0x65) {
                GetFirstObject();
                bVar1 = false;
                local_3c[0].ObjectID = ::NONE.ObjectID;
                if (local_2c != ::NONE.ObjectID) {
                    Object::getObjectType(local_4c);
                    bVar2 = ObjectType::getFlag((ObjectType *)local_4c,BANK);
                    if (bVar2) goto LAB_080bb216;
                }
                bVar1 = true;
LAB_080bb216:
                if (bVar1) {
                    return false;
                }
                if (local_2c == ::NONE.ObjectID) {
                    return true;
                }
                do {
                    local_64 = local_4c;
                    puVar12 = &local_2c;
                    local_4c[0].ObjectID = ::NONE.ObjectID;
                    local_3c[0].ObjectID = ::NONE.ObjectID;
                    Object::getObjectType(local_64);
                    if (local_4c[0].ObjectID == 99) {
                        if (1 < (this->super_TNonplayer).State - ATTACKING) {
                            return false;
                        }
                        if (this->Target == 0) {
                            return false;
                        }
                        if (RaceData[(this->super_TNonplayer).super_TCreature.Race].KickCreatures ==
                            false) {
                            return false;
                        }
                        local_4c[0].ObjectID = local_2c;
                        pTVar4 = GetCreature(local_64);
                        if (pTVar4 == (TCreature *)0x0) {
                            error("TMonster::MovePossible: Kann Hindernis-Kreatur nicht identifizieren.\n"
                                  ,puVar12);
                            return false;
                        }
                        if (RaceData[pTVar4->Race].Unpushable != false) {
                            return false;
                        }
                        if (pTVar4->Type == NPC) {
                            return false;
                        }
                        if (pTVar4->Type == PLAYER) {
                            if (this->Master != 0) {
                                return false;
                            }
                            bVar1 = CheckRight(pTVar4->ID,IGNORED_BY_MONSTERS);
                            if (bVar1) {
                                return false;
                            }
                        }
                        if (RaceData[(this->super_TNonplayer).super_TCreature.Race].SeeInvisible ==
                            false) {
                            bVar1 = false;
                            if (((pTVar4->Outfit).OutfitID == 0) &&
                               ((pTVar4->Outfit).field_1.ObjectType == 0)) {
                                bVar1 = true;
                            }
                            if (bVar1) {
                                return false;
                            }
                        }
                        if (pTVar4->ID == this->Master) {
                            return false;
                        }
                        if (pTVar4->ID == this->Target) {
                            return false;
                        }
                        if (Execute) goto LAB_080bb399;
                    }
                    else {
                        Object::getObjectType(local_64);
                        bVar1 = ObjectType::getFlag((ObjectType *)local_64,UNPASS);
                        if (bVar1) {
                            Object::getObjectType(local_64);
                            bVar1 = ObjectType::getFlag((ObjectType *)local_64,UNMOVE);
                            if (bVar1) {
                                return false;
                            }
                            if (RaceData[(this->super_TNonplayer).super_TCreature.Race].KickBoxes ==
                                false) {
                                bVar1 = false;
                                if (this->Master != 0) {
                                    pTVar7 = (TMonster *)GetCreature(this->Master);
                                    if ((pTVar7 == (TMonster *)0x0) ||
                                       ((pTVar7->super_TNonplayer).super_TCreature.Type != MONSTER))
                                    {
                                        bVar1 = false;
                                    }
                                    else {
                                        bVar1 = CanKickBoxes(pTVar7);
                                    }
                                }
                            }
                            else {
                                bVar1 = true;
                            }
                            if (bVar1 == false) {
                                return false;
                            }
                            if (!Execute) goto LAB_080bb4af;
LAB_080bb5cf:
                            local_4c[0].ObjectID = local_2c;
                            KickBoxes(this,local_4c);
                            goto LAB_080bb1d4;
                        }
LAB_080bb4af:
                        Object::getObjectType(local_4c);
                        bVar1 = ObjectType::getFlag((ObjectType *)local_4c,AVOID);
                        if (bVar1) {
                            if ((this->super_TNonplayer).State == PANIC) {
                                Object::getObjectType(local_4c);
                                uVar6 = ObjectType::getAttribute
                                                  ((ObjectType *)local_4c,AVOIDDAMAGETYPES);
                                if (uVar6 != 0) goto LAB_080bb357;
                            }
                            iVar3 = (this->super_TNonplayer).super_TCreature.Race;
                            if (RaceData[iVar3].NoBurning != false) {
                                Object::getObjectType(local_4c);
                                uVar6 = ObjectType::getAttribute
                                                  ((ObjectType *)local_4c,AVOIDDAMAGETYPES);
                                if (uVar6 == 4) goto LAB_080bb357;
                                iVar3 = (this->super_TNonplayer).super_TCreature.Race;
                            }
                            if (RaceData[iVar3].NoPoison != false) {
                                Object::getObjectType(local_4c);
                                uVar6 = ObjectType::getAttribute
                                                  ((ObjectType *)local_4c,AVOIDDAMAGETYPES);
                                if (uVar6 == 2) goto LAB_080bb357;
                                iVar3 = (this->super_TNonplayer).super_TCreature.Race;
                            }
                            if (RaceData[iVar3].NoEnergy != false) {
                                Object::getObjectType(local_4c);
                                uVar6 = ObjectType::getAttribute
                                                  ((ObjectType *)local_4c,AVOIDDAMAGETYPES);
                                if (uVar6 == 8) goto LAB_080bb357;
                            }
                            Object::getObjectType(local_4c);
                            bVar1 = ObjectType::getFlag((ObjectType *)local_4c,UNMOVE);
                            if (bVar1) {
                                return false;
                            }
                            if (RaceData[(this->super_TNonplayer).super_TCreature.Race].KickBoxes ==
                                false) {
                                bVar1 = false;
                                if (this->Master != 0) {
                                    pTVar7 = (TMonster *)GetCreature(this->Master);
                                    if ((pTVar7 == (TMonster *)0x0) ||
                                       ((pTVar7->super_TNonplayer).super_TCreature.Type != MONSTER))
                                    {
                                        bVar1 = false;
                                    }
                                    else {
                                        bVar1 = CanKickBoxes(pTVar7);
                                    }
                                }
                            }
                            else {
                                bVar1 = true;
                            }
                            if (bVar1 == false) {
                                return false;
                            }
                            if (Execute) goto LAB_080bb5cf;
                        }
                    }
LAB_080bb357:
                    Object::getNextObject(local_3c);
                    local_2c = local_3c[0].ObjectID;
                    if (local_3c[0].ObjectID == ::NONE.ObjectID) {
                        return true;
                    }
                } while( true );
            }
            error(&DAT_08106140,(this->super_TNonplayer).super_TCreature.Name,x,y,z);
            goto LAB_080bb3b7;
        }
        error("TMonster::MovePossible: Monster %s an [%d,%d,%d] darf sich nicht bewegen.\n",
              (this->super_TNonplayer).super_TCreature.Name,
              (this->super_TNonplayer).super_TCreature.posx,
              (this->super_TNonplayer).super_TCreature.posy,
              (this->super_TNonplayer).super_TCreature.posz);
    }
    else {
                    // try { // try from 080bb0ca to 080bb83f has its CatchHandler @ 080bb855
        error(&DAT_08106080,(this->super_TNonplayer).super_TCreature.posx,
              (this->super_TNonplayer).super_TCreature.posy,iVar3,x,y,z);
    }
    return false;
LAB_080bb399:
    if (pTVar4->Type == PLAYER) {
        this->Target = 0;
        goto LAB_080bb3b7;
    }
    bVar1 = KickCreature(this,pTVar4);
    if (!bVar1) {
LAB_080bb3b7:
        puVar5 = (undefined4 *)__cxa_allocate_exception(4);
        *puVar5 = 0x31;
                    // WARNING: Subroutine does not return
        __cxa_throw(puVar5,&RESULT::typeinfo,0);
    }
    goto LAB_080bb1d4;
}



// DWARF original prototype: bool IsPeaceful(TMonster * this)

bool __thiscall TMonster::IsPeaceful(TMonster *this)

{
    return this->Master != 0 && this->Master < 0x40000000;
}



// DWARF original prototype: bool CanKickBoxes(TMonster * this)

bool __thiscall TMonster::CanKickBoxes(TMonster *this)

{
    bool bVar1;
    TCreature *master;
    TMonster *this_00;
    
    if (RaceData[(this->super_TNonplayer).super_TCreature.Race].KickBoxes == false) {
        bVar1 = false;
        if (this->Master != 0) {
            this_00 = (TMonster *)GetCreature(this->Master);
            if ((this_00 == (TMonster *)0x0) ||
               ((this_00->super_TNonplayer).super_TCreature.Type != MONSTER)) {
                bVar1 = false;
            }
            else {
                bVar1 = CanKickBoxes(this_00);
            }
        }
    }
    else {
        bVar1 = true;
    }
    return bVar1;
}



// DWARF original prototype: void KickBoxes(TMonster * this, Object * Obj)

void __thiscall TMonster::KickBoxes(TMonster *this,Object *Obj)

{
    bool bVar1;
    bool bVar2;
    int iVar3;
    ulong CreatureID;
    RESULT r;
    Object *Obj_00;
    Object *Ignore;
    int local_58;
    int x;
    int y;
    int z;
    Object local_3c [4];
    Object local_2c [7];
    
    bVar1 = Object::exists(Obj);
    if (!bVar1) {
        error(&DAT_08106200);
        return;
    }
    local_2c[0] = (Object)Obj->ObjectID;
    GetObjectCoordinates(local_2c,&local_58,&x,&y);
    iVar3 = (this->super_TNonplayer).super_TCreature.posy;
    if (x + -1 != iVar3) {
        bVar1 = false;
                    // try { // try from 080bb98b to 080bbc66 has its CatchHandler @ 080bbc80
        bVar2 = CoordinateFlag();
        if (bVar2) {
            bVar1 = CoordinateFlag();
            bVar1 = !bVar1;
        }
        if (bVar1) {
            local_2c[0].ObjectID = ::NONE.ObjectID;
            GetMapContainer((int)local_3c,local_58,x + -1);
            Ignore = local_2c;
            Obj_00 = (Object *)&z;
            z = Obj->ObjectID;
            CreatureID = (this->super_TNonplayer).super_TCreature.ID;
            goto LAB_080bbb13;
        }
        iVar3 = (this->super_TNonplayer).super_TCreature.posy;
    }
    if (x + 1 == iVar3) {
LAB_080bb9ec:
        iVar3 = (this->super_TNonplayer).super_TCreature.posx;
        if (local_58 + -1 != iVar3) {
            bVar1 = false;
            bVar2 = CoordinateFlag();
            if (bVar2) {
                bVar1 = CoordinateFlag();
                bVar1 = !bVar1;
            }
            if (bVar1) {
                z = ::NONE.ObjectID;
                local_58 = local_58 + -1;
                goto LAB_080bbad4;
            }
            iVar3 = (this->super_TNonplayer).super_TCreature.posx;
        }
        if (local_58 + 1 == iVar3) {
LAB_080bba7c:
            z = Obj->ObjectID;
            GraphicalEffect((Object *)&z,4);
            z = Obj->ObjectID;
            Delete((Object *)&z,-1);
            return;
        }
        bVar1 = false;
        bVar2 = CoordinateFlag();
        if (bVar2) {
            bVar1 = CoordinateFlag();
            bVar1 = !bVar1;
        }
        if (!bVar1) goto LAB_080bba7c;
        z = ::NONE.ObjectID;
        local_58 = local_58 + 1;
    }
    else {
        bVar1 = false;
        bVar2 = CoordinateFlag();
        if (bVar2) {
            bVar1 = CoordinateFlag();
            bVar1 = !bVar1;
        }
        if (!bVar1) goto LAB_080bb9ec;
        z = ::NONE.ObjectID;
        x = x + 1;
    }
LAB_080bbad4:
    Ignore = (Object *)&z;
    ::NONE.ObjectID = z;
    GetMapContainer((int)local_3c,local_58,x);
    local_2c[0] = (Object)Obj->ObjectID;
    Obj_00 = local_2c;
    CreatureID = (this->super_TNonplayer).super_TCreature.ID;
LAB_080bbb13:
    Move(CreatureID,Obj_00,local_3c,-1,false,Ignore);
    return;
}



// DWARF original prototype: bool KickCreature(TMonster * this, TCreature * Obstacle)

bool __thiscall TMonster::KickCreature(TMonster *this,TCreature *Obstacle)

{
    int iVar1;
    TSkill *pTVar2;
    bool bVar3;
    RESULT r;
    int iVar4;
    int iVar5;
    int iVar6;
    Object *Obj_00;
    int iVar7;
    int x;
    char *Text;
    Object *Ignore;
    int z;
    int y;
    ushort HelpY;
    ushort HelpX;
    Object local_4c;
    Object Obj;
    Object local_3c [4];
    Object local_2c [7];
    
    if (Obstacle == (TCreature *)0x0) {
        Text = &DAT_08106360;
LAB_080bbd4d:
        error(Text);
        return false;
    }
    if (Obstacle->Type != MONSTER) {
        Text = "TMonster::KickCreature: Zu verschiebende Kreatur ist kein Monster.\n";
        goto LAB_080bbd4d;
    }
    print();
    iVar6 = Obstacle->posy;
    iVar5 = Obstacle->posx;
    iVar1 = Obstacle->posz;
    iVar7 = iVar6 + -1;
    iVar4 = (this->super_TNonplayer).super_TCreature.posy;
    if (iVar7 != iVar4) {
                    // try { // try from 080bbde8 to 080bc0cf has its CatchHandler @ 080bc0f3
        iVar4 = (*Obstacle->_vptr_TCreature[3])(Obstacle,iVar5,iVar7,iVar1,1,0);
        if (((char)iVar4 != '\0') && (bVar3 = CoordinateFlag(), !bVar3)) {
            local_2c[0].ObjectID = ::NONE.ObjectID;
            GetMapContainer((int)local_3c,iVar5,iVar7);
            local_4c.ObjectID = (Obstacle->CrObject).ObjectID;
            Obj_00 = &local_4c;
            Ignore = local_2c;
            goto LAB_080bbfb2;
        }
        iVar4 = (this->super_TNonplayer).super_TCreature.posy;
    }
    iVar7 = iVar6 + 1;
    if (((iVar7 != iVar4) &&
        (iVar4 = (*Obstacle->_vptr_TCreature[3])(Obstacle,iVar5,iVar7,iVar1,1,0),
        (char)iVar4 != '\0')) && (bVar3 = CoordinateFlag(), !bVar3)) {
        local_4c.ObjectID = ::NONE.ObjectID;
        GetMapContainer((int)local_3c,iVar5,iVar7);
        local_2c[0].ObjectID = (Obstacle->CrObject).ObjectID;
        Obj_00 = local_2c;
        Ignore = &local_4c;
        goto LAB_080bbfb2;
    }
    iVar4 = iVar5 + -1;
    iVar7 = (this->super_TNonplayer).super_TCreature.posx;
    if (iVar4 == iVar7) {
LAB_080bbe7e:
        iVar4 = iVar5 + 1;
        if (((iVar4 == iVar7) ||
            (iVar5 = (*Obstacle->_vptr_TCreature[3])(Obstacle,iVar4,iVar6,iVar1,1,0),
            (char)iVar5 == '\0')) || (bVar3 = CoordinateFlag(), bVar3)) {
            print();
            local_4c.ObjectID = (Obstacle->CrObject).ObjectID;
            GraphicalEffect(&local_4c,4);
            iVar6 = TSkill::Get((Obstacle->super_TSkillBase).Skills[2]);
            TCombat::AddDamageToCombatList
                      (&Obstacle->Combat,(this->super_TNonplayer).super_TCreature.ID,(ushort)iVar6);
            pTVar2 = (Obstacle->super_TSkillBase).Skills[2];
            (*pTVar2->_vptr_TSkill[2])(pTVar2,0);
            (*Obstacle->_vptr_TCreature[2])(Obstacle);
            return false;
        }
    }
    else {
        iVar7 = (*Obstacle->_vptr_TCreature[3])(Obstacle,iVar4,iVar6,iVar1,1,0);
        if (((char)iVar7 == '\0') || (bVar3 = CoordinateFlag(), bVar3)) {
            iVar7 = (this->super_TNonplayer).super_TCreature.posx;
            goto LAB_080bbe7e;
        }
    }
    local_4c.ObjectID = ::NONE.ObjectID;
    GetMapContainer((int)local_3c,iVar4,iVar6);
    local_2c[0].ObjectID = (Obstacle->CrObject).ObjectID;
    Ignore = &local_4c;
    Obj_00 = local_2c;
LAB_080bbfb2:
    Move((this->super_TNonplayer).super_TCreature.ID,Obj_00,local_3c,-1,false,Ignore);
    return true;
}



// DWARF original prototype: void Convince(TMonster * this, TCreature * newMaster)

void __thiscall TMonster::Convince(TMonster *this,TCreature *newMaster)

{
    TCreature *oldMaster;
    TCreature *pTVar1;
    
    if (this->Home != 0) {
        NotifyMonsterhomeOfDeath(this->Home);
    }
    this->Home = 0;
    if (this->Master != 0) {
        pTVar1 = GetCreature(this->Master);
        if (pTVar1 != (TCreature *)0x0) {
            pTVar1->SummonedCreatures = pTVar1->SummonedCreatures + -1;
        }
    }
    this->Master = newMaster->ID;
    newMaster->SummonedCreatures = newMaster->SummonedCreatures + 1;
    TCreature::ToDoClear((TCreature *)this);
    TCreature::ToDoWait((TCreature *)this,100);
    TCreature::ToDoStart((TCreature *)this);
    return;
}



// DWARF original prototype: void SetTarget(TMonster * this, TCreature * NewTarget)

void __thiscall TMonster::SetTarget(TMonster *this,TCreature *NewTarget)

{
    if (NewTarget == (TCreature *)0x0) {
        error("TMonster::SetTarget: NewTarget ist NULL.\n");
        return;
    }
    if (this->Master != 0) {
        return;
    }
    TCreature::Rotate((TCreature *)this,NewTarget);
    this->Target = NewTarget->ID;
    TCreature::ToDoYield((TCreature *)this);
    return;
}



// WARNING: Variable defined which should be unmapped: ShowEffect_local

TCreature * CreateMonster(int Race,int x,int y,int z,int Home,ulong Father,bool ShowEffect)

{
    bool bVar1;
    TMonster *this;
    char *Text;
    bool ShowEffect_local;
    
    bVar1 = ShowEffect;
    if (Race - 1U < 0x1ff) {
        if (RaceData[Race].Name[0] != '\0') {
            SearchFreeField(&x,&y,&z,2,0,false);
            this = (TMonster *)operator_new(0x32c);
                    // try { // try from 080bc3ec to 080bc3f0 has its CatchHandler @ 080bc431
            TMonster::TMonster(this);
            if (!bVar1) {
                return (TCreature *)this;
            }
            GraphicalEffect();
            return (TCreature *)this;
        }
        Text = &DAT_08104f00;
    }
    else {
        Text = &DAT_08104f40;
    }
    error(Text,Race);
    return (TCreature *)0x0;
}



void ConvinceMonster(TCreature *Master,TCreature *Slave)

{
    if (Master == (TCreature *)0x0) {
        Master = (TCreature *)s_ConvinceMonster__Master_existier_08106520;
    }
    else if (Slave == (TCreature *)0x0) {
        Master = (TCreature *)s_ConvinceMonster__Slave_existiert_081064e0;
    }
    else {
        if (Slave->Type == MONSTER) {
            TMonster::Convince((TMonster *)Slave,Master);
            return;
        }
        Master = (TCreature *)s_ConvinceMonster__Slave_ist_kein_M_081064a0;
    }
    error((char *)Master);
    return;
}



void ChallengeMonster(TCreature *Challenger,TCreature *Monster)

{
    if (Challenger == (TCreature *)0x0) {
        Challenger = (TCreature *)s_ChallengeMonster__Herausforderer_081065e0;
    }
    else if (Monster == (TCreature *)0x0) {
        Challenger = (TCreature *)s_ChallengeMonster__Monster_existi_081065a0;
    }
    else {
        if (Monster->Type == MONSTER) {
            if (Monster[1].super_TSkillBase.Skills[1] != (TSkill *)0x0) {
                return;
            }
            TCreature::Rotate(Monster,Challenger);
            Monster[1].super_TSkillBase.Skills[2] = (TSkill *)Challenger->ID;
            TCreature::ToDoYield(Monster);
            return;
        }
        Challenger = (TCreature *)s_ChallengeMonster__Monster_ist_ke_08106560;
    }
    error((char *)Challenger);
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void InitNPCs(void)

{
    char *__s;
    dirent *DirEntry;
    DIR *__dirp;
    dirent *pdVar1;
    size_t sVar2;
    TNPC *this;
    undefined4 *puVar3;
    int iVar4;
    char *s;
    char *pcVar5;
    char *pcVar6;
    bool bVar7;
    DIR *WorkDir;
    char FileName [4096];
    
    __dirp = opendir(NPCPATH);
    if (__dirp == (DIR *)0x0) {
                    // try { // try from 080bc5fd to 080bc62b has its CatchHandler @ 080bc649
        error("InitNPCs: Unterverzeichnis %s nicht gefunden\n",NPCPATH);
        puVar3 = (undefined4 *)__cxa_allocate_exception(4);
        *puVar3 = "Cannot init NPCs";
                    // WARNING: Subroutine does not return
        __cxa_throw(puVar3,char_const*::typeinfo,0);
    }
    do {
        do {
            pdVar1 = readdir(__dirp);
            if (pdVar1 == (dirent *)0x0) {
                closedir(__dirp);
                return;
            }
            __s = pdVar1->d_name;
            sVar2 = strlen(__s);
            bVar7 = sVar2 == 4;
        } while (sVar2 < 5);
        iVar4 = 4;
        pcVar5 = __s + (sVar2 - 4);
        pcVar6 = ".npc";
        do {
            if (iVar4 == 0) break;
            iVar4 = iVar4 + -1;
            bVar7 = *pcVar5 == *pcVar6;
            pcVar5 = pcVar5 + 1;
            pcVar6 = pcVar6 + 1;
        } while (bVar7);
        if (bVar7) {
            sprintf((char *)&WorkDir,"%s/%s",NPCPATH,__s);
                    // try { // try from 080bc5c0 to 080bc5c4 has its CatchHandler @ 080bc649
            this = (TNPC *)operator_new(900);
                    // try { // try from 080bc5ce to 080bc5d2 has its CatchHandler @ 080bc62c
            TNPC::TNPC(this,(char *)&WorkDir);
        }
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void InitNonplayer(void)

{
    store<TNode,256> *psVar1;
    list<> *plVar2;
    
                    // try { // try from 080bc67e to 080bc69e has its CatchHandler @ 080bc710
    print();
    FirstFreeNonplayer = 0;
    CurrentNonplayer = 0;
    psVar1 = (store<TNode,256> *)operator_new(8);
                    // try { // try from 080bc6a8 to 080bc6ac has its CatchHandler @ 080bc6e0
    plVar2 = (list<> *)operator_new(8);
    plVar2->firstNode = (listnode<> *)0x0;
    plVar2->lastNode = (listnode<> *)0x0;
    psVar1->Units = plVar2;
    psVar1->firstFreeItem = (storeitem<TNode> *)0x0;
    NodeTable = psVar1;
                    // try { // try from 080bc6c9 to 080bc6d2 has its CatchHandler @ 080bc710
    InitNPCs();
    LoadMonsterhomes();
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ExitNonplayer(void)

{
    TNonplayer *pTVar1;
    list<> *this;
    listnode<> *__filename;
    store<TNode,256> *psVar2;
    TNonplayer **ppTVar3;
    
    if (0 < FirstFreeNonplayer) {
        do {
            ppTVar3 = vector<>::operator()(&NonplayerList,0);
            pTVar1 = *ppTVar3;
            if (pTVar1 != (TNonplayer *)0x0) {
                (*(pTVar1->super_TCreature)._vptr_TCreature[1])(pTVar1);
            }
        } while (0 < FirstFreeNonplayer);
    }
    psVar2 = NodeTable;
    if (NodeTable != (store<TNode,256> *)0x0) {
        this = NodeTable->Units;
        if (this != (list<> *)0x0) {
            __filename = this->firstNode;
            while (__filename != (listnode<> *)0x0) {
                list<>::remove(this,(char *)__filename);
                __filename = this->firstNode;
            }
            operator_delete(this);
        }
        operator_delete(psVar2);
    }
    return;
}



void __tcf_0(void *param_1)

{
    if (NonplayerList.entry == (TNonplayer **)0x0) {
        return;
    }
    operator_delete__(NonplayerList.entry);
    return;
}



void __tcf_1(void *param_1)

{
    if (Monsterhome.entry == (TMonsterhome *)0x0) {
        return;
    }
    operator_delete__(Monsterhome.entry);
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__I_NonplayerList(void)

{
    __static_initialization_and_destruction_0(1,0xffff);
    return;
}



// DWARF original prototype: ulong GetMaster(TMonster * this)

ulong __thiscall TMonster::GetMaster(TMonster *this)

{
    return this->Master;
}

void __static_initialization_and_destruction_0(int __initialize_p,int __priority)

{
    if ((__priority == 0xffff) && (__initialize_p == 1)) {
        NONE.ObjectID = 0;
    }
    return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__I__ZN9TShortwayC2EP9TCreatureii(void)

{
    __static_initialization_and_destruction_0(1,0xffff);
    return;
}

void __static_initialization_and_destruction_0(int __initialize_p,int __priority)

{
    if ((__priority == 0xffff) && (__initialize_p == 1)) {
        NONE.ObjectID = 0;
    }
    return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__I__ZN7TCombatC2Ev(void)

{
    __static_initialization_and_destruction_0(1,0xffff);
    return;
}



void __static_initialization_and_destruction_0(int __initialize_p,int __priority)

{
    if ((__priority == 0xffff) && (__initialize_p == 1)) {
        NONE.ObjectID = 0;
    }
    return;
}


// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__I__Z14GetSkillByNamePc(void)

{
    __static_initialization_and_destruction_0(1,0xffff);
    return;
}

double __cmath_power<double>(double __x,uint __n)

{
    double dVar1;
    uint uVar2;
    double __y;
    
    dVar1 = 1.0;
    if ((__n & 1) != 0) {
        dVar1 = __x;
    }
    for (uVar2 = __n >> 1; uVar2 != 0; uVar2 = uVar2 >> 1) {
        __x = __x * __x;
        if ((uVar2 & 1) != 0) {
            dVar1 = dVar1 * __x;
        }
    }
    return dVar1;
}



void __static_initialization_and_destruction_0(int __initialize_p,int __priority)

{
    TConnection *pTVar1;
    int local_14;
    
    if (__priority == 0xffff) {
        if (__initialize_p == 1) {
            NONE.ObjectID = 0;
            local_14 = 1099;
            pTVar1 = Connections;
            do {
                    // try { // try from 080cac40 to 080cac44 has its CatchHandler @ 080cac8c
                TXTEASymmetricKey::TXTEASymmetricKey(&pTVar1->SymmetricKey);
                pTVar1->State = CONNECTION_FREE;
                pTVar1 = pTVar1 + 1;
                local_14 = local_14 + -1;
            } while (local_14 != -1);
            __cxa_atexit(__tcf_0,0,&__dso_handle);
        }
        if (__initialize_p == 1) {
            Semaphore::Semaphore(&ConnectionMutex,1);
            __cxa_atexit(__tcf_1,0,&__dso_handle);
        }
    }
    return;
}



// DWARF original prototype: void TConnection(TConnection * this)

void __thiscall TConnection::TConnection(TConnection *this)

{
    TXTEASymmetricKey::TXTEASymmetricKey(&this->SymmetricKey);
    this->State = CONNECTION_FREE;
    return;
}



// DWARF original prototype: void TConnection(TConnection * this)

void __thiscall TConnection::TConnection(TConnection *this)

{
    TXTEASymmetricKey::TXTEASymmetricKey(&this->SymmetricKey);
    this->State = CONNECTION_FREE;
    return;
}



// DWARF original prototype: void Process(TConnection * this)

void __thiscall TConnection::Process(TConnection *this)

{
    ulong uVar1;
    bool bVar2;
    CONNECTIONSTATE CVar3;
    int Time;
    int iVar4;
    TPlayer *this_00;
    TConnection *pTVar5;
    int i;
    
    CVar3 = this->State;
    if (CVar3 == CONNECTION_LOGIN) {
        bVar2 = GameRunning();
        if ((!bVar2) || (this->ConnectionIsOk == false)) {
            if (this->State < CONNECTION_CONNECTED) {
                error(&DAT_08108420,this->State);
            }
            iVar4 = 0x95;
            pTVar5 = this;
            do {
                if (pTVar5->KnownCreatureTable[0].State != KNOWNCREATURE_FREE) {
                    UnchainKnownCreature(this,pTVar5->KnownCreatureTable[0].CreatureID);
                }
                pTVar5->KnownCreatureTable[0].Connection = this;
                pTVar5->KnownCreatureTable[0].State = KNOWNCREATURE_FREE;
                pTVar5->KnownCreatureTable[0].CreatureID = 0;
                pTVar5 = (TConnection *)(pTVar5->InData + 0x10);
                iVar4 = iVar4 + -1;
            } while (-1 < iVar4);
            this->ConnectionIsOk = false;
            this->State = CONNECTION_DISCONNECTED;
            kill(this->PID,1);
        }
        CVar3 = this->State;
    }
    if (1 < CVar3 - CONNECTION_GAME) goto LAB_080cae41;
    iVar4 = RoundNr - this->TimeStamp;
    if (iVar4 == 0x1e) {
        SendPing(this);
    }
    if (iVar4 == 0x3c) {
        SendPing(this);
    }
    if ((RoundNr - 900 == this->TimeStampAction) &&
       (bVar2 = CheckRight(this->CharacterID,NO_LOGOUT_BLOCK), !bVar2)) {
        SendMessage(this,0x12,
                    "You have been idle for %d minutes. You will be disconnected in one minute if you are still idle then."
                    ,0xf);
    }
    bVar2 = GameRunning();
    if ((bVar2) &&
       ((RoundNr - this->TimeStampAction < 0x3c0 ||
        (bVar2 = CheckRight(this->CharacterID,NO_LOGOUT_BLOCK), bVar2)))) {
        if ((this->ConnectionIsOk == false) || (0x59 < iVar4)) {
            if (2 < this->State - CONNECTION_GAME) {
                error(&DAT_08108460,this->State);
            }
            this->State = CONNECTION_LOGOUT;
            this_00 = (TPlayer *)0x0;
            if (this->CharacterID != 0) {
                this_00 = ::GetPlayer(this->CharacterID);
            }
            if (this_00 != (TPlayer *)0x0) {
                TPlayer::ClearConnection(this_00);
                bVar2 = false;
                goto LAB_080cae11;
            }
            goto LAB_080cae21;
        }
    }
    else {
        if (2 < this->State - CONNECTION_GAME) {
            error(&DAT_08108460,this->State);
        }
        this_00 = (TPlayer *)0x0;
        this->State = CONNECTION_LOGOUT;
        if (this->CharacterID != 0) {
            this_00 = ::GetPlayer(this->CharacterID);
        }
        if (this_00 != (TPlayer *)0x0) {
            TPlayer::ClearConnection(this_00);
            bVar2 = true;
LAB_080cae11:
            TCreature::StartLogout(&this_00->super_TCreature,false,bVar2);
        }
LAB_080cae21:
        uVar1 = RoundNr;
        this->CharacterID = 0;
        this->TimeStamp = uVar1;
        this->ClosingIsDelayed = false;
    }
    CVar3 = this->State;
LAB_080cae41:
    if ((CVar3 == CONNECTION_LOGOUT) &&
       (((bVar2 = GameRunning(), !bVar2 || (this->ConnectionIsOk == false)) ||
        (this->TimeStamp <= RoundNr)))) {
        if (this->State < CONNECTION_CONNECTED) {
            error(&DAT_08108420,this->State);
        }
        iVar4 = 0x95;
        pTVar5 = this;
        do {
            if (pTVar5->KnownCreatureTable[0].State != KNOWNCREATURE_FREE) {
                UnchainKnownCreature(this,pTVar5->KnownCreatureTable[0].CreatureID);
            }
            pTVar5->KnownCreatureTable[0].Connection = this;
            pTVar5->KnownCreatureTable[0].State = KNOWNCREATURE_FREE;
            pTVar5->KnownCreatureTable[0].CreatureID = 0;
            pTVar5 = (TConnection *)(pTVar5->InData + 0x10);
            iVar4 = iVar4 + -1;
        } while (-1 < iVar4);
        this->ConnectionIsOk = false;
        this->State = CONNECTION_DISCONNECTED;
        kill(this->PID,1);
    }
    return;
}



// DWARF original prototype: void ResetTimer(TConnection * this, int Command)

void __thiscall TConnection::ResetTimer(TConnection *this,int Command)

{
    if ((((this->State - CONNECTION_GAME < 2) && (this->TimeStamp = RoundNr, Command != 0x69)) &&
        (Command != 0xbe)) && (((Command != 0xc9 && (Command != 0xca)) && (Command != 0x1e)))) {
        this->TimeStampAction = RoundNr;
    }
    return;
}



// DWARF original prototype: void EmergencyPing(TConnection * this)

void __thiscall TConnection::EmergencyPing(TConnection *this)

{
    if (this->State - CONNECTION_GAME < 2) {
        if (RoundNr - this->TimeStamp < 0x50) {
            this->TimeStamp = RoundNr - 100;
        }
        SendPing(this);
        return;
    }
    return;
}



// DWARF original prototype: pid_t GetPID(TConnection * this)

pid_t __thiscall TConnection::GetPID(TConnection *this)

{
    pid_t pVar1;
    
    if (this->State == CONNECTION_FREE) {
        error("TConnection::GetPID: Verbindung ist nicht zugewiesen.\n");
        pVar1 = 0;
    }
    else {
        pVar1 = this->PID;
    }
    return pVar1;
}



// DWARF original prototype: int GetSocket(TConnection * this)

int __thiscall TConnection::GetSocket(TConnection *this)

{
    int iVar1;
    
    if (this->State < CONNECTION_CONNECTED) {
        error("TConnection::GetSocket: Verbindung ist nicht angeschlossen.\n");
        iVar1 = -1;
    }
    else {
        iVar1 = this->Socket;
    }
    return iVar1;
}



// DWARF original prototype: char * GetIPAddress(TConnection * this)

char * __thiscall TConnection::GetIPAddress(TConnection *this)

{
    char *pcVar1;
    
    if (this->State < CONNECTION_CONNECTED) {
        error("TConnection::GetIPAddress: Verbindung ist nicht angeschlossen.\n");
        pcVar1 = "Unknown";
    }
    else {
        pcVar1 = this->IPAddress;
    }
    return pcVar1;
}



// DWARF original prototype: void Free(TConnection * this)

void __thiscall TConnection::Free(TConnection *this)

{
    this->State = CONNECTION_FREE;
    return;
}



// DWARF original prototype: void Assign(TConnection * this)

void __thiscall TConnection::Assign(TConnection *this)

{
    __pid_t _Var1;
    
    if (this->State != CONNECTION_FREE) {
        error("TConnection::Assign: Verbindung ist nicht frei.\n");
    }
    this->State = CONNECTION_ASSIGNED;
    _Var1 = getpid();
    this->PID = _Var1;
    return;
}



// DWARF original prototype: void Connect(TConnection * this, int _Socket)

void __thiscall TConnection::Connect(TConnection *this,int _Socket)

{
    char *__src;
    uint uVar1;
    socklen_t local_30;
    socklen_t addrlen;
    sockaddr_in inaddr;
    sockaddr peer;
    
    if (this->State != CONNECTION_ASSIGNED) {
        error("TConnection::Connect: Verbindung ist keinem Thread zugewiesen .\n");
    }
    this->State = CONNECTION_CONNECTED;
    this->ConnectionIsOk = true;
    this->ClosingIsDelayed = true;
    this->Socket = _Socket;
    local_30 = 0x10;
    getpeername(this->Socket,(sockaddr *)(inaddr.sin_zero + 4),&local_30);
    addrlen._0_1_ = inaddr.sin_zero[4];
    addrlen._1_1_ = inaddr.sin_zero[5];
    addrlen._2_1_ = inaddr.sin_zero[6];
    addrlen._3_1_ = inaddr.sin_zero[7];
    __src = inet_ntoa((in_addr)peer._0_4_);
    strcpy(this->IPAddress,__src);
    uVar1 = rand();
    this->RandomSeed = uVar1;
    return;
}



// DWARF original prototype: void Login(TConnection * this)

void __thiscall TConnection::Login(TConnection *this)

{
    if (this->State != CONNECTION_CONNECTED) {
        error(&DAT_08108680,this->State);
    }
    this->State = CONNECTION_LOGIN;
    return;
}



// WARNING: Removing unreachable block (ram,0x080cb3a6)
// WARNING: Removing unreachable block (ram,0x080cb640)
// DWARF original prototype: bool JoinGame(TConnection * this, TReadBuffer * Buffer)

bool __thiscall TConnection::JoinGame(TConnection *this,TReadBuffer *Buffer)

{
    uint uVar1;
    ulong uVar2;
    TPlayer *this_00;
    TPlayer *pl;
    TConnection *pTVar3;
    int i;
    int iVar4;
    char *Text;
    TPlayer *local_14;
    
    if (this->State != CONNECTION_LOGIN) {
        error(&DAT_081086c0,this->State);
    }
    iVar4 = 0x95;
    pTVar3 = this;
    do {
        pTVar3->KnownCreatureTable[0].Connection = this;
        pTVar3->KnownCreatureTable[0].State = KNOWNCREATURE_FREE;
        pTVar3->KnownCreatureTable[0].CreatureID = 0;
        pTVar3 = (TConnection *)(pTVar3->InData + 0x10);
        iVar4 = iVar4 + -1;
    } while (-1 < iVar4);
                    // try { // try from 080cb3d8 to 080cb3ee has its CatchHandler @ 080cb657
    uVar1 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
    this->TerminalType = uVar1 & 0xffff;
    uVar1 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
    iVar4 = this->TerminalType;
    this->TerminalVersion = uVar1 & 0xffff;
    if ((iVar4 < 0) || ((1 < iVar4 && (iVar4 != 2)))) {
        error("TConnection::JoinGame: Unbekannter Terminal-Typ %d.\n",iVar4);
    }
    else {
        this->TerminalOffsetX = 8;
        this->TerminalOffsetY = 6;
        this->TerminalWidth = 0x12;
        this->TerminalHeight = 0xe;
                    // try { // try from 080cb45a to 080cb45c has its CatchHandler @ 080cb687
        uVar2 = (*(Buffer->super_TReadStream)._vptr_TReadStream[3])(Buffer);
        this->CharacterID = uVar2;
        this_00 = ::GetPlayer(uVar2);
        if (this_00 == (TPlayer *)0x0) {
            this_00 = (TPlayer *)operator_new(0xde8);
                    // try { // try from 080cb60d to 080cb611 has its CatchHandler @ 080cb6a6
            TPlayer::TPlayer(this_00,this,this->CharacterID);
            if (this_00 == (TPlayer *)0x0) {
                return false;
            }
            if (this_00->ConstructError == NOERROR) {
LAB_080cb54c:
                strcpy(this->Name,(this_00->super_TCreature).Name);
                this->TimeStamp = RoundNr;
                this->TimeStampAction = RoundNr;
                return true;
            }
            (*(this_00->super_TCreature)._vptr_TCreature[1])(this_00);
        }
        else {
            if ((this_00->super_TCreature).IsDead == false) {
                if (((this_00->super_TCreature).LoggingOut == false) ||
                   (iVar4 = TCreature::LogoutPossible(&this_00->super_TCreature), iVar4 != 0)) {
                    pTVar3 = (this_00->super_TCreature).Connection;
                    TPlayer::ClearConnection(this_00);
                    if (pTVar3 != (TConnection *)0x0) {
                        pTVar3->CharacterID = 0;
                        if (2 < pTVar3->State - CONNECTION_GAME) {
                            error(&DAT_08108460,pTVar3->State);
                        }
                        pTVar3->State = CONNECTION_LOGOUT;
                        local_14 = (TPlayer *)0x0;
                        if (pTVar3->CharacterID != 0) {
                            local_14 = ::GetPlayer(pTVar3->CharacterID);
                        }
                        if (local_14 != (TPlayer *)0x0) {
                            TPlayer::ClearConnection(local_14);
                            TCreature::StartLogout(&local_14->super_TCreature,false,true);
                        }
                        uVar2 = RoundNr;
                        pTVar3->CharacterID = 0;
                        pTVar3->TimeStamp = uVar2;
                        pTVar3->ClosingIsDelayed = false;
                    }
                    DecrementIsOnlineOrder(this->CharacterID);
                    TPlayer::TakeOver(this_00,this);
                    goto LAB_080cb54c;
                }
                Text = "Spieler %s loggt gerade aus - Einloggen gescheitert.\n";
            }
            else {
                Text = "Spieler %s ist gerade am Sterben - Einloggen gescheitert.\n";
            }
            Log("game",Text,(this_00->super_TCreature).Name);
            DecreasePlayerPoolSlotSticky(this->CharacterID);
        }
    }
    return false;
}



// DWARF original prototype: void EnterGame(TConnection * this)

void __thiscall TConnection::EnterGame(TConnection *this)

{
    if (this->State != CONNECTION_LOGIN) {
        error(&DAT_08108800,this->State);
    }
    this->State = CONNECTION_GAME;
    return;
}



// DWARF original prototype: void Die(TConnection * this)

void __thiscall TConnection::Die(TConnection *this)

{
    if (this->State == CONNECTION_GAME) {
        this->State = CONNECTION_DEAD;
    }
    return;
}



// WARNING: Variable defined which should be unmapped: StopFight_local
// DWARF original prototype: void Logout(TConnection * this, int Delay, bool StopFight)

void __thiscall TConnection::Logout(TConnection *this,int Delay,bool StopFight)

{
    ulong uVar1;
    TPlayer *this_00;
    bool StopFight_local;
    
    if (2 < this->State - CONNECTION_GAME) {
        error(&DAT_08108460,this->State);
    }
    this_00 = (TPlayer *)0x0;
    this->State = CONNECTION_LOGOUT;
    if (this->CharacterID != 0) {
        this_00 = ::GetPlayer(this->CharacterID);
    }
    if (this_00 != (TPlayer *)0x0) {
        TPlayer::ClearConnection(this_00);
        TCreature::StartLogout(&this_00->super_TCreature,false,StopFight);
    }
    uVar1 = RoundNr;
    this->CharacterID = 0;
    this->TimeStamp = Delay + uVar1;
    this->ClosingIsDelayed = false;
    return;
}



// DWARF original prototype: void Close(TConnection * this, bool Delay)

void __thiscall TConnection::Close(TConnection *this,bool Delay)

{
    CONNECTIONSTATE CVar1;
    
    CVar1 = this->State;
    if (CVar1 < CONNECTION_CONNECTED) {
        error(&DAT_08108420,CVar1);
        CVar1 = this->State;
    }
    this->ConnectionIsOk = false;
    this->ClosingIsDelayed = Delay;
    if (CVar1 == CONNECTION_CONNECTED) {
        this->State = CONNECTION_DISCONNECTED;
    }
    return;
}



// DWARF original prototype: void Disconnect(TConnection * this)

void __thiscall TConnection::Disconnect(TConnection *this)

{
    TConnection *pTVar1;
    int i;
    int iVar2;
    
    if (this->State < CONNECTION_CONNECTED) {
        error(&DAT_08108420,this->State);
    }
    iVar2 = 0x95;
    pTVar1 = this;
    do {
        if (pTVar1->KnownCreatureTable[0].State != KNOWNCREATURE_FREE) {
            UnchainKnownCreature(this,pTVar1->KnownCreatureTable[0].CreatureID);
        }
        pTVar1->KnownCreatureTable[0].Connection = this;
        pTVar1->KnownCreatureTable[0].State = KNOWNCREATURE_FREE;
        pTVar1->KnownCreatureTable[0].CreatureID = 0;
        pTVar1 = (TConnection *)(pTVar1->InData + 0x10);
        iVar2 = iVar2 + -1;
    } while (-1 < iVar2);
    this->ConnectionIsOk = false;
    this->State = CONNECTION_DISCONNECTED;
    kill(this->PID,1);
    return;
}



// DWARF original prototype: TPlayer * GetPlayer(TConnection * this)

TPlayer * __thiscall TConnection::GetPlayer(TConnection *this)

{
    TPlayer *pTVar1;
    
    if (this->State - CONNECTION_LOGIN < 4) {
        if (this->CharacterID != 0) {
            pTVar1 = ::GetPlayer(this->CharacterID);
            return pTVar1;
        }
    }
    else {
        error(&DAT_08108840,this->State);
    }
    return (TPlayer *)0x0;
}



// DWARF original prototype: char * GetName(TConnection * this)

char * __thiscall TConnection::GetName(TConnection *this)

{
    char *pcVar1;
    
    if (this->State - CONNECTION_LOGIN < 4) {
        pcVar1 = this->Name;
    }
    else {
        error(&DAT_08108880,this->State);
        pcVar1 = "";
    }
    return pcVar1;
}



// DWARF original prototype: void GetPosition(TConnection * this, int * x, int * y, int * z)

void __thiscall TConnection::GetPosition(TConnection *this,int *x,int *y,int *z)

{
    TPlayer *pTVar1;
    
    if (this->State - CONNECTION_LOGIN < 4) {
        pTVar1 = (TPlayer *)0x0;
        if (this->CharacterID != 0) {
            pTVar1 = ::GetPlayer(this->CharacterID);
        }
    }
    else {
        error(&DAT_08108840,this->State);
        pTVar1 = (TPlayer *)0x0;
    }
    if (pTVar1 == (TPlayer *)0x0) {
        *x = 0;
        *y = 0;
        *z = 0;
    }
    else {
        *x = (pTVar1->super_TCreature).posx;
        *y = (pTVar1->super_TCreature).posy;
        *z = (pTVar1->super_TCreature).posz;
    }
    return;
}



// WARNING: Variable defined which should be unmapped: posz
// DWARF original prototype: bool IsVisible(TConnection * this, int x, int y, int z)

bool __thiscall TConnection::IsVisible(TConnection *this,int x,int y,int z)

{
    bool bVar1;
    int dz;
    int iVar2;
    int iVar3;
    int local_1c;
    int posx;
    int posy;
    int posz;
    
    GetPosition(this,&local_1c,&posx,&posy);
    if (posy < 8) {
        if (7 < z) {
            return false;
        }
        if (posy < 8) goto LAB_080cba8a;
    }
    if (4 < (z - posy) + 2U) {
        return false;
    }
LAB_080cba8a:
    iVar2 = ((y + this->TerminalOffsetY) - posx) - (posy - z);
    iVar3 = ((x + this->TerminalOffsetX) - local_1c) - (posy - z);
    if ((((iVar3 < 0) || (this->TerminalWidth <= iVar3)) || (iVar2 < 0)) ||
       (this->TerminalHeight <= iVar2)) {
        bVar1 = false;
    }
    else {
        bVar1 = true;
    }
    return bVar1;
}



// DWARF original prototype: KNOWNCREATURESTATE KnownCreature(TConnection * this, ulong ID, bool
// UpdateFollows)

KNOWNCREATURESTATE __thiscall
TConnection::KnownCreature(TConnection *this,ulong ID,bool UpdateFollows)

{
    KNOWNCREATURESTATE KVar1;
    int i;
    int iVar2;
    
    iVar2 = 0;
    while (this->KnownCreatureTable[0].CreatureID != ID) {
        iVar2 = iVar2 + 1;
        this = (TConnection *)(this->InData + 0x10);
        if (0x95 < iVar2) {
            return KNOWNCREATURE_FREE;
        }
    }
    KVar1 = this->KnownCreatureTable[0].State;
    if (KVar1 != KNOWNCREATURE_OUTDATED) {
        return KVar1;
    }
    if (!UpdateFollows) {
        return KNOWNCREATURE_OUTDATED;
    }
    this->KnownCreatureTable[0].State = KNOWNCREATURE_UPTODATE;
    return KNOWNCREATURE_OUTDATED;
}



// WARNING: Variable defined which should be unmapped: OldID
// WARNING: Variable defined which should be unmapped: FreeEntry
// DWARF original prototype: ulong NewKnownCreature(TConnection * this, ulong NewID)

ulong __thiscall TConnection::NewKnownCreature(TConnection *this,ulong NewID)

{
    int iVar1;
    ulong uVar2;
    bool bVar3;
    ulong *puVar4;
    TCreature *pTVar5;
    TKnownCreature *pTVar6;
    TCreature *cr;
    int iVar7;
    TConnection *pTVar8;
    int i_1;
    int local_1c;
    int i_2;
    int FreeEntry;
    ulong OldID;
    
    iVar7 = 0;
    i_2 = -1;
    FreeEntry = 0;
    puVar4 = &this->KnownCreatureTable[0].CreatureID;
    do {
        iVar1 = iVar7;
        uVar2 = NewID;
        if (*puVar4 == NewID) break;
        iVar7 = iVar7 + 1;
        puVar4 = puVar4 + 4;
        iVar1 = i_2;
        uVar2 = FreeEntry;
    } while (iVar7 < 0x96);
    FreeEntry = uVar2;
    i_2 = iVar1;
    if (i_2 == -1) {
        iVar7 = 0;
        pTVar6 = this->KnownCreatureTable;
        pTVar8 = this;
        do {
            if (pTVar6->State == KNOWNCREATURE_FREE) {
                FreeEntry = pTVar8->KnownCreatureTable[0].CreatureID;
                i_2 = iVar7;
                break;
            }
            iVar7 = iVar7 + 1;
            pTVar6 = pTVar6 + 1;
            pTVar8 = (TConnection *)(pTVar8->InData + 0x10);
        } while (iVar7 < 0x96);
        if (i_2 == -1) {
            local_1c = 0;
            puVar4 = &this->KnownCreatureTable[0].CreatureID;
            do {
                pTVar5 = GetCreature(*puVar4);
                if (pTVar5 == (TCreature *)0x0) {
                    error("TUserCom::NewKnownCreature: Bekannte Kreatur existiert nicht.\n");
LAB_080cbc81:
                    if ((pTVar5 == (TCreature *)0x0) ||
                       (bVar3 = IsVisible(this,pTVar5->posx,pTVar5->posy,pTVar5->posz), !bVar3)) {
                        i_2 = local_1c;
                        FreeEntry = *puVar4;
                        UnchainKnownCreature(this,FreeEntry);
                        break;
                    }
                }
                else {
                    bVar3 = IsVisible(this,pTVar5->posx,pTVar5->posy,pTVar5->posz);
                    if (!bVar3) goto LAB_080cbc81;
                }
                local_1c = local_1c + 1;
                puVar4 = puVar4 + 4;
            } while (local_1c < 0x96);
            if (i_2 == -1) {
                print();
                return 0;
            }
        }
    }
    if (this->KnownCreatureTable[i_2].State != KNOWNCREATURE_FREE) {
        error(&DAT_08108900);
    }
    this->KnownCreatureTable[i_2].CreatureID = NewID;
    this->KnownCreatureTable[i_2].State = KNOWNCREATURE_UPTODATE;
    pTVar5 = GetCreature(NewID);
    if (pTVar5 == (TCreature *)0x0) {
        error("TUserCom::NewKnownCreature: Kreatur %lu existiert nicht.\n",NewID);
    }
    else {
        this->KnownCreatureTable[i_2].Next = pTVar5->FirstKnowingConnection;
        pTVar5->FirstKnowingConnection = this->KnownCreatureTable + i_2;
    }
    return FreeEntry;
}



// WARNING: Variable defined which should be unmapped: Unchain_local
// DWARF original prototype: void ClearKnownCreatureTable(TConnection * this, bool Unchain)

void __thiscall TConnection::ClearKnownCreatureTable(TConnection *this,bool Unchain)

{
    TConnection *pTVar1;
    int i;
    int iVar2;
    bool Unchain_local;
    
    iVar2 = 0x95;
    pTVar1 = this;
    do {
        if ((Unchain) && (pTVar1->KnownCreatureTable[0].State != KNOWNCREATURE_FREE)) {
            UnchainKnownCreature(this,pTVar1->KnownCreatureTable[0].CreatureID);
        }
        pTVar1->KnownCreatureTable[0].Connection = this;
        pTVar1->KnownCreatureTable[0].State = KNOWNCREATURE_FREE;
        pTVar1->KnownCreatureTable[0].CreatureID = 0;
        pTVar1 = (TConnection *)(pTVar1->InData + 0x10);
        iVar2 = iVar2 + -1;
    } while (-1 < iVar2);
    return;
}



// DWARF original prototype: void UnchainKnownCreature(TConnection * this, ulong ID)

void __thiscall TConnection::UnchainKnownCreature(TConnection *this,ulong ID)

{
    TKnownCreature *pTVar1;
    TCreature *pTVar2;
    TCreature *cr;
    TKnownCreature *KnownCreature;
    TKnownCreature *pTVar3;
    
    pTVar2 = GetCreature(ID);
    if (pTVar2 == (TCreature *)0x0) {
        this = (TConnection *)s_TUserCom__UnchainKnownCreature__K_08108a40;
    }
    else {
        pTVar1 = pTVar2->FirstKnowingConnection;
        if (pTVar1 != (TKnownCreature *)0x0) {
            if (pTVar1->Connection == this) {
                pTVar1->State = KNOWNCREATURE_FREE;
                pTVar2->FirstKnowingConnection = pTVar1->Next;
            }
            else {
                do {
                    pTVar3 = pTVar1;
                    pTVar1 = pTVar3->Next;
                    if (pTVar1 == (TKnownCreature *)0x0) {
                        this = (TConnection *)s_TUserCom__UnchainKnownCreature__K_081089c0;
                        goto LAB_080cbe0d;
                    }
                } while (pTVar1->Connection != this);
                pTVar1->State = KNOWNCREATURE_FREE;
                pTVar3->Next = pTVar1->Next;
            }
            return;
        }
        this = (TConnection *)s_TUserCom__UnchainKnownCreature__K_08108a00;
    }
LAB_080cbe0d:
    error((char *)this);
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

TConnection * AssignFreeConnection(void)

{
    int i;
    int iVar1;
    __pid_t _Var2;
    TConnection *pTVar3;
    
    pTVar3 = Connections;
    Semaphore::down(&ConnectionMutex);
    iVar1 = 0;
    do {
        if (pTVar3->State == CONNECTION_FREE) {
            pTVar3->State = CONNECTION_ASSIGNED;
            _Var2 = getpid();
            pTVar3->PID = _Var2;
            Semaphore::up(&ConnectionMutex);
            return pTVar3;
        }
        iVar1 = iVar1 + 1;
        pTVar3 = pTVar3 + 1;
    } while (iVar1 < 0x44c);
    Semaphore::up(&ConnectionMutex);
    return (TConnection *)0x0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

TConnection * GetFirstConnection(void)

{
    TConnection *pTVar1;
    
    ConnectionIterator = -1;
    pTVar1 = (TConnection *)(PlayerDataPool[0x7cd].QuestValues + 0x9a);
    do {
        ConnectionIterator = ConnectionIterator + 1;
        if (pTVar1[1].State != CONNECTION_FREE) {
            return pTVar1 + 1;
        }
        pTVar1 = pTVar1 + 1;
    } while (ConnectionIterator < 1099);
    return (TConnection *)0x0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

TConnection * GetNextConnection(void)

{
    TConnection *pTVar1;
    
    if (ConnectionIterator < 1099) {
        pTVar1 = Connections + ConnectionIterator;
        do {
            ConnectionIterator = ConnectionIterator + 1;
            if (pTVar1[1].State != CONNECTION_FREE) {
                return pTVar1 + 1;
            }
            pTVar1 = pTVar1 + 1;
        } while (ConnectionIterator < 1099);
    }
    return (TConnection *)0x0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ProcessConnections(void)

{
    TConnection *Connection;
    TConnection *this;
    TConnection *pTVar1;
    
    this = GetFirstConnection();
joined_r0x080cbf6d:
    do {
        if (this == (TConnection *)0x0) {
            return;
        }
        TConnection::Process(this);
        if (ConnectionIterator < 1099) {
            pTVar1 = Connections + ConnectionIterator;
            do {
                this = pTVar1 + 1;
                ConnectionIterator = ConnectionIterator + 1;
                if (pTVar1[1].State != CONNECTION_FREE) goto joined_r0x080cbf6d;
                pTVar1 = this;
            } while (ConnectionIterator < 1099);
        }
        this = (TConnection *)0x0;
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void InitConnections(void)

{
    CONNECTIONSTATE *pCVar1;
    
    pCVar1 = &Connections[0].State;
    do {
        *pCVar1 = CONNECTION_FREE;
        pCVar1 = pCVar1 + 0x147e;
    } while ((int)pCVar1 < 0xa67ef89);
    FirstSendingConnection = (TConnection *)0x0;
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ExitConnections(void)

{
    return;
}



void __tcf_0(void *param_1)

{
    int unaff_EBX;
    TConnection **ppTVar1;
    
    for (ppTVar1 = &FirstSendingConnection; (TConnection *)ppTVar1 != Connections;
        ppTVar1 = (TConnection **)((int)ppTVar1 + -0x51f8)) {
        TXTEASymmetricKey::~TXTEASymmetricKey
                  (&((TConnection *)((int)ppTVar1 + -0x51f8))->SymmetricKey,unaff_EBX);
    }
    return;
}



void __tcf_1(void *param_1)

{
    int in_stack_00000008;
    
    Semaphore::~Semaphore(&ConnectionMutex,in_stack_00000008);
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__I_Connections(void)

{
    __static_initialization_and_destruction_0(1,0xffff);
    return;
}



void __static_initialization_and_destruction_0(int __initialize_p,int __priority)

{
    if ((__priority == 0xffff) && (__initialize_p == 1)) {
        NONE.ObjectID = 0;
    }
    return;
}



bool BeginSendData(TConnection *Connection)

{
    bool bVar1;
    
    bVar1 = false;
    if (Connection != (TConnection *)0x0) {
        bVar1 = false;
        if ((Connection->State - CONNECTION_LOGIN < 4) &&
           (bVar1 = false, Connection->State != CONNECTION_LOGIN)) {
            if (Connection->NextToCommit == Connection->NextToSend + 0x4000) {
                bVar1 = false;
                TConnection::GetSocket(Connection);
                print();
            }
            else {
                Connection->NextToWrite = Connection->NextToCommit;
                bVar1 = true;
                Connection->Overflow = false;
            }
        }
    }
    return bVar1;
}



void FinishSendData(TConnection *Connection)

{
    if (Connection == (TConnection *)0x0) {
        Connection = (TConnection *)s_FinishSendData__Verbindung_ist_N_08108b60;
    }
    else {
        if (Connection->State - CONNECTION_LOGIN < 4) {
            if (Connection->Overflow == false) {
                Connection->NextToCommit = Connection->NextToWrite;
                if (Connection->WillingToSend == false) {
                    Connection->NextSendingConnection = FirstSendingConnection;
                    FirstSendingConnection = Connection;
                    Connection->WillingToSend = true;
                }
            }
            else {
                print();
            }
            return;
        }
        Connection = (TConnection *)s_FinishSendData__Verbindung_ist_n_08108b20;
    }
    error((char *)Connection);
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void SendAll(void)

{
    TConnection **ppTVar1;
    pid_t __pid;
    TConnection *Connection;
    TConnection *this;
    
    this = FirstSendingConnection;
    if (FirstSendingConnection != (TConnection *)0x0) {
        do {
            if (this->WillingToSend == false) {
                error("SendAll: Verbindung ist nicht sendewillig.\n");
            }
            else {
                this->WillingToSend = false;
                if ((this->State - CONNECTION_LOGIN < 4) && (this->NextToSend != this->NextToCommit)
                   ) {
                    __pid = TConnection::GetPID(this);
                    kill(__pid,0xc);
                }
            }
            ppTVar1 = &this->NextSendingConnection;
            this = *ppTVar1;
        } while (*ppTVar1 != (TConnection *)0x0);
    }
    FirstSendingConnection = (TConnection *)0x0;
    return;
}



void SkipFlush(TConnection *Connection)

{
    int iVar1;
    int iVar2;
    
    if (Skip != -1) {
        do {
            if (Skip < 0x100) {
                iVar1 = Connection->NextToSend;
                iVar2 = Connection->NextToWrite;
                if (iVar2 < iVar1 + 0x4000) {
                    Connection->OutData[iVar2 % 0x4000] = (uchar)Skip;
                    iVar2 = iVar2 + 1;
                    Connection->NextToWrite = iVar2;
                }
                else {
                    Connection->Overflow = true;
                }
                if (iVar2 < iVar1 + 0x4000) {
                    Connection->OutData[iVar2 % 0x4000] = 0xff;
                    Connection->NextToWrite = iVar2 + 1;
                }
                else {
                    Connection->Overflow = true;
                }
                Skip = -1;
            }
            else {
                iVar2 = Connection->NextToWrite;
                if (iVar2 < Connection->NextToSend + 0x4000) {
                    Connection->OutData[iVar2 % 0x4000] = 0xff;
                    Connection->NextToWrite = iVar2 + 1;
                }
                else {
                    Connection->Overflow = true;
                }
                iVar2 = Connection->NextToWrite;
                if (iVar2 < Connection->NextToSend + 0x4000) {
                    Connection->OutData[iVar2 % 0x4000] = 0xff;
                    Connection->NextToWrite = iVar2 + 1;
                }
                else {
                    Connection->Overflow = true;
                }
                Skip = Skip + -0x100;
            }
        } while (-1 < Skip);
    }
    return;
}



void SendMapObject(TConnection *Connection,Object *Obj)

{
    undefined2 uVar1;
    ushort uVar2;
    bool bVar3;
    uchar uVar4;
    TPlayer *this;
    KNOWNCREATURESTATE KVar5;
    int iVar6;
    uint uVar7;
    TPlayer *pTVar8;
    ulong uVar9;
    size_t Length;
    char *pcVar10;
    int iVar11;
    uint uVar12;
    int iVar13;
    char *s;
    uint uVar14;
    char *__s;
    char *pcVar15;
    uchar local_74;
    uchar local_4c;
    uchar local_44 [4];
    int HelpBrightness;
    int HelpColor;
    Object local_2c [7];
    
    bVar3 = Object::exists(Obj);
    if (!bVar3) {
        pcVar15 = &DAT_08108be0;
LAB_080cc3ff:
        error(pcVar15);
        return;
    }
    Object::getObjectType(local_2c);
    if (local_2c[0].ObjectID != 99) {
        local_2c[0] = (Object)Obj->ObjectID;
        Object::getObjectType((Object *)&HelpColor);
        bVar3 = ObjectType::getFlag((ObjectType *)&HelpColor,DISGUISE);
        if (bVar3) {
            Object::getObjectType((Object *)&HelpColor);
            uVar9 = ObjectType::getAttribute((ObjectType *)&HelpColor,DISGUISETARGET);
            HelpColor._0_2_ = (undefined2)uVar9;
        }
        else {
            Object::getObjectType((Object *)&HelpColor);
        }
        iVar6 = Connection->NextToWrite;
        if (iVar6 < Connection->NextToSend + 0x3fff) {
            Connection->OutData[iVar6 % 0x4000] = (uchar)(undefined2)HelpColor;
            uVar12 = iVar6 + 1;
            uVar7 = iVar6 + 0x4000;
            if (-1 < (int)uVar12) {
                uVar7 = uVar12;
            }
            *(char *)((int)Connection + (uVar12 - (uVar7 & 0xffffc000)) + 0x806) =
                 (char)((ushort)(undefined2)HelpColor >> 8);
            Connection->NextToWrite = iVar6 + 2;
        }
        else {
            Connection->Overflow = true;
        }
        Object::getObjectType((Object *)&HelpColor);
        bVar3 = ObjectType::getFlag((ObjectType *)&HelpColor,LIQUIDCONTAINER);
        if (bVar3) {
            uVar9 = Object::getAttribute(Obj,CONTAINERLIQUIDTYPE);
            uVar4 = GetLiquidColor(uVar9);
            iVar6 = Connection->NextToWrite;
            if (iVar6 < Connection->NextToSend + 0x4000) {
                Connection->OutData[iVar6 % 0x4000] = uVar4;
                Connection->NextToWrite = iVar6 + 1;
            }
            else {
                Connection->Overflow = true;
            }
        }
        Object::getObjectType((Object *)&HelpColor);
        bVar3 = ObjectType::getFlag((ObjectType *)&HelpColor,LIQUIDPOOL);
        if (bVar3) {
            uVar9 = Object::getAttribute(Obj,POOLLIQUIDTYPE);
            uVar4 = GetLiquidColor(uVar9);
            iVar6 = Connection->NextToWrite;
            if (iVar6 < Connection->NextToSend + 0x4000) {
                Connection->OutData[iVar6 % 0x4000] = uVar4;
                Connection->NextToWrite = iVar6 + 1;
            }
            else {
                Connection->Overflow = true;
            }
        }
        Object::getObjectType((Object *)&HelpColor);
        bVar3 = ObjectType::getFlag((ObjectType *)&HelpColor,CUMULATIVE);
        if (!bVar3) {
            return;
        }
        uVar9 = Object::getAttribute(Obj,AMOUNT);
        iVar6 = Connection->NextToWrite;
        if (Connection->NextToSend + 0x4000 <= iVar6) {
            Connection->Overflow = true;
            return;
        }
        Connection->OutData[iVar6 % 0x4000] = (uchar)uVar9;
LAB_080cce56:
        Connection->NextToWrite = iVar6 + 1;
        return;
    }
    local_2c[0] = (Object)Obj->ObjectID;
    this = (TPlayer *)GetCreature(local_2c);
    if (this == (TPlayer *)0x0) {
        pcVar15 = "SendMapObject: Kreatur hat kein Kreatur-Objekt\n";
        goto LAB_080cc3ff;
    }
    KVar5 = TConnection::KnownCreature(Connection,(this->super_TCreature).ID,true);
    if (KVar5 == KNOWNCREATURE_UPTODATE) {
        iVar11 = Connection->NextToSend;
        iVar6 = Connection->NextToWrite;
        if (iVar6 < iVar11 + 0x4000) {
            Connection->OutData[iVar6 % 0x4000] = 'c';
            iVar6 = iVar6 + 1;
            Connection->NextToWrite = iVar6;
        }
        else {
            Connection->Overflow = true;
        }
        if (iVar6 < iVar11 + 0x4000) {
            Connection->OutData[iVar6 % 0x4000] = '\0';
            iVar6 = iVar6 + 1;
            Connection->NextToWrite = iVar6;
        }
        else {
            Connection->Overflow = true;
        }
        uVar9 = (this->super_TCreature).ID;
        if (iVar6 < iVar11 + 0x3ffd) {
            Connection->OutData[iVar6 % 0x4000] = (uchar)uVar9;
            uVar12 = iVar6 + 1;
            uVar7 = iVar6 + 0x4000;
            if (-1 < (int)uVar12) {
                uVar7 = uVar12;
            }
            *(char *)((int)Connection + (uVar12 - (uVar7 & 0xffffc000)) + 0x806) =
                 (char)(uVar9 >> 8);
            uVar12 = iVar6 + 2;
            uVar7 = iVar6 + 0x4001;
            if (-1 < (int)uVar12) {
                uVar7 = uVar12;
            }
            *(char *)((int)Connection + (uVar12 - (uVar7 & 0xffffc000)) + 0x806) =
                 (char)(uVar9 >> 0x10);
            uVar12 = iVar6 + 3;
            uVar7 = iVar6 + 0x4002;
            if (-1 < (int)uVar12) {
                uVar7 = uVar12;
            }
            *(char *)((int)Connection + (uVar12 - (uVar7 & 0xffffc000)) + 0x806) =
                 (char)(uVar9 >> 0x18);
            iVar6 = iVar6 + 4;
            Connection->NextToWrite = iVar6;
        }
        else {
            Connection->Overflow = true;
        }
        if (iVar11 + 0x4000 <= iVar6) {
            Connection->Overflow = true;
            return;
        }
        Connection->OutData[iVar6 % 0x4000] = (uchar)(this->super_TCreature).Direction;
        goto LAB_080cce56;
    }
    if (1 < (int)KVar5) {
        if (KVar5 != KNOWNCREATURE_OUTDATED) {
            return;
        }
        iVar11 = Connection->NextToSend;
        iVar6 = Connection->NextToWrite;
        if (iVar6 < iVar11 + 0x4000) {
            iVar13 = iVar6 % 0x4000;
            iVar6 = iVar6 + 1;
            Connection->OutData[iVar13] = 'b';
            Connection->NextToWrite = iVar6;
        }
        else {
            Connection->Overflow = true;
        }
        if (iVar6 < iVar11 + 0x4000) {
            Connection->OutData[iVar6 % 0x4000] = '\0';
            iVar6 = iVar6 + 1;
            Connection->NextToWrite = iVar6;
        }
        else {
            Connection->Overflow = true;
        }
        uVar9 = (this->super_TCreature).ID;
        if (iVar6 < iVar11 + 0x3ffd) {
            uVar12 = iVar6 + 1;
            Connection->OutData[iVar6 % 0x4000] = (uchar)uVar9;
            uVar7 = iVar6 + 0x4000;
            if (-1 < (int)uVar12) {
                uVar7 = uVar12;
            }
            *(char *)((int)Connection + (uVar12 - (uVar7 & 0xffffc000)) + 0x806) =
                 (char)(uVar9 >> 8);
            uVar12 = iVar6 + 2;
            uVar7 = iVar6 + 0x4001;
            if (-1 < (int)uVar12) {
                uVar7 = uVar12;
            }
            *(char *)((int)Connection + (uVar12 - (uVar7 & 0xffffc000)) + 0x806) =
                 (char)(uVar9 >> 0x10);
            uVar12 = iVar6 + 3;
            uVar7 = iVar6 + 0x4002;
            if (-1 < (int)uVar12) {
                uVar7 = uVar12;
            }
            *(char *)((int)Connection + (uVar12 - (uVar7 & 0xffffc000)) + 0x806) =
                 (char)(uVar9 >> 0x18);
            Connection->NextToWrite = iVar6 + 4;
        }
        else {
            Connection->Overflow = true;
        }
        iVar6 = TCreature::GetHealth((TCreature *)this);
        uVar4 = (uchar)iVar6;
        iVar6 = Connection->NextToSend;
        goto LAB_080cc4e9;
    }
    if (KVar5 != KNOWNCREATURE_FREE) {
        return;
    }
    iVar11 = Connection->NextToSend;
    iVar6 = Connection->NextToWrite;
    if (iVar6 < iVar11 + 0x4000) {
        iVar13 = iVar6 % 0x4000;
        iVar6 = iVar6 + 1;
        Connection->OutData[iVar13] = 'a';
        Connection->NextToWrite = iVar6;
    }
    else {
        Connection->Overflow = true;
    }
    if (iVar6 < iVar11 + 0x4000) {
        Connection->OutData[iVar6 % 0x4000] = '\0';
        Connection->NextToWrite = iVar6 + 1;
    }
    else {
        Connection->Overflow = true;
    }
    uVar9 = TConnection::NewKnownCreature(Connection,(this->super_TCreature).ID);
    iVar11 = Connection->NextToSend;
    iVar6 = Connection->NextToWrite;
    if (iVar6 < iVar11 + 0x3ffd) {
        Connection->OutData[iVar6 % 0x4000] = (uchar)uVar9;
        uVar12 = iVar6 + 1;
        uVar7 = iVar6 + 0x4000;
        if (-1 < (int)uVar12) {
            uVar7 = uVar12;
        }
        *(char *)((int)Connection + (uVar12 - (uVar7 & 0xffffc000)) + 0x806) = (char)(uVar9 >> 8);
        uVar12 = iVar6 + 2;
        uVar7 = iVar6 + 0x4001;
        if (-1 < (int)uVar12) {
            uVar7 = uVar12;
        }
        *(char *)((int)Connection + (uVar12 - (uVar7 & 0xffffc000)) + 0x806) = (char)(uVar9 >> 0x10)
        ;
        uVar12 = iVar6 + 3;
        uVar7 = iVar6 + 0x4002;
        if (-1 < (int)uVar12) {
            uVar7 = uVar12;
        }
        iVar6 = iVar6 + 4;
        *(char *)((int)Connection + (uVar12 - (uVar7 & 0xffffc000)) + 0x806) = (char)(uVar9 >> 0x18)
        ;
        Connection->NextToWrite = iVar6;
    }
    else {
        Connection->Overflow = true;
    }
    uVar9 = (this->super_TCreature).ID;
    if (iVar6 < iVar11 + 0x3ffd) {
        Connection->OutData[iVar6 % 0x4000] = (uchar)uVar9;
        uVar12 = iVar6 + 1;
        uVar7 = iVar6 + 0x4000;
        if (-1 < (int)uVar12) {
            uVar7 = uVar12;
        }
        *(char *)((int)Connection + (uVar12 - (uVar7 & 0xffffc000)) + 0x806) = (char)(uVar9 >> 8);
        uVar12 = iVar6 + 2;
        uVar7 = iVar6 + 0x4001;
        if (-1 < (int)uVar12) {
            uVar7 = uVar12;
        }
        *(char *)((int)Connection + (uVar12 - (uVar7 & 0xffffc000)) + 0x806) = (char)(uVar9 >> 0x10)
        ;
        uVar12 = iVar6 + 3;
        uVar7 = iVar6 + 0x4002;
        if (-1 < (int)uVar12) {
            uVar7 = uVar12;
        }
        *(char *)((int)Connection + (uVar12 - (uVar7 & 0xffffc000)) + 0x806) = (char)(uVar9 >> 0x18)
        ;
        Connection->NextToWrite = iVar6 + 4;
    }
    else {
        Connection->Overflow = true;
    }
    if ((this->super_TCreature).Type == MONSTER) {
        pcVar15 = (this->super_TCreature).Name;
        pcVar10 = strchr(pcVar15,0x20);
        __s = pcVar10 + 1;
        if (pcVar10 == (char *)0x0) {
            __s = pcVar15;
        }
        if (__s == (char *)0x0) goto LAB_080ccb5e;
        Length = strlen(__s);
        iVar6 = Connection->NextToWrite;
        if (iVar6 < Connection->NextToSend + 0x3fff) {
            local_4c = (uchar)(Length & 0xffff);
            Connection->OutData[iVar6 % 0x4000] = local_4c;
            uVar12 = iVar6 + 1;
            uVar7 = iVar6 + 0x4000;
            if (-1 < (int)uVar12) {
                uVar7 = uVar12;
            }
            local_4c = (uchar)((Length & 0xffff) >> 8);
            *(uchar *)((int)Connection + (uVar12 - (uVar7 & 0xffffc000)) + 0x806) = local_4c;
            Connection->NextToWrite = iVar6 + 2;
        }
        else {
            Connection->Overflow = true;
        }
joined_r0x080ccbc6:
        if (0 < (int)Length) {
            SendText(Connection,__s,Length);
        }
    }
    else {
        __s = (this->super_TCreature).Name;
        if (__s != (char *)0x0) {
            Length = strlen(__s);
            iVar6 = Connection->NextToWrite;
            if (iVar6 < iVar11 + 0x3fff) {
                local_74 = (uchar)(Length & 0xffff);
                Connection->OutData[iVar6 % 0x4000] = local_74;
                uVar12 = iVar6 + 1;
                uVar7 = iVar6 + 0x4000;
                if (-1 < (int)uVar12) {
                    uVar7 = uVar12;
                }
                local_74 = (uchar)((Length & 0xffff) >> 8);
                *(uchar *)((int)Connection + (uVar12 - (uVar7 & 0xffffc000)) + 0x806) = local_74;
                Connection->NextToWrite = iVar6 + 2;
            }
            else {
                Connection->Overflow = true;
            }
            goto joined_r0x080ccbc6;
        }
LAB_080ccb5e:
        error("SendString: String ist NULL.\n");
    }
    iVar6 = TCreature::GetHealth((TCreature *)this);
    uVar4 = (uchar)iVar6;
    iVar6 = Connection->NextToSend;
LAB_080cc4e9:
    iVar11 = Connection->NextToWrite;
    if (iVar11 < iVar6 + 0x4000) {
        Connection->OutData[iVar11 % 0x4000] = uVar4;
        iVar11 = iVar11 + 1;
        Connection->NextToWrite = iVar11;
    }
    else {
        Connection->Overflow = true;
    }
    if (iVar11 < iVar6 + 0x4000) {
        Connection->OutData[iVar11 % 0x4000] = (uchar)(this->super_TCreature).Direction;
        iVar11 = iVar11 + 1;
        Connection->NextToWrite = iVar11;
    }
    else {
        Connection->Overflow = true;
    }
    uVar1 = (undefined2)(this->super_TCreature).Outfit.OutfitID;
    if (iVar11 < iVar6 + 0x3fff) {
        Connection->OutData[iVar11 % 0x4000] = (uchar)uVar1;
        uVar12 = iVar11 + 1;
        uVar7 = iVar11 + 0x4000;
        if (-1 < (int)uVar12) {
            uVar7 = uVar12;
        }
        *(char *)((int)Connection + (uVar12 - (uVar7 & 0xffffc000)) + 0x806) =
             (char)((ushort)uVar1 >> 8);
        Connection->NextToWrite = iVar11 + 2;
    }
    else {
        Connection->Overflow = true;
    }
    if ((this->super_TCreature).Outfit.OutfitID == 0) {
        uVar2 = (this->super_TCreature).Outfit.field_1.ObjectType;
        iVar11 = Connection->NextToWrite;
        if (iVar11 < iVar6 + 0x3fff) {
            uVar12 = iVar11 + 1;
            Connection->OutData[iVar11 % 0x4000] = (uchar)uVar2;
            uVar7 = iVar11 + 0x4000;
            if (-1 < (int)uVar12) {
                uVar7 = uVar12;
            }
            *(char *)((int)Connection + (uVar12 - (uVar7 & 0xffffc000)) + 0x806) =
                 (char)(uVar2 >> 8);
            Connection->NextToWrite = iVar11 + 2;
        }
        else {
            Connection->Overflow = true;
        }
    }
    else {
        SendText(Connection,(char *)(this->super_TCreature).Outfit.field_1.Colors,4);
    }
    GetCreatureLight((this->super_TCreature).ID,(int *)local_44,&HelpBrightness);
    iVar11 = Connection->NextToSend;
    iVar6 = Connection->NextToWrite;
    if (iVar6 < iVar11 + 0x4000) {
        Connection->OutData[iVar6 % 0x4000] = local_44[0];
        iVar6 = iVar6 + 1;
        Connection->NextToWrite = iVar6;
    }
    else {
        Connection->Overflow = true;
    }
    if (iVar6 < iVar11 + 0x4000) {
        Connection->OutData[iVar6 % 0x4000] = (uchar)HelpBrightness;
        Connection->NextToWrite = iVar6 + 1;
    }
    else {
        Connection->Overflow = true;
    }
    uVar7 = TCreature::GetSpeed((TCreature *)this);
    iVar6 = Connection->NextToWrite;
    iVar11 = Connection->NextToSend;
    if (iVar6 < iVar11 + 0x3fff) {
        local_74 = (uchar)(uVar7 & 0xffff);
        Connection->OutData[iVar6 % 0x4000] = local_74;
        uVar14 = iVar6 + 1;
        uVar12 = iVar6 + 0x4000;
        if (-1 < (int)uVar14) {
            uVar12 = uVar14;
        }
        local_74 = (uchar)((uVar7 & 0xffff) >> 8);
        *(uchar *)((int)Connection + (uVar14 - (uVar12 & 0xffffc000)) + 0x806) = local_74;
        Connection->NextToWrite = iVar6 + 2;
    }
    else {
        Connection->Overflow = true;
    }
    if ((this->super_TCreature).Type == PLAYER) {
        pTVar8 = TConnection::GetPlayer(Connection);
        iVar6 = TPlayer::GetPlayerkillingMark(this,pTVar8);
        uVar4 = (uchar)iVar6;
        iVar11 = Connection->NextToSend;
    }
    else {
        uVar4 = '\0';
    }
    iVar6 = Connection->NextToWrite;
    if (iVar6 < iVar11 + 0x4000) {
        Connection->OutData[iVar6 % 0x4000] = uVar4;
        Connection->NextToWrite = iVar6 + 1;
    }
    else {
        Connection->Overflow = true;
    }
    if ((this->super_TCreature).Type == PLAYER) {
        pTVar8 = TConnection::GetPlayer(Connection);
        iVar6 = TPlayer::GetPartyMark(this,pTVar8);
        uVar4 = (uchar)iVar6;
        iVar11 = Connection->NextToSend;
    }
    else {
        uVar4 = '\0';
    }
    iVar6 = Connection->NextToWrite;
    if (iVar6 < iVar11 + 0x4000) {
        Connection->OutData[iVar6 % 0x4000] = uVar4;
        Connection->NextToWrite = iVar6 + 1;
    }
    else {
        Connection->Overflow = true;
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void SendMapPoint(void)

{
    int Count;
    int iVar1;
    TConnection *in_stack_00000004;
    Object local_4c [4];
    Object local_3c [4];
    ulong local_2c;
    Object Obj;
    
    GetFirstObject();
    local_3c[0].ObjectID = NONE.ObjectID;
    if (local_2c != NONE.ObjectID) {
        iVar1 = 0;
        SkipFlush(in_stack_00000004);
        if (local_2c != NONE.ObjectID) {
            do {
                iVar1 = iVar1 + 1;
                local_4c[0].ObjectID = local_2c;
                local_3c[0].ObjectID = NONE.ObjectID;
                SendMapObject(in_stack_00000004,local_4c);
                Object::getNextObject(local_3c);
                local_2c = local_3c[0].ObjectID;
                if (iVar1 == 10) break;
            } while (local_3c[0].ObjectID != NONE.ObjectID);
        }
    }
    Skip = Skip + 1;
    return;
}



void SendResult(TConnection *Connection,RESULT r)

{
    int iVar1;
    bool bVar2;
    TPlayer *pTVar3;
    char *pcVar4;
    
    if (Connection == (TConnection *)0x0) {
        return;
    }
    switch(r) {
    case NOERROR:
        Connection = (TConnection *)s_SendResult__NOERROR_08109aa1;
        goto LAB_080cd2ea;
    case NOTACCESSIBLE:
        pcVar4 = "Sorry, not possible.";
        break;
    case NOTMOVABLE:
        pcVar4 = "You cannot move this object.";
        break;
    case NOTTAKABLE:
        pcVar4 = "You cannot take this object.";
        break;
    case NOROOM:
        pcVar4 = "There is not enough room.";
        break;
    case OUTOFRANGE:
        pcVar4 = "Destination is out of range.";
        break;
    case OUTOFHOME:
        Connection = (TConnection *)s_SendResult__OUTOFHOME_08109b3c;
        goto LAB_080cd2ea;
    case CANNOTTHROW:
        pcVar4 = "You cannot throw there.";
        break;
    case TOOHEAVY:
        pcVar4 = "This object is too heavy.";
        break;
    case CROSSREFERENCE:
        pcVar4 = "This is impossible.";
        break;
    case CONTAINERFULL:
        pcVar4 = "You cannot put more objects in this container.";
        break;
    case WRONGPOSITION:
        pcVar4 = "Put this object in your hand.";
        break;
    case WRONGPOSITION2:
        pcVar4 = "Put this object in both hands.";
        break;
    case WRONGCLOTHES:
        pcVar4 = "You cannot dress this object there.";
        break;
    case HANDSNOTFREE:
        pcVar4 = "Both hands have to be free.";
        break;
    case HANDBLOCKED:
        pcVar4 = "Drop the double-handed object first.";
        break;
    case ONEWEAPONONLY:
        pcVar4 = "You may only use one weapon.";
        break;
    case NOMATCH:
        Connection = (TConnection *)s_SendResult__NOMATCH_08109bf0;
        goto LAB_080cd2ea;
    case NOTCUMULABLE:
        Connection = (TConnection *)s_SendResult__NOTCUMULABLE_08109c05;
        goto LAB_080cd2ea;
    case TOOMANYPARTS:
        Connection = (TConnection *)s_SendResult__TOOMANYPARTS_08109c1f;
        goto LAB_080cd2ea;
    case EMPTYCONTAINER:
        Connection = (TConnection *)s_SendResult__EMPTYCONTAINER_08109c39;
        goto LAB_080cd2ea;
    case SPLITOBJECT:
        Connection = (TConnection *)s_SendResult__SPLITOBJECT_08109c55;
        goto LAB_080cd2ea;
    case NOKEYMATCH:
        pcVar4 = "The key does not match.";
        break;
    case UPSTAIRS:
        pcVar4 = "First go upstairs.";
        break;
    case DOWNSTAIRS:
        pcVar4 = "First go downstairs.";
        break;
    case CREATURENOTEXISTING:
        pcVar4 = "A creature with this name does not exist.";
        break;
    case PLAYERNOTEXISTING:
        pcVar4 = "A player with this name does not exist.";
        break;
    case PLAYERNOTONLINE:
        pcVar4 = "A player with this name is not online.";
        break;
    case NAMEAMBIGUOUS:
        pcVar4 = "Playername is ambiguous.";
        break;
    case NOTUSABLE:
        pcVar4 = "You cannot use this object.";
        break;
    case FEDUP:
        pcVar4 = "You are full.";
        break;
    case SPELLUNKNOWN:
        pcVar4 = "You must learn this spell first.";
        break;
    case LOWMAGICLEVEL:
        pcVar4 = "Your magic level is too low.";
        break;
    case MAGICITEM:
        pcVar4 = "A magic item is necessary to cast this spell.";
        break;
    case NOTENOUGHMANA:
        pcVar4 = "You do not have enough mana.";
        break;
    case NOSKILL:
        Connection = (TConnection *)s_SendResult__NOSKILL_08109d2b;
        goto LAB_080cd2ea;
    case TARGETLOST:
        pcVar4 = "Target lost.";
        break;
    case NOCREATURE:
        pcVar4 = "You can only use this rune on creatures.";
        break;
    case TOOLONG:
        Connection = (TConnection *)s_SendResult__TOOLONG_08109d4d;
LAB_080cd2ea:
        error((char *)Connection);
        return;
    case ATTACKNOTALLOWED:
        pcVar4 = "You may not attack this person.";
        break;
    case NOWAY:
        pcVar4 = "There is no way.";
        break;
    case LOGINERROR:
        pcVar4 = "An error occured while logging in.";
        break;
    case PROTECTIONZONE:
        pcVar4 = "This action is not permitted in a protection zone.";
        break;
    case ENTERPROTECTIONZONE:
        pcVar4 = "Characters who attacked other players may not enter a protection zone.";
        goto LAB_080cd511;
    case EXHAUSTED:
        pcVar4 = "You are exhausted.";
        break;
    case NOTINVITED:
        pcVar4 = "You are not invited.";
        goto LAB_080cd511;
    case NOPREMIUMACCOUNT:
        pcVar4 = "You need a premium account.";
        break;
    case MOVENOTPOSSIBLE:
        pcVar4 = "Sorry, not possible.";
LAB_080cd511:
        SendMessage(Connection,0x17,pcVar4);
        bVar2 = BeginSendData(Connection);
        if (!bVar2) {
            return;
        }
        iVar1 = Connection->NextToWrite;
        if (iVar1 < Connection->NextToSend + 0x4000) {
            Connection->OutData[iVar1 % 0x4000] = 0xb5;
            Connection->NextToWrite = iVar1 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        pTVar3 = TConnection::GetPlayer(Connection);
        if (pTVar3 == (TPlayer *)0x0) {
            return;
        }
        iVar1 = Connection->NextToWrite;
        if (iVar1 < Connection->NextToSend + 0x4000) {
            Connection->OutData[iVar1 % 0x4000] = (uchar)(pTVar3->super_TCreature).Direction;
            Connection->NextToWrite = iVar1 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        FinishSendData(Connection);
        return;
    case ALREADYTRADING:
        pcVar4 = "You are already trading. Finish this trade first.";
        break;
    case PARTNERTRADING:
        pcVar4 = "This person is already trading.";
        break;
    case TOOMANYOBJECTS:
        pcVar4 = "You can only trade up to 100 objects at one time.";
        break;
    case TOOMANYSLAVES:
        pcVar4 = "You cannot control more creatures.";
        break;
    case NOTTURNABLE:
        pcVar4 = "You cannot turn this object.";
        break;
    case SECUREMODE:
        pcVar4 = "Turn secure mode off if you really want to attack unmarked players.";
        break;
    case NOTENOUGHSOULPOINTS:
        pcVar4 = "You do not have enough soulpoints.";
        break;
    case LOWLEVEL:
        pcVar4 = "Your level is too low.";
        break;
    default:
        goto switchD_080cd2dc_caseD_ffffffff;
    }
    SendMessage(Connection,0x17,pcVar4);
switchD_080cd2dc_caseD_ffffffff:
    return;
}



// WARNING: Variable defined which should be unmapped: Color

void SendRefresh(TConnection *Connection)

{
    int iVar1;
    bool bVar2;
    int iVar3;
    uchar local_18 [4];
    int Brightness;
    int Color;
    
    SendFullScreen(Connection);
    bVar2 = BeginSendData(Connection);
    if (bVar2) {
        iVar3 = Connection->NextToWrite;
        if (iVar3 < Connection->NextToSend + 0x4000) {
            Connection->OutData[iVar3 % 0x4000] = 0x82;
            Connection->NextToWrite = iVar3 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        GetAmbiente((int *)local_18,&Brightness);
        iVar1 = Connection->NextToSend;
        iVar3 = Connection->NextToWrite;
        if (iVar3 < iVar1 + 0x4000) {
            Connection->OutData[iVar3 % 0x4000] = local_18[0];
            iVar3 = iVar3 + 1;
            Connection->NextToWrite = iVar3;
        }
        else {
            Connection->Overflow = true;
        }
        if (iVar3 < iVar1 + 0x4000) {
            Connection->OutData[iVar3 % 0x4000] = (uchar)Brightness;
            Connection->NextToWrite = iVar3 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        FinishSendData(Connection);
    }
    SendPlayerData(Connection);
    SendPlayerSkills(Connection);
    return;
}



// WARNING: Variable defined which should be unmapped: id_local

void __regparm2 SendInitGame(TConnection *Connection,ulong id)

{
    int iVar1;
    undefined2 uVar2;
    bool bVar3;
    int iVar4;
    uint uVar5;
    uint uVar6;
    TConnection *in_stack_00000004;
    ulong in_stack_00000008;
    uchar local_14;
    ulong id_local;
    
    bVar3 = BeginSendData(in_stack_00000004);
    if (bVar3) {
        iVar1 = in_stack_00000004->NextToSend;
        iVar4 = in_stack_00000004->NextToWrite;
        if (iVar4 < iVar1 + 0x4000) {
            in_stack_00000004->OutData[iVar4 % 0x4000] = '\n';
            iVar4 = iVar4 + 1;
            in_stack_00000004->NextToWrite = iVar4;
        }
        else {
            in_stack_00000004->Overflow = true;
        }
        if (iVar4 < iVar1 + 0x3ffd) {
            uVar6 = iVar4 + 1;
            local_14 = (uchar)in_stack_00000008;
            in_stack_00000004->OutData[iVar4 % 0x4000] = local_14;
            uVar5 = iVar4 + 0x4000;
            if (-1 < (int)uVar6) {
                uVar5 = uVar6;
            }
            *(char *)((int)in_stack_00000004 + (uVar6 - (uVar5 & 0xffffc000)) + 0x806) =
                 (char)(in_stack_00000008 >> 8);
            uVar6 = iVar4 + 2;
            uVar5 = iVar4 + 0x4001;
            if (-1 < (int)uVar6) {
                uVar5 = uVar6;
            }
            *(char *)((int)in_stack_00000004 + (uVar6 - (uVar5 & 0xffffc000)) + 0x806) =
                 (char)(in_stack_00000008 >> 0x10);
            uVar6 = iVar4 + 3;
            uVar5 = iVar4 + 0x4002;
            if (-1 < (int)uVar6) {
                uVar5 = uVar6;
            }
            *(char *)((int)in_stack_00000004 + (uVar6 - (uVar5 & 0xffffc000)) + 0x806) =
                 (char)(in_stack_00000008 >> 0x18);
            iVar4 = iVar4 + 4;
            in_stack_00000004->NextToWrite = iVar4;
        }
        else {
            in_stack_00000004->Overflow = true;
        }
        uVar2 = (undefined2)Beat;
        if (iVar4 < iVar1 + 0x3fff) {
            uVar6 = iVar4 + 1;
            in_stack_00000004->OutData[iVar4 % 0x4000] = (uchar)(undefined2)Beat;
            uVar5 = iVar4 + 0x4000;
            if (-1 < (int)uVar6) {
                uVar5 = uVar6;
            }
            *(char *)((int)in_stack_00000004 + (uVar6 - (uVar5 & 0xffffc000)) + 0x806) =
                 (char)((ushort)uVar2 >> 8);
            in_stack_00000004->NextToWrite = iVar4 + 2;
        }
        else {
            in_stack_00000004->Overflow = true;
        }
        bVar3 = CheckRight(in_stack_00000008,SEND_BUGREPORTS);
        iVar4 = in_stack_00000004->NextToWrite;
        if (iVar4 < in_stack_00000004->NextToSend + 0x4000) {
            in_stack_00000004->OutData[iVar4 % 0x4000] = bVar3;
            in_stack_00000004->NextToWrite = iVar4 + 1;
        }
        else {
            in_stack_00000004->Overflow = true;
        }
        FinishSendData(in_stack_00000004);
        return;
    }
    return;
}



// WARNING: Variable defined which should be unmapped: Connection_local

void __regparm2 SendRights(TConnection *Connection)

{
    bool bVar1;
    bool bVar2;
    TPlayer *pTVar3;
    int Action;
    int iVar4;
    int Reason;
    int Actions;
    uint uVar5;
    TConnection *in_stack_00000004;
    RIGHT local_20;
    int Right;
    bool SendIt;
    TPlayer *pl;
    TConnection *Connection_local;
    
    bVar1 = BeginSendData(in_stack_00000004);
    if (bVar1) {
        iVar4 = in_stack_00000004->NextToWrite;
        if (iVar4 < in_stack_00000004->NextToSend + 0x4000) {
            in_stack_00000004->OutData[iVar4 % 0x4000] = '\v';
            in_stack_00000004->NextToWrite = iVar4 + 1;
        }
        else {
            in_stack_00000004->Overflow = true;
        }
        pTVar3 = TConnection::GetPlayer(in_stack_00000004);
        bVar1 = false;
        local_20 = NAME_INSULTING;
        do {
            bVar2 = CheckRight((pTVar3->super_TCreature).ID,local_20);
            uVar5 = 0;
            if (bVar2) {
                iVar4 = 0;
                uVar5 = 0;
                do {
                    bVar2 = CheckBanishmentRight
                                      ((pTVar3->super_TCreature).ID,local_20 - NAME_INSULTING,iVar4)
                    ;
                    if (bVar2) {
                        uVar5 = uVar5 | 1 << ((byte)iVar4 & 0x1f);
                    }
                    iVar4 = iVar4 + 1;
                } while (iVar4 < 7);
                if (uVar5 != 0) {
                    bVar2 = CheckRight((pTVar3->super_TCreature).ID,IP_BANISHMENT);
                    if (bVar2) {
                        uVar5 = uVar5 | 0x80;
                    }
                }
            }
            iVar4 = in_stack_00000004->NextToWrite;
            if (iVar4 < in_stack_00000004->NextToSend + 0x4000) {
                in_stack_00000004->OutData[iVar4 % 0x4000] = (uchar)uVar5;
                in_stack_00000004->NextToWrite = iVar4 + 1;
            }
            else {
                in_stack_00000004->Overflow = true;
            }
            if (uVar5 != 0) {
                bVar1 = true;
            }
            local_20 = local_20 + NOTATION;
        } while ((int)local_20 < 0x32);
        if (bVar1) {
            FinishSendData(in_stack_00000004);
            return;
        }
    }
    return;
}



void SendPing(TConnection *Connection)

{
    int iVar1;
    bool bVar2;
    
    bVar2 = BeginSendData(Connection);
    if (bVar2) {
        iVar1 = Connection->NextToWrite;
        if (iVar1 < Connection->NextToSend + 0x4000) {
            Connection->OutData[iVar1 % 0x4000] = '\x1e';
            Connection->NextToWrite = iVar1 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        FinishSendData(Connection);
        return;
    }
    return;
}



// WARNING: Variable defined which should be unmapped: posz

void SendFullScreen(TConnection *Connection)

{
    bool bVar1;
    int iVar2;
    uint uVar3;
    uint uVar4;
    int y;
    int iVar5;
    int iVar6;
    int z_1;
    int z;
    int iVar7;
    int local_30;
    int local_2c;
    int x_1;
    int x;
    int sy;
    int sx;
    int posx;
    int posy;
    int posz;
    
    bVar1 = BeginSendData(Connection);
    if (bVar1) {
        iVar7 = Connection->NextToWrite;
        if (iVar7 < Connection->NextToSend + 0x4000) {
            Connection->OutData[iVar7 % 0x4000] = 'd';
            Connection->NextToWrite = iVar7 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        TConnection::GetPosition(Connection,&sx,&posx,&posy);
        iVar2 = Connection->NextToSend;
        iVar7 = Connection->NextToWrite;
        if (iVar7 < iVar2 + 0x3fff) {
            Connection->OutData[iVar7 % 0x4000] = (uchar)(undefined2)sx;
            uVar4 = iVar7 + 1;
            uVar3 = iVar7 + 0x4000;
            if (-1 < (int)uVar4) {
                uVar3 = uVar4;
            }
            *(char *)((int)Connection + (uVar4 - (uVar3 & 0xffffc000)) + 0x806) =
                 (char)((ushort)(undefined2)sx >> 8);
            iVar7 = iVar7 + 2;
            Connection->NextToWrite = iVar7;
        }
        else {
            Connection->Overflow = true;
        }
        if (iVar7 < iVar2 + 0x3fff) {
            uVar4 = iVar7 + 1;
            Connection->OutData[iVar7 % 0x4000] = (uchar)(undefined2)posx;
            uVar3 = iVar7 + 0x4000;
            if (-1 < (int)uVar4) {
                uVar3 = uVar4;
            }
            *(char *)((int)Connection + (uVar4 - (uVar3 & 0xffffc000)) + 0x806) =
                 (char)((ushort)(undefined2)posx >> 8);
            iVar7 = iVar7 + 2;
            Connection->NextToWrite = iVar7;
        }
        else {
            Connection->Overflow = true;
        }
        if (iVar7 < iVar2 + 0x4000) {
            Connection->OutData[iVar7 % 0x4000] = (uchar)posy;
            Connection->NextToWrite = iVar7 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        Skip = -1;
        if (posy < 8) {
            iVar7 = 7;
            local_30 = Connection->TerminalWidth;
            do {
                x_1 = 0;
                if (0 < local_30) {
                    iVar2 = Connection->TerminalHeight;
                    do {
                        iVar5 = 0;
                        if (0 < iVar2) {
                            do {
                                iVar5 = iVar5 + 1;
                                SendMapPoint();
                                iVar2 = Connection->TerminalHeight;
                            } while (iVar5 < iVar2);
                            local_30 = Connection->TerminalWidth;
                        }
                        x_1 = x_1 + 1;
                    } while (x_1 < local_30);
                }
                iVar7 = iVar7 + -1;
            } while (-1 < iVar7);
        }
        else {
            iVar7 = posy + -2;
            if ((iVar7 <= posy + 2) && (iVar7 < 0x10)) {
                local_30 = Connection->TerminalWidth;
                iVar2 = posy;
                do {
                    local_2c = 0;
                    if (0 < local_30) {
                        iVar5 = Connection->TerminalHeight;
                        do {
                            iVar6 = 0;
                            if (0 < iVar5) {
                                do {
                                    iVar6 = iVar6 + 1;
                                    SendMapPoint();
                                    iVar5 = Connection->TerminalHeight;
                                } while (iVar6 < iVar5);
                                local_30 = Connection->TerminalWidth;
                                iVar2 = posy;
                            }
                            local_2c = local_2c + 1;
                        } while (local_2c < local_30);
                    }
                    iVar7 = iVar7 + 1;
                } while ((iVar7 <= iVar2 + 2) && (iVar7 < 0x10));
            }
        }
        SkipFlush(Connection);
        FinishSendData(Connection);
    }
    return;
}



// WARNING: Variable defined which should be unmapped: posz

void SendRow(TConnection *Connection,int Direction)

{
    bool bVar1;
    int iVar2;
    int iVar3;
    int z;
    int iVar4;
    int local_2c;
    int end;
    int dz;
    int sy;
    int sx;
    int posx;
    int posy;
    int posz;
    
    bVar1 = BeginSendData(Connection);
    if (!bVar1) {
        return;
    }
    if (Direction == 1) {
        iVar4 = Connection->NextToWrite;
        if (Connection->NextToSend + 0x4000 <= iVar4) goto LAB_080cdfdc;
        Connection->OutData[iVar4 % 0x4000] = 'f';
    }
    else if (Direction < 2) {
        if (Direction != 0) {
LAB_080cdfab:
            error(&DAT_08109140,Direction);
            return;
        }
        iVar4 = Connection->NextToWrite;
        if (Connection->NextToSend + 0x4000 <= iVar4) goto LAB_080cdfdc;
        Connection->OutData[iVar4 % 0x4000] = 'e';
    }
    else if (Direction == 2) {
        iVar4 = Connection->NextToWrite;
        if (Connection->NextToSend + 0x4000 <= iVar4) {
LAB_080cdfdc:
            Connection->Overflow = true;
            goto LAB_080cdfe3;
        }
        Connection->OutData[iVar4 % 0x4000] = 'g';
    }
    else {
        if (Direction != 3) goto LAB_080cdfab;
        iVar4 = Connection->NextToWrite;
        if (Connection->NextToSend + 0x4000 <= iVar4) goto LAB_080cdfdc;
        Connection->OutData[iVar4 % 0x4000] = 'h';
    }
    Connection->NextToWrite = iVar4 + 1;
LAB_080cdfe3:
    TConnection::GetPosition(Connection,&sx,&posx,&posy);
    Skip = -1;
    if (posy < 8) {
        end = -1;
        iVar4 = 7;
        local_2c = -1;
    }
    else {
        end = 1;
        iVar4 = posy + -2;
        local_2c = 0x10;
        if (posy + 3 < 0x11) {
            local_2c = posy + 3;
        }
    }
    if (Direction == 1) {
        if (iVar4 != local_2c) {
            iVar2 = Connection->TerminalHeight;
            do {
                iVar3 = 0;
                if (0 < iVar2) {
                    do {
                        iVar3 = iVar3 + 1;
                        SendMapPoint();
                        iVar2 = Connection->TerminalHeight;
                    } while (iVar3 < iVar2);
                }
                iVar4 = iVar4 + end;
            } while (iVar4 != local_2c);
        }
    }
    else if (Direction < 2) {
        if ((Direction == 0) && (iVar4 != local_2c)) {
            iVar2 = Connection->TerminalWidth;
            do {
                iVar3 = 0;
                if (0 < iVar2) {
                    do {
                        iVar3 = iVar3 + 1;
                        SendMapPoint();
                        iVar2 = Connection->TerminalWidth;
                    } while (iVar3 < iVar2);
                }
                iVar4 = iVar4 + end;
            } while (iVar4 != local_2c);
        }
    }
    else if (Direction == 2) {
        if (iVar4 != local_2c) {
            iVar2 = Connection->TerminalWidth;
            do {
                iVar3 = 0;
                if (0 < iVar2) {
                    do {
                        iVar3 = iVar3 + 1;
                        SendMapPoint();
                        iVar2 = Connection->TerminalWidth;
                    } while (iVar3 < iVar2);
                }
                iVar4 = iVar4 + end;
            } while (iVar4 != local_2c);
        }
    }
    else if ((Direction == 3) && (iVar4 != local_2c)) {
        iVar2 = Connection->TerminalHeight;
        do {
            iVar3 = 0;
            if (0 < iVar2) {
                do {
                    iVar3 = iVar3 + 1;
                    SendMapPoint();
                    iVar2 = Connection->TerminalHeight;
                } while (iVar3 < iVar2);
            }
            iVar4 = iVar4 + end;
        } while (iVar4 != local_2c);
    }
    SkipFlush(Connection);
    FinishSendData(Connection);
    return;
}



// WARNING: Variable defined which should be unmapped: posz

void SendFloors(TConnection *Connection,bool Up)

{
    bool bVar1;
    int iVar2;
    int iVar3;
    int iVar4;
    int z;
    int iVar5;
    int local_30;
    int x;
    int sy;
    int sx;
    int dz;
    int end;
    int posx;
    int posy;
    int posz;
    
    bVar1 = BeginSendData(Connection);
    if (!bVar1) {
        return;
    }
    iVar5 = Connection->NextToWrite;
    if (iVar5 < Connection->NextToSend + 0x4000) {
        Connection->OutData[iVar5 % 0x4000] = !Up + 0xbe;
        Connection->NextToWrite = iVar5 + 1;
    }
    else {
        Connection->Overflow = true;
    }
    TConnection::GetPosition(Connection,&end,&posx,&posy);
    if (Up) {
        if (7 < posy) {
            sx = -1;
            iVar5 = posy + -2;
            dz = posy + -3;
            goto LAB_080ce3a4;
        }
        if (posy != 7) goto LAB_080ce47c;
        sx = -1;
        iVar5 = 5;
    }
    else {
        if (8 < posy) {
            sx = 1;
            iVar5 = posy + 2;
            dz = posy + 3;
            if (0x10 < iVar5) {
                iVar5 = 0x10;
            }
            if (0x10 < dz) {
                dz = 0x10;
            }
            goto LAB_080ce3a4;
        }
        if (posy == 8) {
            sx = 1;
            iVar5 = 8;
            dz = 0xb;
            goto LAB_080ce3a4;
        }
LAB_080ce47c:
        sx = 0;
        iVar5 = -1;
    }
    dz = -1;
LAB_080ce3a4:
    Skip = -1;
    if (iVar5 != dz) {
        iVar3 = Connection->TerminalWidth;
        do {
            local_30 = 0;
            if (0 < iVar3) {
                iVar2 = Connection->TerminalHeight;
                do {
                    iVar4 = 0;
                    if (0 < iVar2) {
                        do {
                            iVar4 = iVar4 + 1;
                            SendMapPoint();
                            iVar2 = Connection->TerminalHeight;
                        } while (iVar4 < iVar2);
                        iVar3 = Connection->TerminalWidth;
                    }
                    local_30 = local_30 + 1;
                } while (local_30 < iVar3);
            }
            iVar5 = iVar5 + sx;
        } while (iVar5 != dz);
    }
    SkipFlush(Connection);
    FinishSendData(Connection);
    return;
}



// WARNING: Variable defined which should be unmapped: x_local

void __regparm2 SendFieldData(TConnection *Connection,int x,int y,int z)

{
    int iVar1;
    bool bVar2;
    uint uVar3;
    int iVar4;
    uint uVar5;
    int iVar6;
    undefined4 in_stack_0000000c;
    undefined1 in_stack_00000010;
    int z_local;
    int y_local;
    int x_local;
    
    bVar2 = BeginSendData((TConnection *)y);
    if (bVar2) {
        iVar1 = *(int *)(y + 0x4808);
        iVar4 = *(int *)(y + 0x4810);
        if (iVar4 < iVar1 + 0x4000) {
            iVar6 = iVar4 % 0x4000;
            iVar4 = iVar4 + 1;
            *(undefined1 *)(y + 0x806 + iVar6) = 0x69;
            *(int *)(y + 0x4810) = iVar4;
        }
        else {
            *(undefined1 *)(y + 0x4814) = 1;
        }
        if (iVar4 < iVar1 + 0x3fff) {
            *(char *)(y + 0x806 + iVar4 % 0x4000) = (char)z;
            uVar5 = iVar4 + 1;
            uVar3 = iVar4 + 0x4000;
            if (-1 < (int)uVar5) {
                uVar3 = uVar5;
            }
            iVar4 = iVar4 + 2;
            *(char *)(y + 0x806 + (uVar5 - (uVar3 & 0xffffc000))) = (char)((uint)z >> 8);
            *(int *)(y + 0x4810) = iVar4;
        }
        else {
            *(undefined1 *)(y + 0x4814) = 1;
        }
        if (iVar4 < iVar1 + 0x3fff) {
            *(char *)(y + 0x806 + iVar4 % 0x4000) = (char)in_stack_0000000c;
            uVar5 = iVar4 + 1;
            uVar3 = iVar4 + 0x4000;
            if (-1 < (int)uVar5) {
                uVar3 = uVar5;
            }
            iVar4 = iVar4 + 2;
            *(char *)(y + 0x806 + (uVar5 - (uVar3 & 0xffffc000))) =
                 (char)((uint)in_stack_0000000c >> 8);
            *(int *)(y + 0x4810) = iVar4;
        }
        else {
            *(undefined1 *)(y + 0x4814) = 1;
        }
        if (iVar4 < iVar1 + 0x4000) {
            *(undefined1 *)(y + 0x806 + iVar4 % 0x4000) = in_stack_00000010;
            *(int *)(y + 0x4810) = iVar4 + 1;
        }
        else {
            *(undefined1 *)(y + 0x4814) = 1;
        }
        Skip = -1;
        SendMapPoint();
        SkipFlush((TConnection *)y);
        FinishSendData((TConnection *)y);
        return;
    }
    return;
}



void SendCloseContainer(TConnection *Connection,int ContNr)

{
    int iVar1;
    bool bVar2;
    int iVar3;
    
    bVar2 = BeginSendData(Connection);
    if (bVar2) {
        iVar1 = Connection->NextToSend;
        iVar3 = Connection->NextToWrite;
        if (iVar3 < iVar1 + 0x4000) {
            Connection->OutData[iVar3 % 0x4000] = 'o';
            iVar3 = iVar3 + 1;
            Connection->NextToWrite = iVar3;
        }
        else {
            Connection->Overflow = true;
        }
        if (iVar3 < iVar1 + 0x4000) {
            Connection->OutData[iVar3 % 0x4000] = (uchar)ContNr;
            Connection->NextToWrite = iVar3 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        FinishSendData(Connection);
        return;
    }
    return;
}



void SendContainer(TConnection *Connection,int ContNr)

{
    int iVar1;
    bool bVar2;
    uchar uVar3;
    TPlayer *pl;
    TPlayer *Window;
    ulong uVar4;
    char *__s;
    size_t Length;
    uint uVar5;
    int iVar6;
    uint uVar7;
    undefined2 uVar8;
    int *piVar9;
    undefined4 uVar10;
    int local_6c;
    int Count;
    int local_60;
    Object local_5c [4];
    Object local_4c [4];
    Object local_3c [4];
    Object local_2c;
    Object Obj;
    
    bVar2 = BeginSendData(Connection);
    if (!bVar2) {
        return;
    }
    iVar1 = Connection->NextToSend;
    iVar6 = Connection->NextToWrite;
    if (iVar6 < iVar1 + 0x4000) {
        Connection->OutData[iVar6 % 0x4000] = 'n';
        iVar6 = iVar6 + 1;
        Connection->NextToWrite = iVar6;
    }
    else {
        Connection->Overflow = true;
    }
    if (iVar6 < iVar1 + 0x4000) {
        Connection->OutData[iVar6 % 0x4000] = (uchar)ContNr;
        Connection->NextToWrite = iVar6 + 1;
    }
    else {
        Connection->Overflow = true;
    }
    Window = TConnection::GetPlayer(Connection);
    if (Window == (TPlayer *)0x0) {
        error(&DAT_081091c0);
        return;
    }
    iVar6 = ContNr;
    TPlayer::GetOpenContainer((TPlayer *)&local_2c,(int)Window);
    bVar2 = Object::exists(&local_2c);
    if (!bVar2) {
        error("SendContainer: Container %d existiert nicht.\n",ContNr,iVar6);
        return;
    }
    local_3c[0].ObjectID = local_2c.ObjectID;
    Object::getObjectType(local_4c);
    bVar2 = ObjectType::getFlag((ObjectType *)local_4c,DISGUISE);
    if (bVar2) {
        Object::getObjectType(local_4c);
        uVar4 = ObjectType::getAttribute((ObjectType *)local_4c,DISGUISETARGET);
        uVar8 = (undefined2)uVar4;
    }
    else {
        Object::getObjectType(local_4c);
        uVar8 = (undefined2)local_4c[0].ObjectID;
    }
    iVar6 = Connection->NextToWrite;
    if (iVar6 < Connection->NextToSend + 0x3fff) {
        Connection->OutData[iVar6 % 0x4000] = (uchar)uVar8;
        uVar7 = iVar6 + 1;
        uVar5 = iVar6 + 0x4000;
        if (-1 < (int)uVar7) {
            uVar5 = uVar7;
        }
        *(char *)((int)Connection + (uVar7 - (uVar5 & 0xffffc000)) + 0x806) =
             (char)((ushort)uVar8 >> 8);
        Connection->NextToWrite = iVar6 + 2;
    }
    else {
        Connection->Overflow = true;
    }
    Object::getObjectType(local_4c);
    uVar10 = 0xffffffff;
    __s = ObjectType::getName((ObjectType *)local_4c);
    if (__s == (char *)0x0) {
        error("SendString: String ist NULL.\n",uVar10);
    }
    else {
        Length = strlen(__s);
        iVar6 = Connection->NextToWrite;
        if (iVar6 < Connection->NextToSend + 0x3fff) {
            Count._0_1_ = (uchar)(Length & 0xffff);
            Connection->OutData[iVar6 % 0x4000] = (uchar)Count;
            uVar7 = iVar6 + 1;
            uVar5 = iVar6 + 0x4000;
            if (-1 < (int)uVar7) {
                uVar5 = uVar7;
            }
            Count._0_1_ = (uchar)((Length & 0xffff) >> 8);
            *(uchar *)((int)Connection + (uVar7 - (uVar5 & 0xffffc000)) + 0x806) = (uchar)Count;
            Connection->NextToWrite = iVar6 + 2;
        }
        else {
            Connection->Overflow = true;
        }
        if (0 < (int)Length) {
            SendText(Connection,__s,Length);
        }
    }
    Object::getObjectType(local_4c);
    uVar4 = ObjectType::getAttribute((ObjectType *)local_4c,CAPACITY);
    iVar6 = Connection->NextToWrite;
    if (iVar6 < Connection->NextToSend + 0x4000) {
        Connection->OutData[iVar6 % 0x4000] = (uchar)uVar4;
        Connection->NextToWrite = iVar6 + 1;
    }
    else {
        Connection->Overflow = true;
    }
    Object::getContainer(local_4c);
    Object::getObjectType(local_3c);
    if ((_func_int_varargs **)local_3c[0].ObjectID != (_func_int_varargs **)0x0) {
        Object::getContainer(local_3c);
        Object::getObjectType(local_5c);
        bVar2 = false;
        if ((0 < (int)local_5c[0].ObjectID) && ((int)local_5c[0].ObjectID < 0xb)) {
            bVar2 = true;
        }
        uVar3 = '\x01';
        if (!bVar2) goto LAB_080ce9df;
    }
    uVar3 = '\0';
LAB_080ce9df:
    iVar6 = Connection->NextToWrite;
    if (iVar6 < Connection->NextToSend + 0x4000) {
        Connection->OutData[iVar6 % 0x4000] = uVar3;
        Connection->NextToWrite = iVar6 + 1;
    }
    else {
        Connection->Overflow = true;
    }
    local_5c[0].ObjectID = local_2c.ObjectID;
    local_60 = CountObjectsInContainer(local_5c);
    iVar6 = Connection->NextToWrite;
    piVar9 = &OBJECTS_PER_CONTAINER;
    if (local_60 < 0x25) {
        piVar9 = &local_60;
    }
    if (iVar6 < Connection->NextToSend + 0x4000) {
        Connection->OutData[iVar6 % 0x4000] = (uchar)*piVar9;
        Connection->NextToWrite = iVar6 + 1;
    }
    else {
        Connection->Overflow = true;
    }
    local_6c = 0;
    local_3c[0].ObjectID = local_2c.ObjectID;
    GetFirstContainerObject(local_4c);
    local_2c.ObjectID = local_4c[0].ObjectID;
    while( true ) {
        bVar2 = false;
        local_5c[0].ObjectID = NONE.ObjectID;
        local_4c[0].ObjectID = NONE.ObjectID;
        if ((local_2c.ObjectID != NONE.ObjectID) && (local_6c < 0x24)) {
            bVar2 = true;
        }
        if (!bVar2) break;
        local_5c[0].ObjectID = local_2c.ObjectID;
        Object::getObjectType(local_4c);
        bVar2 = ObjectType::getFlag((ObjectType *)local_4c,DISGUISE);
        if (bVar2) {
            Object::getObjectType(local_4c);
            uVar4 = ObjectType::getAttribute((ObjectType *)local_4c,DISGUISETARGET);
            uVar8 = (undefined2)uVar4;
        }
        else {
            Object::getObjectType(local_4c);
            uVar8 = (undefined2)local_4c[0].ObjectID;
        }
        iVar6 = Connection->NextToWrite;
        if (iVar6 < Connection->NextToSend + 0x3fff) {
            Connection->OutData[iVar6 % 0x4000] = (uchar)uVar8;
            uVar7 = iVar6 + 1;
            uVar5 = iVar6 + 0x4000;
            if (-1 < (int)uVar7) {
                uVar5 = uVar7;
            }
            *(char *)((int)Connection + (uVar7 - (uVar5 & 0xffffc000)) + 0x806) =
                 (char)((ushort)uVar8 >> 8);
            Connection->NextToWrite = iVar6 + 2;
        }
        else {
            Connection->Overflow = true;
        }
        Object::getObjectType(local_5c);
        bVar2 = ObjectType::getFlag((ObjectType *)local_5c,LIQUIDCONTAINER);
        if (bVar2) {
            uVar4 = Object::getAttribute(&local_2c,CONTAINERLIQUIDTYPE);
            uVar3 = GetLiquidColor(uVar4);
            iVar6 = Connection->NextToWrite;
            if (iVar6 < Connection->NextToSend + 0x4000) {
                Connection->OutData[iVar6 % 0x4000] = uVar3;
                Connection->NextToWrite = iVar6 + 1;
            }
            else {
                Connection->Overflow = true;
            }
        }
        Object::getObjectType(local_5c);
        bVar2 = ObjectType::getFlag((ObjectType *)local_5c,LIQUIDPOOL);
        if (bVar2) {
            uVar4 = Object::getAttribute(&local_2c,POOLLIQUIDTYPE);
            uVar3 = GetLiquidColor(uVar4);
            iVar6 = Connection->NextToWrite;
            if (iVar6 < Connection->NextToSend + 0x4000) {
                Connection->OutData[iVar6 % 0x4000] = uVar3;
                Connection->NextToWrite = iVar6 + 1;
            }
            else {
                Connection->Overflow = true;
            }
        }
        Object::getObjectType(local_5c);
        bVar2 = ObjectType::getFlag((ObjectType *)local_5c,CUMULATIVE);
        if (bVar2) {
            uVar4 = Object::getAttribute(&local_2c,AMOUNT);
            iVar6 = Connection->NextToWrite;
            if (iVar6 < Connection->NextToSend + 0x4000) {
                Connection->OutData[iVar6 % 0x4000] = (uchar)uVar4;
                Connection->NextToWrite = iVar6 + 1;
            }
            else {
                Connection->Overflow = true;
            }
        }
        Object::getNextObject(local_4c);
        local_2c.ObjectID = local_4c[0].ObjectID;
        local_6c = local_6c + 1;
    }
    FinishSendData(Connection);
    return;
}



void SendCreateInContainer(TConnection *Connection,int ContNr,Object *Obj)

{
    int iVar1;
    bool bVar2;
    uchar uVar3;
    ulong uVar4;
    uint uVar5;
    int iVar6;
    uint uVar7;
    Object local_3c [4];
    ulong local_2c;
    
    bVar2 = BeginSendData(Connection);
    if (bVar2) {
        bVar2 = Object::exists(Obj);
        if (bVar2) {
            iVar1 = Connection->NextToSend;
            iVar6 = Connection->NextToWrite;
            if (iVar6 < iVar1 + 0x4000) {
                Connection->OutData[iVar6 % 0x4000] = 'p';
                iVar6 = iVar6 + 1;
                Connection->NextToWrite = iVar6;
            }
            else {
                Connection->Overflow = true;
            }
            if (iVar6 < iVar1 + 0x4000) {
                Connection->OutData[iVar6 % 0x4000] = (uchar)ContNr;
                Connection->NextToWrite = iVar6 + 1;
            }
            else {
                Connection->Overflow = true;
            }
            local_2c = Obj->ObjectID;
            Object::getObjectType(local_3c);
            bVar2 = ObjectType::getFlag((ObjectType *)local_3c,DISGUISE);
            if (bVar2) {
                Object::getObjectType(local_3c);
                uVar4 = ObjectType::getAttribute((ObjectType *)local_3c,DISGUISETARGET);
                local_3c[0].ObjectID._0_2_ = (undefined2)uVar4;
            }
            else {
                Object::getObjectType(local_3c);
            }
            iVar6 = Connection->NextToWrite;
            if (iVar6 < Connection->NextToSend + 0x3fff) {
                Connection->OutData[iVar6 % 0x4000] = (uchar)(undefined2)local_3c[0].ObjectID;
                uVar7 = iVar6 + 1;
                uVar5 = iVar6 + 0x4000;
                if (-1 < (int)uVar7) {
                    uVar5 = uVar7;
                }
                *(char *)((int)Connection + (uVar7 - (uVar5 & 0xffffc000)) + 0x806) =
                     (char)((ushort)(undefined2)local_3c[0].ObjectID >> 8);
                Connection->NextToWrite = iVar6 + 2;
            }
            else {
                Connection->Overflow = true;
            }
            Object::getObjectType(local_3c);
            bVar2 = ObjectType::getFlag((ObjectType *)local_3c,LIQUIDCONTAINER);
            if (bVar2) {
                uVar4 = Object::getAttribute(Obj,CONTAINERLIQUIDTYPE);
                uVar3 = GetLiquidColor(uVar4);
                iVar6 = Connection->NextToWrite;
                if (iVar6 < Connection->NextToSend + 0x4000) {
                    Connection->OutData[iVar6 % 0x4000] = uVar3;
                    Connection->NextToWrite = iVar6 + 1;
                }
                else {
                    Connection->Overflow = true;
                }
            }
            Object::getObjectType(local_3c);
            bVar2 = ObjectType::getFlag((ObjectType *)local_3c,LIQUIDPOOL);
            if (bVar2) {
                uVar4 = Object::getAttribute(Obj,POOLLIQUIDTYPE);
                uVar3 = GetLiquidColor(uVar4);
                iVar6 = Connection->NextToWrite;
                if (iVar6 < Connection->NextToSend + 0x4000) {
                    Connection->OutData[iVar6 % 0x4000] = uVar3;
                    Connection->NextToWrite = iVar6 + 1;
                }
                else {
                    Connection->Overflow = true;
                }
            }
            Object::getObjectType(local_3c);
            bVar2 = ObjectType::getFlag((ObjectType *)local_3c,CUMULATIVE);
            if (bVar2) {
                uVar4 = Object::getAttribute(Obj,AMOUNT);
                iVar6 = Connection->NextToWrite;
                if (iVar6 < Connection->NextToSend + 0x4000) {
                    Connection->OutData[iVar6 % 0x4000] = (uchar)uVar4;
                    Connection->NextToWrite = iVar6 + 1;
                }
                else {
                    Connection->Overflow = true;
                }
            }
            FinishSendData(Connection);
        }
        else {
            error(&DAT_08109200);
        }
    }
    return;
}



void SendChangeInContainer(TConnection *Connection,int ContNr,Object *Obj)

{
    int iVar1;
    bool bVar2;
    uchar uVar3;
    int iVar4;
    ulong uVar5;
    uint uVar6;
    int iVar7;
    uint uVar8;
    uchar local_40;
    int RNum;
    Object local_2c [7];
    
    bVar2 = BeginSendData(Connection);
    if (bVar2) {
        bVar2 = Object::exists(Obj);
        if (bVar2) {
            local_2c[0] = (Object)Obj->ObjectID;
            iVar4 = GetObjectRNum(local_2c);
            if (iVar4 < 0x24) {
                iVar1 = Connection->NextToSend;
                iVar7 = Connection->NextToWrite;
                if (iVar7 < iVar1 + 0x4000) {
                    Connection->OutData[iVar7 % 0x4000] = 'q';
                    iVar7 = iVar7 + 1;
                    Connection->NextToWrite = iVar7;
                }
                else {
                    Connection->Overflow = true;
                }
                if (iVar7 < iVar1 + 0x4000) {
                    Connection->OutData[iVar7 % 0x4000] = (uchar)ContNr;
                    iVar7 = iVar7 + 1;
                    Connection->NextToWrite = iVar7;
                }
                else {
                    Connection->Overflow = true;
                }
                if (iVar7 < iVar1 + 0x4000) {
                    local_40 = (uchar)iVar4;
                    Connection->NextToWrite = iVar7 + 1;
                    Connection->OutData[iVar7 % 0x4000] = local_40;
                }
                else {
                    Connection->Overflow = true;
                }
                local_2c[0] = (Object)Obj->ObjectID;
                Object::getObjectType((Object *)&RNum);
                bVar2 = ObjectType::getFlag((ObjectType *)&RNum,DISGUISE);
                if (bVar2) {
                    Object::getObjectType((Object *)&RNum);
                    uVar5 = ObjectType::getAttribute((ObjectType *)&RNum,DISGUISETARGET);
                    RNum._0_2_ = (undefined2)uVar5;
                }
                else {
                    Object::getObjectType((Object *)&RNum);
                }
                iVar4 = Connection->NextToWrite;
                if (iVar4 < Connection->NextToSend + 0x3fff) {
                    Connection->OutData[iVar4 % 0x4000] = (uchar)(undefined2)RNum;
                    uVar8 = iVar4 + 1;
                    uVar6 = iVar4 + 0x4000;
                    if (-1 < (int)uVar8) {
                        uVar6 = uVar8;
                    }
                    *(char *)((int)Connection + (uVar8 - (uVar6 & 0xffffc000)) + 0x806) =
                         (char)((ushort)(undefined2)RNum >> 8);
                    Connection->NextToWrite = iVar4 + 2;
                }
                else {
                    Connection->Overflow = true;
                }
                Object::getObjectType((Object *)&RNum);
                bVar2 = ObjectType::getFlag((ObjectType *)&RNum,LIQUIDCONTAINER);
                if (bVar2) {
                    uVar5 = Object::getAttribute(Obj,CONTAINERLIQUIDTYPE);
                    uVar3 = GetLiquidColor(uVar5);
                    iVar4 = Connection->NextToWrite;
                    if (iVar4 < Connection->NextToSend + 0x4000) {
                        Connection->OutData[iVar4 % 0x4000] = uVar3;
                        Connection->NextToWrite = iVar4 + 1;
                    }
                    else {
                        Connection->Overflow = true;
                    }
                }
                Object::getObjectType((Object *)&RNum);
                bVar2 = ObjectType::getFlag((ObjectType *)&RNum,LIQUIDPOOL);
                if (bVar2) {
                    uVar5 = Object::getAttribute(Obj,POOLLIQUIDTYPE);
                    uVar3 = GetLiquidColor(uVar5);
                    iVar4 = Connection->NextToWrite;
                    if (iVar4 < Connection->NextToSend + 0x4000) {
                        Connection->OutData[iVar4 % 0x4000] = uVar3;
                        Connection->NextToWrite = iVar4 + 1;
                    }
                    else {
                        Connection->Overflow = true;
                    }
                }
                Object::getObjectType((Object *)&RNum);
                bVar2 = ObjectType::getFlag((ObjectType *)&RNum,CUMULATIVE);
                if (bVar2) {
                    uVar5 = Object::getAttribute(Obj,AMOUNT);
                    iVar4 = Connection->NextToWrite;
                    if (iVar4 < Connection->NextToSend + 0x4000) {
                        Connection->OutData[iVar4 % 0x4000] = (uchar)uVar5;
                        Connection->NextToWrite = iVar4 + 1;
                    }
                    else {
                        Connection->Overflow = true;
                    }
                }
                FinishSendData(Connection);
            }
        }
        else {
            error(&DAT_08109240);
        }
    }
    return;
}



void SendDeleteInContainer(TConnection *Connection,int ContNr,Object *Obj)

{
    int iVar1;
    bool bVar2;
    int iVar3;
    int iVar4;
    int RNum;
    Object local_2c [7];
    
    bVar2 = BeginSendData(Connection);
    if (bVar2) {
        bVar2 = Object::exists(Obj);
        if (bVar2) {
            local_2c[0] = (Object)Obj->ObjectID;
            iVar3 = GetObjectRNum(local_2c);
            if (iVar3 < 0x24) {
                iVar1 = Connection->NextToSend;
                iVar4 = Connection->NextToWrite;
                if (iVar4 < iVar1 + 0x4000) {
                    Connection->OutData[iVar4 % 0x4000] = 'r';
                    iVar4 = iVar4 + 1;
                    Connection->NextToWrite = iVar4;
                }
                else {
                    Connection->Overflow = true;
                }
                if (iVar4 < iVar1 + 0x4000) {
                    Connection->OutData[iVar4 % 0x4000] = (uchar)ContNr;
                    iVar4 = iVar4 + 1;
                    Connection->NextToWrite = iVar4;
                }
                else {
                    Connection->Overflow = true;
                }
                if (iVar4 < iVar1 + 0x4000) {
                    Connection->OutData[iVar4 % 0x4000] = (uchar)iVar3;
                    Connection->NextToWrite = iVar4 + 1;
                }
                else {
                    Connection->Overflow = true;
                }
                FinishSendData(Connection);
            }
        }
        else {
            error(&DAT_08109280);
        }
    }
    return;
}



void SendBodyInventory(TConnection *Connection,ulong CreatureID)

{
    int Position;
    int Position_00;
    Object local_4c [4];
    ulong local_3c;
    ulong local_2c;
    Object Obj;
    
    Position_00 = 1;
    do {
        GetBodyObject((ulong)&local_2c,CreatureID);
        local_3c = NONE.ObjectID;
        local_4c[0].ObjectID = NONE.ObjectID;
        if (local_2c != NONE.ObjectID) {
            local_4c[0].ObjectID = local_2c;
            SendSetInventory(Connection,Position_00,local_4c);
        }
        Position_00 = Position_00 + 1;
    } while (Position_00 < 0xb);
    return;
}



void SendSetInventory(TConnection *Connection,int Position,Object *Obj)

{
    int iVar1;
    bool bVar2;
    uchar uVar3;
    ulong uVar4;
    uint uVar5;
    int iVar6;
    uint uVar7;
    Object local_3c [4];
    ulong local_2c;
    
    bVar2 = BeginSendData(Connection);
    if (bVar2) {
        iVar1 = Connection->NextToSend;
        iVar6 = Connection->NextToWrite;
        if (iVar6 < iVar1 + 0x4000) {
            Connection->OutData[iVar6 % 0x4000] = 'x';
            iVar6 = iVar6 + 1;
            Connection->NextToWrite = iVar6;
        }
        else {
            Connection->Overflow = true;
        }
        if (iVar6 < iVar1 + 0x4000) {
            Connection->OutData[iVar6 % 0x4000] = (uchar)Position;
            Connection->NextToWrite = iVar6 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        bVar2 = Object::exists(Obj);
        if (bVar2) {
            local_2c = Obj->ObjectID;
            Object::getObjectType(local_3c);
            bVar2 = ObjectType::getFlag((ObjectType *)local_3c,DISGUISE);
            if (bVar2) {
                Object::getObjectType(local_3c);
                uVar4 = ObjectType::getAttribute((ObjectType *)local_3c,DISGUISETARGET);
                local_3c[0].ObjectID._0_2_ = (undefined2)uVar4;
            }
            else {
                Object::getObjectType(local_3c);
            }
            iVar6 = Connection->NextToWrite;
            if (iVar6 < Connection->NextToSend + 0x3fff) {
                Connection->OutData[iVar6 % 0x4000] = (uchar)(undefined2)local_3c[0].ObjectID;
                uVar7 = iVar6 + 1;
                uVar5 = iVar6 + 0x4000;
                if (-1 < (int)uVar7) {
                    uVar5 = uVar7;
                }
                *(char *)((int)Connection + (uVar7 - (uVar5 & 0xffffc000)) + 0x806) =
                     (char)((ushort)(undefined2)local_3c[0].ObjectID >> 8);
                Connection->NextToWrite = iVar6 + 2;
            }
            else {
                Connection->Overflow = true;
            }
            Object::getObjectType(local_3c);
            bVar2 = ObjectType::getFlag((ObjectType *)local_3c,LIQUIDCONTAINER);
            if (bVar2) {
                uVar4 = Object::getAttribute(Obj,CONTAINERLIQUIDTYPE);
                uVar3 = GetLiquidColor(uVar4);
                iVar6 = Connection->NextToWrite;
                if (iVar6 < Connection->NextToSend + 0x4000) {
                    Connection->OutData[iVar6 % 0x4000] = uVar3;
                    Connection->NextToWrite = iVar6 + 1;
                }
                else {
                    Connection->Overflow = true;
                }
            }
            Object::getObjectType(local_3c);
            bVar2 = ObjectType::getFlag((ObjectType *)local_3c,LIQUIDPOOL);
            if (bVar2) {
                uVar4 = Object::getAttribute(Obj,POOLLIQUIDTYPE);
                uVar3 = GetLiquidColor(uVar4);
                iVar6 = Connection->NextToWrite;
                if (iVar6 < Connection->NextToSend + 0x4000) {
                    Connection->OutData[iVar6 % 0x4000] = uVar3;
                    Connection->NextToWrite = iVar6 + 1;
                }
                else {
                    Connection->Overflow = true;
                }
            }
            Object::getObjectType(local_3c);
            bVar2 = ObjectType::getFlag((ObjectType *)local_3c,CUMULATIVE);
            if (bVar2) {
                uVar4 = Object::getAttribute(Obj,AMOUNT);
                iVar6 = Connection->NextToWrite;
                if (iVar6 < Connection->NextToSend + 0x4000) {
                    Connection->OutData[iVar6 % 0x4000] = (uchar)uVar4;
                    Connection->NextToWrite = iVar6 + 1;
                }
                else {
                    Connection->Overflow = true;
                }
            }
            FinishSendData(Connection);
        }
        else {
            error("SendSetInventory: Objekt existiert nicht.\n");
        }
    }
    return;
}



void SendDeleteInventory(TConnection *Connection,int Position)

{
    int iVar1;
    bool bVar2;
    int iVar3;
    
    bVar2 = BeginSendData(Connection);
    if (bVar2) {
        iVar1 = Connection->NextToSend;
        iVar3 = Connection->NextToWrite;
        if (iVar3 < iVar1 + 0x4000) {
            Connection->OutData[iVar3 % 0x4000] = 'y';
            iVar3 = iVar3 + 1;
            Connection->NextToWrite = iVar3;
        }
        else {
            Connection->Overflow = true;
        }
        if (iVar3 < iVar1 + 0x4000) {
            Connection->OutData[iVar3 % 0x4000] = (uchar)Position;
            Connection->NextToWrite = iVar3 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        FinishSendData(Connection);
        return;
    }
    return;
}



void SendTradeObjects(TConnection *Connection,Object *Obj)

{
    int iVar1;
    bool bVar2;
    uchar uVar3;
    ulong uVar4;
    uint uVar5;
    uint uVar6;
    Object local_4c [4];
    Object local_3c [4];
    Object local_2c [7];
    
    bVar2 = Object::exists(Obj);
    if (bVar2) {
        local_2c[0] = (Object)Obj->ObjectID;
        Object::getObjectType(local_3c);
        bVar2 = ObjectType::getFlag((ObjectType *)local_3c,DISGUISE);
        if (bVar2) {
            Object::getObjectType(local_3c);
            uVar4 = ObjectType::getAttribute((ObjectType *)local_3c,DISGUISETARGET);
            local_3c[0].ObjectID._0_2_ = (undefined2)uVar4;
        }
        else {
            Object::getObjectType(local_3c);
        }
        iVar1 = Connection->NextToWrite;
        if (iVar1 < Connection->NextToSend + 0x3fff) {
            Connection->OutData[iVar1 % 0x4000] = (uchar)(undefined2)local_3c[0].ObjectID;
            uVar6 = iVar1 + 1;
            uVar5 = iVar1 + 0x4000;
            if (-1 < (int)uVar6) {
                uVar5 = uVar6;
            }
            *(char *)((int)Connection + (uVar6 - (uVar5 & 0xffffc000)) + 0x806) =
                 (char)((ushort)(undefined2)local_3c[0].ObjectID >> 8);
            Connection->NextToWrite = iVar1 + 2;
        }
        else {
            Connection->Overflow = true;
        }
        Object::getObjectType(local_3c);
        bVar2 = ObjectType::getFlag((ObjectType *)local_3c,LIQUIDCONTAINER);
        if (bVar2) {
            uVar4 = Object::getAttribute(Obj,CONTAINERLIQUIDTYPE);
            uVar3 = GetLiquidColor(uVar4);
            iVar1 = Connection->NextToWrite;
            if (iVar1 < Connection->NextToSend + 0x4000) {
                Connection->OutData[iVar1 % 0x4000] = uVar3;
                Connection->NextToWrite = iVar1 + 1;
            }
            else {
                Connection->Overflow = true;
            }
        }
        Object::getObjectType(local_3c);
        bVar2 = ObjectType::getFlag((ObjectType *)local_3c,LIQUIDPOOL);
        if (bVar2) {
            uVar4 = Object::getAttribute(Obj,POOLLIQUIDTYPE);
            uVar3 = GetLiquidColor(uVar4);
            iVar1 = Connection->NextToWrite;
            if (iVar1 < Connection->NextToSend + 0x4000) {
                Connection->OutData[iVar1 % 0x4000] = uVar3;
                Connection->NextToWrite = iVar1 + 1;
            }
            else {
                Connection->Overflow = true;
            }
        }
        Object::getObjectType(local_3c);
        bVar2 = ObjectType::getFlag((ObjectType *)local_3c,CUMULATIVE);
        if (bVar2) {
            uVar4 = Object::getAttribute(Obj,AMOUNT);
            iVar1 = Connection->NextToWrite;
            if (iVar1 < Connection->NextToSend + 0x4000) {
                Connection->OutData[iVar1 % 0x4000] = (uchar)uVar4;
                Connection->NextToWrite = iVar1 + 1;
            }
            else {
                Connection->Overflow = true;
            }
        }
        Object::getObjectType(local_3c);
        bVar2 = ObjectType::getFlag((ObjectType *)local_3c,CONTAINER);
        if (bVar2) {
            local_4c[0] = (Object)Obj->ObjectID;
            GetFirstContainerObject(local_2c);
            Obj->ObjectID = (ulong)local_2c[0];
            if (local_2c[0].ObjectID != NONE.ObjectID) {
                do {
                    local_4c[0] = (Object)Obj->ObjectID;
                    local_3c[0].ObjectID = NONE.ObjectID;
                    SendTradeObjects(Connection,local_4c);
                    Object::getNextObject(local_3c);
                    Obj->ObjectID = (ulong)local_3c[0];
                } while (local_3c[0].ObjectID != NONE.ObjectID);
            }
        }
    }
    return;
}



void SendTradeOffer(TConnection *Connection,char *Name,bool OwnOffer,Object *Obj)

{
    int iVar1;
    bool bVar2;
    size_t Length;
    int iVar3;
    uint uVar4;
    uint uVar5;
    char *Text;
    Object local_2c [7];
    
    bVar2 = BeginSendData(Connection);
    if (bVar2) {
        iVar1 = Connection->NextToSend;
        iVar3 = Connection->NextToWrite;
        if (iVar3 < iVar1 + 0x4000) {
            Connection->OutData[iVar3 % 0x4000] = !OwnOffer + '}';
            Connection->NextToWrite = iVar3 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        if (Name == (char *)0x0) {
            Text = "SendTradeOffer: Name ist NULL.\n";
        }
        else {
            Length = strlen(Name);
            iVar3 = Connection->NextToWrite;
            if (iVar3 < iVar1 + 0x3fff) {
                Connection->OutData[iVar3 % 0x4000] = (uchar)(Length & 0xffff);
                uVar5 = iVar3 + 1;
                uVar4 = iVar3 + 0x4000;
                if (-1 < (int)uVar5) {
                    uVar4 = uVar5;
                }
                *(char *)((int)Connection + (uVar5 - (uVar4 & 0xffffc000)) + 0x806) =
                     (char)((Length & 0xffff) >> 8);
                Connection->NextToWrite = iVar3 + 2;
            }
            else {
                Connection->Overflow = true;
            }
            if (0 < (int)Length) {
                SendText(Connection,Name,Length);
            }
            bVar2 = Object::exists(Obj);
            if (bVar2) {
                local_2c[0] = (Object)Obj->ObjectID;
                iVar3 = CountObjects(local_2c);
                iVar1 = Connection->NextToWrite;
                if (iVar1 < Connection->NextToSend + 0x4000) {
                    Connection->OutData[iVar1 % 0x4000] = (uchar)iVar3;
                    Connection->NextToWrite = iVar1 + 1;
                }
                else {
                    Connection->Overflow = true;
                }
                local_2c[0] = (Object)Obj->ObjectID;
                SendTradeObjects(Connection,local_2c);
                FinishSendData(Connection);
                return;
            }
            Text = "SendTradeOffer: Objekt existiert nicht.\n";
        }
        error(Text);
    }
    return;
}



void SendCloseTrade(TConnection *Connection)

{
    int iVar1;
    bool bVar2;
    
    bVar2 = BeginSendData(Connection);
    if (bVar2) {
        iVar1 = Connection->NextToWrite;
        if (iVar1 < Connection->NextToSend + 0x4000) {
            Connection->OutData[iVar1 % 0x4000] = '\x7f';
            Connection->NextToWrite = iVar1 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        FinishSendData(Connection);
        return;
    }
    return;
}



void SendAddField(TConnection *Connection,int x,int y,int z,Object *Obj)

{
    int iVar1;
    bool bVar2;
    uint uVar3;
    int iVar4;
    uint uVar5;
    Object local_2c [7];
    
    bVar2 = BeginSendData(Connection);
    if (bVar2) {
        iVar1 = Connection->NextToSend;
        iVar4 = Connection->NextToWrite;
        if (iVar4 < iVar1 + 0x4000) {
            Connection->OutData[iVar4 % 0x4000] = 'j';
            iVar4 = iVar4 + 1;
            Connection->NextToWrite = iVar4;
        }
        else {
            Connection->Overflow = true;
        }
        if (iVar4 < iVar1 + 0x3fff) {
            Connection->OutData[iVar4 % 0x4000] = (uchar)x;
            uVar5 = iVar4 + 1;
            uVar3 = iVar4 + 0x4000;
            if (-1 < (int)uVar5) {
                uVar3 = uVar5;
            }
            iVar4 = iVar4 + 2;
            *(char *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) =
                 (char)((uint)x >> 8);
            Connection->NextToWrite = iVar4;
        }
        else {
            Connection->Overflow = true;
        }
        if (iVar4 < iVar1 + 0x3fff) {
            Connection->OutData[iVar4 % 0x4000] = (uchar)y;
            uVar5 = iVar4 + 1;
            uVar3 = iVar4 + 0x4000;
            if (-1 < (int)uVar5) {
                uVar3 = uVar5;
            }
            iVar4 = iVar4 + 2;
            *(char *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) =
                 (char)((uint)y >> 8);
            Connection->NextToWrite = iVar4;
        }
        else {
            Connection->Overflow = true;
        }
        if (iVar4 < iVar1 + 0x4000) {
            Connection->OutData[iVar4 % 0x4000] = (uchar)z;
            Connection->NextToWrite = iVar4 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        bVar2 = Object::exists(Obj);
        if (bVar2) {
            local_2c[0] = (Object)Obj->ObjectID;
            SendMapObject(Connection,local_2c);
            FinishSendData(Connection);
        }
        else {
            error(&DAT_08109360);
        }
    }
    return;
}



void SendDeleteField(TConnection *Connection,int x,int y,int z,Object *Obj)

{
    int iVar1;
    bool bVar2;
    int iVar3;
    uint uVar4;
    int RNum;
    uint uVar5;
    Object local_2c [7];
    
    bVar2 = BeginSendData(Connection);
    if (bVar2) {
        iVar1 = Connection->NextToSend;
        iVar3 = Connection->NextToWrite;
        if (iVar3 < iVar1 + 0x4000) {
            Connection->OutData[iVar3 % 0x4000] = 'l';
            iVar3 = iVar3 + 1;
            Connection->NextToWrite = iVar3;
        }
        else {
            Connection->Overflow = true;
        }
        if (iVar3 < iVar1 + 0x3fff) {
            Connection->OutData[iVar3 % 0x4000] = (uchar)x;
            uVar5 = iVar3 + 1;
            uVar4 = iVar3 + 0x4000;
            if (-1 < (int)uVar5) {
                uVar4 = uVar5;
            }
            *(char *)((int)Connection + (uVar5 - (uVar4 & 0xffffc000)) + 0x806) =
                 (char)((uint)x >> 8);
            iVar3 = iVar3 + 2;
            Connection->NextToWrite = iVar3;
        }
        else {
            Connection->Overflow = true;
        }
        if (iVar3 < iVar1 + 0x3fff) {
            Connection->OutData[iVar3 % 0x4000] = (uchar)y;
            uVar5 = iVar3 + 1;
            uVar4 = iVar3 + 0x4000;
            if (-1 < (int)uVar5) {
                uVar4 = uVar5;
            }
            *(char *)((int)Connection + (uVar5 - (uVar4 & 0xffffc000)) + 0x806) =
                 (char)((uint)y >> 8);
            iVar3 = iVar3 + 2;
            Connection->NextToWrite = iVar3;
        }
        else {
            Connection->Overflow = true;
        }
        if (iVar3 < iVar1 + 0x4000) {
            Connection->OutData[iVar3 % 0x4000] = (uchar)z;
            Connection->NextToWrite = iVar3 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        bVar2 = Object::exists(Obj);
        if (bVar2) {
            local_2c[0] = (Object)Obj->ObjectID;
            iVar3 = GetObjectRNum(local_2c);
            if (iVar3 < 10) {
                iVar1 = Connection->NextToWrite;
                if (iVar1 < Connection->NextToSend + 0x4000) {
                    Connection->OutData[iVar1 % 0x4000] = (uchar)iVar3;
                    Connection->NextToWrite = iVar1 + 1;
                }
                else {
                    Connection->Overflow = true;
                }
                FinishSendData(Connection);
            }
        }
        else {
            error(&DAT_08109360);
        }
    }
    return;
}



void SendChangeField(TConnection *Connection,int x,int y,int z,Object *Obj)

{
    int iVar1;
    bool bVar2;
    int iVar3;
    uint uVar4;
    int RNum;
    uint uVar5;
    Object local_2c [7];
    
    bVar2 = BeginSendData(Connection);
    if (bVar2) {
        iVar1 = Connection->NextToSend;
        iVar3 = Connection->NextToWrite;
        if (iVar3 < iVar1 + 0x4000) {
            Connection->OutData[iVar3 % 0x4000] = 'k';
            iVar3 = iVar3 + 1;
            Connection->NextToWrite = iVar3;
        }
        else {
            Connection->Overflow = true;
        }
        if (iVar3 < iVar1 + 0x3fff) {
            Connection->OutData[iVar3 % 0x4000] = (uchar)x;
            uVar5 = iVar3 + 1;
            uVar4 = iVar3 + 0x4000;
            if (-1 < (int)uVar5) {
                uVar4 = uVar5;
            }
            *(char *)((int)Connection + (uVar5 - (uVar4 & 0xffffc000)) + 0x806) =
                 (char)((uint)x >> 8);
            iVar3 = iVar3 + 2;
            Connection->NextToWrite = iVar3;
        }
        else {
            Connection->Overflow = true;
        }
        if (iVar3 < iVar1 + 0x3fff) {
            Connection->OutData[iVar3 % 0x4000] = (uchar)y;
            uVar5 = iVar3 + 1;
            uVar4 = iVar3 + 0x4000;
            if (-1 < (int)uVar5) {
                uVar4 = uVar5;
            }
            *(char *)((int)Connection + (uVar5 - (uVar4 & 0xffffc000)) + 0x806) =
                 (char)((uint)y >> 8);
            iVar3 = iVar3 + 2;
            Connection->NextToWrite = iVar3;
        }
        else {
            Connection->Overflow = true;
        }
        if (iVar3 < iVar1 + 0x4000) {
            Connection->OutData[iVar3 % 0x4000] = (uchar)z;
            Connection->NextToWrite = iVar3 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        bVar2 = Object::exists(Obj);
        if (bVar2) {
            local_2c[0] = (Object)Obj->ObjectID;
            iVar3 = GetObjectRNum(local_2c);
            if (iVar3 < 10) {
                iVar1 = Connection->NextToWrite;
                if (iVar1 < Connection->NextToSend + 0x4000) {
                    Connection->OutData[iVar1 % 0x4000] = (uchar)iVar3;
                    Connection->NextToWrite = iVar1 + 1;
                }
                else {
                    Connection->Overflow = true;
                }
                local_2c[0] = (Object)Obj->ObjectID;
                SendMapObject(Connection,local_2c);
                FinishSendData(Connection);
            }
        }
        else {
            error(&DAT_081093a0);
        }
    }
    return;
}



void SendMoveCreature(TConnection *Connection,ulong CreatureID,int x,int y,int z)

{
    undefined2 uVar1;
    int iVar2;
    bool bVar3;
    bool bVar4;
    bool bVar5;
    TCreature *pTVar6;
    int iVar7;
    uint uVar8;
    int iVar9;
    uint uVar10;
    TCreature *cr;
    uchar uStack_30;
    bool DestVisible;
    bool StartVisible;
    int RNum;
    
    if (Connection != (TConnection *)0x0) {
        pTVar6 = GetCreature(CreatureID);
        if (pTVar6 == (TCreature *)0x0) {
            error("SendMoveCreature: Kreatur existiert nicht.\n");
        }
        else {
            RNum = (pTVar6->CrObject).ObjectID;
            iVar7 = GetObjectRNum((Object *)&RNum);
            bVar3 = false;
            bVar4 = TConnection::IsVisible(Connection,pTVar6->posx,pTVar6->posy,pTVar6->posz);
            if ((bVar4) && (iVar7 < 10)) {
                bVar3 = true;
            }
            bVar4 = TConnection::IsVisible(Connection,x,y,z);
            if (bVar3) {
                if (bVar4) {
                    bVar5 = BeginSendData(Connection);
                    if (!bVar5) {
                        return;
                    }
                    iVar2 = Connection->NextToSend;
                    iVar9 = Connection->NextToWrite;
                    if (iVar9 < iVar2 + 0x4000) {
                        Connection->OutData[iVar9 % 0x4000] = 'm';
                        iVar9 = iVar9 + 1;
                        Connection->NextToWrite = iVar9;
                    }
                    else {
                        Connection->Overflow = true;
                    }
                    uVar1 = (undefined2)pTVar6->posx;
                    if (iVar9 < iVar2 + 0x3fff) {
                        Connection->OutData[iVar9 % 0x4000] = (uchar)uVar1;
                        uVar10 = iVar9 + 1;
                        uVar8 = iVar9 + 0x4000;
                        if (-1 < (int)uVar10) {
                            uVar8 = uVar10;
                        }
                        *(char *)((int)Connection + (uVar10 - (uVar8 & 0xffffc000)) + 0x806) =
                             (char)((ushort)uVar1 >> 8);
                        iVar9 = iVar9 + 2;
                        Connection->NextToWrite = iVar9;
                    }
                    else {
                        Connection->Overflow = true;
                    }
                    uVar1 = (undefined2)pTVar6->posy;
                    if (iVar9 < iVar2 + 0x3fff) {
                        Connection->OutData[iVar9 % 0x4000] = (uchar)uVar1;
                        uVar10 = iVar9 + 1;
                        uVar8 = iVar9 + 0x4000;
                        if (-1 < (int)uVar10) {
                            uVar8 = uVar10;
                        }
                        iVar9 = iVar9 + 2;
                        *(char *)((int)Connection + (uVar10 - (uVar8 & 0xffffc000)) + 0x806) =
                             (char)((ushort)uVar1 >> 8);
                        Connection->NextToWrite = iVar9;
                    }
                    else {
                        Connection->Overflow = true;
                    }
                    if (iVar9 < iVar2 + 0x4000) {
                        Connection->OutData[iVar9 % 0x4000] = (uchar)pTVar6->posz;
                        iVar9 = iVar9 + 1;
                        Connection->NextToWrite = iVar9;
                    }
                    else {
                        Connection->Overflow = true;
                    }
                    if (iVar9 < iVar2 + 0x4000) {
                        uStack_30 = (uchar)iVar7;
                        iVar7 = iVar9 % 0x4000;
                        iVar9 = iVar9 + 1;
                        Connection->OutData[iVar7] = uStack_30;
                        Connection->NextToWrite = iVar9;
                    }
                    else {
                        Connection->Overflow = true;
                    }
                    if (iVar9 < iVar2 + 0x3fff) {
                        Connection->OutData[iVar9 % 0x4000] = (uchar)x;
                        uVar10 = iVar9 + 1;
                        uVar8 = iVar9 + 0x4000;
                        if (-1 < (int)uVar10) {
                            uVar8 = uVar10;
                        }
                        *(char *)((int)Connection + (uVar10 - (uVar8 & 0xffffc000)) + 0x806) =
                             (char)((uint)x >> 8);
                        iVar9 = iVar9 + 2;
                        Connection->NextToWrite = iVar9;
                    }
                    else {
                        Connection->Overflow = true;
                    }
                    if (iVar9 < iVar2 + 0x3fff) {
                        Connection->OutData[iVar9 % 0x4000] = (uchar)y;
                        uVar10 = iVar9 + 1;
                        uVar8 = iVar9 + 0x4000;
                        if (-1 < (int)uVar10) {
                            uVar8 = uVar10;
                        }
                        iVar9 = iVar9 + 2;
                        *(char *)((int)Connection + (uVar10 - (uVar8 & 0xffffc000)) + 0x806) =
                             (char)((uint)y >> 8);
                        Connection->NextToWrite = iVar9;
                    }
                    else {
                        Connection->Overflow = true;
                    }
                    if (iVar9 < iVar2 + 0x4000) {
                        Connection->OutData[iVar9 % 0x4000] = (uchar)z;
                        Connection->NextToWrite = iVar9 + 1;
                    }
                    else {
                        Connection->Overflow = true;
                    }
                    FinishSendData(Connection);
                }
                if (bVar3) {
                    if (bVar4) {
                        return;
                    }
                    RNum = (pTVar6->CrObject).ObjectID;
                    SendDeleteField(Connection,pTVar6->posx,pTVar6->posy,pTVar6->posz,
                                    (Object *)&RNum);
                    return;
                }
            }
            else if (!bVar4) {
                return;
            }
            if (bVar4) {
                RNum = (pTVar6->CrObject).ObjectID;
                SendAddField(Connection,x,y,z,(Object *)&RNum);
            }
        }
    }
    return;
}



// WARNING: Variable defined which should be unmapped: y_local

void __regparm2 SendGraphicalEffect(TConnection *Connection,int x,int y,int z,int Type)

{
    int iVar1;
    bool bVar2;
    uint uVar3;
    int iVar4;
    int iVar5;
    uint uVar6;
    undefined1 in_stack_00000010;
    undefined1 in_stack_00000014;
    int Type_local;
    int z_local;
    int y_local;
    
    bVar2 = BeginSendData((TConnection *)y);
    if (bVar2) {
        iVar1 = *(int *)(y + 0x4808);
        iVar4 = *(int *)(y + 0x4810);
        if (iVar4 < iVar1 + 0x4000) {
            *(undefined1 *)(y + 0x806 + iVar4 % 0x4000) = 0x83;
            iVar4 = iVar4 + 1;
            *(int *)(y + 0x4810) = iVar4;
        }
        else {
            *(undefined1 *)(y + 0x4814) = 1;
        }
        if (iVar4 < iVar1 + 0x3fff) {
            *(char *)(y + 0x806 + iVar4 % 0x4000) = (char)(z & 0xffffU);
            uVar6 = iVar4 + 1;
            uVar3 = iVar4 + 0x4000;
            if (-1 < (int)uVar6) {
                uVar3 = uVar6;
            }
            iVar4 = iVar4 + 2;
            *(char *)(y + 0x806 + (uVar6 - (uVar3 & 0xffffc000))) = (char)((z & 0xffffU) >> 8);
            *(int *)(y + 0x4810) = iVar4;
        }
        else {
            *(undefined1 *)(y + 0x4814) = 1;
        }
        if (iVar4 < iVar1 + 0x3fff) {
            *(char *)(y + 0x806 + iVar4 % 0x4000) = (char)Type;
            uVar6 = iVar4 + 1;
            uVar3 = iVar4 + 0x4000;
            if (-1 < (int)uVar6) {
                uVar3 = uVar6;
            }
            iVar4 = iVar4 + 2;
            *(char *)(y + 0x806 + (uVar6 - (uVar3 & 0xffffc000))) = (char)((uint)Type >> 8);
            *(int *)(y + 0x4810) = iVar4;
        }
        else {
            *(undefined1 *)(y + 0x4814) = 1;
        }
        if (iVar4 < iVar1 + 0x4000) {
            iVar5 = iVar4 % 0x4000;
            iVar4 = iVar4 + 1;
            *(undefined1 *)(y + 0x806 + iVar5) = in_stack_00000010;
            *(int *)(y + 0x4810) = iVar4;
        }
        else {
            *(undefined1 *)(y + 0x4814) = 1;
        }
        if (iVar4 < iVar1 + 0x4000) {
            *(undefined1 *)(y + 0x806 + iVar4 % 0x4000) = in_stack_00000014;
            *(int *)(y + 0x4810) = iVar4 + 1;
        }
        else {
            *(undefined1 *)(y + 0x4814) = 1;
        }
        FinishSendData((TConnection *)y);
        return;
    }
    return;
}



// WARNING: Variable defined which should be unmapped: z_local
// WARNING: Unknown calling convention -- yet parameter storage is locked

void SendTextualEffect(TConnection *Connection,int x,int y,int z,int Color,char *Text)

{
    int iVar1;
    bool bVar2;
    size_t Length;
    uint uVar3;
    int iVar4;
    uint uVar5;
    char *Text_local;
    int Color_local;
    int z_local;
    
    if (Text == (char *)0x0) {
        Connection = (TConnection *)s_SendTextualEffect__Text_ist_NULL_08109460;
    }
    else {
        if (*Text != '\0') {
            bVar2 = BeginSendData(Connection);
            if (bVar2) {
                iVar1 = Connection->NextToSend;
                iVar4 = Connection->NextToWrite;
                if (iVar4 < iVar1 + 0x4000) {
                    Connection->OutData[iVar4 % 0x4000] = 0x84;
                    iVar4 = iVar4 + 1;
                    Connection->NextToWrite = iVar4;
                }
                else {
                    Connection->Overflow = true;
                }
                if (iVar4 < iVar1 + 0x3fff) {
                    Connection->OutData[iVar4 % 0x4000] = (uchar)(x & 0xffffU);
                    uVar5 = iVar4 + 1;
                    uVar3 = iVar4 + 0x4000;
                    if (-1 < (int)uVar5) {
                        uVar3 = uVar5;
                    }
                    iVar4 = iVar4 + 2;
                    *(char *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) =
                         (char)((x & 0xffffU) >> 8);
                    Connection->NextToWrite = iVar4;
                }
                else {
                    Connection->Overflow = true;
                }
                if (iVar4 < iVar1 + 0x3fff) {
                    uVar5 = iVar4 + 1;
                    Connection->OutData[iVar4 % 0x4000] = (uchar)(y & 0xffffU);
                    uVar3 = iVar4 + 0x4000;
                    if (-1 < (int)uVar5) {
                        uVar3 = uVar5;
                    }
                    *(char *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) =
                         (char)((y & 0xffffU) >> 8);
                    iVar4 = iVar4 + 2;
                    Connection->NextToWrite = iVar4;
                }
                else {
                    Connection->Overflow = true;
                }
                if (iVar4 < iVar1 + 0x4000) {
                    Color_local._0_1_ = (uchar)z;
                    Connection->OutData[iVar4 % 0x4000] = (uchar)Color_local;
                    iVar4 = iVar4 + 1;
                    Connection->NextToWrite = iVar4;
                }
                else {
                    Connection->Overflow = true;
                }
                if (iVar4 < iVar1 + 0x4000) {
                    Text_local._0_1_ = (uchar)Color;
                    Connection->OutData[iVar4 % 0x4000] = (uchar)Text_local;
                    Connection->NextToWrite = iVar4 + 1;
                }
                else {
                    Connection->Overflow = true;
                }
                if (Text == (char *)0x0) {
                    error("SendString: String ist NULL.\n");
                }
                else {
                    Length = strlen(Text);
                    iVar4 = Connection->NextToWrite;
                    if (iVar4 < iVar1 + 0x3fff) {
                        Connection->OutData[iVar4 % 0x4000] = (uchar)(Length & 0xffff);
                        uVar5 = iVar4 + 1;
                        uVar3 = iVar4 + 0x4000;
                        if (-1 < (int)uVar5) {
                            uVar3 = uVar5;
                        }
                        *(char *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) =
                             (char)((Length & 0xffff) >> 8);
                        Connection->NextToWrite = iVar4 + 2;
                    }
                    else {
                        Connection->Overflow = true;
                    }
                    if (0 < (int)Length) {
                        SendText(Connection,Text,Length);
                    }
                }
                FinishSendData(Connection);
                return;
            }
            return;
        }
        Connection = (TConnection *)s_SendTextualEffect__Text_ist_leer_08109420;
    }
    error((char *)Connection);
    return;
}



// WARNING: Variable defined which should be unmapped: sy_local

void __regparm2
SendMissileEffect(TConnection *Connection,int sx,int sy,int sz,int zx,int zy,int zz,int Type)

{
    int iVar1;
    bool bVar2;
    uint uVar3;
    int iVar4;
    int iVar5;
    uint uVar6;
    undefined1 in_stack_0000001c;
    undefined1 in_stack_00000020;
    int Type_local;
    int zz_local;
    int zy_local;
    int zx_local;
    int sz_local;
    int sy_local;
    
    bVar2 = BeginSendData((TConnection *)sy);
    if (bVar2) {
        iVar1 = *(int *)(sy + 0x4808);
        iVar4 = *(int *)(sy + 0x4810);
        if (iVar4 < iVar1 + 0x4000) {
            *(undefined1 *)(sy + 0x806 + iVar4 % 0x4000) = 0x85;
            iVar4 = iVar4 + 1;
            *(int *)(sy + 0x4810) = iVar4;
        }
        else {
            *(undefined1 *)(sy + 0x4814) = 1;
        }
        if (iVar4 < iVar1 + 0x3fff) {
            *(char *)(sy + 0x806 + iVar4 % 0x4000) = (char)(sz & 0xffffU);
            uVar6 = iVar4 + 1;
            uVar3 = iVar4 + 0x4000;
            if (-1 < (int)uVar6) {
                uVar3 = uVar6;
            }
            iVar4 = iVar4 + 2;
            *(char *)(sy + 0x806 + (uVar6 - (uVar3 & 0xffffc000))) = (char)((sz & 0xffffU) >> 8);
            *(int *)(sy + 0x4810) = iVar4;
        }
        else {
            *(undefined1 *)(sy + 0x4814) = 1;
        }
        if (iVar4 < iVar1 + 0x3fff) {
            *(char *)(sy + 0x806 + iVar4 % 0x4000) = (char)zx;
            uVar6 = iVar4 + 1;
            uVar3 = iVar4 + 0x4000;
            if (-1 < (int)uVar6) {
                uVar3 = uVar6;
            }
            iVar4 = iVar4 + 2;
            *(char *)(sy + 0x806 + (uVar6 - (uVar3 & 0xffffc000))) = (char)((uint)zx >> 8);
            *(int *)(sy + 0x4810) = iVar4;
        }
        else {
            *(undefined1 *)(sy + 0x4814) = 1;
        }
        if (iVar4 < iVar1 + 0x4000) {
            zx_local._0_1_ = (undefined1)zy;
            iVar5 = iVar4 % 0x4000;
            iVar4 = iVar4 + 1;
            *(undefined1 *)(sy + 0x806 + iVar5) = (undefined1)zx_local;
            *(int *)(sy + 0x4810) = iVar4;
        }
        else {
            *(undefined1 *)(sy + 0x4814) = 1;
        }
        if (iVar4 < iVar1 + 0x3fff) {
            *(char *)(sy + 0x806 + iVar4 % 0x4000) = (char)zz;
            uVar6 = iVar4 + 1;
            uVar3 = iVar4 + 0x4000;
            if (-1 < (int)uVar6) {
                uVar3 = uVar6;
            }
            iVar4 = iVar4 + 2;
            *(char *)(sy + 0x806 + (uVar6 - (uVar3 & 0xffffc000))) = (char)((uint)zz >> 8);
            *(int *)(sy + 0x4810) = iVar4;
        }
        else {
            *(undefined1 *)(sy + 0x4814) = 1;
        }
        if (iVar4 < iVar1 + 0x3fff) {
            *(char *)(sy + 0x806 + iVar4 % 0x4000) = (char)Type;
            uVar6 = iVar4 + 1;
            uVar3 = iVar4 + 0x4000;
            if (-1 < (int)uVar6) {
                uVar3 = uVar6;
            }
            iVar4 = iVar4 + 2;
            *(char *)(sy + 0x806 + (uVar6 - (uVar3 & 0xffffc000))) = (char)((uint)Type >> 8);
            *(int *)(sy + 0x4810) = iVar4;
        }
        else {
            *(undefined1 *)(sy + 0x4814) = 1;
        }
        if (iVar4 < iVar1 + 0x4000) {
            iVar5 = iVar4 % 0x4000;
            iVar4 = iVar4 + 1;
            *(undefined1 *)(sy + 0x806 + iVar5) = in_stack_0000001c;
            *(int *)(sy + 0x4810) = iVar4;
        }
        else {
            *(undefined1 *)(sy + 0x4814) = 1;
        }
        if (iVar4 < iVar1 + 0x4000) {
            *(undefined1 *)(sy + 0x806 + iVar4 % 0x4000) = in_stack_00000020;
            *(int *)(sy + 0x4810) = iVar4 + 1;
        }
        else {
            *(undefined1 *)(sy + 0x4814) = 1;
        }
        FinishSendData((TConnection *)sy);
        return;
    }
    return;
}



// WARNING: Variable defined which should be unmapped: Color_local

void __regparm2 SendMarkCreature(TConnection *Connection,ulong CreatureID,int Color)

{
    int iVar1;
    bool bVar2;
    uint uVar3;
    int iVar4;
    uint uVar5;
    undefined4 in_stack_00000008;
    undefined1 in_stack_0000000c;
    int Color_local;
    
    bVar2 = BeginSendData((TConnection *)Color);
    if (bVar2) {
        iVar1 = *(int *)(Color + 0x4808);
        iVar4 = *(int *)(Color + 0x4810);
        if (iVar4 < iVar1 + 0x4000) {
            *(undefined1 *)(Color + 0x806 + iVar4 % 0x4000) = 0x86;
            iVar4 = iVar4 + 1;
            *(int *)(Color + 0x4810) = iVar4;
        }
        else {
            *(undefined1 *)(Color + 0x4814) = 1;
        }
        if (iVar4 < iVar1 + 0x3ffd) {
            *(char *)(Color + 0x806 + iVar4 % 0x4000) = (char)in_stack_00000008;
            uVar5 = iVar4 + 1;
            uVar3 = iVar4 + 0x4000;
            if (-1 < (int)uVar5) {
                uVar3 = uVar5;
            }
            *(char *)(Color + 0x806 + (uVar5 - (uVar3 & 0xffffc000))) =
                 (char)((uint)in_stack_00000008 >> 8);
            uVar5 = iVar4 + 2;
            uVar3 = iVar4 + 0x4001;
            if (-1 < (int)uVar5) {
                uVar3 = uVar5;
            }
            *(char *)(Color + 0x806 + (uVar5 - (uVar3 & 0xffffc000))) =
                 (char)((uint)in_stack_00000008 >> 0x10);
            uVar5 = iVar4 + 3;
            uVar3 = iVar4 + 0x4002;
            if (-1 < (int)uVar5) {
                uVar3 = uVar5;
            }
            iVar4 = iVar4 + 4;
            *(char *)(Color + 0x806 + (uVar5 - (uVar3 & 0xffffc000))) =
                 (char)((uint)in_stack_00000008 >> 0x18);
            *(int *)(Color + 0x4810) = iVar4;
        }
        else {
            *(undefined1 *)(Color + 0x4814) = 1;
        }
        if (iVar4 < iVar1 + 0x4000) {
            *(undefined1 *)(Color + 0x806 + iVar4 % 0x4000) = in_stack_0000000c;
            *(int *)(Color + 0x4810) = iVar4 + 1;
        }
        else {
            *(undefined1 *)(Color + 0x4814) = 1;
        }
        FinishSendData((TConnection *)Color);
        return;
    }
    return;
}



void SendEditText(TConnection *Connection,Object *Obj)

{
    Object *this;
    bool bVar1;
    TPlayer *pl;
    ulong uVar2;
    size_t sVar3;
    uint uVar4;
    TPlayer *pTVar5;
    int iVar6;
    int iVar7;
    uint uVar8;
    ushort *puVar9;
    char *Text_00;
    uchar local_1060;
    char *local_1048;
    char *Editor;
    char *Text;
    ushort MaxLen;
    char Buffer [4096];
    
    bVar1 = BeginSendData(Connection);
    if (!bVar1) {
        return;
    }
    iVar6 = Connection->NextToWrite;
    if (iVar6 < Connection->NextToSend + 0x4000) {
        Connection->OutData[iVar6 % 0x4000] = 0x96;
        Connection->NextToWrite = iVar6 + 1;
    }
    else {
        Connection->Overflow = true;
    }
    bVar1 = Object::exists(Obj);
    if (!bVar1) {
        Text_00 = &DAT_081094e0;
LAB_080d1c40:
        error(Text_00);
        return;
    }
    uVar2 = Obj->ObjectID;
    iVar6 = Connection->NextToWrite;
    if (iVar6 < Connection->NextToSend + 0x3ffd) {
        uVar8 = iVar6 + 1;
        Connection->OutData[iVar6 % 0x4000] = (uchar)uVar2;
        uVar4 = iVar6 + 0x4000;
        if (-1 < (int)uVar8) {
            uVar4 = uVar8;
        }
        *(char *)((int)Connection + (uVar8 - (uVar4 & 0xffffc000)) + 0x806) = (char)(uVar2 >> 8);
        uVar8 = iVar6 + 2;
        uVar4 = iVar6 + 0x4001;
        if (-1 < (int)uVar8) {
            uVar4 = uVar8;
        }
        *(char *)((int)Connection + (uVar8 - (uVar4 & 0xffffc000)) + 0x806) = (char)(uVar2 >> 0x10);
        uVar8 = iVar6 + 3;
        uVar4 = iVar6 + 0x4002;
        if (-1 < (int)uVar8) {
            uVar4 = uVar8;
        }
        *(char *)((int)Connection + (uVar8 - (uVar4 & 0xffffc000)) + 0x806) = (char)(uVar2 >> 0x18);
        Connection->NextToWrite = iVar6 + 4;
    }
    else {
        Connection->Overflow = true;
    }
    this = (Object *)(Buffer + 0xffc);
    Object::getObjectType(this);
    bVar1 = ObjectType::getFlag((ObjectType *)this,DISGUISE);
    if (bVar1) {
        Object::getObjectType(this);
        uVar2 = ObjectType::getAttribute((ObjectType *)this,DISGUISETARGET);
        Buffer._4092_2_ = (undefined2)uVar2;
    }
    else {
        Object::getObjectType(this);
    }
    iVar6 = Connection->NextToWrite;
    if (iVar6 < Connection->NextToSend + 0x3fff) {
        uVar8 = iVar6 + 1;
        Connection->OutData[iVar6 % 0x4000] = (uchar)Buffer._4092_2_;
        uVar4 = iVar6 + 0x4000;
        if (-1 < (int)uVar8) {
            uVar4 = uVar8;
        }
        *(char *)((int)Connection + (uVar8 - (uVar4 & 0xffffc000)) + 0x806) =
             SUB21(Buffer._4092_2_,1);
        Connection->NextToWrite = iVar6 + 2;
    }
    else {
        Connection->Overflow = true;
    }
    Editor = (char *)&MaxLen;
    puVar9 = &MaxLen;
    for (iVar6 = 0x400; iVar6 != 0; iVar6 = iVar6 + -1) {
        puVar9[0] = 0;
        puVar9[1] = 0;
        puVar9 = puVar9 + 2;
    }
    Object::getObjectType(this);
    bVar1 = ObjectType::getFlag((ObjectType *)this,WRITE);
    if (bVar1) {
LAB_080d171d:
        Object::getObjectType(this);
        bVar1 = ObjectType::getFlag((ObjectType *)this,WRITE);
        Object::getObjectType(this);
        uVar2 = ObjectType::getAttribute((ObjectType *)this,!bVar1 + MAXLENGTH);
        Text._0_2_ = (short)uVar2 + -1;
        uVar2 = Object::getAttribute(Obj,TEXTSTRING);
        Editor = GetDynamicString(uVar2);
        uVar2 = Object::getAttribute(Obj,EDITOR);
        local_1048 = GetDynamicString(uVar2);
    }
    else {
        Object::getObjectType(this);
        bVar1 = ObjectType::getFlag((ObjectType *)this,WRITEONCE);
        if (bVar1) goto LAB_080d171d;
        Object::getObjectType(this);
        bVar1 = ObjectType::getFlag((ObjectType *)this,INFORMATION);
        if (bVar1) {
            Object::getObjectType(this);
            uVar2 = ObjectType::getAttribute((ObjectType *)this,INFORMATIONTYPE);
            if (uVar2 != 4) goto LAB_080d1b88;
            pTVar5 = TConnection::GetPlayer(Connection);
            if (pTVar5 == (TPlayer *)0x0) {
                Text_00 = &DAT_081094a0;
                goto LAB_080d1c40;
            }
            GetSpellbook((pTVar5->super_TCreature).ID,Editor);
            local_1048 = (char *)0x0;
            sVar3 = strlen(Editor);
            Text._0_2_ = (short)sVar3;
        }
        else {
LAB_080d1b88:
            uVar2 = Object::getAttribute(Obj,TEXTSTRING);
            Editor = GetDynamicString(uVar2);
            uVar2 = Object::getAttribute(Obj,EDITOR);
            local_1048 = GetDynamicString(uVar2);
            Text._0_2_ = 0;
            if (Editor != (char *)0x0) {
                sVar3 = strlen(Editor);
                Text._0_2_ = (short)sVar3;
            }
        }
    }
    iVar6 = Connection->NextToSend;
    iVar7 = Connection->NextToWrite;
    if (iVar7 < iVar6 + 0x3fff) {
        Connection->OutData[iVar7 % 0x4000] = (uchar)Text;
        uVar8 = iVar7 + 1;
        uVar4 = iVar7 + 0x4000;
        if (-1 < (int)uVar8) {
            uVar4 = uVar8;
        }
        *(char *)((int)Connection + (uVar8 - (uVar4 & 0xffffc000)) + 0x806) =
             (char)((ushort)(short)Text >> 8);
        Connection->NextToWrite = iVar7 + 2;
    }
    else {
        Connection->Overflow = true;
    }
    if (Editor != (char *)0x0) {
        if ((short)Text != 0) {
            sVar3 = strlen(Editor);
            iVar7 = Connection->NextToWrite;
            if (iVar7 < iVar6 + 0x3fff) {
                local_1060 = (uchar)(sVar3 & 0xffff);
                Connection->OutData[iVar7 % 0x4000] = local_1060;
                uVar8 = iVar7 + 1;
                uVar4 = iVar7 + 0x4000;
                if (-1 < (int)uVar8) {
                    uVar4 = uVar8;
                }
                local_1060 = (uchar)((sVar3 & 0xffff) >> 8);
                *(uchar *)((int)Connection + (uVar8 - (uVar4 & 0xffffc000)) + 0x806) = local_1060;
                Connection->NextToWrite = iVar7 + 2;
            }
            else {
                Connection->Overflow = true;
            }
            if (0 < (int)sVar3) {
                SendText(Connection,Editor,sVar3);
                iVar6 = Connection->NextToSend;
            }
            if (local_1048 == (char *)0x0) {
                iVar7 = Connection->NextToWrite;
                if (iVar7 < iVar6 + 0x3fff) {
                    uVar8 = iVar7 + 1;
                    uVar4 = iVar7 + 0x4000;
                    if (-1 < (int)uVar8) {
                        uVar4 = uVar8;
                    }
                    Connection->OutData[iVar7 % 0x4000] = '\0';
                    *(undefined1 *)((int)Connection + (uVar8 - (uVar4 & 0xffffc000)) + 0x806) = 0;
                    Connection->NextToWrite = iVar7 + 2;
                }
                else {
                    Connection->Overflow = true;
                }
            }
            else {
                sVar3 = strlen(local_1048);
                iVar7 = Connection->NextToWrite;
                if (iVar7 < iVar6 + 0x3fff) {
                    Connection->OutData[iVar7 % 0x4000] = (uchar)(sVar3 & 0xffff);
                    uVar8 = iVar7 + 1;
                    uVar4 = iVar7 + 0x4000;
                    if (-1 < (int)uVar8) {
                        uVar4 = uVar8;
                    }
                    *(char *)((int)Connection + (uVar8 - (uVar4 & 0xffffc000)) + 0x806) =
                         (char)((sVar3 & 0xffff) >> 8);
                    Connection->NextToWrite = iVar7 + 2;
                }
                else {
                    Connection->Overflow = true;
                }
                if (0 < (int)sVar3) {
                    SendText(Connection,local_1048,sVar3);
                }
            }
        }
        if (Editor == (char *)0x0) {
            iVar6 = Connection->NextToSend;
        }
        else {
            if ((short)Text != 0) goto LAB_080d1904;
            iVar6 = Connection->NextToSend;
        }
    }
    iVar7 = Connection->NextToWrite;
    if (iVar7 < iVar6 + 0x3fff) {
        Connection->OutData[iVar7 % 0x4000] = '\0';
        uVar8 = iVar7 + 1;
        uVar4 = iVar7 + 0x4000;
        if (-1 < (int)uVar8) {
            uVar4 = uVar8;
        }
        *(undefined1 *)((int)Connection + (uVar8 - (uVar4 & 0xffffc000)) + 0x806) = 0;
        iVar7 = iVar7 + 2;
        Connection->NextToWrite = iVar7;
    }
    else {
        Connection->Overflow = true;
    }
    if (iVar7 < iVar6 + 0x3fff) {
        Connection->OutData[iVar7 % 0x4000] = '\0';
        uVar8 = iVar7 + 1;
        uVar4 = iVar7 + 0x4000;
        if (-1 < (int)uVar8) {
            uVar4 = uVar8;
        }
        *(undefined1 *)((int)Connection + (uVar8 - (uVar4 & 0xffffc000)) + 0x806) = 0;
        Connection->NextToWrite = iVar7 + 2;
    }
    else {
        Connection->Overflow = true;
    }
LAB_080d1904:
    FinishSendData(Connection);
    return;
}



// WARNING: Variable defined which should be unmapped: Type_local
// WARNING: Unknown calling convention -- yet parameter storage is locked

void SendEditList(TConnection *Connection,uchar Type,ulong ID,char *Text)

{
    int iVar1;
    bool bVar2;
    size_t Length;
    uint uVar3;
    int iVar4;
    uint uVar5;
    char *Text_local;
    uchar Type_local;
    
    bVar2 = BeginSendData(Connection);
    if (!bVar2) {
        return;
    }
    iVar1 = Connection->NextToSend;
    iVar4 = Connection->NextToWrite;
    if (iVar4 < iVar1 + 0x4000) {
        Connection->OutData[iVar4 % 0x4000] = 0x97;
        iVar4 = iVar4 + 1;
        Connection->NextToWrite = iVar4;
    }
    else {
        Connection->Overflow = true;
    }
    if (iVar4 < iVar1 + 0x4000) {
        Connection->OutData[iVar4 % 0x4000] = Type;
        iVar4 = iVar4 + 1;
        Connection->NextToWrite = iVar4;
    }
    else {
        Connection->Overflow = true;
    }
    if (iVar4 < iVar1 + 0x3ffd) {
        uVar5 = iVar4 + 1;
        Connection->OutData[iVar4 % 0x4000] = (uchar)ID;
        uVar3 = iVar4 + 0x4000;
        if (-1 < (int)uVar5) {
            uVar3 = uVar5;
        }
        *(char *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) = (char)(ID >> 8);
        uVar5 = iVar4 + 2;
        uVar3 = iVar4 + 0x4001;
        if (-1 < (int)uVar5) {
            uVar3 = uVar5;
        }
        *(char *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) = (char)(ID >> 0x10);
        uVar5 = iVar4 + 3;
        uVar3 = iVar4 + 0x4002;
        if (-1 < (int)uVar5) {
            uVar3 = uVar5;
        }
        *(char *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) = (char)(ID >> 0x18);
        Connection->NextToWrite = iVar4 + 4;
    }
    else {
        Connection->Overflow = true;
    }
    Length = strlen(Text);
    if (Length < 0xfa1) {
        if (Text == (char *)0x0) {
            error("SendString: String ist NULL.\n");
        }
        else {
            iVar4 = Connection->NextToWrite;
            if (iVar4 < iVar1 + 0x3fff) {
                Connection->OutData[iVar4 % 0x4000] = (uchar)(Length & 0xffff);
                uVar5 = iVar4 + 1;
                uVar3 = iVar4 + 0x4000;
                if (-1 < (int)uVar5) {
                    uVar3 = uVar5;
                }
                *(char *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) =
                     (char)((Length & 0xffff) >> 8);
                Connection->NextToWrite = iVar4 + 2;
            }
            else {
                Connection->Overflow = true;
            }
            if (0 < (int)Length) {
                SendText(Connection,Text,Length);
            }
        }
        FinishSendData(Connection);
        return;
    }
    error("SendEditList: Text ist zu lang.\n");
    return;
}



// WARNING: Variable defined which should be unmapped: Color

void SendAmbiente(TConnection *Connection)

{
    int iVar1;
    bool bVar2;
    int iVar3;
    uchar local_18 [4];
    int Brightness;
    int Color;
    
    bVar2 = BeginSendData(Connection);
    if (bVar2) {
        iVar3 = Connection->NextToWrite;
        if (iVar3 < Connection->NextToSend + 0x4000) {
            Connection->OutData[iVar3 % 0x4000] = 0x82;
            Connection->NextToWrite = iVar3 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        GetAmbiente((int *)local_18,&Brightness);
        iVar1 = Connection->NextToSend;
        iVar3 = Connection->NextToWrite;
        if (iVar3 < iVar1 + 0x4000) {
            Connection->OutData[iVar3 % 0x4000] = local_18[0];
            iVar3 = iVar3 + 1;
            Connection->NextToWrite = iVar3;
        }
        else {
            Connection->Overflow = true;
        }
        if (iVar3 < iVar1 + 0x4000) {
            Connection->OutData[iVar3 % 0x4000] = (uchar)Brightness;
            Connection->NextToWrite = iVar3 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        FinishSendData(Connection);
    }
    return;
}



void SendCreatureHealth(TConnection *Connection,ulong CreatureID)

{
    bool bVar1;
    TCreature *cr;
    TCreature *this;
    int iVar2;
    int iVar3;
    uint uVar4;
    uint uVar5;
    
    bVar1 = BeginSendData(Connection);
    if (!bVar1) {
        return;
    }
    iVar2 = Connection->NextToSend;
    iVar3 = Connection->NextToWrite;
    if (iVar3 < iVar2 + 0x4000) {
        Connection->OutData[iVar3 % 0x4000] = 0x8c;
        iVar3 = iVar3 + 1;
        Connection->NextToWrite = iVar3;
    }
    else {
        Connection->Overflow = true;
    }
    if (iVar3 < iVar2 + 0x3ffd) {
        uVar5 = iVar3 + 1;
        Connection->OutData[iVar3 % 0x4000] = (uchar)CreatureID;
        uVar4 = iVar3 + 0x4000;
        if (-1 < (int)uVar5) {
            uVar4 = uVar5;
        }
        *(char *)((int)Connection + (uVar5 - (uVar4 & 0xffffc000)) + 0x806) =
             (char)(CreatureID >> 8);
        uVar5 = iVar3 + 2;
        uVar4 = iVar3 + 0x4001;
        if (-1 < (int)uVar5) {
            uVar4 = uVar5;
        }
        *(char *)((int)Connection + (uVar5 - (uVar4 & 0xffffc000)) + 0x806) =
             (char)(CreatureID >> 0x10);
        uVar5 = iVar3 + 3;
        uVar4 = iVar3 + 0x4002;
        if (-1 < (int)uVar5) {
            uVar4 = uVar5;
        }
        *(char *)((int)Connection + (uVar5 - (uVar4 & 0xffffc000)) + 0x806) =
             (char)(CreatureID >> 0x18);
        Connection->NextToWrite = iVar3 + 4;
    }
    else {
        Connection->Overflow = true;
    }
    this = GetCreature(CreatureID);
    if (this != (TCreature *)0x0) {
        iVar2 = TCreature::GetHealth(this);
        iVar3 = Connection->NextToWrite;
        if (iVar3 < Connection->NextToSend + 0x4000) {
            Connection->OutData[iVar3 % 0x4000] = (uchar)iVar2;
            Connection->NextToWrite = iVar3 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        FinishSendData(Connection);
        return;
    }
    error("SendCreatureHealth: Kreatur %ld existiert nicht.\n");
    return;
}



// WARNING: Variable defined which should be unmapped: HelpColor

void SendCreatureLight(TConnection *Connection,ulong CreatureID)

{
    int iVar1;
    bool bVar2;
    TCreature *pTVar3;
    int iVar4;
    TCreature *cr;
    uint uVar5;
    int iVar6;
    uint uVar7;
    uchar local_18 [4];
    int HelpBrightness;
    int HelpColor;
    
    bVar2 = BeginSendData(Connection);
    if (bVar2) {
        iVar1 = Connection->NextToSend;
        iVar4 = Connection->NextToWrite;
        if (iVar4 < iVar1 + 0x4000) {
            Connection->OutData[iVar4 % 0x4000] = 0x8d;
            iVar4 = iVar4 + 1;
            Connection->NextToWrite = iVar4;
        }
        else {
            Connection->Overflow = true;
        }
        if (iVar4 < iVar1 + 0x3ffd) {
            uVar7 = iVar4 + 1;
            Connection->OutData[iVar4 % 0x4000] = (uchar)CreatureID;
            uVar5 = iVar4 + 0x4000;
            if (-1 < (int)uVar7) {
                uVar5 = uVar7;
            }
            *(char *)((int)Connection + (uVar7 - (uVar5 & 0xffffc000)) + 0x806) =
                 (char)(CreatureID >> 8);
            uVar7 = iVar4 + 2;
            uVar5 = iVar4 + 0x4001;
            if (-1 < (int)uVar7) {
                uVar5 = uVar7;
            }
            *(char *)((int)Connection + (uVar7 - (uVar5 & 0xffffc000)) + 0x806) =
                 (char)(CreatureID >> 0x10);
            uVar7 = iVar4 + 3;
            uVar5 = iVar4 + 0x4002;
            if (-1 < (int)uVar7) {
                uVar5 = uVar7;
            }
            *(char *)((int)Connection + (uVar7 - (uVar5 & 0xffffc000)) + 0x806) =
                 (char)(CreatureID >> 0x18);
            Connection->NextToWrite = iVar4 + 4;
        }
        else {
            Connection->Overflow = true;
        }
        pTVar3 = GetCreature(CreatureID);
        if (pTVar3 == (TCreature *)0x0) {
            error("SendCreatureLight: Kreatur %ld existiert nicht.\n",CreatureID);
        }
        else {
            GetCreatureLight(pTVar3->ID,(int *)local_18,&HelpBrightness);
            iVar1 = Connection->NextToSend;
            iVar4 = Connection->NextToWrite;
            if (iVar4 < iVar1 + 0x4000) {
                iVar6 = iVar4 % 0x4000;
                iVar4 = iVar4 + 1;
                Connection->OutData[iVar6] = local_18[0];
                Connection->NextToWrite = iVar4;
            }
            else {
                Connection->Overflow = true;
            }
            if (iVar4 < iVar1 + 0x4000) {
                Connection->OutData[iVar4 % 0x4000] = (uchar)HelpBrightness;
                Connection->NextToWrite = iVar4 + 1;
            }
            else {
                Connection->Overflow = true;
            }
            FinishSendData(Connection);
        }
    }
    return;
}



void SendCreatureOutfit(TConnection *Connection,ulong CreatureID)

{
    undefined2 uVar1;
    ushort uVar2;
    int iVar3;
    bool bVar4;
    TCreature *pTVar5;
    uint uVar6;
    int iVar7;
    TCreature *cr;
    uint uVar8;
    
    bVar4 = BeginSendData(Connection);
    if (!bVar4) {
        return;
    }
    iVar3 = Connection->NextToSend;
    iVar7 = Connection->NextToWrite;
    if (iVar7 < iVar3 + 0x4000) {
        Connection->OutData[iVar7 % 0x4000] = 0x8e;
        iVar7 = iVar7 + 1;
        Connection->NextToWrite = iVar7;
    }
    else {
        Connection->Overflow = true;
    }
    if (iVar7 < iVar3 + 0x3ffd) {
        uVar8 = iVar7 + 1;
        Connection->OutData[iVar7 % 0x4000] = (uchar)CreatureID;
        uVar6 = iVar7 + 0x4000;
        if (-1 < (int)uVar8) {
            uVar6 = uVar8;
        }
        *(char *)((int)Connection + (uVar8 - (uVar6 & 0xffffc000)) + 0x806) =
             (char)(CreatureID >> 8);
        uVar8 = iVar7 + 2;
        uVar6 = iVar7 + 0x4001;
        if (-1 < (int)uVar8) {
            uVar6 = uVar8;
        }
        *(char *)((int)Connection + (uVar8 - (uVar6 & 0xffffc000)) + 0x806) =
             (char)(CreatureID >> 0x10);
        uVar8 = iVar7 + 3;
        uVar6 = iVar7 + 0x4002;
        if (-1 < (int)uVar8) {
            uVar6 = uVar8;
        }
        *(char *)((int)Connection + (uVar8 - (uVar6 & 0xffffc000)) + 0x806) =
             (char)(CreatureID >> 0x18);
        Connection->NextToWrite = iVar7 + 4;
    }
    else {
        Connection->Overflow = true;
    }
    pTVar5 = GetCreature(CreatureID);
    if (pTVar5 != (TCreature *)0x0) {
        uVar1 = (undefined2)(pTVar5->Outfit).OutfitID;
        iVar7 = Connection->NextToSend;
        iVar3 = Connection->NextToWrite;
        if (iVar3 < iVar7 + 0x3fff) {
            Connection->OutData[iVar3 % 0x4000] = (uchar)uVar1;
            uVar8 = iVar3 + 1;
            uVar6 = iVar3 + 0x4000;
            if (-1 < (int)uVar8) {
                uVar6 = uVar8;
            }
            *(char *)((int)Connection + (uVar8 - (uVar6 & 0xffffc000)) + 0x806) =
                 (char)((ushort)uVar1 >> 8);
            Connection->NextToWrite = iVar3 + 2;
        }
        else {
            Connection->Overflow = true;
        }
        if ((pTVar5->Outfit).OutfitID == 0) {
            uVar2 = (pTVar5->Outfit).field_1.ObjectType;
            iVar3 = Connection->NextToWrite;
            if (iVar3 < iVar7 + 0x3fff) {
                uVar8 = iVar3 + 1;
                Connection->OutData[iVar3 % 0x4000] = (uchar)uVar2;
                uVar6 = iVar3 + 0x4000;
                if (-1 < (int)uVar8) {
                    uVar6 = uVar8;
                }
                *(char *)((int)Connection + (uVar8 - (uVar6 & 0xffffc000)) + 0x806) =
                     (char)(uVar2 >> 8);
                Connection->NextToWrite = iVar3 + 2;
            }
            else {
                Connection->Overflow = true;
            }
        }
        else {
            SendText(Connection,(char *)(pTVar5->Outfit).field_1.Colors,4);
        }
        FinishSendData(Connection);
        return;
    }
    error("SendCreatureOutfit: Kreatur %ld existiert nicht.\n");
    return;
}



void SendCreatureSpeed(TConnection *Connection,ulong CreatureID)

{
    int iVar1;
    bool bVar2;
    TCreature *cr;
    TCreature *this;
    uint uVar3;
    int iVar4;
    uint uVar5;
    uint uVar6;
    
    bVar2 = BeginSendData(Connection);
    if (!bVar2) {
        return;
    }
    iVar1 = Connection->NextToSend;
    iVar4 = Connection->NextToWrite;
    if (iVar4 < iVar1 + 0x4000) {
        Connection->OutData[iVar4 % 0x4000] = 0x8f;
        iVar4 = iVar4 + 1;
        Connection->NextToWrite = iVar4;
    }
    else {
        Connection->Overflow = true;
    }
    if (iVar4 < iVar1 + 0x3ffd) {
        uVar6 = iVar4 + 1;
        Connection->OutData[iVar4 % 0x4000] = (uchar)CreatureID;
        uVar3 = iVar4 + 0x4000;
        if (-1 < (int)uVar6) {
            uVar3 = uVar6;
        }
        *(char *)((int)Connection + (uVar6 - (uVar3 & 0xffffc000)) + 0x806) =
             (char)(CreatureID >> 8);
        uVar6 = iVar4 + 2;
        uVar3 = iVar4 + 0x4001;
        if (-1 < (int)uVar6) {
            uVar3 = uVar6;
        }
        *(char *)((int)Connection + (uVar6 - (uVar3 & 0xffffc000)) + 0x806) =
             (char)(CreatureID >> 0x10);
        uVar6 = iVar4 + 3;
        uVar3 = iVar4 + 0x4002;
        if (-1 < (int)uVar6) {
            uVar3 = uVar6;
        }
        *(char *)((int)Connection + (uVar6 - (uVar3 & 0xffffc000)) + 0x806) =
             (char)(CreatureID >> 0x18);
        Connection->NextToWrite = iVar4 + 4;
    }
    else {
        Connection->Overflow = true;
    }
    this = GetCreature(CreatureID);
    if (this != (TCreature *)0x0) {
        uVar3 = TCreature::GetSpeed(this);
        iVar4 = Connection->NextToWrite;
        if (iVar4 < Connection->NextToSend + 0x3fff) {
            Connection->OutData[iVar4 % 0x4000] = (uchar)(uVar3 & 0xffff);
            uVar5 = iVar4 + 1;
            uVar6 = iVar4 + 0x4000;
            if (-1 < (int)uVar5) {
                uVar6 = uVar5;
            }
            *(char *)((int)Connection + (uVar5 - (uVar6 & 0xffffc000)) + 0x806) =
                 (char)((uVar3 & 0xffff) >> 8);
            Connection->NextToWrite = iVar4 + 2;
        }
        else {
            Connection->Overflow = true;
        }
        FinishSendData(Connection);
        return;
    }
    error("SendCreatureSpeed: Kreatur %ld existiert nicht.\n");
    return;
}



void SendCreatureSkull(TConnection *Connection,ulong CreatureID)

{
    bool bVar1;
    TPlayer *this;
    TPlayer *Observer;
    int iVar2;
    int iVar3;
    uint uVar4;
    TPlayer *pl;
    uint uVar5;
    
    bVar1 = BeginSendData(Connection);
    if (!bVar1) {
        return;
    }
    iVar2 = Connection->NextToSend;
    iVar3 = Connection->NextToWrite;
    if (iVar3 < iVar2 + 0x4000) {
        Connection->OutData[iVar3 % 0x4000] = 0x90;
        iVar3 = iVar3 + 1;
        Connection->NextToWrite = iVar3;
    }
    else {
        Connection->Overflow = true;
    }
    if (iVar3 < iVar2 + 0x3ffd) {
        uVar5 = iVar3 + 1;
        Connection->OutData[iVar3 % 0x4000] = (uchar)CreatureID;
        uVar4 = iVar3 + 0x4000;
        if (-1 < (int)uVar5) {
            uVar4 = uVar5;
        }
        *(char *)((int)Connection + (uVar5 - (uVar4 & 0xffffc000)) + 0x806) =
             (char)(CreatureID >> 8);
        uVar5 = iVar3 + 2;
        uVar4 = iVar3 + 0x4001;
        if (-1 < (int)uVar5) {
            uVar4 = uVar5;
        }
        *(char *)((int)Connection + (uVar5 - (uVar4 & 0xffffc000)) + 0x806) =
             (char)(CreatureID >> 0x10);
        uVar5 = iVar3 + 3;
        uVar4 = iVar3 + 0x4002;
        if (-1 < (int)uVar5) {
            uVar4 = uVar5;
        }
        *(char *)((int)Connection + (uVar5 - (uVar4 & 0xffffc000)) + 0x806) =
             (char)(CreatureID >> 0x18);
        Connection->NextToWrite = iVar3 + 4;
    }
    else {
        Connection->Overflow = true;
    }
    this = GetPlayer(CreatureID);
    if (this != (TPlayer *)0x0) {
        Observer = TConnection::GetPlayer(Connection);
        iVar2 = TPlayer::GetPlayerkillingMark(this,Observer);
        iVar3 = Connection->NextToWrite;
        if (iVar3 < Connection->NextToSend + 0x4000) {
            Connection->OutData[iVar3 % 0x4000] = (uchar)iVar2;
            Connection->NextToWrite = iVar3 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        FinishSendData(Connection);
        return;
    }
    error("SendCreatureSkull: Kreatur %ld existiert nicht.\n");
    return;
}



void SendCreatureParty(TConnection *Connection,ulong CreatureID)

{
    bool bVar1;
    TPlayer *this;
    TPlayer *Observer;
    int iVar2;
    int iVar3;
    uint uVar4;
    TPlayer *pl;
    uint uVar5;
    
    bVar1 = BeginSendData(Connection);
    if (!bVar1) {
        return;
    }
    iVar2 = Connection->NextToSend;
    iVar3 = Connection->NextToWrite;
    if (iVar3 < iVar2 + 0x4000) {
        Connection->OutData[iVar3 % 0x4000] = 0x91;
        iVar3 = iVar3 + 1;
        Connection->NextToWrite = iVar3;
    }
    else {
        Connection->Overflow = true;
    }
    if (iVar3 < iVar2 + 0x3ffd) {
        uVar5 = iVar3 + 1;
        Connection->OutData[iVar3 % 0x4000] = (uchar)CreatureID;
        uVar4 = iVar3 + 0x4000;
        if (-1 < (int)uVar5) {
            uVar4 = uVar5;
        }
        *(char *)((int)Connection + (uVar5 - (uVar4 & 0xffffc000)) + 0x806) =
             (char)(CreatureID >> 8);
        uVar5 = iVar3 + 2;
        uVar4 = iVar3 + 0x4001;
        if (-1 < (int)uVar5) {
            uVar4 = uVar5;
        }
        *(char *)((int)Connection + (uVar5 - (uVar4 & 0xffffc000)) + 0x806) =
             (char)(CreatureID >> 0x10);
        uVar5 = iVar3 + 3;
        uVar4 = iVar3 + 0x4002;
        if (-1 < (int)uVar5) {
            uVar4 = uVar5;
        }
        *(char *)((int)Connection + (uVar5 - (uVar4 & 0xffffc000)) + 0x806) =
             (char)(CreatureID >> 0x18);
        Connection->NextToWrite = iVar3 + 4;
    }
    else {
        Connection->Overflow = true;
    }
    this = GetPlayer(CreatureID);
    if (this != (TPlayer *)0x0) {
        Observer = TConnection::GetPlayer(Connection);
        iVar2 = TPlayer::GetPartyMark(this,Observer);
        iVar3 = Connection->NextToWrite;
        if (iVar3 < Connection->NextToSend + 0x4000) {
            Connection->OutData[iVar3 % 0x4000] = (uchar)iVar2;
            Connection->NextToWrite = iVar3 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        FinishSendData(Connection);
        return;
    }
    error("SendCreatureParty: Kreatur %ld existiert nicht.\n");
    return;
}



void SendClearTarget(TConnection *Connection)

{
    int iVar1;
    bool bVar2;
    
    bVar2 = BeginSendData(Connection);
    if (bVar2) {
        iVar1 = Connection->NextToWrite;
        if (iVar1 < Connection->NextToSend + 0x4000) {
            Connection->OutData[iVar1 % 0x4000] = 0xa3;
            Connection->NextToWrite = iVar1 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        FinishSendData(Connection);
        return;
    }
    return;
}



// WARNING: Variable defined which should be unmapped: pl

void SendPlayerData(TConnection *Connection)

{
    undefined2 uVar1;
    TSkill *pTVar2;
    bool bVar3;
    TPlayer *pTVar4;
    uint uVar5;
    int iVar6;
    uint uVar7;
    TSkill *sk;
    int Capacity;
    uint uVar8;
    int iVar9;
    int local_1c;
    TPlayer *pl;
    
    bVar3 = BeginSendData(Connection);
    if (!bVar3) {
        return;
    }
    iVar9 = Connection->NextToWrite;
    if (iVar9 < Connection->NextToSend + 0x4000) {
        Connection->OutData[iVar9 % 0x4000] = 0xa0;
        Connection->NextToWrite = iVar9 + 1;
    }
    else {
        Connection->Overflow = true;
    }
    pTVar4 = TConnection::GetPlayer(Connection);
    if (pTVar4 == (TPlayer *)0x0) {
        error(&DAT_081096e0);
        return;
    }
    pTVar2 = (pTVar4->super_TCreature).super_TSkillBase.Skills[2];
    if (pTVar2 == (TSkill *)0x0) {
        local_1c = Connection->NextToSend;
        iVar9 = Connection->NextToWrite;
        if (local_1c + 0x3fff <= iVar9) goto LAB_080d3570;
        Connection->OutData[iVar9 % 0x4000] = '\0';
        uVar8 = iVar9 + 1;
        uVar5 = iVar9 + 0x4000;
        if (-1 < (int)uVar8) {
            uVar5 = uVar8;
        }
        *(undefined1 *)((int)Connection + (uVar8 - (uVar5 & 0xffffc000)) + 0x806) = 0;
LAB_080d2d93:
        iVar9 = iVar9 + 2;
        Connection->NextToWrite = iVar9;
    }
    else {
        uVar5 = TSkill::Get(pTVar2);
        local_1c = Connection->NextToSend;
        iVar9 = Connection->NextToWrite;
        if (iVar9 < local_1c + 0x3fff) {
            Connection->OutData[iVar9 % 0x4000] = (uchar)(uVar5 & 0xffff);
            uVar7 = iVar9 + 1;
            uVar8 = iVar9 + 0x4000;
            if (-1 < (int)uVar7) {
                uVar8 = uVar7;
            }
            *(char *)((int)Connection + (uVar7 - (uVar8 & 0xffffc000)) + 0x806) =
                 (char)((uVar5 & 0xffff) >> 8);
            goto LAB_080d2d93;
        }
LAB_080d3570:
        Connection->Overflow = true;
    }
    if (pTVar2 == (TSkill *)0x0) {
        if (local_1c + 0x3fff <= iVar9) goto LAB_080d3510;
        Connection->OutData[iVar9 % 0x4000] = '\0';
        uVar8 = iVar9 + 1;
        uVar5 = iVar9 + 0x4000;
        if (-1 < (int)uVar8) {
            uVar5 = uVar8;
        }
        *(undefined1 *)((int)Connection + (uVar8 - (uVar5 & 0xffffc000)) + 0x806) = 0;
LAB_080d2df5:
        Connection->NextToWrite = iVar9 + 2;
    }
    else {
        uVar1 = (undefined2)pTVar2->Max;
        if (iVar9 < local_1c + 0x3fff) {
            uVar8 = iVar9 + 1;
            Connection->OutData[iVar9 % 0x4000] = (uchar)uVar1;
            uVar5 = iVar9 + 0x4000;
            if (-1 < (int)uVar8) {
                uVar5 = uVar8;
            }
            *(char *)((int)Connection + (uVar8 - (uVar5 & 0xffffc000)) + 0x806) =
                 (char)((ushort)uVar1 >> 8);
            goto LAB_080d2df5;
        }
LAB_080d3510:
        Connection->Overflow = true;
    }
    iVar9 = 0;
    pTVar2 = (pTVar4->super_TCreature).super_TSkillBase.Skills[5];
    if (pTVar2 != (TSkill *)0x0) {
        iVar6 = TSkill::Get(pTVar2);
        iVar9 = GetInventoryWeight((pTVar4->super_TCreature).ID);
        iVar9 = iVar6 * 100 - iVar9;
    }
    if (iVar9 < 0) {
        iVar9 = 0;
    }
    bVar3 = CheckRight((pTVar4->super_TCreature).ID,ZERO_CAPACITY);
    if (bVar3) {
        iVar9 = 0;
    }
    local_1c = Connection->NextToSend;
    iVar6 = Connection->NextToWrite;
    uVar5 = iVar9 / 100 & 0xffff;
    if (iVar6 < local_1c + 0x3fff) {
        Connection->OutData[iVar6 % 0x4000] = (uchar)uVar5;
        uVar7 = iVar6 + 1;
        uVar8 = iVar6 + 0x4000;
        if (-1 < (int)uVar7) {
            uVar8 = uVar7;
        }
        *(char *)((int)Connection + (uVar7 - (uVar8 & 0xffffc000)) + 0x806) = (char)(uVar5 >> 8);
        iVar6 = iVar6 + 2;
        Connection->NextToWrite = iVar6;
    }
    else {
        Connection->Overflow = true;
    }
    pTVar2 = (pTVar4->super_TCreature).super_TSkillBase.Skills[0];
    if (pTVar2 == (TSkill *)0x0) {
        if (local_1c + 0x3ffd <= iVar6) goto LAB_080d3425;
        uVar8 = iVar6 + 1;
        Connection->OutData[iVar6 % 0x4000] = '\0';
        uVar5 = iVar6 + 0x4000;
        if (-1 < (int)uVar8) {
            uVar5 = uVar8;
        }
        *(undefined1 *)((int)Connection + (uVar8 - (uVar5 & 0xffffc000)) + 0x806) = 0;
        uVar8 = iVar6 + 2;
        uVar5 = iVar6 + 0x4001;
        if (-1 < (int)uVar8) {
            uVar5 = uVar8;
        }
        *(undefined1 *)((int)Connection + (uVar8 - (uVar5 & 0xffffc000)) + 0x806) = 0;
        uVar8 = iVar6 + 3;
        uVar5 = iVar6 + 0x4002;
        if (-1 < (int)uVar8) {
            uVar5 = uVar8;
        }
        *(undefined1 *)((int)Connection + (uVar8 - (uVar5 & 0xffffc000)) + 0x806) = 0;
LAB_080d2f38:
        Connection->NextToWrite = iVar6 + 4;
    }
    else {
        iVar9 = pTVar2->Exp;
        if (iVar6 < local_1c + 0x3ffd) {
            Connection->OutData[iVar6 % 0x4000] = (uchar)iVar9;
            uVar8 = iVar6 + 1;
            uVar5 = iVar6 + 0x4000;
            if (-1 < (int)uVar8) {
                uVar5 = uVar8;
            }
            *(char *)((int)Connection + (uVar8 - (uVar5 & 0xffffc000)) + 0x806) =
                 (char)((uint)iVar9 >> 8);
            uVar8 = iVar6 + 2;
            uVar5 = iVar6 + 0x4001;
            if (-1 < (int)uVar8) {
                uVar5 = uVar8;
            }
            *(char *)((int)Connection + (uVar8 - (uVar5 & 0xffffc000)) + 0x806) =
                 (char)((uint)iVar9 >> 0x10);
            uVar8 = iVar6 + 3;
            uVar5 = iVar6 + 0x4002;
            if (-1 < (int)uVar8) {
                uVar5 = uVar8;
            }
            *(char *)((int)Connection + (uVar8 - (uVar5 & 0xffffc000)) + 0x806) =
                 (char)((uint)iVar9 >> 0x18);
            goto LAB_080d2f38;
        }
LAB_080d3425:
        Connection->Overflow = true;
    }
    if (pTVar2 == (TSkill *)0x0) {
        iVar9 = Connection->NextToWrite;
        if (local_1c + 0x3fff <= iVar9) goto LAB_080d33c6;
        uVar8 = iVar9 + 1;
        Connection->OutData[iVar9 % 0x4000] = '\0';
        uVar5 = iVar9 + 0x4000;
        if (-1 < (int)uVar8) {
            uVar5 = uVar8;
        }
        *(undefined1 *)((int)Connection + (uVar8 - (uVar5 & 0xffffc000)) + 0x806) = 0;
LAB_080d2fb2:
        Connection->NextToWrite = iVar9 + 2;
    }
    else {
        uVar5 = TSkill::Get(pTVar2);
        local_1c = Connection->NextToSend;
        iVar9 = Connection->NextToWrite;
        if (iVar9 < local_1c + 0x3fff) {
            Connection->OutData[iVar9 % 0x4000] = (uchar)(uVar5 & 0xffff);
            uVar7 = iVar9 + 1;
            uVar8 = iVar9 + 0x4000;
            if (-1 < (int)uVar7) {
                uVar8 = uVar7;
            }
            *(char *)((int)Connection + (uVar7 - (uVar8 & 0xffffc000)) + 0x806) =
                 (char)((uVar5 & 0xffff) >> 8);
            goto LAB_080d2fb2;
        }
LAB_080d33c6:
        Connection->Overflow = true;
    }
    if (pTVar2 == (TSkill *)0x0) {
        iVar9 = Connection->NextToWrite;
        if (local_1c + 0x4000 <= iVar9) goto LAB_080d3383;
        Connection->OutData[iVar9 % 0x4000] = '\0';
LAB_080d3009:
        Connection->NextToWrite = iVar9 + 1;
    }
    else {
        iVar6 = TSkill::GetProgress(pTVar2);
        local_1c = Connection->NextToSend;
        iVar9 = Connection->NextToWrite;
        if (iVar9 < local_1c + 0x4000) {
            Connection->OutData[iVar9 % 0x4000] = (uchar)iVar6;
            goto LAB_080d3009;
        }
LAB_080d3383:
        Connection->Overflow = true;
    }
    pTVar2 = (pTVar4->super_TCreature).super_TSkillBase.Skills[3];
    if (pTVar2 == (TSkill *)0x0) {
        iVar9 = Connection->NextToWrite;
        if (local_1c + 0x3fff <= iVar9) goto LAB_080d3321;
        uVar8 = iVar9 + 1;
        Connection->OutData[iVar9 % 0x4000] = '\0';
        uVar5 = iVar9 + 0x4000;
        if (-1 < (int)uVar8) {
            uVar5 = uVar8;
        }
        *(undefined1 *)((int)Connection + (uVar8 - (uVar5 & 0xffffc000)) + 0x806) = 0;
LAB_080d3086:
        iVar9 = iVar9 + 2;
        Connection->NextToWrite = iVar9;
    }
    else {
        uVar5 = TSkill::Get(pTVar2);
        local_1c = Connection->NextToSend;
        iVar9 = Connection->NextToWrite;
        if (iVar9 < local_1c + 0x3fff) {
            Connection->OutData[iVar9 % 0x4000] = (uchar)(uVar5 & 0xffff);
            uVar7 = iVar9 + 1;
            uVar8 = iVar9 + 0x4000;
            if (-1 < (int)uVar7) {
                uVar8 = uVar7;
            }
            *(char *)((int)Connection + (uVar7 - (uVar8 & 0xffffc000)) + 0x806) =
                 (char)((uVar5 & 0xffff) >> 8);
            goto LAB_080d3086;
        }
LAB_080d3321:
        Connection->Overflow = true;
    }
    if (pTVar2 == (TSkill *)0x0) {
        if (local_1c + 0x3fff <= iVar9) goto LAB_080d32c8;
        uVar8 = iVar9 + 1;
        Connection->OutData[iVar9 % 0x4000] = '\0';
        uVar5 = iVar9 + 0x4000;
        if (-1 < (int)uVar8) {
            uVar5 = uVar8;
        }
        *(undefined1 *)((int)Connection + (uVar8 - (uVar5 & 0xffffc000)) + 0x806) = 0;
LAB_080d30e8:
        Connection->NextToWrite = iVar9 + 2;
    }
    else {
        uVar1 = (undefined2)pTVar2->Max;
        if (iVar9 < local_1c + 0x3fff) {
            Connection->OutData[iVar9 % 0x4000] = (uchar)uVar1;
            uVar8 = iVar9 + 1;
            uVar5 = iVar9 + 0x4000;
            if (-1 < (int)uVar8) {
                uVar5 = uVar8;
            }
            *(char *)((int)Connection + (uVar8 - (uVar5 & 0xffffc000)) + 0x806) =
                 (char)((ushort)uVar1 >> 8);
            goto LAB_080d30e8;
        }
LAB_080d32c8:
        Connection->Overflow = true;
    }
    pTVar2 = (pTVar4->super_TCreature).super_TSkillBase.Skills[1];
    if (pTVar2 == (TSkill *)0x0) {
        iVar9 = Connection->NextToWrite;
        if (local_1c + 0x4000 <= iVar9) goto LAB_080d3286;
        Connection->OutData[iVar9 % 0x4000] = '\0';
LAB_080d3143:
        Connection->NextToWrite = iVar9 + 1;
    }
    else {
        iVar6 = TSkill::Get(pTVar2);
        local_1c = Connection->NextToSend;
        iVar9 = Connection->NextToWrite;
        if (iVar9 < local_1c + 0x4000) {
            Connection->OutData[iVar9 % 0x4000] = (uchar)iVar6;
            goto LAB_080d3143;
        }
LAB_080d3286:
        Connection->Overflow = true;
    }
    if (pTVar2 == (TSkill *)0x0) {
        iVar9 = Connection->NextToWrite;
        if (local_1c + 0x4000 <= iVar9) goto LAB_080d3243;
        Connection->OutData[iVar9 % 0x4000] = '\0';
LAB_080d319a:
        Connection->NextToWrite = iVar9 + 1;
    }
    else {
        iVar6 = TSkill::GetProgress(pTVar2);
        local_1c = Connection->NextToSend;
        iVar9 = Connection->NextToWrite;
        if (iVar9 < local_1c + 0x4000) {
            Connection->OutData[iVar9 % 0x4000] = (uchar)iVar6;
            goto LAB_080d319a;
        }
LAB_080d3243:
        Connection->Overflow = true;
    }
    pTVar2 = (pTVar4->super_TCreature).super_TSkillBase.Skills[0x16];
    if (pTVar2 == (TSkill *)0x0) {
        iVar9 = Connection->NextToWrite;
        if (local_1c + 0x4000 <= iVar9) goto LAB_080d3201;
        Connection->OutData[iVar9 % 0x4000] = '\0';
    }
    else {
        iVar6 = TSkill::Get(pTVar2);
        iVar9 = Connection->NextToWrite;
        if (Connection->NextToSend + 0x4000 <= iVar9) {
LAB_080d3201:
            Connection->Overflow = true;
            goto LAB_080d31f2;
        }
        Connection->OutData[iVar9 % 0x4000] = (uchar)iVar6;
    }
    Connection->NextToWrite = iVar9 + 1;
LAB_080d31f2:
    FinishSendData(Connection);
    return;
}



// WARNING: Variable defined which should be unmapped: pl

void SendPlayerSkills(TConnection *Connection)

{
    TSkill *pTVar1;
    bool bVar2;
    TPlayer *pTVar3;
    int iVar4;
    int iVar5;
    int iVar6;
    TSkill *sk;
    uchar local_18;
    TPlayer *pl;
    
    bVar2 = BeginSendData(Connection);
    if (!bVar2) {
        return;
    }
    iVar6 = Connection->NextToWrite;
    if (iVar6 < Connection->NextToSend + 0x4000) {
        Connection->OutData[iVar6 % 0x4000] = 0xa1;
        Connection->NextToWrite = iVar6 + 1;
    }
    else {
        Connection->Overflow = true;
    }
    pTVar3 = TConnection::GetPlayer(Connection);
    if (pTVar3 == (TPlayer *)0x0) {
        error(&DAT_08109720);
        return;
    }
    pTVar1 = (pTVar3->super_TCreature).super_TSkillBase.Skills[0xb];
    if (pTVar1 == (TSkill *)0x0) {
        iVar5 = Connection->NextToSend;
        iVar6 = Connection->NextToWrite;
        if (iVar5 + 0x4000 <= iVar6) goto LAB_080d3e93;
        Connection->OutData[iVar6 % 0x4000] = '\0';
LAB_080d36d2:
        Connection->NextToWrite = iVar6 + 1;
    }
    else {
        iVar4 = TSkill::Get(pTVar1);
        iVar5 = Connection->NextToSend;
        iVar6 = Connection->NextToWrite;
        if (iVar6 < iVar5 + 0x4000) {
            local_18 = (uchar)iVar4;
            Connection->OutData[iVar6 % 0x4000] = local_18;
            goto LAB_080d36d2;
        }
LAB_080d3e93:
        Connection->Overflow = true;
    }
    if (pTVar1 == (TSkill *)0x0) {
        iVar6 = Connection->NextToWrite;
        if (iVar5 + 0x4000 <= iVar6) goto LAB_080d3e52;
        Connection->OutData[iVar6 % 0x4000] = '\0';
LAB_080d3725:
        Connection->NextToWrite = iVar6 + 1;
    }
    else {
        iVar4 = TSkill::GetProgress(pTVar1);
        iVar6 = Connection->NextToWrite;
        iVar5 = Connection->NextToSend;
        if (iVar6 < iVar5 + 0x4000) {
            Connection->OutData[iVar6 % 0x4000] = (uchar)iVar4;
            goto LAB_080d3725;
        }
LAB_080d3e52:
        Connection->Overflow = true;
    }
    pTVar1 = (pTVar3->super_TCreature).super_TSkillBase.Skills[9];
    if (pTVar1 == (TSkill *)0x0) {
        iVar6 = Connection->NextToWrite;
        if (iVar5 + 0x4000 <= iVar6) goto LAB_080d3e13;
        Connection->OutData[iVar6 % 0x4000] = '\0';
LAB_080d3781:
        Connection->NextToWrite = iVar6 + 1;
    }
    else {
        iVar4 = TSkill::Get(pTVar1);
        iVar5 = Connection->NextToSend;
        iVar6 = Connection->NextToWrite;
        if (iVar6 < iVar5 + 0x4000) {
            local_18 = (uchar)iVar4;
            Connection->OutData[iVar6 % 0x4000] = local_18;
            goto LAB_080d3781;
        }
LAB_080d3e13:
        Connection->Overflow = true;
    }
    if (pTVar1 == (TSkill *)0x0) {
        iVar6 = Connection->NextToWrite;
        if (iVar5 + 0x4000 <= iVar6) goto LAB_080d3dd2;
        Connection->OutData[iVar6 % 0x4000] = '\0';
LAB_080d37d4:
        Connection->NextToWrite = iVar6 + 1;
    }
    else {
        iVar4 = TSkill::GetProgress(pTVar1);
        iVar6 = Connection->NextToWrite;
        iVar5 = Connection->NextToSend;
        if (iVar6 < iVar5 + 0x4000) {
            Connection->OutData[iVar6 % 0x4000] = (uchar)iVar4;
            goto LAB_080d37d4;
        }
LAB_080d3dd2:
        Connection->Overflow = true;
    }
    pTVar1 = (pTVar3->super_TCreature).super_TSkillBase.Skills[8];
    if (pTVar1 == (TSkill *)0x0) {
        iVar6 = Connection->NextToWrite;
        if (iVar5 + 0x4000 <= iVar6) goto LAB_080d3d93;
        Connection->OutData[iVar6 % 0x4000] = '\0';
LAB_080d3830:
        Connection->NextToWrite = iVar6 + 1;
    }
    else {
        iVar4 = TSkill::Get(pTVar1);
        iVar5 = Connection->NextToSend;
        iVar6 = Connection->NextToWrite;
        if (iVar6 < iVar5 + 0x4000) {
            local_18 = (uchar)iVar4;
            Connection->OutData[iVar6 % 0x4000] = local_18;
            goto LAB_080d3830;
        }
LAB_080d3d93:
        Connection->Overflow = true;
    }
    if (pTVar1 == (TSkill *)0x0) {
        iVar6 = Connection->NextToWrite;
        if (iVar5 + 0x4000 <= iVar6) goto LAB_080d3d52;
        Connection->OutData[iVar6 % 0x4000] = '\0';
LAB_080d3883:
        Connection->NextToWrite = iVar6 + 1;
    }
    else {
        iVar4 = TSkill::GetProgress(pTVar1);
        iVar6 = Connection->NextToWrite;
        iVar5 = Connection->NextToSend;
        if (iVar6 < iVar5 + 0x4000) {
            Connection->OutData[iVar6 % 0x4000] = (uchar)iVar4;
            goto LAB_080d3883;
        }
LAB_080d3d52:
        Connection->Overflow = true;
    }
    pTVar1 = (pTVar3->super_TCreature).super_TSkillBase.Skills[10];
    if (pTVar1 == (TSkill *)0x0) {
        iVar6 = Connection->NextToWrite;
        if (iVar5 + 0x4000 <= iVar6) goto LAB_080d3d13;
        Connection->OutData[iVar6 % 0x4000] = '\0';
LAB_080d38df:
        Connection->NextToWrite = iVar6 + 1;
    }
    else {
        iVar4 = TSkill::Get(pTVar1);
        iVar5 = Connection->NextToSend;
        iVar6 = Connection->NextToWrite;
        if (iVar6 < iVar5 + 0x4000) {
            local_18 = (uchar)iVar4;
            Connection->OutData[iVar6 % 0x4000] = local_18;
            goto LAB_080d38df;
        }
LAB_080d3d13:
        Connection->Overflow = true;
    }
    if (pTVar1 == (TSkill *)0x0) {
        iVar6 = Connection->NextToWrite;
        if (iVar5 + 0x4000 <= iVar6) goto LAB_080d3cd2;
        Connection->OutData[iVar6 % 0x4000] = '\0';
LAB_080d3932:
        Connection->NextToWrite = iVar6 + 1;
    }
    else {
        iVar4 = TSkill::GetProgress(pTVar1);
        iVar6 = Connection->NextToWrite;
        iVar5 = Connection->NextToSend;
        if (iVar6 < iVar5 + 0x4000) {
            Connection->OutData[iVar6 % 0x4000] = (uchar)iVar4;
            goto LAB_080d3932;
        }
LAB_080d3cd2:
        Connection->Overflow = true;
    }
    pTVar1 = (pTVar3->super_TCreature).super_TSkillBase.Skills[7];
    if (pTVar1 == (TSkill *)0x0) {
        iVar6 = Connection->NextToWrite;
        if (iVar5 + 0x4000 <= iVar6) goto LAB_080d3c93;
        Connection->OutData[iVar6 % 0x4000] = '\0';
LAB_080d398e:
        Connection->NextToWrite = iVar6 + 1;
    }
    else {
        iVar4 = TSkill::Get(pTVar1);
        iVar5 = Connection->NextToSend;
        iVar6 = Connection->NextToWrite;
        if (iVar6 < iVar5 + 0x4000) {
            local_18 = (uchar)iVar4;
            Connection->OutData[iVar6 % 0x4000] = local_18;
            goto LAB_080d398e;
        }
LAB_080d3c93:
        Connection->Overflow = true;
    }
    if (pTVar1 == (TSkill *)0x0) {
        iVar6 = Connection->NextToWrite;
        if (iVar5 + 0x4000 <= iVar6) goto LAB_080d3c52;
        Connection->OutData[iVar6 % 0x4000] = '\0';
LAB_080d39e1:
        Connection->NextToWrite = iVar6 + 1;
    }
    else {
        iVar4 = TSkill::GetProgress(pTVar1);
        iVar6 = Connection->NextToWrite;
        iVar5 = Connection->NextToSend;
        if (iVar6 < iVar5 + 0x4000) {
            Connection->OutData[iVar6 % 0x4000] = (uchar)iVar4;
            goto LAB_080d39e1;
        }
LAB_080d3c52:
        Connection->Overflow = true;
    }
    pTVar1 = (pTVar3->super_TCreature).super_TSkillBase.Skills[6];
    if (pTVar1 == (TSkill *)0x0) {
        iVar6 = Connection->NextToWrite;
        if (iVar5 + 0x4000 <= iVar6) goto LAB_080d3c13;
        Connection->OutData[iVar6 % 0x4000] = '\0';
LAB_080d3a3d:
        Connection->NextToWrite = iVar6 + 1;
    }
    else {
        iVar4 = TSkill::Get(pTVar1);
        iVar5 = Connection->NextToSend;
        iVar6 = Connection->NextToWrite;
        if (iVar6 < iVar5 + 0x4000) {
            local_18 = (uchar)iVar4;
            Connection->OutData[iVar6 % 0x4000] = local_18;
            goto LAB_080d3a3d;
        }
LAB_080d3c13:
        Connection->Overflow = true;
    }
    if (pTVar1 == (TSkill *)0x0) {
        iVar6 = Connection->NextToWrite;
        if (iVar5 + 0x4000 <= iVar6) goto LAB_080d3bd2;
        Connection->OutData[iVar6 % 0x4000] = '\0';
LAB_080d3a90:
        Connection->NextToWrite = iVar6 + 1;
    }
    else {
        iVar4 = TSkill::GetProgress(pTVar1);
        iVar6 = Connection->NextToWrite;
        iVar5 = Connection->NextToSend;
        if (iVar6 < iVar5 + 0x4000) {
            Connection->OutData[iVar6 % 0x4000] = (uchar)iVar4;
            goto LAB_080d3a90;
        }
LAB_080d3bd2:
        Connection->Overflow = true;
    }
    pTVar1 = (pTVar3->super_TCreature).super_TSkillBase.Skills[0xd];
    if (pTVar1 == (TSkill *)0x0) {
        iVar6 = Connection->NextToWrite;
        if (iVar5 + 0x4000 <= iVar6) goto LAB_080d3b91;
        Connection->OutData[iVar6 % 0x4000] = '\0';
LAB_080d3aec:
        Connection->NextToWrite = iVar6 + 1;
    }
    else {
        iVar4 = TSkill::Get(pTVar1);
        iVar5 = Connection->NextToSend;
        iVar6 = Connection->NextToWrite;
        if (iVar6 < iVar5 + 0x4000) {
            local_18 = (uchar)iVar4;
            Connection->OutData[iVar6 % 0x4000] = local_18;
            goto LAB_080d3aec;
        }
LAB_080d3b91:
        Connection->Overflow = true;
    }
    if (pTVar1 == (TSkill *)0x0) {
        iVar6 = Connection->NextToWrite;
        if (iVar5 + 0x4000 <= iVar6) goto LAB_080d3b50;
        Connection->OutData[iVar6 % 0x4000] = '\0';
    }
    else {
        iVar5 = TSkill::GetProgress(pTVar1);
        iVar6 = Connection->NextToWrite;
        if (Connection->NextToSend + 0x4000 <= iVar6) {
LAB_080d3b50:
            Connection->Overflow = true;
            goto LAB_080d3b3e;
        }
        Connection->OutData[iVar6 % 0x4000] = (uchar)iVar5;
    }
    Connection->NextToWrite = iVar6 + 1;
LAB_080d3b3e:
    FinishSendData(Connection);
    return;
}



// WARNING: Variable defined which should be unmapped: State_local

void SendPlayerState(TConnection *Connection,uchar State)

{
    int iVar1;
    bool bVar2;
    int iVar3;
    uchar State_local;
    
    bVar2 = BeginSendData(Connection);
    if (bVar2) {
        iVar1 = Connection->NextToSend;
        iVar3 = Connection->NextToWrite;
        if (iVar3 < iVar1 + 0x4000) {
            Connection->OutData[iVar3 % 0x4000] = 0xa2;
            iVar3 = iVar3 + 1;
            Connection->NextToWrite = iVar3;
        }
        else {
            Connection->Overflow = true;
        }
        if (iVar3 < iVar1 + 0x4000) {
            Connection->OutData[iVar3 % 0x4000] = State;
            Connection->NextToWrite = iVar3 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        FinishSendData(Connection);
        return;
    }
    return;
}



void SendMessage(TConnection *Connection,int Mode,char *Text,...)

{
    int iVar1;
    bool bVar2;
    size_t Length;
    uint uVar3;
    uint uVar4;
    int iVar5;
    int iVar6;
    char local_101c [4];
    char Buffer [4096];
    
    if (Mode - 0x12U < 6) {
        bVar2 = BeginSendData(Connection);
        if (bVar2) {
            vsnprintf(local_101c,0x1000,Text,&stack0x00000010);
            iVar1 = Connection->NextToSend;
            iVar6 = Connection->NextToWrite;
            if (iVar6 < iVar1 + 0x4000) {
                iVar5 = iVar6 % 0x4000;
                iVar6 = iVar6 + 1;
                Connection->OutData[iVar5] = 0xb4;
                Connection->NextToWrite = iVar6;
            }
            else {
                Connection->Overflow = true;
            }
            if (iVar6 < iVar1 + 0x4000) {
                iVar5 = iVar6 % 0x4000;
                iVar6 = iVar6 + 1;
                Connection->OutData[iVar5] = (uchar)Mode;
                Connection->NextToWrite = iVar6;
            }
            else {
                Connection->Overflow = true;
            }
            Length = strlen(local_101c);
            if (iVar6 < iVar1 + 0x3fff) {
                Connection->OutData[iVar6 % 0x4000] = (uchar)(Length & 0xffff);
                uVar4 = iVar6 + 1;
                uVar3 = iVar6 + 0x4000;
                if (-1 < (int)uVar4) {
                    uVar3 = uVar4;
                }
                *(char *)((int)Connection + (uVar4 - (uVar3 & 0xffffc000)) + 0x806) =
                     (char)((Length & 0xffff) >> 8);
                Connection->NextToWrite = iVar6 + 2;
            }
            else {
                Connection->Overflow = true;
            }
            if (0 < (int)Length) {
                SendText(Connection,local_101c,Length);
            }
            FinishSendData(Connection);
        }
    }
    else {
        error(&DAT_08109760,Mode);
    }
    return;
}



void SendSnapback(TConnection *Connection)

{
    int iVar1;
    bool bVar2;
    TPlayer *pl;
    TPlayer *pTVar3;
    
    bVar2 = BeginSendData(Connection);
    if (bVar2) {
        iVar1 = Connection->NextToWrite;
        if (iVar1 < Connection->NextToSend + 0x4000) {
            Connection->OutData[iVar1 % 0x4000] = 0xb5;
            Connection->NextToWrite = iVar1 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        pTVar3 = TConnection::GetPlayer(Connection);
        if (pTVar3 != (TPlayer *)0x0) {
            iVar1 = Connection->NextToWrite;
            if (iVar1 < Connection->NextToSend + 0x4000) {
                Connection->OutData[iVar1 % 0x4000] = (uchar)(pTVar3->super_TCreature).Direction;
                Connection->NextToWrite = iVar1 + 1;
            }
            else {
                Connection->Overflow = true;
            }
            FinishSendData(Connection);
            return;
        }
    }
    return;
}



// WARNING: Variable defined which should be unmapped: Sender_local

void SendTalk(TConnection *Connection,ulong StatementID,char *Sender,int Mode,char *Text,int Data)

{
    bool bVar1;
    size_t sVar2;
    uint uVar3;
    int iVar4;
    uint uVar5;
    int local_28;
    uchar local_24;
    uchar local_1c;
    int Data_local;
    char *Text_local;
    char *Sender_local;
    
    if ((((Mode != 4) && (Mode != 7)) && (Mode != 8)) &&
       (((Mode != 6 && (Mode != 0xb)) && (Mode != 9)))) {
        error(&DAT_081097c0);
        return;
    }
    if (Sender == (char *)0x0) {
        Connection = (TConnection *)s_SendTalk______Sender_ist_NULL__081097a0;
    }
    else {
        if (Text != (char *)0x0) {
            bVar1 = BeginSendData(Connection);
            if (bVar1) {
                local_28 = Connection->NextToSend;
                iVar4 = Connection->NextToWrite;
                if (iVar4 < local_28 + 0x4000) {
                    Connection->OutData[iVar4 % 0x4000] = 0xaa;
                    iVar4 = iVar4 + 1;
                    Connection->NextToWrite = iVar4;
                }
                else {
                    Connection->Overflow = true;
                }
                if (iVar4 < local_28 + 0x3ffd) {
                    Connection->OutData[iVar4 % 0x4000] = (uchar)StatementID;
                    uVar5 = iVar4 + 1;
                    uVar3 = iVar4 + 0x4000;
                    if (-1 < (int)uVar5) {
                        uVar3 = uVar5;
                    }
                    *(char *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) =
                         (char)(StatementID >> 8);
                    uVar5 = iVar4 + 2;
                    uVar3 = iVar4 + 0x4001;
                    if (-1 < (int)uVar5) {
                        uVar3 = uVar5;
                    }
                    *(char *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) =
                         (char)(StatementID >> 0x10);
                    uVar5 = iVar4 + 3;
                    uVar3 = iVar4 + 0x4002;
                    if (-1 < (int)uVar5) {
                        uVar3 = uVar5;
                    }
                    *(char *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) =
                         (char)(StatementID >> 0x18);
                    Connection->NextToWrite = iVar4 + 4;
                }
                else {
                    Connection->Overflow = true;
                }
                if (Sender == (char *)0x0) {
                    error("SendString: String ist NULL.\n");
                    local_28 = Connection->NextToSend;
                }
                else {
                    sVar2 = strlen(Sender);
                    iVar4 = Connection->NextToWrite;
                    if (iVar4 < local_28 + 0x3fff) {
                        local_24 = (uchar)(sVar2 & 0xffff);
                        Connection->OutData[iVar4 % 0x4000] = local_24;
                        uVar5 = iVar4 + 1;
                        uVar3 = iVar4 + 0x4000;
                        if (-1 < (int)uVar5) {
                            uVar3 = uVar5;
                        }
                        local_24 = (uchar)((sVar2 & 0xffff) >> 8);
                        *(uchar *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) =
                             local_24;
                        Connection->NextToWrite = iVar4 + 2;
                    }
                    else {
                        Connection->Overflow = true;
                    }
                    if (0 < (int)sVar2) {
                        SendText(Connection,Sender,sVar2);
                        local_28 = Connection->NextToSend;
                    }
                }
                iVar4 = Connection->NextToWrite;
                if (iVar4 < local_28 + 0x4000) {
                    Connection->OutData[iVar4 % 0x4000] = (uchar)Mode;
                    Connection->NextToWrite = iVar4 + 1;
                }
                else {
                    Connection->Overflow = true;
                }
                if (Mode == 6) {
                    iVar4 = Connection->NextToWrite;
                    if (iVar4 < local_28 + 0x3ffd) {
                        local_1c = (uchar)Data;
                        uVar5 = iVar4 + 1;
                        Connection->OutData[iVar4 % 0x4000] = local_1c;
                        uVar3 = iVar4 + 0x4000;
                        if (-1 < (int)uVar5) {
                            uVar3 = uVar5;
                        }
                        local_1c = (uchar)((uint)Data >> 8);
                        *(uchar *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) =
                             local_1c;
                        uVar5 = iVar4 + 2;
                        uVar3 = iVar4 + 0x4001;
                        if (-1 < (int)uVar5) {
                            uVar3 = uVar5;
                        }
                        local_1c = (uchar)((uint)Data >> 0x10);
                        *(uchar *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) =
                             local_1c;
                        uVar5 = iVar4 + 3;
                        uVar3 = iVar4 + 0x4002;
                        if (-1 < (int)uVar5) {
                            uVar3 = uVar5;
                        }
                        local_1c = (uchar)((uint)Data >> 0x18);
                        Connection->NextToWrite = iVar4 + 4;
                        *(uchar *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) =
                             local_1c;
                    }
                    else {
                        Connection->Overflow = true;
                    }
                }
                if (Text == (char *)0x0) {
                    error("SendString: String ist NULL.\n");
                }
                else {
                    sVar2 = strlen(Text);
                    iVar4 = Connection->NextToWrite;
                    if (iVar4 < local_28 + 0x3fff) {
                        Connection->OutData[iVar4 % 0x4000] = (uchar)(sVar2 & 0xffff);
                        uVar5 = iVar4 + 1;
                        uVar3 = iVar4 + 0x4000;
                        if (-1 < (int)uVar5) {
                            uVar3 = uVar5;
                        }
                        *(char *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) =
                             (char)((sVar2 & 0xffff) >> 8);
                        Connection->NextToWrite = iVar4 + 2;
                    }
                    else {
                        Connection->Overflow = true;
                    }
                    if (0 < (int)sVar2) {
                        SendText(Connection,Text,sVar2);
                    }
                }
                FinishSendData(Connection);
                return;
            }
            return;
        }
        Connection = (TConnection *)s_SendTalk______Text_ist_NULL__08109deb;
    }
    error((char *)Connection);
    return;
}



// WARNING: Removing unreachable block (ram,0x080d4a56)
// WARNING: Variable defined which should be unmapped: Sender_local

void __regparm2
SendTalk(TConnection *Connection,ulong StatementID,char *Sender,int Mode,int Channel,char *Text)

{
    bool bVar1;
    size_t sVar2;
    uint uVar3;
    int iVar4;
    uint uVar5;
    int iVar6;
    undefined2 in_stack_00000014;
    char *in_stack_00000018;
    int local_2c;
    char local_28;
    char local_24;
    char *Text_local;
    int Channel_local;
    char *Sender_local;
    
    if ((((Text != (char *)0x5) && (Text != (char *)0xa)) && (Text != (char *)0xc)) &&
       (Text != (char *)0xe)) {
        error(&DAT_08109820);
        return;
    }
    if (Channel == 0) {
        Sender = "SendTalk (C): Sender ist NULL.\n";
    }
    else {
        if (in_stack_00000018 != (char *)0x0) {
            bVar1 = BeginSendData((TConnection *)Sender);
            if (!bVar1) {
                return;
            }
            local_2c = *(int *)(Sender + 0x4808);
            iVar4 = *(int *)(Sender + 0x4810);
            if (iVar4 < local_2c + 0x4000) {
                Sender[iVar4 % 0x4000 + 0x806] = -0x56;
                iVar4 = iVar4 + 1;
                *(int *)(Sender + 0x4810) = iVar4;
            }
            else {
                Sender[0x4814] = '\x01';
            }
            if (iVar4 < local_2c + 0x3ffd) {
                Sender[iVar4 % 0x4000 + 0x806] = (char)Mode;
                uVar5 = iVar4 + 1;
                uVar3 = iVar4 + 0x4000;
                if (-1 < (int)uVar5) {
                    uVar3 = uVar5;
                }
                Sender[(uVar5 - (uVar3 & 0xffffc000)) + 0x806] = (char)((uint)Mode >> 8);
                uVar5 = iVar4 + 2;
                uVar3 = iVar4 + 0x4001;
                if (-1 < (int)uVar5) {
                    uVar3 = uVar5;
                }
                Sender[(uVar5 - (uVar3 & 0xffffc000)) + 0x806] = (char)((uint)Mode >> 0x10);
                uVar5 = iVar4 + 3;
                uVar3 = iVar4 + 0x4002;
                if (-1 < (int)uVar5) {
                    uVar3 = uVar5;
                }
                Sender[(uVar5 - (uVar3 & 0xffffc000)) + 0x806] = (char)((uint)Mode >> 0x18);
                *(int *)(Sender + 0x4810) = iVar4 + 4;
            }
            else {
                Sender[0x4814] = '\x01';
            }
            if (Text == (char *)0xe) {
                sVar2 = strlen("");
                iVar4 = *(int *)(Sender + 0x4810);
                if (iVar4 < local_2c + 0x3fff) {
                    local_24 = (char)(sVar2 & 0xffff);
                    Sender[iVar4 % 0x4000 + 0x806] = local_24;
                    uVar5 = iVar4 + 1;
                    uVar3 = iVar4 + 0x4000;
                    if (-1 < (int)uVar5) {
                        uVar3 = uVar5;
                    }
                    local_24 = (char)((sVar2 & 0xffff) >> 8);
                    Sender[(uVar5 - (uVar3 & 0xffffc000)) + 0x806] = local_24;
                    *(int *)(Sender + 0x4810) = iVar4 + 2;
                }
                else {
                    Sender[0x4814] = '\x01';
                }
                if (0 < (int)sVar2) {
                    SendText((TConnection *)Sender,"",sVar2);
                    local_2c = *(int *)(Sender + 0x4808);
                }
            }
            else {
                if (Channel == 0) {
                    error("SendString: String ist NULL.\n");
                }
                else {
                    sVar2 = strlen((char *)Channel);
                    iVar4 = *(int *)(Sender + 0x4810);
                    if (iVar4 < local_2c + 0x3fff) {
                        local_28 = (char)(sVar2 & 0xffff);
                        Sender[iVar4 % 0x4000 + 0x806] = local_28;
                        uVar5 = iVar4 + 1;
                        uVar3 = iVar4 + 0x4000;
                        if (-1 < (int)uVar5) {
                            uVar3 = uVar5;
                        }
                        local_28 = (char)((sVar2 & 0xffff) >> 8);
                        Sender[(uVar5 - (uVar3 & 0xffffc000)) + 0x806] = local_28;
                        *(int *)(Sender + 0x4810) = iVar4 + 2;
                    }
                    else {
                        Sender[0x4814] = '\x01';
                    }
                    if ((int)sVar2 < 1) goto LAB_080d47d5;
                    SendText((TConnection *)Sender,(char *)Channel,sVar2);
                }
                local_2c = *(int *)(Sender + 0x4808);
            }
LAB_080d47d5:
            iVar4 = *(int *)(Sender + 0x4810);
            if (iVar4 < local_2c + 0x4000) {
                iVar6 = iVar4 % 0x4000;
                iVar4 = iVar4 + 1;
                Sender[iVar6 + 0x806] = (char)Text;
                *(int *)(Sender + 0x4810) = iVar4;
            }
            else {
                Sender[0x4814] = '\x01';
            }
            if (iVar4 < local_2c + 0x3fff) {
                uVar5 = iVar4 + 1;
                Sender[iVar4 % 0x4000 + 0x806] = (char)in_stack_00000014;
                uVar3 = iVar4 + 0x4000;
                if (-1 < (int)uVar5) {
                    uVar3 = uVar5;
                }
                Sender[(uVar5 - (uVar3 & 0xffffc000)) + 0x806] =
                     (char)((ushort)in_stack_00000014 >> 8);
                *(int *)(Sender + 0x4810) = iVar4 + 2;
            }
            else {
                Sender[0x4814] = '\x01';
            }
            if (in_stack_00000018 == (char *)0x0) {
                error("SendString: String ist NULL.\n");
            }
            else {
                sVar2 = strlen(in_stack_00000018);
                iVar4 = *(int *)(Sender + 0x4810);
                if (iVar4 < local_2c + 0x3fff) {
                    Sender[iVar4 % 0x4000 + 0x806] = (char)(sVar2 & 0xffff);
                    uVar5 = iVar4 + 1;
                    uVar3 = iVar4 + 0x4000;
                    if (-1 < (int)uVar5) {
                        uVar3 = uVar5;
                    }
                    Sender[(uVar5 - (uVar3 & 0xffffc000)) + 0x806] = (char)((sVar2 & 0xffff) >> 8);
                    *(int *)(Sender + 0x4810) = iVar4 + 2;
                }
                else {
                    Sender[0x4814] = '\x01';
                }
                if (0 < (int)sVar2) {
                    SendText((TConnection *)Sender,in_stack_00000018,sVar2);
                }
            }
            FinishSendData((TConnection *)Sender);
            return;
        }
        Sender = "SendTalk (C): Text ist NULL.\n";
    }
    error(Sender);
    return;
}



// WARNING: Variable defined which should be unmapped: Sender_local
// WARNING: Unknown calling convention -- yet parameter storage is locked

void SendTalk(TConnection *Connection,ulong StatementID,char *Sender,int Mode,int x,int y,int z,
             char *Text)

{
    bool bVar1;
    size_t sVar2;
    uint uVar3;
    int iVar4;
    uint uVar5;
    int local_30;
    char *Text_local;
    int z_local;
    int y_local;
    int x_local;
    int Mode_local;
    char *Sender_local;
    
    if (((2 < Mode - 1U) && (Mode != 0x10)) && (Mode != 0x11)) {
        error(&DAT_08109880);
        return;
    }
    if (Sender == (char *)0x0) {
        Connection = (TConnection *)s_SendTalk__K___Sender_ist_NULL__08109860;
    }
    else {
        if (Text != (char *)0x0) {
            bVar1 = BeginSendData(Connection);
            if (bVar1) {
                local_30 = Connection->NextToSend;
                iVar4 = Connection->NextToWrite;
                if (iVar4 < local_30 + 0x4000) {
                    Connection->OutData[iVar4 % 0x4000] = 0xaa;
                    iVar4 = iVar4 + 1;
                    Connection->NextToWrite = iVar4;
                }
                else {
                    Connection->Overflow = true;
                }
                if (iVar4 < local_30 + 0x3ffd) {
                    uVar5 = iVar4 + 1;
                    Connection->OutData[iVar4 % 0x4000] = (uchar)StatementID;
                    uVar3 = iVar4 + 0x4000;
                    if (-1 < (int)uVar5) {
                        uVar3 = uVar5;
                    }
                    *(char *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) =
                         (char)(StatementID >> 8);
                    uVar5 = iVar4 + 2;
                    uVar3 = iVar4 + 0x4001;
                    if (-1 < (int)uVar5) {
                        uVar3 = uVar5;
                    }
                    *(char *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) =
                         (char)(StatementID >> 0x10);
                    uVar5 = iVar4 + 3;
                    uVar3 = iVar4 + 0x4002;
                    if (-1 < (int)uVar5) {
                        uVar3 = uVar5;
                    }
                    *(char *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) =
                         (char)(StatementID >> 0x18);
                    Connection->NextToWrite = iVar4 + 4;
                }
                else {
                    Connection->Overflow = true;
                }
                if (Sender == (char *)0x0) {
                    error("SendString: String ist NULL.\n");
                    local_30 = Connection->NextToSend;
                }
                else {
                    sVar2 = strlen(Sender);
                    iVar4 = Connection->NextToWrite;
                    if (iVar4 < local_30 + 0x3fff) {
                        Connection->OutData[iVar4 % 0x4000] = (uchar)(sVar2 & 0xffff);
                        uVar5 = iVar4 + 1;
                        uVar3 = iVar4 + 0x4000;
                        if (-1 < (int)uVar5) {
                            uVar3 = uVar5;
                        }
                        *(char *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) =
                             (char)((sVar2 & 0xffff) >> 8);
                        Connection->NextToWrite = iVar4 + 2;
                    }
                    else {
                        Connection->Overflow = true;
                    }
                    if (0 < (int)sVar2) {
                        SendText(Connection,Sender,sVar2);
                        local_30 = Connection->NextToSend;
                    }
                }
                iVar4 = Connection->NextToWrite;
                if (iVar4 < local_30 + 0x4000) {
                    x_local._0_1_ = (uchar)Mode;
                    Connection->OutData[iVar4 % 0x4000] = (uchar)x_local;
                    iVar4 = iVar4 + 1;
                    Connection->NextToWrite = iVar4;
                }
                else {
                    Connection->Overflow = true;
                }
                if (iVar4 < local_30 + 0x3fff) {
                    uVar5 = iVar4 + 1;
                    Connection->OutData[iVar4 % 0x4000] = (uchar)x;
                    uVar3 = iVar4 + 0x4000;
                    if (-1 < (int)uVar5) {
                        uVar3 = uVar5;
                    }
                    iVar4 = iVar4 + 2;
                    *(char *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) =
                         (char)((uint)x >> 8);
                    Connection->NextToWrite = iVar4;
                }
                else {
                    Connection->Overflow = true;
                }
                if (iVar4 < local_30 + 0x3fff) {
                    uVar5 = iVar4 + 1;
                    Connection->OutData[iVar4 % 0x4000] = (uchar)y;
                    uVar3 = iVar4 + 0x4000;
                    if (-1 < (int)uVar5) {
                        uVar3 = uVar5;
                    }
                    iVar4 = iVar4 + 2;
                    *(char *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) =
                         (char)((uint)y >> 8);
                    Connection->NextToWrite = iVar4;
                }
                else {
                    Connection->Overflow = true;
                }
                if (iVar4 < local_30 + 0x4000) {
                    Text_local._0_1_ = (uchar)z;
                    Connection->OutData[iVar4 % 0x4000] = (uchar)Text_local;
                    Connection->NextToWrite = iVar4 + 1;
                }
                else {
                    Connection->Overflow = true;
                }
                if (Text == (char *)0x0) {
                    error("SendString: String ist NULL.\n");
                }
                else {
                    sVar2 = strlen(Text);
                    iVar4 = Connection->NextToWrite;
                    if (iVar4 < local_30 + 0x3fff) {
                        Connection->OutData[iVar4 % 0x4000] = (uchar)(sVar2 & 0xffff);
                        uVar5 = iVar4 + 1;
                        uVar3 = iVar4 + 0x4000;
                        if (-1 < (int)uVar5) {
                            uVar3 = uVar5;
                        }
                        *(char *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) =
                             (char)((sVar2 & 0xffff) >> 8);
                        Connection->NextToWrite = iVar4 + 2;
                    }
                    else {
                        Connection->Overflow = true;
                    }
                    if (0 < (int)sVar2) {
                        SendText(Connection,Text,sVar2);
                    }
                }
                FinishSendData(Connection);
                return;
            }
            return;
        }
        Connection = (TConnection *)s_SendTalk__K___Text_ist_NULL__08109e27;
    }
    error((char *)Connection);
    return;
}



// WARNING: Removing unreachable block (ram,0x080d5313)
// WARNING: Variable defined which should be unmapped: pl

void SendChannels(TConnection *Connection)

{
    int iVar1;
    int iVar2;
    ulong uVar3;
    uint uVar4;
    bool bVar5;
    size_t sVar6;
    uint uVar7;
    int i;
    int iVar8;
    uchar uVar9;
    uchar uVar10;
    int Count;
    uint uVar11;
    uint uVar12;
    int i_1;
    uint uVar13;
    ulong uStack_50;
    size_t sStack_44;
    undefined1 auStack_40 [12];
    uint local_34;
    char *local_28;
    undefined1 *local_24;
    bool_0_ *Available;
    int local_1c;
    int Channels;
    TPlayer *pTStack_14;
    bool OwnChannel;
    TPlayer *pl;
    
    Available = &stack0xffffffb4;
    uStack_50 = 0x80d5017;
    bVar5 = BeginSendData(Connection);
    if (bVar5) {
        iVar1 = Connection->NextToWrite;
        if (iVar1 < Connection->NextToSend + 0x4000) {
            Connection->OutData[iVar1 % 0x4000] = 0xab;
            Connection->NextToWrite = iVar1 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        uStack_50 = 0x80d504d;
        pTStack_14 = TConnection::GetPlayer(Connection);
        if (pTStack_14 != (TPlayer *)0x0) {
            uVar9 = '\0';
            iVar8 = 0;
            uStack_50 = 0x80d506a;
            Channels._3_1_ = MayOpenChannel((pTStack_14->super_TCreature).ID);
            uStack_50 = 0x80d5072;
            local_1c = GetNumberOfChannels();
            iVar1 = -(local_1c + 0xfU & 0xfffffff0);
            local_24 = auStack_40 + iVar1;
            uVar10 = '\0';
            if (0 < local_1c) {
                do {
                    uVar3 = (pTStack_14->super_TCreature).ID;
                    *(int *)(&stack0xffffffb4 + iVar1) = iVar8;
                    *(ulong *)(&stack0xffffffb8 + iVar1) = uVar3;
                    *(undefined4 *)((int)&uStack_50 + iVar1) = 0x80d53bb;
                    bVar5 = ChannelAvailable(*(int *)(&stack0xffffffb4 + iVar1),
                                             *(ulong *)(&stack0xffffffb8 + iVar1));
                    uVar9 = uVar10;
                    if (bVar5) {
                        uVar9 = uVar10 + '\x01';
                    }
                    local_24[iVar8] = bVar5;
                    iVar8 = iVar8 + 1;
                    uVar10 = uVar9;
                } while (iVar8 < local_1c);
            }
            if (Channels._3_1_ != '\0') {
                uVar9 = uVar9 + '\x01';
            }
            iVar8 = Connection->NextToSend;
            iVar2 = Connection->NextToWrite;
            if (iVar2 < iVar8 + 0x4000) {
                Connection->OutData[iVar2 % 0x4000] = uVar9;
                Connection->NextToWrite = iVar2 + 1;
            }
            else {
                Connection->Overflow = true;
            }
            if (Channels._3_1_ != '\0') {
                iVar2 = Connection->NextToWrite;
                if (iVar2 < iVar8 + 0x3fff) {
                    uVar11 = iVar2 + 1;
                    uVar13 = iVar2 + 0x4000;
                    if (-1 < (int)uVar11) {
                        uVar13 = uVar11;
                    }
                    Connection->OutData[iVar2 % 0x4000] = 0xff;
                    *(undefined1 *)((int)Connection + (uVar11 - (uVar13 & 0xffffc000)) + 0x806) =
                         0xff;
                    Connection->NextToWrite = iVar2 + 2;
                }
                else {
                    Connection->Overflow = true;
                }
                *(char **)(&stack0xffffffb4 + iVar1) = "Private Chat Channel";
                *(undefined4 *)((int)&uStack_50 + iVar1) = 0x80d50f8;
                sVar6 = strlen(*(char **)(&stack0xffffffb4 + iVar1));
                iVar8 = Connection->NextToWrite;
                if (iVar8 < Connection->NextToSend + 0x3fff) {
                    Connection->OutData[iVar8 % 0x4000] = (uchar)(sVar6 & 0xffff);
                    uVar11 = iVar8 + 1;
                    uVar13 = iVar8 + 0x4000;
                    if (-1 < (int)uVar11) {
                        uVar13 = uVar11;
                    }
                    *(char *)((int)Connection + (uVar11 - (uVar13 & 0xffffc000)) + 0x806) =
                         (char)((sVar6 & 0xffff) >> 8);
                    Connection->NextToWrite = iVar8 + 2;
                }
                else {
                    Connection->Overflow = true;
                }
                if (0 < (int)sVar6) {
                    *(size_t *)((int)&sStack_44 + iVar1) = sVar6;
                    *(char **)(&stack0xffffffb8 + iVar1) = "Private Chat Channel";
                    *(TConnection **)(&stack0xffffffb4 + iVar1) = Connection;
                    *(undefined4 *)((int)&uStack_50 + iVar1) = 0x80d513b;
                    SendText(*(TConnection **)(&stack0xffffffb4 + iVar1),
                             *(char **)(&stack0xffffffb8 + iVar1),*(int *)((int)&sStack_44 + iVar1))
                    ;
                }
            }
            if (0 < local_1c) {
                uVar13 = 0;
                do {
                    if (local_24[uVar13] != '\0') {
                        iVar8 = Connection->NextToWrite;
                        if (iVar8 < Connection->NextToSend + 0x3fff) {
                            uVar7 = iVar8 + 1;
                            Connection->OutData[iVar8 % 0x4000] = (uchar)(uVar13 & 0xffff);
                            uVar11 = iVar8 + 0x4000;
                            if (-1 < (int)uVar7) {
                                uVar11 = uVar7;
                            }
                            *(char *)((int)Connection + (uVar7 - (uVar11 & 0xffffc000)) + 0x806) =
                                 (char)((uVar13 & 0xffff) >> 8);
                            Connection->NextToWrite = iVar8 + 2;
                        }
                        else {
                            Connection->Overflow = true;
                        }
                        uVar3 = (pTStack_14->super_TCreature).ID;
                        *(uint *)(&stack0xffffffb4 + iVar1) = uVar13;
                        *(ulong *)(&stack0xffffffb8 + iVar1) = uVar3;
                        *(undefined4 *)((int)&uStack_50 + iVar1) = 0x80d5198;
                        local_28 = GetChannelName(*(int *)(&stack0xffffffb4 + iVar1),
                                                  *(ulong *)(&stack0xffffffb8 + iVar1));
                        if (local_28 == (char *)0x0) {
                            *(char **)(&stack0xffffffb4 + iVar1) = "SendString: String ist NULL.\n";
                            *(undefined4 *)((int)&uStack_50 + iVar1) = 0x80d5270;
                            error(*(char **)(&stack0xffffffb4 + iVar1));
                        }
                        else {
                            *(char **)(&stack0xffffffb4 + iVar1) = local_28;
                            *(undefined4 *)((int)&uStack_50 + iVar1) = 0x80d51ae;
                            sVar6 = strlen(*(char **)(&stack0xffffffb4 + iVar1));
                            uVar11 = sVar6 & 0xffff;
                            local_34 = uVar11;
                            iVar8 = Connection->NextToWrite;
                            if (iVar8 < Connection->NextToSend + 0x3fff) {
                                local_34._0_1_ = (uchar)uVar11;
                                Connection->OutData[iVar8 % 0x4000] = (uchar)local_34;
                                uVar12 = iVar8 + 1;
                                uVar7 = iVar8 + 0x4000;
                                if (-1 < (int)uVar12) {
                                    uVar7 = uVar12;
                                }
                                local_34 = uVar11 >> 8;
                                uVar4 = local_34;
                                local_34._0_1_ = (uchar)(uVar11 >> 8);
                                *(uchar *)((int)Connection + (uVar12 - (uVar7 & 0xffffc000)) + 0x806
                                          ) = (uchar)local_34;
                                Connection->NextToWrite = iVar8 + 2;
                                local_34 = uVar4;
                            }
                            else {
                                Connection->Overflow = true;
                            }
                            if (0 < (int)sVar6) {
                                *(size_t *)((int)&sStack_44 + iVar1) = sVar6;
                                *(char **)(&stack0xffffffb8 + iVar1) = local_28;
                                *(TConnection **)(&stack0xffffffb4 + iVar1) = Connection;
                                *(undefined4 *)((int)&uStack_50 + iVar1) = 0x80d51ef;
                                SendText(*(TConnection **)(&stack0xffffffb4 + iVar1),
                                         *(char **)(&stack0xffffffb8 + iVar1),
                                         *(int *)((int)&sStack_44 + iVar1));
                            }
                        }
                    }
                    uVar13 = uVar13 + 1;
                } while ((int)uVar13 < local_1c);
            }
            *(TConnection **)(&stack0xffffffb4 + iVar1) = Connection;
            *(undefined4 *)((int)&uStack_50 + iVar1) = 0x80d5204;
            FinishSendData(*(TConnection **)(&stack0xffffffb4 + iVar1));
        }
    }
    return;
}



// WARNING: Variable defined which should be unmapped: pl

void SendOpenChannel(TConnection *Connection,int Channel)

{
    bool bVar1;
    TPlayer *pTVar2;
    int iVar3;
    char *__s;
    size_t Length;
    uint uVar4;
    uint uVar5;
    TPlayer *pl;
    
    bVar1 = BeginSendData(Connection);
    if (bVar1) {
        if (Channel == 3) {
            error("SendOpenChannel: Kanal ist GM-Request-Queue.\n");
            return;
        }
        iVar3 = Connection->NextToWrite;
        if (iVar3 < Connection->NextToSend + 0x4000) {
            Connection->OutData[iVar3 % 0x4000] = 0xac;
            Connection->NextToWrite = iVar3 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        pTVar2 = TConnection::GetPlayer(Connection);
        if (pTVar2 != (TPlayer *)0x0) {
            if ((-1 < Channel) && (iVar3 = GetNumberOfChannels(), Channel < iVar3)) {
                iVar3 = Connection->NextToWrite;
                if (iVar3 < Connection->NextToSend + 0x3fff) {
                    Connection->OutData[iVar3 % 0x4000] = (uchar)(Channel & 0xffffU);
                    uVar5 = iVar3 + 1;
                    uVar4 = iVar3 + 0x4000;
                    if (-1 < (int)uVar5) {
                        uVar4 = uVar5;
                    }
                    *(char *)((int)Connection + (uVar5 - (uVar4 & 0xffffc000)) + 0x806) =
                         (char)((Channel & 0xffffU) >> 8);
                    Connection->NextToWrite = iVar3 + 2;
                }
                else {
                    Connection->Overflow = true;
                }
                __s = GetChannelName(Channel,(pTVar2->super_TCreature).ID);
                if (__s == (char *)0x0) {
                    error("SendString: String ist NULL.\n");
                }
                else {
                    Length = strlen(__s);
                    iVar3 = Connection->NextToWrite;
                    if (iVar3 < Connection->NextToSend + 0x3fff) {
                        Connection->OutData[iVar3 % 0x4000] = (uchar)(Length & 0xffff);
                        uVar5 = iVar3 + 1;
                        uVar4 = iVar3 + 0x4000;
                        if (-1 < (int)uVar5) {
                            uVar4 = uVar5;
                        }
                        *(char *)((int)Connection + (uVar5 - (uVar4 & 0xffffc000)) + 0x806) =
                             (char)((Length & 0xffff) >> 8);
                        Connection->NextToWrite = iVar3 + 2;
                    }
                    else {
                        Connection->Overflow = true;
                    }
                    if (0 < (int)Length) {
                        SendText(Connection,__s,Length);
                    }
                }
                FinishSendData(Connection);
                return;
            }
            error(&DAT_081098a0);
            return;
        }
    }
    return;
}



// WARNING: Variable defined which should be unmapped: Name_local
// WARNING: Unknown calling convention -- yet parameter storage is locked

void SendPrivateChannel(TConnection *Connection,char *Name)

{
    int iVar1;
    int iVar2;
    bool bVar3;
    size_t Length;
    uint uVar4;
    uint uVar5;
    char *Name_local;
    
    bVar3 = BeginSendData(Connection);
    if (!bVar3) {
        return;
    }
    iVar1 = Connection->NextToSend;
    iVar2 = Connection->NextToWrite;
    if (iVar2 < iVar1 + 0x4000) {
        Connection->OutData[iVar2 % 0x4000] = 0xad;
        Connection->NextToWrite = iVar2 + 1;
    }
    else {
        Connection->Overflow = true;
    }
    if (Name != (char *)0x0) {
        Length = strlen(Name);
        iVar2 = Connection->NextToWrite;
        if (iVar2 < iVar1 + 0x3fff) {
            Connection->OutData[iVar2 % 0x4000] = (uchar)(Length & 0xffff);
            uVar5 = iVar2 + 1;
            uVar4 = iVar2 + 0x4000;
            if (-1 < (int)uVar5) {
                uVar4 = uVar5;
            }
            *(char *)((int)Connection + (uVar5 - (uVar4 & 0xffffc000)) + 0x806) =
                 (char)((Length & 0xffff) >> 8);
            Connection->NextToWrite = iVar2 + 2;
        }
        else {
            Connection->Overflow = true;
        }
        if (0 < (int)Length) {
            SendText(Connection,Name,Length);
        }
        FinishSendData(Connection);
        return;
    }
    error("SendPrivateChannel: Name ist NULL.\n");
    return;
}



void SendOpenRequestQueue(TConnection *Connection)

{
    int iVar1;
    bool bVar2;
    int iVar3;
    uint uVar4;
    uint uVar5;
    
    bVar2 = BeginSendData(Connection);
    if (bVar2) {
        iVar1 = Connection->NextToSend;
        iVar3 = Connection->NextToWrite;
        if (iVar3 < iVar1 + 0x4000) {
            Connection->OutData[iVar3 % 0x4000] = 0xae;
            iVar3 = iVar3 + 1;
            Connection->NextToWrite = iVar3;
        }
        else {
            Connection->Overflow = true;
        }
        if (iVar3 < iVar1 + 0x3fff) {
            uVar5 = iVar3 + 1;
            Connection->OutData[iVar3 % 0x4000] = '\x03';
            uVar4 = iVar3 + 0x4000;
            if (-1 < (int)uVar5) {
                uVar4 = uVar5;
            }
            *(undefined1 *)((int)Connection + (uVar5 - (uVar4 & 0xffffc000)) + 0x806) = 0;
            Connection->NextToWrite = iVar3 + 2;
        }
        else {
            Connection->Overflow = true;
        }
        FinishSendData(Connection);
        return;
    }
    return;
}



// WARNING: Variable defined which should be unmapped: Name_local

void __regparm2 SendDeleteRequest(TConnection *Connection,char *Name)

{
    int iVar1;
    int iVar2;
    bool bVar3;
    size_t Length;
    uint uVar4;
    uint uVar5;
    TConnection *in_stack_00000004;
    char *in_stack_00000008;
    char *Name_local;
    
    bVar3 = BeginSendData(in_stack_00000004);
    if (!bVar3) {
        return;
    }
    iVar1 = in_stack_00000004->NextToSend;
    iVar2 = in_stack_00000004->NextToWrite;
    if (iVar2 < iVar1 + 0x4000) {
        in_stack_00000004->OutData[iVar2 % 0x4000] = 0xaf;
        in_stack_00000004->NextToWrite = iVar2 + 1;
    }
    else {
        in_stack_00000004->Overflow = true;
    }
    if (in_stack_00000008 != (char *)0x0) {
        Length = strlen(in_stack_00000008);
        iVar2 = in_stack_00000004->NextToWrite;
        if (iVar2 < iVar1 + 0x3fff) {
            in_stack_00000004->OutData[iVar2 % 0x4000] = (uchar)(Length & 0xffff);
            uVar5 = iVar2 + 1;
            uVar4 = iVar2 + 0x4000;
            if (-1 < (int)uVar5) {
                uVar4 = uVar5;
            }
            *(char *)((int)in_stack_00000004 + (uVar5 - (uVar4 & 0xffffc000)) + 0x806) =
                 (char)((Length & 0xffff) >> 8);
            in_stack_00000004->NextToWrite = iVar2 + 2;
        }
        else {
            in_stack_00000004->Overflow = true;
        }
        if (0 < (int)Length) {
            SendText(in_stack_00000004,in_stack_00000008,Length);
        }
        FinishSendData(in_stack_00000004);
        return;
    }
    error("SendDeleteRequest: Name ist NULL.\n");
    return;
}



// WARNING: Variable defined which should be unmapped: Name_local
// WARNING: Unknown calling convention -- yet parameter storage is locked

void SendFinishRequest(TConnection *Connection,char *Name)

{
    int iVar1;
    int iVar2;
    bool bVar3;
    size_t Length;
    uint uVar4;
    uint uVar5;
    char *Name_local;
    
    bVar3 = BeginSendData(Connection);
    if (!bVar3) {
        return;
    }
    iVar1 = Connection->NextToSend;
    iVar2 = Connection->NextToWrite;
    if (iVar2 < iVar1 + 0x4000) {
        Connection->OutData[iVar2 % 0x4000] = 0xb0;
        Connection->NextToWrite = iVar2 + 1;
    }
    else {
        Connection->Overflow = true;
    }
    if (Name != (char *)0x0) {
        Length = strlen(Name);
        iVar2 = Connection->NextToWrite;
        if (iVar2 < iVar1 + 0x3fff) {
            Connection->OutData[iVar2 % 0x4000] = (uchar)(Length & 0xffff);
            uVar5 = iVar2 + 1;
            uVar4 = iVar2 + 0x4000;
            if (-1 < (int)uVar5) {
                uVar4 = uVar5;
            }
            *(char *)((int)Connection + (uVar5 - (uVar4 & 0xffffc000)) + 0x806) =
                 (char)((Length & 0xffff) >> 8);
            Connection->NextToWrite = iVar2 + 2;
        }
        else {
            Connection->Overflow = true;
        }
        if (0 < (int)Length) {
            SendText(Connection,Name,Length);
        }
        FinishSendData(Connection);
        return;
    }
    error("SendFinishRequest: Name ist NULL.\n");
    return;
}



void SendCloseRequest(TConnection *Connection)

{
    int iVar1;
    bool bVar2;
    
    bVar2 = BeginSendData(Connection);
    if (bVar2) {
        iVar1 = Connection->NextToWrite;
        if (iVar1 < Connection->NextToSend + 0x4000) {
            Connection->OutData[iVar1 % 0x4000] = 0xb1;
            Connection->NextToWrite = iVar1 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        FinishSendData(Connection);
        return;
    }
    return;
}



// WARNING: Variable defined which should be unmapped: pl

void SendOpenOwnChannel(TConnection *Connection,int Channel)

{
    bool bVar1;
    TPlayer *pTVar2;
    int iVar3;
    char *__s;
    size_t Length;
    uint uVar4;
    uint uVar5;
    TPlayer *pl;
    
    bVar1 = BeginSendData(Connection);
    if (bVar1) {
        iVar3 = Connection->NextToWrite;
        if (iVar3 < Connection->NextToSend + 0x4000) {
            Connection->OutData[iVar3 % 0x4000] = 0xb2;
            Connection->NextToWrite = iVar3 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        pTVar2 = TConnection::GetPlayer(Connection);
        if (pTVar2 != (TPlayer *)0x0) {
            if ((-1 < Channel) && (iVar3 = GetNumberOfChannels(), Channel < iVar3)) {
                iVar3 = Connection->NextToWrite;
                if (iVar3 < Connection->NextToSend + 0x3fff) {
                    Connection->OutData[iVar3 % 0x4000] = (uchar)(Channel & 0xffffU);
                    uVar5 = iVar3 + 1;
                    uVar4 = iVar3 + 0x4000;
                    if (-1 < (int)uVar5) {
                        uVar4 = uVar5;
                    }
                    *(char *)((int)Connection + (uVar5 - (uVar4 & 0xffffc000)) + 0x806) =
                         (char)((Channel & 0xffffU) >> 8);
                    Connection->NextToWrite = iVar3 + 2;
                }
                else {
                    Connection->Overflow = true;
                }
                __s = GetChannelName(Channel,(pTVar2->super_TCreature).ID);
                if (__s == (char *)0x0) {
                    error("SendString: String ist NULL.\n");
                }
                else {
                    Length = strlen(__s);
                    iVar3 = Connection->NextToWrite;
                    if (iVar3 < Connection->NextToSend + 0x3fff) {
                        Connection->OutData[iVar3 % 0x4000] = (uchar)(Length & 0xffff);
                        uVar5 = iVar3 + 1;
                        uVar4 = iVar3 + 0x4000;
                        if (-1 < (int)uVar5) {
                            uVar4 = uVar5;
                        }
                        *(char *)((int)Connection + (uVar5 - (uVar4 & 0xffffc000)) + 0x806) =
                             (char)((Length & 0xffff) >> 8);
                        Connection->NextToWrite = iVar3 + 2;
                    }
                    else {
                        Connection->Overflow = true;
                    }
                    if (0 < (int)Length) {
                        SendText(Connection,__s,Length);
                    }
                }
                FinishSendData(Connection);
                return;
            }
            error(&DAT_081099e0);
            return;
        }
    }
    return;
}



void SendCloseChannel(TConnection *Connection,int Channel)

{
    int iVar1;
    bool bVar2;
    int iVar3;
    uint uVar4;
    uint uVar5;
    
    bVar2 = BeginSendData(Connection);
    if (bVar2) {
        iVar1 = Connection->NextToSend;
        iVar3 = Connection->NextToWrite;
        if (iVar3 < iVar1 + 0x4000) {
            Connection->OutData[iVar3 % 0x4000] = 0xb3;
            iVar3 = iVar3 + 1;
            Connection->NextToWrite = iVar3;
        }
        else {
            Connection->Overflow = true;
        }
        if (iVar3 < iVar1 + 0x3fff) {
            uVar5 = iVar3 + 1;
            Connection->OutData[iVar3 % 0x4000] = (uchar)(Channel & 0xffffU);
            uVar4 = iVar3 + 0x4000;
            if (-1 < (int)uVar5) {
                uVar4 = uVar5;
            }
            *(char *)((int)Connection + (uVar5 - (uVar4 & 0xffffc000)) + 0x806) =
                 (char)((Channel & 0xffffU) >> 8);
            Connection->NextToWrite = iVar3 + 2;
        }
        else {
            Connection->Overflow = true;
        }
        FinishSendData(Connection);
        return;
    }
    return;
}



void SendOutfit(TConnection *Connection)

{
    undefined2 uVar1;
    int iVar2;
    bool bVar3;
    TPlayer *pTVar4;
    uint uVar5;
    short sVar6;
    TPlayer *pl;
    uint uVar7;
    
    bVar3 = BeginSendData(Connection);
    if (bVar3) {
        iVar2 = Connection->NextToWrite;
        if (iVar2 < Connection->NextToSend + 0x4000) {
            Connection->OutData[iVar2 % 0x4000] = 200;
            Connection->NextToWrite = iVar2 + 1;
        }
        else {
            Connection->Overflow = true;
        }
        pTVar4 = TConnection::GetPlayer(Connection);
        if (pTVar4 != (TPlayer *)0x0) {
            uVar1 = (undefined2)(pTVar4->super_TCreature).OrgOutfit.OutfitID;
            iVar2 = Connection->NextToWrite;
            if (iVar2 < Connection->NextToSend + 0x3fff) {
                Connection->OutData[iVar2 % 0x4000] = (uchar)uVar1;
                uVar7 = iVar2 + 1;
                uVar5 = iVar2 + 0x4000;
                if (-1 < (int)uVar7) {
                    uVar5 = uVar7;
                }
                *(char *)((int)Connection + (uVar7 - (uVar5 & 0xffffc000)) + 0x806) =
                     (char)((ushort)uVar1 >> 8);
                Connection->NextToWrite = iVar2 + 2;
            }
            else {
                Connection->Overflow = true;
            }
            SendText(Connection,(char *)(pTVar4->super_TCreature).OrgOutfit.field_1.Colors,4);
            if ((pTVar4->super_TCreature).Sex == 1) {
                iVar2 = Connection->NextToWrite;
                if (iVar2 < Connection->NextToSend + 0x3fff) {
                    uVar7 = iVar2 + 1;
                    Connection->OutData[iVar2 % 0x4000] = 0x80;
                    uVar5 = iVar2 + 0x4000;
                    if (-1 < (int)uVar7) {
                        uVar5 = uVar7;
                    }
                    *(undefined1 *)((int)Connection + (uVar7 - (uVar5 & 0xffffc000)) + 0x806) = 0;
                    Connection->NextToWrite = iVar2 + 2;
                }
                else {
                    Connection->Overflow = true;
                }
                bVar3 = CheckRight((pTVar4->super_TCreature).ID,PREMIUM_ACCOUNT);
                sVar6 = (ushort)bVar3 * 3 + 0x83;
            }
            else {
                iVar2 = Connection->NextToWrite;
                if (iVar2 < Connection->NextToSend + 0x3fff) {
                    uVar7 = iVar2 + 1;
                    Connection->OutData[iVar2 % 0x4000] = 0x88;
                    uVar5 = iVar2 + 0x4000;
                    if (-1 < (int)uVar7) {
                        uVar5 = uVar7;
                    }
                    *(undefined1 *)((int)Connection + (uVar7 - (uVar5 & 0xffffc000)) + 0x806) = 0;
                    Connection->NextToWrite = iVar2 + 2;
                }
                else {
                    Connection->Overflow = true;
                }
                bVar3 = CheckRight((pTVar4->super_TCreature).ID,PREMIUM_ACCOUNT);
                sVar6 = (ushort)bVar3 * 3 + 0x8b;
            }
            iVar2 = Connection->NextToWrite;
            if (iVar2 < Connection->NextToSend + 0x3fff) {
                uVar7 = iVar2 + 1;
                Connection->OutData[iVar2 % 0x4000] = (uchar)sVar6;
                uVar5 = iVar2 + 0x4000;
                if (-1 < (int)uVar7) {
                    uVar5 = uVar7;
                }
                *(char *)((int)Connection + (uVar7 - (uVar5 & 0xffffc000)) + 0x806) =
                     (char)((ushort)sVar6 >> 8);
                Connection->NextToWrite = iVar2 + 2;
            }
            else {
                Connection->Overflow = true;
            }
            FinishSendData(Connection);
            return;
        }
    }
    return;
}



// WARNING: Variable defined which should be unmapped: Name_local

void __regparm2 SendBuddyData(TConnection *Connection,ulong CharacterID,char *Name,bool Online)

{
    bool bVar1;
    size_t Length;
    uint uVar2;
    int iVar3;
    uint uVar4;
    undefined3 in_stack_00000009;
    char *in_stack_0000000c;
    char in_stack_00000010;
    int local_20;
    bool Online_local;
    char *Name_local;
    
    bVar1 = BeginSendData((TConnection *)Name);
    if (bVar1) {
        local_20 = *(int *)(Name + 0x4808);
        iVar3 = *(int *)(Name + 0x4810);
        if (iVar3 < local_20 + 0x4000) {
            Name[iVar3 % 0x4000 + 0x806] = -0x2e;
            iVar3 = iVar3 + 1;
            *(int *)(Name + 0x4810) = iVar3;
        }
        else {
            Name[0x4814] = '\x01';
        }
        if (iVar3 < local_20 + 0x3ffd) {
            uVar4 = iVar3 + 1;
            Name[iVar3 % 0x4000 + 0x806] = Online;
            uVar2 = iVar3 + 0x4000;
            if (-1 < (int)uVar4) {
                uVar2 = uVar4;
            }
            Name[(uVar4 - (uVar2 & 0xffffc000)) + 0x806] = (char)in_stack_00000009;
            uVar4 = iVar3 + 2;
            uVar2 = iVar3 + 0x4001;
            if (-1 < (int)uVar4) {
                uVar2 = uVar4;
            }
            Name[(uVar4 - (uVar2 & 0xffffc000)) + 0x806] = (char)((uint3)in_stack_00000009 >> 8);
            uVar4 = iVar3 + 3;
            uVar2 = iVar3 + 0x4002;
            if (-1 < (int)uVar4) {
                uVar2 = uVar4;
            }
            Name[(uVar4 - (uVar2 & 0xffffc000)) + 0x806] = (char)((uint3)in_stack_00000009 >> 0x10);
            *(int *)(Name + 0x4810) = iVar3 + 4;
        }
        else {
            Name[0x4814] = '\x01';
        }
        if (in_stack_0000000c != (char *)0x0) {
            Length = strlen(in_stack_0000000c);
            iVar3 = *(int *)(Name + 0x4810);
            if (iVar3 < local_20 + 0x3fff) {
                Name[iVar3 % 0x4000 + 0x806] = (char)(Length & 0xffff);
                uVar4 = iVar3 + 1;
                uVar2 = iVar3 + 0x4000;
                if (-1 < (int)uVar4) {
                    uVar2 = uVar4;
                }
                Name[(uVar4 - (uVar2 & 0xffffc000)) + 0x806] = (char)((Length & 0xffff) >> 8);
                *(int *)(Name + 0x4810) = iVar3 + 2;
            }
            else {
                Name[0x4814] = '\x01';
            }
            if (0 < (int)Length) {
                SendText((TConnection *)Name,in_stack_0000000c,Length);
                local_20 = *(int *)(Name + 0x4808);
            }
            iVar3 = *(int *)(Name + 0x4810);
            if (iVar3 < local_20 + 0x4000) {
                Name[iVar3 % 0x4000 + 0x806] = in_stack_00000010 != '\0';
                *(int *)(Name + 0x4810) = iVar3 + 1;
            }
            else {
                Name[0x4814] = '\x01';
            }
            FinishSendData((TConnection *)Name);
            return;
        }
    }
    return;
}



// WARNING: Variable defined which should be unmapped: Online_local

void SendBuddyStatus(TConnection *Connection,ulong CharacterID,bool Online)

{
    int iVar1;
    bool bVar2;
    uint uVar3;
    uint uVar4;
    uint uVar5;
    bool Online_local;
    
    bVar2 = BeginSendData(Connection);
    if (bVar2) {
        iVar1 = Connection->NextToSend;
        uVar4 = Connection->NextToWrite;
        if ((int)uVar4 < iVar1 + 0x4000) {
            uVar3 = uVar4 + 0x3fff;
            if (-1 < (int)uVar4) {
                uVar3 = uVar4;
            }
            *(char *)((int)Connection + (uVar4 - (uVar3 & 0xffffc000)) + 0x806) = !Online + -0x2d;
            uVar4 = uVar4 + 1;
            Connection->NextToWrite = uVar4;
        }
        else {
            Connection->Overflow = true;
        }
        if ((int)uVar4 < iVar1 + 0x3ffd) {
            uVar5 = uVar4 + 1;
            Connection->OutData[(int)uVar4 % 0x4000] = (uchar)CharacterID;
            uVar3 = uVar4 + 0x4000;
            if (-1 < (int)uVar5) {
                uVar3 = uVar5;
            }
            *(char *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) =
                 (char)(CharacterID >> 8);
            uVar5 = uVar4 + 2;
            uVar3 = uVar4 + 0x4001;
            if (-1 < (int)uVar5) {
                uVar3 = uVar5;
            }
            *(char *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) =
                 (char)(CharacterID >> 0x10);
            uVar5 = uVar4 + 3;
            uVar3 = uVar4 + 0x4002;
            if (-1 < (int)uVar5) {
                uVar3 = uVar5;
            }
            *(char *)((int)Connection + (uVar5 - (uVar3 & 0xffffc000)) + 0x806) =
                 (char)(CharacterID >> 0x18);
            Connection->NextToWrite = uVar4 + 4;
        }
        else {
            Connection->Overflow = true;
        }
        FinishSendData(Connection);
        return;
    }
    return;
}



// WARNING: Variable defined which should be unmapped: Message

void BroadcastMessage(int Mode,char *Text,...)

{
    TConnection *Connection_00;
    TConnection *Connection;
    char local_40c [4];
    char Message [1024];
    
    vsnprintf(local_40c,0x400,Text,&stack0x0000000c);
    Connection_00 = GetFirstConnection();
    while (Connection_00 != (TConnection *)0x0) {
        if (Connection_00->State - CONNECTION_LOGIN < 4) {
            SendMessage(Connection_00,Mode,local_40c);
        }
        Connection_00 = GetNextConnection();
    }
    return;
}



void DeleteGamemasterRequest(char *Name)

{
    bool bVar1;
    TPlayer *pl;
    TConnection *this;
    TPlayer *pTVar2;
    undefined3 extraout_var;
    char *Name_00;
    TConnection *Connection;
    
    if (Name != (char *)0x0) {
        this = GetFirstConnection();
        while (this != (TConnection *)0x0) {
            if ((this->State - CONNECTION_LOGIN < 4) &&
               (pTVar2 = TConnection::GetPlayer(this), pTVar2 != (TPlayer *)0x0)) {
                bVar1 = ChannelSubscribed(3,(pTVar2->super_TCreature).ID);
                if (bVar1) {
                    SendDeleteRequest((TConnection *)CONCAT31(extraout_var,bVar1),Name_00);
                }
            }
            this = GetNextConnection();
        }
        return;
    }
    error("DeleteGamemasterRequest: Name ist NULL.\n");
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__I__Z13BeginSendDataP11TConnection(void)

{
    __static_initialization_and_destruction_0(1,0xffff);
    return;
}



// WARNING: Variable defined which should be unmapped: Text_local

void SendText(TConnection *Connection,char *Text,int Length)

{
    int Offset;
    int iVar1;
    uchar *__dest;
    size_t __n;
    char *Text_local;
    
    if (Text == (char *)0x0) {
        error("SendText: Text ist NULL.\n");
        return;
    }
    if (0 < Length) {
        if ((Connection->NextToSend - Length) + 0x4000 < Connection->NextToWrite) {
            Connection->Overflow = true;
        }
        else {
            iVar1 = Connection->NextToWrite % 0x4000;
            if (Length + iVar1 < 0x4001) {
                __dest = Connection->OutData + iVar1;
                __n = Length;
            }
            else {
                memcpy(Connection->OutData + iVar1,Text,0x4000 - iVar1);
                __dest = Connection->OutData;
                Text = Text + (0x4000 - iVar1);
                __n = (Length + iVar1) - 0x4000;
            }
            memcpy(__dest,Text,__n);
            Connection->NextToWrite = Connection->NextToWrite + Length;
        }
        return;
    }
    error(&DAT_08109a60);
    return;
}



void __static_initialization_and_destruction_0(int __initialize_p,int __priority)

{
    if ((__priority == 0xffff) && (__initialize_p == 1)) {
        NONE.ObjectID = 0;
    }
    return;
}



bool CommandAllowed(TConnection *Connection,ushort Command)

{
    CONNECTIONSTATE CVar1;
    
    if (Connection == (TConnection *)0x0) {
        error("CommandAllowed: Connection ist NULL.\n");
    }
    else {
        CVar1 = Connection->State;
        if (CVar1 == CONNECTION_GAME) {
            return 1 < (ushort)(Command - 10);
        }
        if ((3 < (int)CVar1) && ((int)CVar1 < 7)) {
            if ((Command != 0xe6) && (((Command != 0xe8 && (Command != 0x1e)) && (Command != 0x14)))
               ) {
                return false;
            }
            return true;
        }
        error(&DAT_08109f80,CVar1,(uint)Command);
    }
    return false;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

bool CheckSpecialCoordinates(void)

{
    bool bVar1;
    int in_stack_00000008;
    int in_stack_0000000c;
    int in_stack_00000010;
    char in_stack_00000014;
    
    if (in_stack_00000008 == 0xffff) {
        bVar1 = in_stack_00000014 != '\0';
        if (in_stack_0000000c != 0) {
            if ((in_stack_0000000c - 0xbU < 0x35) || (0x4f < in_stack_0000000c)) {
                print();
                bVar1 = false;
            }
            else {
                bVar1 = true;
            }
        }
    }
    else {
        bVar1 = IsOnMap(in_stack_00000008,in_stack_0000000c,in_stack_00000010);
    }
    return bVar1;
}



// WARNING: Variable defined which should be unmapped: posz

bool CheckVisibility(int Command,TConnection *Connection,int x,int y,int z)

{
    bool bVar1;
    int local_1c;
    int posx;
    int posy;
    int posz;
    
    if (Connection == (TConnection *)0x0) {
        error("CheckVisibility: Connection ist NULL.\n");
    }
    else {
        bVar1 = TConnection::IsVisible(Connection,x,y,z);
        if (bVar1) {
            return true;
        }
        TConnection::GetPosition(Connection,&local_1c,&posx,&posy);
        print();
    }
    return false;
}



bool CheckObjectType(int Command,int TypeID)

{
    bool bVar1;
    
    bVar1 = ObjectTypeExists(TypeID);
    if (!bVar1) {
        print();
    }
    return bVar1;
}



ObjectType GetObjectType(ushort TypeID)

{
    bool bVar1;
    uint TypeID_00;
    undefined2 in_stack_00000006;
    ushort in_stack_00000008;
    
    TypeID_00 = (uint)in_stack_00000008;
    bVar1 = ObjectTypeExists(TypeID_00);
    if (!bVar1) {
        print();
        TypeID_00 = 0;
    }
    ObjectType::setTypeID(_TypeID,TypeID_00);
    return (ObjectType)(int)_TypeID;
}



void CGoDirection(TConnection *Connection,int dx,int dy)

{
    bool bVar1;
    RESULT r;
    TPlayer *this;
    TPlayer *pl;
    int local_48;
    int x;
    int y;
    int z;
    TToDoEntry TD;
    
    if (Connection == (TConnection *)0x0) {
        error("CGoDirection: Connection ist NULL.\n");
    }
    else {
        TConnection::GetPosition(Connection,&local_48,&x,&y);
        this = TConnection::GetPlayer(Connection);
        if (this != (TPlayer *)0x0) {
                    // try { // try from 080d6a74 to 080d6abb has its CatchHandler @ 080d6ae0
            bVar1 = TCreature::ToDoClear(&this->super_TCreature);
            if (bVar1) {
                SendSnapback(Connection);
            }
            z = 1;
            TD.field_1.Go.x = dy + x;
            TD.Code = dx + local_48;
            TD.field_1.Go.y = y;
            TCreature::ToDoAdd(&this->super_TCreature,(TToDoEntry *)&z);
            TCreature::ToDoStart(&this->super_TCreature);
        }
    }
    return;
}



void CGoPath(TConnection *Connection,TReadBuffer *Buffer)

{
    bool bVar1;
    RESULT r;
    uint uVar2;
    TPlayer *this;
    uint uVar3;
    int Steps;
    int local_50;
    int i;
    TPlayer *pl;
    int x;
    int y;
    int z;
    TToDoEntry TD;
    
    if (Connection == (TConnection *)0x0) {
                    // try { // try from 080d6c37 to 080d6c3b has its CatchHandler @ 080d6c86
        error("CGoPath: Connection ist NULL.\n");
    }
    else {
                    // try { // try from 080d6b42 to 080d6b6c has its CatchHandler @ 080d6c86
        uVar2 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
        TConnection::GetPosition(Connection,(int *)&pl,&x,&y);
        this = TConnection::GetPlayer(Connection);
        if (this != (TPlayer *)0x0) {
                    // try { // try from 080d6b77 to 080d6c27 has its CatchHandler @ 080d6c3e
            bVar1 = TCreature::ToDoClear(&this->super_TCreature);
            if (bVar1) {
                SendSnapback(Connection);
            }
            local_50 = 0;
            if ((uVar2 & 0xff) != 0) {
                do {
                    uVar3 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
                    switch(uVar3 & 0xff) {
                    default:
                        goto switchD_080d6ba0_caseD_0;
                    case 1:
                        pl = (TPlayer *)((int)&(pl->super_TCreature)._vptr_TCreature + 1);
                        goto LAB_080d6baa;
                    case 2:
                        pl = (TPlayer *)((int)&(pl->super_TCreature)._vptr_TCreature + 1);
                        break;
                    case 3:
                        break;
                    case 4:
                        pl = (TPlayer *)((int)pl[-1].AddresseesTimes + 0x4f);
                        break;
                    case 5:
                        pl = (TPlayer *)((int)pl[-1].AddresseesTimes + 0x4f);
                        goto LAB_080d6baa;
                    case 6:
                        pl = (TPlayer *)((int)pl[-1].AddresseesTimes + 0x4f);
                    case 7:
                        goto switchD_080d6ba0_caseD_7;
                    case 8:
                        pl = (TPlayer *)((int)&(pl->super_TCreature)._vptr_TCreature + 1);
                        goto switchD_080d6ba0_caseD_7;
                    }
                    x = x + -1;
LAB_080d6baa:
                    z = 1;
                    TD.Code = (ToDoType)pl;
                    TD.field_1.Go.x = x;
                    TD.field_1.Go.y = y;
                    TCreature::ToDoAdd(&this->super_TCreature,(TToDoEntry *)&z);
switchD_080d6ba0_caseD_0:
                    local_50 = local_50 + 1;
                } while (local_50 < (int)(uVar2 & 0xff));
            }
            TCreature::ToDoStart(&this->super_TCreature);
        }
    }
    return;
switchD_080d6ba0_caseD_7:
    x = x + 1;
    goto LAB_080d6baa;
}



void CStop(TConnection *Connection)

{
    TPlayer *this;
    
    if (Connection == (TConnection *)0x0) {
        error("CGoStop: Connection ist NULL.\n");
        return;
    }
    this = TConnection::GetPlayer(Connection);
    if (this != (TPlayer *)0x0) {
        TCreature::ToDoStop(&this->super_TCreature);
        return;
    }
    return;
}



void CLookAtPoint(TConnection *Connection,TReadBuffer *Buffer)

{
    ulong CreatureID_00;
    bool bVar1;
    TPlayer *pl;
    uint uVar2;
    uint uVar3;
    uint uVar4;
    TPlayer *pTVar5;
    ObjectType *Type;
    ObjectType *z;
    int x;
    ulong CreatureID;
    int y;
    int posx;
    int posy;
    int posz;
    Object local_2c;
    Object Obj;
    
    if (Connection == (TConnection *)0x0) {
        error("CLookAtPoint: Connection ist NULL.\n");
    }
    else {
                    // try { // try from 080d6d05 to 080d6df2 has its CatchHandler @ 080d6ee6
        uVar2 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
        uVar2 = uVar2 & 0xffff;
        uVar3 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
        uVar4 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
        z = (ObjectType *)(uVar4 & 0xff);
        bVar1 = CheckSpecialCoordinates();
        if (bVar1) {
            if ((uVar2 == 0xffff) ||
               (bVar1 = TConnection::IsVisible(Connection,uVar2,uVar3 & 0xffff,(int)z), bVar1)) {
                pTVar5 = TConnection::GetPlayer(Connection);
                if (pTVar5 != (TPlayer *)0x0) {
                    CreatureID_00 = (pTVar5->super_TCreature).ID;
                    ObjectType::setTypeID((ObjectType *)&posz,0);
                    Type = (ObjectType *)0xffffffff;
                    if (uVar2 == 0xffff) {
                        Type = z;
                    }
                    GetObject((ulong)&local_2c,CreatureID_00,uVar2,uVar3 & 0xffff,(int)z,Type);
                    bVar1 = Object::exists(&local_2c);
                    if (bVar1) {
                        posz = local_2c.ObjectID;
                    // try { // try from 080d6e20 to 080d6e24 has its CatchHandler @ 080d6ea1
                        Look(CreatureID_00,(Object *)&posz);
                    }
                }
            }
            else {
                    // try { // try from 080d6e3f to 080d6e9b has its CatchHandler @ 080d6ee6
                TConnection::GetPosition(Connection,&y,&posx,&posy);
                print();
            }
        }
    }
    return;
}



// WARNING: Variable defined which should be unmapped: posz

void CRefreshField(TConnection *Connection,TReadBuffer *Buffer)

{
    bool bVar1;
    uint uVar2;
    uint uVar3;
    TConnection *Connection_00;
    int x_00;
    int x;
    int y;
    int posx;
    int posy;
    int posz;
    
    if (Connection == (TConnection *)0x0) {
        error("CRefreshField: Connection ist NULL.\n");
    }
    else {
                    // try { // try from 080d6f22 to 080d700e has its CatchHandler @ 080d7014
        uVar2 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
        uVar2 = uVar2 & 0xffff;
        uVar3 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
        Connection_00 = (TConnection *)(uVar3 & 0xffff);
        uVar3 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
        bVar1 = IsOnMap(uVar2,(int)Connection_00,uVar3 & 0xff);
        if (bVar1) {
            bVar1 = TConnection::IsVisible(Connection,uVar2,(int)Connection_00,uVar3 & 0xff);
            if (bVar1) {
                SendFieldData(Connection_00,x_00,(int)Connection,uVar2);
            }
            else {
                TConnection::GetPosition(Connection,&y,&posx,&posy);
                print();
            }
        }
    }
    return;
}



void CTalk(TConnection *Connection,TReadBuffer *Buffer)

{
    bool bVar1;
    int GamemasterID;
    uint uVar2;
    TPlayer *this;
    char *pcVar3;
    ulong uVar4;
    TConnection *this_00;
    TPlayer *pTVar5;
    TCreature *pTVar6;
    int iVar7;
    uint uVar8;
    int Mode;
    TPlayer *pl;
    int Channel;
    char Text [256];
    char Addressee [30];
    
    if (Connection == (TConnection *)0x0) {
        error("CTalk: Connection ist NULL.\n");
        return;
    }
                    // try { // try from 080d7055 to 080d713e has its CatchHandler @ 080d76f6
    uVar2 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
    uVar2 = uVar2 & 0xff;
    if ((((((7 < uVar2 - 1) && (uVar2 != 0xb)) && (uVar2 != 0xf)) &&
         ((uVar2 != 10 && (uVar2 != 0xe)))) && (uVar2 != 9)) && (uVar2 != 0xd)) {
LAB_080d708d:
        print();
        return;
    }
    Text[0xfc] = '\0';
    pl = (TPlayer *)0x0;
    if ((((uVar2 == 4) || (uVar2 == 7)) || ((uVar2 == 0xb || (uVar2 == 0xf)))) &&
       ((*(Buffer->super_TReadStream)._vptr_TReadStream[4])(Buffer,Text + 0xfc,0x1e),
       Text[0xfc] == '\0')) goto LAB_080d7126;
    if (((uVar2 == 5) || (uVar2 == 10)) || (uVar2 == 0xe)) {
        uVar8 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
        pl = (TPlayer *)(uVar8 & 0xffff);
        iVar7 = GetNumberOfChannels();
        if (iVar7 <= (int)pl) goto LAB_080d708d;
        sprintf(Text + 0xfc,"%d",pl);
    }
    (*(Buffer->super_TReadStream)._vptr_TReadStream[4])(Buffer,&Channel,0x100);
    if (((char)Channel == '\0') ||
       (this = TConnection::GetPlayer(Connection), this == (TPlayer *)0x0)) goto LAB_080d7126;
    pcVar3 = strchr((char *)&Channel,10);
    if (pcVar3 != (char *)0x0) {
        error("CTalk: %s verwendet Newlines (%d,%s)\n",(this->super_TCreature).Name,uVar2,&Channel);
        return;
    }
    if ((uVar2 == 7) &&
       (bVar1 = CheckRight((this->super_TCreature).ID,READ_GAMEMASTER_CHANNEL), !bVar1)) {
        uVar2 = 4;
    }
    if ((uVar2 == 9) &&
       (bVar1 = CheckRight((this->super_TCreature).ID,GAMEMASTER_BROADCAST), !bVar1)) {
        uVar2 = 1;
    }
    if ((uVar2 == 10) &&
       (bVar1 = CheckRight((this->super_TCreature).ID,GAMEMASTER_BROADCAST), !bVar1)) {
        uVar2 = 5;
    }
    if ((uVar2 == 0xb) &&
       (bVar1 = CheckRight((this->super_TCreature).ID,GAMEMASTER_BROADCAST), !bVar1)) {
        uVar2 = 4;
    }
    if ((uVar2 == 0xd) &&
       (bVar1 = CheckRight((this->super_TCreature).ID,ANONYMOUS_BROADCAST), !bVar1)) {
        uVar2 = 1;
    }
    if ((uVar2 == 0xe) &&
       (bVar1 = CheckRight((this->super_TCreature).ID,ANONYMOUS_BROADCAST), !bVar1)) {
        uVar2 = 5;
    }
    if ((uVar2 == 0xf) &&
       (bVar1 = CheckRight((this->super_TCreature).ID,ANONYMOUS_BROADCAST), !bVar1)) {
        uVar2 = 4;
    }
    if ((uVar2 == 3) &&
       (iVar7 = TSkill::Get((this->super_TCreature).super_TSkillBase.Skills[0]), iVar7 < 2)) {
        pcVar3 = "You may not yell as long as you are on level 1.";
        goto LAB_080d731f;
    }
    if (uVar2 == 5) {
        iVar7 = TSkill::Get((this->super_TCreature).super_TSkillBase.Skills[0]);
        if (iVar7 < 2) {
            pcVar3 = "You may not speak into channels as long as you are on level 1.";
            goto LAB_080d731f;
        }
LAB_080d7444:
        if (pl == (TPlayer *)0x3) {
LAB_080d7126:
            print();
            return;
        }
    }
    else if ((uVar2 == 10) || (uVar2 == 0xe)) goto LAB_080d7444;
    if ((((uVar2 == 5) || (uVar2 == 10)) || (uVar2 == 0xe)) &&
       (bVar1 = ChannelSubscribed((int)pl,(this->super_TCreature).ID), !bVar1)) {
        Text[0xfc] = '\0';
        uVar2 = 1;
    }
    if (((uVar2 == 5) && (pl == (TPlayer *)0x7)) &&
       (bVar1 = CheckRight((this->super_TCreature).ID,HIGHLIGHT_HELP_CHANNEL), bVar1)) {
        this->TutorActivities = this->TutorActivities + 1;
        print();
        uVar2 = 0xc;
    }
    if (uVar2 == 8) {
        if (this->Request == 0) {
            return;
        }
        if (this->RequestProcessingGamemaster == 0) {
            pcVar3 = "Please wait until your request is answered.";
            goto LAB_080d731f;
        }
        pTVar6 = GetCreature(this->RequestProcessingGamemaster);
        if (pTVar6 == (TCreature *)0x0) {
            SendCloseRequest(Connection);
            this->Request = 0;
            return;
        }
        strcpy(Text + 0xfc,pTVar6->Name);
    }
    if (uVar2 != 6) {
                    // try { // try from 080d7226 to 080d7238 has its CatchHandler @ 080d76a6
        TCreature::ToDoTalk(&this->super_TCreature);
        TCreature::ToDoStart(&this->super_TCreature);
        return;
    }
    if (this->Request == 0) {
        if ((char)Channel == '\0') {
            return;
        }
                    // try { // try from 080d7268 to 080d76a0 has its CatchHandler @ 080d76f6
        uVar4 = AddDynamicString((char *)&Channel);
        this->Request = uVar4;
        this->RequestTimestamp = RoundNr;
        this->RequestProcessingGamemaster = 0;
        this_00 = GetFirstConnection();
        if (this_00 == (TConnection *)0x0) {
            return;
        }
        do {
            if (((this_00->State - CONNECTION_LOGIN < 4) &&
                (pTVar5 = TConnection::GetPlayer(this_00), pTVar5 != (TPlayer *)0x0)) &&
               (bVar1 = ChannelSubscribed(3,(pTVar5->super_TCreature).ID), bVar1)) {
                SendTalk(this_00,0,(this->super_TCreature).Name,6,(char *)&Channel,0);
            }
            this_00 = GetNextConnection();
        } while (this_00 != (TConnection *)0x0);
        return;
    }
    pcVar3 = "You have already submitted a request. Please wait until it is answered.";
LAB_080d731f:
    SendMessage(Connection,0x17,pcVar3);
    return;
}



void CGetChannels(TConnection *Connection)

{
    if (Connection != (TConnection *)0x0) {
        SendChannels(Connection);
        return;
    }
    error("CGetChannels: Connection ist NULL.\n");
    return;
}



void CJoinChannel(TConnection *Connection,TReadBuffer *Buffer)

{
    bool bVar1;
    TPlayer *pl;
    uint uVar2;
    int iVar3;
    TPlayer *pTVar4;
    int Channel;
    
    if (Connection == (TConnection *)0x0) {
                    // try { // try from 080d77c7 to 080d77cb has its CatchHandler @ 080d7816
        error("CJoinChannel:  ist NULL.\n");
    }
    else {
                    // try { // try from 080d774b to 080d776b has its CatchHandler @ 080d7816
        uVar2 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
        uVar2 = uVar2 & 0xffff;
        iVar3 = GetNumberOfChannels();
        if ((int)uVar2 < iVar3) {
            pTVar4 = TConnection::GetPlayer(Connection);
            if (pTVar4 != (TPlayer *)0x0) {
                    // try { // try from 080d777d to 080d77b6 has its CatchHandler @ 080d77ce
                bVar1 = JoinChannel(uVar2,(pTVar4->super_TCreature).ID);
                if (uVar2 == 3) {
                    SendOpenRequestQueue(Connection);
                    SendExistingRequests(Connection);
                }
                else if (bVar1) {
                    SendOpenOwnChannel(Connection,uVar2);
                }
                else {
                    SendOpenChannel(Connection,uVar2);
                }
            }
        }
    }
    return;
}



void CLeaveChannel(TConnection *Connection,TReadBuffer *Buffer)

{
    TPlayer *pl;
    uint uVar1;
    int iVar2;
    TPlayer *pTVar3;
    int Channel;
    
    if (Connection == (TConnection *)0x0) {
        error("CLeaveChannel: Connection ist NULL.\n");
    }
    else {
                    // try { // try from 080d784b to 080d789b has its CatchHandler @ 080d78a0
        uVar1 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
        iVar2 = GetNumberOfChannels();
        if ((int)(uVar1 & 0xffff) < iVar2) {
            pTVar3 = TConnection::GetPlayer(Connection);
            if (pTVar3 != (TPlayer *)0x0) {
                LeaveChannel(uVar1 & 0xffff,(pTVar3->super_TCreature).ID,true);
            }
        }
    }
    return;
}



void CPrivateChannel(TConnection *Connection,TReadBuffer *Buffer)

{
    ulong uVar1;
    TPlayer *pTVar2;
    char *Name_00;
    ulong OppID;
    char local_3c [4];
    char Name [30];
    
    if (Connection == (TConnection *)0x0) {
        error("CPrivateChannel: Connection ist NULL.\n");
    }
    else {
                    // try { // try from 080d78f1 to 080d7972 has its CatchHandler @ 080d7975
        (*(Buffer->super_TReadStream)._vptr_TReadStream[4])(Buffer,local_3c,0x1e);
        if (local_3c[0] != '\0') {
            uVar1 = GetCharacterID(local_3c);
            if (uVar1 == 0) {
                SendResult(Connection,PLAYERNOTEXISTING);
            }
            else {
                pTVar2 = TConnection::GetPlayer(Connection);
                if (uVar1 == (pTVar2->super_TCreature).ID) {
                    SendMessage(Connection,0x17,
                                "You cannot set up a private message channel with yourself.");
                }
                else {
                    Name_00 = GetCharacterName(local_3c);
                    SendPrivateChannel(Connection,Name_00);
                }
            }
        }
    }
    return;
}



void CProcessRequest(TConnection *Connection,TReadBuffer *Buffer)

{
    bool bVar1;
    TPlayer *pTVar2;
    int iVar3;
    TPlayer *pl;
    char *Text;
    TPlayer *local_40;
    TPlayer *Opp;
    char Name [30];
    
    if (Connection == (TConnection *)0x0) {
        error("CProcessRequest: Connection ist NULL.\n");
    }
    else {
                    // try { // try from 080d79b0 to 080d7a9d has its CatchHandler @ 080d7aa3
        pTVar2 = TConnection::GetPlayer(Connection);
        if (((pTVar2 != (TPlayer *)0x0) &&
            (bVar1 = ChannelAvailable(3,(pTVar2->super_TCreature).ID), bVar1)) &&
           ((*(Buffer->super_TReadStream)._vptr_TReadStream[4])(Buffer,&Opp,0x1e), (char)Opp != '\0'
           )) {
            iVar3 = IdentifyPlayer((char *)&Opp,true,true,&local_40);
            if (iVar3 == 0) {
                if ((local_40->Request != 0) && (local_40->RequestProcessingGamemaster == 0)) {
                    local_40->RequestProcessingGamemaster = (pTVar2->super_TCreature).ID;
                    DeleteGamemasterRequest((local_40->super_TCreature).Name);
                    return;
                }
                Text = "Request has already been processed.";
            }
            else {
                Text = "Player is not online any more.";
            }
            SendMessage(Connection,0x17,Text);
            SendFinishRequest(Connection,"Name");
        }
    }
    return;
}



void CRemoveRequest(TConnection *Connection,TReadBuffer *Buffer)

{
    bool bVar1;
    TPlayer *pTVar2;
    int iVar3;
    TPlayer *pl;
    TPlayer *local_40;
    TPlayer *Opp;
    char Name [30];
    
    if (Connection == (TConnection *)0x0) {
        error("CRemoveRequest: Connection ist NULL.\n");
    }
    else {
                    // try { // try from 080d7ae0 to 080d7bdc has its CatchHandler @ 080d7be2
        pTVar2 = TConnection::GetPlayer(Connection);
        if (((pTVar2 != (TPlayer *)0x0) &&
            (bVar1 = ChannelAvailable(3,(pTVar2->super_TCreature).ID), bVar1)) &&
           ((*(Buffer->super_TReadStream)._vptr_TReadStream[4])(Buffer,&Opp,0x1e), (char)Opp != '\0'
           )) {
            iVar3 = IdentifyPlayer((char *)&Opp,true,true,&local_40);
            if (iVar3 == 0) {
                if (local_40->Request != 0) {
                    if (local_40->RequestProcessingGamemaster == 0) {
                        DeleteGamemasterRequest((local_40->super_TCreature).Name);
                    }
                    else if (local_40->RequestProcessingGamemaster != (pTVar2->super_TCreature).ID)
                    {
                        return;
                    }
                    SendCloseRequest((local_40->super_TCreature).Connection);
                    local_40->Request = 0;
                }
            }
            else {
                SendMessage(Connection,0x17,"Player is not online any more.");
                SendFinishRequest(Connection,"Name");
            }
        }
    }
    return;
}



void CCancelRequest(TConnection *Connection)

{
    bool bVar1;
    TPlayer *pTVar2;
    TPlayer *pTVar3;
    TPlayer *pl;
    
    if (Connection != (TConnection *)0x0) {
        pTVar2 = TConnection::GetPlayer(Connection);
        if (pTVar2 != (TPlayer *)0x0) {
            bVar1 = ChannelAvailable(3,(pTVar2->super_TCreature).ID);
            if ((bVar1) && (pTVar2->Request != 0)) {
                if (pTVar2->RequestProcessingGamemaster == 0) {
                    DeleteGamemasterRequest((pTVar2->super_TCreature).Name);
                }
                else {
                    pTVar3 = GetPlayer(pTVar2->RequestProcessingGamemaster);
                    if (pTVar3 != (TPlayer *)0x0) {
                        SendFinishRequest((pTVar3->super_TCreature).Connection,
                                          (pTVar2->super_TCreature).Name);
                    }
                }
                pTVar2->Request = 0;
            }
        }
        return;
    }
    error("CCancelRequest: Connection ist NULL.\n");
    return;
}



void CRotate(TConnection *Connection,int Direction)

{
    RESULT r;
    TPlayer *this;
    TPlayer *pl;
    
    if (Connection != (TConnection *)0x0) {
        if ((uint)Direction < 4) {
            this = TConnection::GetPlayer(Connection);
            if (this != (TPlayer *)0x0) {
                    // try { // try from 080d7cf5 to 080d7d01 has its CatchHandler @ 080d7d20
                TCreature::ToDoRotate(&this->super_TCreature,Direction);
                TCreature::ToDoStart(&this->super_TCreature);
            }
        }
        return;
    }
    error("CRotate: Connection ist NULL.\n");
    return;
}



void CBugReport(TConnection *Connection,TReadBuffer *Buffer)

{
    uint *puVar1;
    char cVar2;
    int iVar3;
    char *pcVar4;
    time_t *ptVar5;
    size_t sVar6;
    uint *puVar7;
    uint *puVar8;
    uint uVar9;
    uint uVar10;
    int LineStart;
    bool bVar11;
    int iVar12;
    int iVar13;
    int iVar14;
    int iVar15;
    int iVar16;
    size_t local_48c;
    int LastSpace;
    int i;
    int local_47c;
    int posx;
    int posy;
    int posz;
    time_t Time;
    char Line [80];
    char Text [1024];
    
    if (Connection == (TConnection *)0x0) {
        error("CBugReport: Connection ist NULL.\n");
        return;
    }
    puVar1 = (uint *)(Line + 0x4c);
                    // try { // try from 080d7d91 to 080d811b has its CatchHandler @ 080d8121
    (*(Buffer->super_TReadStream)._vptr_TReadStream[4])(Buffer,puVar1,0x400);
    while( true ) {
        puVar8 = puVar1;
        if (Line[0x4c] == '\0') {
            return;
        }
        do {
            puVar7 = puVar8;
            uVar9 = *puVar7 + 0xfefefeff & ~*puVar7;
            uVar10 = uVar9 & 0x80808080;
            puVar8 = puVar7 + 1;
        } while (uVar10 == 0);
        bVar11 = (uVar9 & 0x8080) == 0;
        if (bVar11) {
            uVar10 = uVar10 >> 0x10;
        }
        if (bVar11) {
            puVar8 = (uint *)((int)puVar7 + 6);
        }
        iVar3 = isprint((int)*(char *)((int)puVar8 +
                                      (int)(Line + (-(int)puVar1 -
                                                   (uint)CARRY1((byte)uVar10,(byte)uVar10)) + 0x48))
                       );
        puVar8 = puVar1;
        if (iVar3 != 0) break;
        do {
            puVar7 = puVar8;
            uVar9 = *puVar7 + 0xfefefeff & ~*puVar7;
            uVar10 = uVar9 & 0x80808080;
            puVar8 = puVar7 + 1;
        } while (uVar10 == 0);
        bVar11 = (uVar9 & 0x8080) == 0;
        if (bVar11) {
            uVar10 = uVar10 >> 0x10;
        }
        if (bVar11) {
            puVar8 = (uint *)((int)puVar7 + 6);
        }
        *(char *)((int)puVar8 +
                 (int)(Line + (-(int)puVar1 - (uint)CARRY1((byte)uVar10,(byte)uVar10)) + 0x48)) =
             '\0';
    }
    if (Line[0x4c] == '\0') {
        return;
    }
    time(&posz);
    TConnection::GetPosition(Connection,&local_47c,&posx,&posy);
    pcVar4 = ctime(&posz);
    iVar13 = Connection->TerminalVersion;
    iVar12 = Connection->TerminalType;
    ptVar5 = (time_t *)TConnection::GetName(Connection);
    Log("bugreport","%s - %d/%d - [%d,%d,%d] - %s",ptVar5,iVar12,iVar13,local_47c,posx,posy,pcVar4);
    iVar3 = 0;
    iVar14 = local_47c;
    iVar15 = posx;
    iVar16 = posy;
LAB_080d7f12:
    do {
        if (Line[iVar3 + 0x4c] == '\0') {
            Log("bugreport",
                "---------------------------------------------------------------------------\n",
                ptVar5,iVar12,iVar13,iVar14,iVar15,iVar16,pcVar4);
            SendMessage(Connection,0x15,"Comment sent.");
            return;
        }
        local_48c = 0xffffffff;
        LastSpace = 0;
        while (cVar2 = Line[LastSpace + iVar3 + -0x1c + 0x68], cVar2 != '\0') {
            if (0x4a < LastSpace) {
                if (local_48c == 0xffffffff) {
                    strncpy((char *)&Time,(char *)(iVar3 + (int)puVar1),0x4a);
                    ptVar5 = &Time;
                    Line[0x46] = '-';
                    Line[0x47] = '\0';
                    Log("bugreport","%s\n",ptVar5,iVar12,iVar13,iVar14,iVar15,iVar16,pcVar4);
                    iVar3 = iVar3 + 0x4a;
                }
                else {
                    strncpy((char *)&Time,(char *)(iVar3 + (int)puVar1),local_48c);
                    Line[local_48c - 4] = '\0';
                    ptVar5 = &Time;
                    Log("bugreport","%s\n",ptVar5);
                    if (Line[local_48c + iVar3 + -0x1c + 0x68] == ' ') {
                        iVar3 = iVar3 + 1;
                    }
                    iVar3 = iVar3 + local_48c;
                }
                goto LAB_080d7f12;
            }
            if (cVar2 == '\n') {
                strncpy((char *)&Time,(char *)(iVar3 + (int)puVar1),LastSpace);
                ptVar5 = &Time;
                Line[LastSpace + -4] = '\0';
                Log("bugreport","%s\n",ptVar5);
                iVar3 = LastSpace + 1 + iVar3;
                goto LAB_080d7f12;
            }
            bVar11 = isSpace((int)cVar2);
            sVar6 = LastSpace;
            if (!bVar11) {
                sVar6 = local_48c;
            }
            LastSpace = LastSpace + 1;
            local_48c = sVar6;
        }
        ptVar5 = (time_t *)(iVar3 + (int)puVar1);
        Log("bugreport","%s\n",ptVar5,iVar12,iVar13,iVar14,iVar15,iVar16,pcVar4);
        iVar3 = iVar3 + LastSpace;
    } while( true );
}



void CErrorFileEntry(TConnection *Connection,TReadBuffer *Buffer)

{
    char cVar1;
    int iVar2;
    bool bVar3;
    char *pcVar4;
    char *pcVar5;
    int iVar6;
    time_t *__s;
    size_t __n;
    int LastSpace;
    size_t __n_00;
    time_t *ptVar7;
    int local_b0c;
    int posx;
    int posy;
    int posz;
    time_t Time;
    char Line [80];
    char Comment [513];
    time_t local_89c;
    char Stack [2049];
    time_t local_8c;
    char Date [27];
    undefined1 local_6c [4];
    char Title [65];
    
    if (Connection == (TConnection *)0x0) {
        error("CErrorFileEntry: Connection ist NULL.\n");
    }
    else {
                    // try { // try from 080d8174 to 080d851e has its CatchHandler @ 080d8521
        (*(Buffer->super_TReadStream)._vptr_TReadStream[4])(Buffer,local_6c,0x41);
        (*(Buffer->super_TReadStream)._vptr_TReadStream[4])(Buffer,&local_8c,0x1b);
        (*(Buffer->super_TReadStream)._vptr_TReadStream[4])(Buffer,&local_89c,0x801);
        (*(Buffer->super_TReadStream)._vptr_TReadStream[4])(Buffer,Line + 0x4c,0x201);
        if (((char)local_89c != '\0') || (Line[0x4c] != '\0')) {
            time(&posz);
            TConnection::GetPosition(Connection,&local_b0c,&posx,&posy);
            pcVar4 = ctime(&posz);
            iVar6 = Connection->TerminalVersion;
            iVar2 = Connection->TerminalType;
            pcVar5 = TConnection::GetName(Connection);
            Log("client-error","%s - %d/%d - [%d,%d,%d] - %s",pcVar5,iVar2,iVar6,local_b0c,posx,posy
                ,pcVar4);
            Log("client-error","%s\n",local_6c);
            ptVar7 = &local_8c;
            Log("client-error","%s\n",ptVar7);
            Log("client-error","\n");
            __s = &local_89c;
            while( true ) {
                pcVar4 = strchr((char *)__s,10);
                if (pcVar4 == (char *)0x0) break;
                *pcVar4 = '\0';
                if ((char)*__s != '\0') {
                    Log("client-error","%s\n",__s);
                    ptVar7 = __s;
                }
                __s = (time_t *)(pcVar4 + 1);
            }
            if ((char)*__s != '\0') {
                Log("client-error","%s\n",__s);
                ptVar7 = __s;
            }
            if (((char)local_89c != '\0') && (Line[0x4c] != '\0')) {
                Log("client-error","\n",ptVar7);
            }
            iVar6 = 0;
LAB_080d8335:
            if (Line[iVar6 + 0x4c] != '\0') {
                __n = 0;
                __n_00 = 0xffffffff;
                while (cVar1 = Line[__n + iVar6 + -0x1c + 0x68], cVar1 != '\0') {
                    if (0x4a < (int)__n) {
                        if (__n_00 == 0xffffffff) {
                            ptVar7 = &Time;
                            strncpy((char *)&Time,Line + iVar6 + 0x4c,0x4a);
                            Line[0x46] = '-';
                            Line[0x47] = '\0';
                            Log("client-error","%s\n",ptVar7);
                            iVar6 = iVar6 + 0x4a;
                        }
                        else {
                            ptVar7 = &Time;
                            strncpy((char *)&Time,Line + iVar6 + 0x4c,__n_00);
                            Line[__n_00 - 4] = '\0';
                            Log("client-error","%s\n",ptVar7);
                            if (Line[__n_00 + iVar6 + -0x1c + 0x68] == ' ') {
                                iVar6 = iVar6 + 1;
                            }
                            iVar6 = iVar6 + __n_00;
                        }
                        goto LAB_080d8335;
                    }
                    if (cVar1 == '\n') {
                        strncpy((char *)&Time,Line + iVar6 + 0x4c,__n);
                        ptVar7 = &Time;
                        Line[__n - 4] = '\0';
                        Log("client-error","%s\n",ptVar7);
                        iVar6 = __n + 1 + iVar6;
                        goto LAB_080d8335;
                    }
                    bVar3 = isSpace((int)cVar1);
                    if (bVar3) {
                        __n_00 = __n;
                    }
                    __n = __n + 1;
                }
                ptVar7 = (time_t *)(Line + iVar6 + 0x4c);
                Log("client-error","%s\n",ptVar7);
                iVar6 = iVar6 + __n;
                goto LAB_080d8335;
            }
            Log("client-error",
                "---------------------------------------------------------------------------\n",
                ptVar7);
        }
    }
    return;
}



void CMoveObject(TConnection *Connection,TReadBuffer *Buffer)

{
    bool bVar1;
    RESULT r;
    uint uVar2;
    uint uVar3;
    uint uVar4;
    uint uVar5;
    int iVar6;
    uint uVar7;
    uint uVar8;
    TPlayer *this;
    int sx;
    uint uVar9;
    uint uVar10;
    uint uVar11;
    undefined4 uVar12;
    TPlayer *pl;
    uchar Count;
    int zz;
    int zy;
    int zx;
    uchar RNum;
    int sz;
    int sy;
    int posx;
    int posy;
    int posz;
    int posx_1;
    int posy_1;
    int posz_1;
    ObjectType local_2c;
    ObjectType Type;
    
    if (Connection == (TConnection *)0x0) {
        error("CMoveObject: Connection ist NULL.\n");
        return;
    }
                    // try { // try from 080d8565 to 080d870d has its CatchHandler @ 080d88c6
    uVar2 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
    uVar2 = uVar2 & 0xffff;
    uVar3 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
    uVar4 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
    uVar5 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
    uVar5 = uVar5 & 0xffff;
    GetObjectType((ushort)&local_2c);
    iVar6 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer,uVar5);
    zx._3_1_ = (uchar)iVar6;
    uVar5 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
    uVar5 = uVar5 & 0xffff;
    uVar7 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
    uVar7 = uVar7 & 0xffff;
    uVar8 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
    uVar8 = uVar8 & 0xff;
    iVar6 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
    if (uVar2 != 0xffff) {
        zx._3_1_ = '\x01';
    }
    bVar1 = CheckSpecialCoordinates();
    if (!bVar1) {
        return;
    }
    if ((uVar2 != 0xffff) &&
       (bVar1 = TConnection::IsVisible(Connection,uVar2,uVar3 & 0xffff,uVar4 & 0xff), !bVar1)) {
        TConnection::GetPosition(Connection,&posz,&posx_1,&posy_1);
        print();
        return;
    }
    uVar12 = 1;
    uVar9 = uVar5;
    uVar10 = uVar7;
    uVar11 = uVar8;
    bVar1 = CheckSpecialCoordinates();
    if (!bVar1) {
        return;
    }
    if (uVar5 == 0xffff) goto LAB_080d86c1;
    if (Connection == (TConnection *)0x0) {
        error("CheckVisibility: Connection ist NULL.\n",uVar9,uVar10,uVar11,uVar12);
LAB_080d87dd:
        bVar1 = false;
    }
    else {
        bVar1 = TConnection::IsVisible(Connection,uVar5,uVar7,uVar8);
        if (!bVar1) {
                    // try { // try from 080d8792 to 080d886b has its CatchHandler @ 080d88c6
            TConnection::GetPosition(Connection,&sy,&posx,&posy);
            print();
            goto LAB_080d87dd;
        }
        bVar1 = true;
    }
    if (!bVar1) {
        return;
    }
LAB_080d86c1:
    ObjectType::setTypeID((ObjectType *)&posz_1,0);
    if ((local_2c.TypeID != posz_1) &&
       (((bVar1 = ObjectType::getFlag(&local_2c,CUMULATIVE), !bVar1 || ((uchar)iVar6 != '\0')) &&
        (this = TConnection::GetPlayer(Connection), this != (TPlayer *)0x0)))) {
                    // try { // try from 080d871f to 080d8774 has its CatchHandler @ 080d8871
        ObjectType::setTypeID((ObjectType *)&posz_1,local_2c.TypeID);
        TCreature::ToDoMove(&this->super_TCreature,uVar2,uVar3 & 0xffff,uVar4 & 0xff,
                            (ObjectType *)&posz_1,zx._3_1_,uVar5,uVar7,uVar8,(uchar)iVar6);
        TCreature::ToDoStart(&this->super_TCreature);
    }
    return;
}



void CTradeObject(TConnection *Connection,TReadBuffer *Buffer)

{
    bool bVar1;
    RESULT r;
    uint uVar2;
    uint uVar3;
    uint uVar4;
    uint uVar5;
    int iVar6;
    ulong TradePartner_00;
    TPlayer *this;
    ulong TradePartner;
    TPlayer *pl;
    uchar RNum;
    int z;
    int y;
    int x;
    int posx;
    int posy;
    int posz;
    int local_2c;
    ObjectType Type;
    
    if (Connection == (TConnection *)0x0) {
        error("CTradeObject: Connection ist NULL.\n");
    }
    else {
                    // try { // try from 080d8905 to 080d89fc has its CatchHandler @ 080d8b26
        uVar2 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
        uVar2 = uVar2 & 0xffff;
        uVar3 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
        uVar4 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
        uVar5 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
        uVar5 = uVar5 & 0xffff;
        GetObjectType((ushort)&local_2c);
        iVar6 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer,uVar5);
        pl._3_1_ = (uchar)iVar6;
        TradePartner_00 = (*(Buffer->super_TReadStream)._vptr_TReadStream[3])(Buffer);
        if (uVar2 != 0xffff) {
            pl._3_1_ = '\x01';
        }
        bVar1 = CheckSpecialCoordinates();
        if (bVar1) {
            if ((uVar2 == 0xffff) ||
               (bVar1 = TConnection::IsVisible(Connection,uVar2,uVar3 & 0xffff,uVar4 & 0xff), bVar1)
               ) {
                ObjectType::setTypeID((ObjectType *)&posz,0);
                if ((local_2c != posz) &&
                   (this = TConnection::GetPlayer(Connection), this != (TPlayer *)0x0)) {
                    // try { // try from 080d8a0e to 080d8a4d has its CatchHandler @ 080d8ad1
                    ObjectType::setTypeID((ObjectType *)&posz,local_2c);
                    TCreature::ToDoTrade
                              (&this->super_TCreature,uVar2,uVar3 & 0xffff,uVar4 & 0xff,
                               (ObjectType *)&posz,pl._3_1_,TradePartner_00);
                    TCreature::ToDoStart(&this->super_TCreature);
                }
            }
            else {
                    // try { // try from 080d8a68 to 080d8acb has its CatchHandler @ 080d8b26
                TConnection::GetPosition(Connection,&x,&posx,&posy);
                print();
            }
        }
    }
    return;
}



void CInspectTrade(TConnection *Connection,TReadBuffer *Buffer)

{
    bool bVar1;
    RESULT r;
    uint uVar2;
    TPlayer *pTVar3;
    int Side;
    TPlayer *pl;
    Object local_2c;
    Object Obj;
    
    if (Connection == (TConnection *)0x0) {
                    // try { // try from 080d8bf7 to 080d8bfb has its CatchHandler @ 080d8c40
        error("CInspectTrade: Connection ist NULL.\n");
    }
    else {
                    // try { // try from 080d8b62 to 080d8bb0 has its CatchHandler @ 080d8c40
        uVar2 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
        (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
        pTVar3 = TConnection::GetPlayer(Connection);
        if (pTVar3 != (TPlayer *)0x0) {
            TPlayer::InspectTrade((TPlayer *)&local_2c,SUB41(pTVar3,0),(uint)((uVar2 & 0xff) == 0));
            bVar1 = Object::exists(&local_2c);
            if (bVar1) {
                pl = (TPlayer *)local_2c.ObjectID;
                    // try { // try from 080d8be6 to 080d8bea has its CatchHandler @ 080d8bfe
                Look((pTVar3->super_TCreature).ID,(Object *)&pl);
            }
        }
    }
    return;
}



void CAcceptTrade(TConnection *Connection)

{
    TPlayer *this;
    
    if (Connection == (TConnection *)0x0) {
        error("CAcceptTrade: Connection ist NULL.\n");
        return;
    }
    this = TConnection::GetPlayer(Connection);
    if (this != (TPlayer *)0x0) {
        TPlayer::AcceptTrade(this);
        return;
    }
    return;
}



void CRejectTrade(TConnection *Connection)

{
    TPlayer *this;
    
    if (Connection == (TConnection *)0x0) {
        error("CRejectTrade: Connection ist NULL.\n");
        return;
    }
    this = TConnection::GetPlayer(Connection);
    if (this != (TPlayer *)0x0) {
        TPlayer::RejectTrade(this);
        return;
    }
    return;
}



void CUseObject(TConnection *Connection,TReadBuffer *Buffer)

{
    bool bVar1;
    uint uVar2;
    uint uVar3;
    uint uVar4;
    uint uVar5;
    int iVar6;
    int iVar7;
    TPlayer *this;
    int x;
    TPlayer *pl;
    uchar Dummy;
    uchar RNum;
    int z;
    int y;
    int posx;
    int posy;
    int posz;
    ObjectType local_3c [4];
    ObjectType local_2c;
    ObjectType Type;
    
    if (Connection == (TConnection *)0x0) {
        error("CUseObject: Connection ist NULL.\n");
    }
    else {
                    // try { // try from 080d8cf5 to 080d8e0a has its CatchHandler @ 080d8f86
        uVar2 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
        uVar2 = uVar2 & 0xffff;
        uVar3 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
        uVar4 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
        uVar5 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
        uVar5 = uVar5 & 0xffff;
        GetObjectType((ushort)&local_2c);
        iVar6 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer,uVar5);
        iVar7 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
        bVar1 = CheckSpecialCoordinates();
        if (bVar1) {
            if ((uVar2 == 0xffff) ||
               (bVar1 = TConnection::IsVisible(Connection,uVar2,uVar3 & 0xffff,uVar4 & 0xff), bVar1)
               ) {
                ObjectType::setTypeID(local_3c,0);
                if ((((local_2c.TypeID != local_3c[0].TypeID) &&
                     (bVar1 = ObjectType::getFlag(&local_2c,MULTIUSE), !bVar1)) &&
                    ((bVar1 = ObjectType::getFlag(&local_2c,CONTAINER), !bVar1 ||
                     ((byte)iVar7 < 0x10)))) &&
                   (this = TConnection::GetPlayer(Connection), this != (TPlayer *)0x0)) {
                    // try { // try from 080d8e1d to 080d8eae has its CatchHandler @ 080d8f31
                    TCreature::ToDoWait(&this->super_TCreature,100);
                    ObjectType::setTypeID(local_3c,0);
                    ObjectType::setTypeID((ObjectType *)&posz,local_2c.TypeID);
                    TCreature::ToDoUse(&this->super_TCreature,'\x01',uVar2,uVar3 & 0xffff,
                                       uVar4 & 0xff,(ObjectType *)&posz,(uchar)iVar6,(byte)iVar7,0,0
                                       ,0,local_3c,'\0');
                    TCreature::ToDoStart(&this->super_TCreature);
                }
            }
            else {
                    // try { // try from 080d8ecc to 080d8f2b has its CatchHandler @ 080d8f86
                TConnection::GetPosition(Connection,&y,&posx,&posy);
                print();
            }
        }
    }
    return;
}



void CUseTwoObjects(TConnection *Connection,TReadBuffer *Buffer)

{
    bool bVar1;
    uint uVar2;
    uint uVar3;
    uint uVar4;
    uint uVar5;
    int iVar6;
    uint uVar7;
    uint uVar8;
    uint uVar9;
    int iVar10;
    TPlayer *this;
    int x1;
    uint uVar11;
    uint uVar12;
    undefined4 uVar13;
    TPlayer *pl;
    uchar RNum2;
    int z2;
    int y2;
    int x2;
    uchar RNum1;
    int z1;
    int y1;
    int posx;
    int posy;
    int posz;
    int posx_1;
    int posy_1;
    int posz_1;
    ObjectType local_4c [4];
    int local_3c;
    ObjectType Type2;
    ObjectType local_2c;
    ObjectType Type1;
    
    if (Connection == (TConnection *)0x0) {
        error("CUseTwoObjects: Connection ist NULL.\n");
        return;
    }
                    // try { // try from 080d8fc5 to 080d91a8 has its CatchHandler @ 080d93c0
    uVar2 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
    uVar2 = uVar2 & 0xffff;
    uVar3 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
    uVar4 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
    uVar5 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
    uVar5 = uVar5 & 0xffff;
    GetObjectType((ushort)&local_2c);
    iVar6 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer,uVar5);
    uVar5 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
    uVar5 = uVar5 & 0xffff;
    uVar7 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
    uVar7 = uVar7 & 0xffff;
    uVar8 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
    uVar8 = uVar8 & 0xff;
    uVar9 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
    uVar9 = uVar9 & 0xffff;
    GetObjectType((ushort)&local_3c);
    iVar10 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer,uVar9);
    bVar1 = CheckSpecialCoordinates();
    if (!bVar1) {
        return;
    }
    if ((uVar2 != 0xffff) &&
       (bVar1 = TConnection::IsVisible(Connection,uVar2,uVar3 & 0xffff,uVar4 & 0xff), !bVar1)) {
        TConnection::GetPosition(Connection,&posz,&posx_1,&posy_1);
        print();
        return;
    }
    ObjectType::setTypeID(local_4c,0);
    if (local_2c.TypeID == local_4c[0].TypeID) {
        return;
    }
    bVar1 = ObjectType::getFlag(&local_2c,MULTIUSE);
    if (!bVar1) {
        return;
    }
    uVar13 = 0;
    uVar9 = uVar5;
    uVar11 = uVar7;
    uVar12 = uVar8;
    bVar1 = CheckSpecialCoordinates();
    if (!bVar1) {
        return;
    }
    if (uVar5 == 0xffff) goto LAB_080d9182;
    if (Connection == (TConnection *)0x0) {
        error("CheckVisibility: Connection ist NULL.\n",uVar9,uVar11,uVar12,uVar13);
LAB_080d92d0:
        bVar1 = false;
    }
    else {
        bVar1 = TConnection::IsVisible(Connection,uVar5,uVar7,uVar8);
        if (!bVar1) {
                    // try { // try from 080d927f to 080d935b has its CatchHandler @ 080d93c0
            TConnection::GetPosition(Connection,&y1,&posx,&posy);
            print();
            goto LAB_080d92d0;
        }
        bVar1 = true;
    }
    if (!bVar1) {
        return;
    }
LAB_080d9182:
    ObjectType::setTypeID(local_4c,0);
    if ((local_3c != local_4c[0].TypeID) &&
       (this = TConnection::GetPlayer(Connection), this != (TPlayer *)0x0)) {
                    // try { // try from 080d91c2 to 080d9261 has its CatchHandler @ 080d9361
        TCreature::ToDoWait(&this->super_TCreature,100);
        ObjectType::setTypeID(local_4c,local_3c);
        ObjectType::setTypeID((ObjectType *)&posz_1,local_2c.TypeID);
        TCreature::ToDoUse(&this->super_TCreature,'\x02',uVar2,uVar3 & 0xffff,uVar4 & 0xff,
                           (ObjectType *)&posz_1,(uchar)iVar6,'\0',uVar5,uVar7,uVar8,local_4c,
                           (uchar)iVar10);
        TCreature::ToDoStart(&this->super_TCreature);
    }
    return;
}



void CUseOnCreature(TConnection *Connection,TReadBuffer *Buffer)

{
    bool bVar1;
    uint uVar2;
    uint uVar3;
    uint uVar4;
    uint uVar5;
    uint uVar6;
    ulong id;
    TCreature *pTVar7;
    TPlayer *this;
    undefined4 uVar8;
    RESULT r;
    uint uVar9;
    undefined4 uVar10;
    TPlayer *pl;
    uchar RNum;
    int z;
    int y;
    int x;
    int posx;
    int posy;
    int posz;
    int posx_1;
    int posy_1;
    int posz_1;
    Object local_5c [4];
    Object local_4c;
    Object Obj2;
    Object local_3c;
    Object Obj1;
    ulong local_2c;
    ObjectType Type;
    
    if (Connection == (TConnection *)0x0) {
        error("CUseOnCreature: Connection ist NULL.\n");
        return;
    }
                    // try { // try from 080d93f5 to 080d9655 has its CatchHandler @ 080d9826
    uVar2 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
    uVar2 = uVar2 & 0xffff;
    uVar3 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
    uVar3 = uVar3 & 0xffff;
    uVar4 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
    uVar4 = uVar4 & 0xff;
    uVar5 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
    uVar5 = uVar5 & 0xffff;
    GetObjectType((ushort)&local_2c);
    uVar6 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer,uVar5);
    id = (*(Buffer->super_TReadStream)._vptr_TReadStream[3])(Buffer);
    uVar10 = 0;
    uVar5 = uVar3;
    uVar9 = uVar4;
    bVar1 = CheckSpecialCoordinates();
    if (!bVar1) {
        return;
    }
    if ((uVar2 != 0xffff) &&
       (uVar5 = uVar3, uVar9 = uVar4, bVar1 = TConnection::IsVisible(Connection,uVar2,uVar3,uVar4),
       !bVar1)) {
        TConnection::GetPosition(Connection,&posz,&posx_1,&posy_1);
        print();
        return;
    }
    uVar8 = 0;
    ObjectType::setTypeID((ObjectType *)&local_3c,0);
    if (local_2c == local_3c.ObjectID) {
        return;
    }
    pTVar7 = GetCreature(id);
    if (pTVar7 == (TCreature *)0x0) {
        return;
    }
    if (Connection == (TConnection *)0x0) {
        error("CheckVisibility: Connection ist NULL.\n",uVar8,uVar5,uVar9,uVar10);
LAB_080d9726:
        bVar1 = false;
    }
    else {
        bVar1 = TConnection::IsVisible(Connection,pTVar7->posx,pTVar7->posy,pTVar7->posz);
        if (!bVar1) {
                    // try { // try from 080d96d8 to 080d97be has its CatchHandler @ 080d9826
            TConnection::GetPosition(Connection,&x,&posx,&posy);
            print();
            goto LAB_080d9726;
        }
        bVar1 = true;
    }
    if (!bVar1) {
        return;
    }
    if (pTVar7->Type == PLAYER) {
        return;
    }
    this = TConnection::GetPlayer(Connection);
    if (this == (TPlayer *)0x0) {
        return;
    }
    uVar5 = (this->super_TCreature).posx - pTVar7->posx;
    if (0x7fffffff < uVar5) {
        uVar5 = -uVar5;
    }
    if ((int)uVar5 < Connection->TerminalOffsetX) {
        uVar5 = (this->super_TCreature).posy - pTVar7->posy;
        if (0x7fffffff < uVar5) {
            uVar5 = -uVar5;
        }
        if ((int)uVar5 < Connection->TerminalOffsetY) {
            ObjectType::setTypeID((ObjectType *)&local_4c,local_2c);
            GetObject((ulong)&local_3c,(this->super_TCreature).ID,uVar2,uVar3,uVar4,
                      (ObjectType *)(uVar6 & 0xff));
            local_4c.ObjectID = (pTVar7->CrObject).ObjectID;
            bVar1 = Object::exists(&local_3c);
            if ((bVar1) && (bVar1 = Object::exists(&local_4c), bVar1)) {
                    // try { // try from 080d9678 to 080d96ba has its CatchHandler @ 080d97c4
                TCreature::ToDoWait(&this->super_TCreature,100);
                local_5c[0].ObjectID = local_4c.ObjectID;
                posz_1 = local_3c.ObjectID;
                TCreature::ToDoUse(&this->super_TCreature,'\x02',(Object *)&posz_1,local_5c);
                TCreature::ToDoStart(&this->super_TCreature);
                return;
            }
            r = NOTACCESSIBLE;
            goto LAB_080d95cc;
        }
    }
    r = OUTOFRANGE;
LAB_080d95cc:
    SendResult(Connection,r);
    return;
}



void CTurnObject(TConnection *Connection,TReadBuffer *Buffer)

{
    bool bVar1;
    uint uVar2;
    uint uVar3;
    uint uVar4;
    uint uVar5;
    int iVar6;
    TPlayer *this;
    TPlayer *pl;
    int z;
    int y;
    int x;
    int posx;
    int posy;
    int posz;
    int local_2c;
    ObjectType Type;
    
    if (Connection == (TConnection *)0x0) {
        error("CTurnObject: Connection ist NULL.\n");
    }
    else {
                    // try { // try from 080d9865 to 080d9944 has its CatchHandler @ 080d9a76
        uVar2 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
        uVar2 = uVar2 & 0xffff;
        uVar3 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
        uVar4 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
        uVar5 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
        uVar5 = uVar5 & 0xffff;
        GetObjectType((ushort)&local_2c);
        iVar6 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer,uVar5);
        bVar1 = CheckSpecialCoordinates();
        if (bVar1) {
            if ((uVar2 == 0xffff) ||
               (bVar1 = TConnection::IsVisible(Connection,uVar2,uVar3 & 0xffff,uVar4 & 0xff), bVar1)
               ) {
                ObjectType::setTypeID((ObjectType *)&posz,0);
                if ((local_2c != posz) &&
                   (this = TConnection::GetPlayer(Connection), this != (TPlayer *)0x0)) {
                    // try { // try from 080d9957 to 080d99a0 has its CatchHandler @ 080d9a21
                    TCreature::ToDoWait(&this->super_TCreature,100);
                    ObjectType::setTypeID((ObjectType *)&posz,local_2c);
                    TCreature::ToDoTurn(&this->super_TCreature,uVar2,uVar3 & 0xffff,uVar4 & 0xff,
                                        (ObjectType *)&posz,(uchar)iVar6);
                    TCreature::ToDoStart(&this->super_TCreature);
                }
            }
            else {
                    // try { // try from 080d99bb to 080d9a1b has its CatchHandler @ 080d9a76
                TConnection::GetPosition(Connection,&x,&posx,&posy);
                print();
            }
        }
    }
    return;
}



void CCloseContainer(TConnection *Connection,TReadBuffer *Buffer)

{
    uint uVar1;
    TPlayer *this;
    TPlayer *pl;
    int Window;
    Object local_1c [4];
    
    if (Connection == (TConnection *)0x0) {
        error("CCloseContainer: Connection ist NULL.\n");
    }
    else {
                    // try { // try from 080d9aab to 080d9b02 has its CatchHandler @ 080d9b05
        uVar1 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
        uVar1 = uVar1 & 0xff;
        if (uVar1 < 0x10) {
            this = TConnection::GetPlayer(Connection);
            if (this != (TPlayer *)0x0) {
                local_1c[0].ObjectID = NONE.ObjectID;
                TPlayer::SetOpenContainer(this,uVar1,local_1c);
                SendCloseContainer(Connection,uVar1);
            }
        }
    }
    return;
}



void CUpContainer(TConnection *Connection,TReadBuffer *Buffer)

{
    bool bVar1;
    uint uVar2;
    TPlayer *this;
    int Window;
    TPlayer *pl;
    Object local_4c [4];
    _func_int_varargs **local_3c;
    _func_int_varargs **local_2c;
    Object Con;
    
    if (Connection == (TConnection *)0x0) {
        error("CUpContainer: Connection ist NULL.\n");
    }
    else {
                    // try { // try from 080d9b42 to 080d9c5b has its CatchHandler @ 080d9c61
        uVar2 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
        uVar2 = uVar2 & 0xff;
        if ((uVar2 < 0x10) && (this = TConnection::GetPlayer(Connection), this != (TPlayer *)0x0)) {
            TPlayer::GetOpenContainer((TPlayer *)&local_2c,(int)this);
            local_3c = (_func_int_varargs **)NONE.ObjectID;
            if (local_2c != (_func_int_varargs **)NONE.ObjectID) {
                Object::getContainer(local_4c);
                local_2c = (_func_int_varargs **)local_4c[0].ObjectID;
                local_3c = (_func_int_varargs **)local_4c[0].ObjectID;
                Object::getObjectType(local_4c);
                if ((_func_int_varargs **)local_4c[0].ObjectID != (_func_int_varargs **)0x0) {
                    Object::getObjectType(local_4c);
                    bVar1 = false;
                    if ((0 < (int)local_4c[0].ObjectID) && ((int)local_4c[0].ObjectID < 0xb)) {
                        bVar1 = true;
                    }
                    if (!bVar1) {
                        local_4c[0].ObjectID = (ulong)local_2c;
                        TPlayer::SetOpenContainer(this,uVar2,local_4c);
                        SendContainer(Connection,uVar2);
                        return;
                    }
                }
                local_4c[0].ObjectID = NONE.ObjectID;
                TPlayer::SetOpenContainer(this,uVar2,local_4c);
                SendCloseContainer(Connection,uVar2);
            }
        }
    }
    return;
}



void CRefreshContainer(TConnection *Connection,TReadBuffer *Buffer)

{
    uint uVar1;
    TPlayer *Window_00;
    int Window;
    _func_int_varargs **local_1c;
    Object Con;
    
    if (Connection == (TConnection *)0x0) {
        error("CRefreshContainer: Connection ist NULL.\n");
    }
    else {
                    // try { // try from 080d9c9b to 080d9cfb has its CatchHandler @ 080d9d00
        uVar1 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
        if ((uVar1 & 0xff) < 0x10) {
            Window_00 = TConnection::GetPlayer(Connection);
            if (Window_00 != (TPlayer *)0x0) {
                TPlayer::GetOpenContainer((TPlayer *)&local_1c,(int)Window_00);
                if (local_1c != (_func_int_varargs **)NONE.ObjectID) {
                    SendContainer(Connection,uVar1 & 0xff);
                }
            }
        }
    }
    return;
}



void CGetOutfit(TConnection *Connection)

{
    bool bVar1;
    TPlayer *pl;
    TPlayer *pTVar2;
    
    if (Connection == (TConnection *)0x0) {
        error("CGetOutfit: Connection ist NULL.\n");
        return;
    }
    pTVar2 = TConnection::GetPlayer(Connection);
    if (pTVar2 != (TPlayer *)0x0) {
        bVar1 = CheckRight((pTVar2->super_TCreature).ID,GAMEMASTER_OUTFIT);
        if (!bVar1) {
            SendOutfit(Connection);
            return;
        }
        SendMessage(Connection,0x17,"You may not change your outfit.");
    }
    return;
}



void CSetOutfit(TConnection *Connection,TReadBuffer *Buffer)

{
    TPlayer *pTVar1;
    uint uVar2;
    int iVar3;
    TOutfit *pTVar4;
    int OutfitID;
    TOutfit *pTVar5;
    bool bVar6;
    TPlayer *pl;
    TOutfit NewOutfit;
    undefined4 local_18;
    uchar Colors [4];
    
    if (Connection == (TConnection *)0x0) {
        error("CSetOutfit: Connection ist NULL.\n");
        return;
    }
                    // try { // try from 080d9dc0 to 080d9f8e has its CatchHandler @ 080d9f94
    pTVar1 = TConnection::GetPlayer(Connection);
    if (pTVar1 == (TPlayer *)0x0) {
        return;
    }
    uVar2 = (*(Buffer->super_TReadStream)._vptr_TReadStream[2])(Buffer);
    uVar2 = uVar2 & 0xffff;
    (*(Buffer->super_TReadStream)._vptr_TReadStream[5])(Buffer,&local_18,4);
    iVar3 = (pTVar1->super_TCreature).Sex;
    if (iVar3 == 1) {
        bVar6 = false;
        if ((0x7f < uVar2) && (uVar2 < 0x87)) {
            bVar6 = true;
        }
        if (bVar6) {
            bVar6 = CheckRight((pTVar1->super_TCreature).ID,PREMIUM_ACCOUNT);
            if (bVar6) {
                iVar3 = (pTVar1->super_TCreature).Sex;
            }
            else {
                if (0x83 < uVar2) goto LAB_080d9f0c;
                iVar3 = (pTVar1->super_TCreature).Sex;
            }
            goto LAB_080d9e00;
        }
LAB_080d9f0c:
        print();
    }
    else {
LAB_080d9e00:
        if (iVar3 == 2) {
            bVar6 = false;
            if ((0x87 < uVar2) && (uVar2 < 0x8f)) {
                bVar6 = true;
            }
            if ((!bVar6) ||
               ((bVar6 = CheckRight((pTVar1->super_TCreature).ID,PREMIUM_ACCOUNT), !bVar6 &&
                (0x8b < uVar2)))) goto LAB_080d9f0c;
        }
        if (((((byte)local_18 < 0x85) && (local_18._1_1_ < 0x85)) && (local_18._2_1_ < 0x85)) &&
           (local_18._3_1_ < 0x85)) {
            iVar3 = 8;
            pTVar4 = &(pTVar1->super_TCreature).OrgOutfit;
            bVar6 = pTVar4 == (TOutfit *)0x0;
            pTVar5 = &(pTVar1->super_TCreature).Outfit;
            do {
                if (iVar3 == 0) break;
                iVar3 = iVar3 + -1;
                bVar6 = (char)pTVar4->OutfitID == (char)pTVar5->OutfitID;
                pTVar4 = (TOutfit *)((int)&pTVar4->OutfitID + 1);
                pTVar5 = (TOutfit *)((int)&pTVar5->OutfitID + 1);
            } while (bVar6);
            if (bVar6) {
                (pTVar1->super_TCreature).Outfit.OutfitID = uVar2;
                *(undefined4 *)&(pTVar1->super_TCreature).Outfit.field_1.ObjectType = local_18;
                AnnounceChangedCreature((pTVar1->super_TCreature).ID,3);
            }
            (pTVar1->super_TCreature).OrgOutfit.OutfitID = uVar2;
            *(undefined4 *)&(pTVar1->super_TCreature).OrgOutfit.field_1.ObjectType = local_18;
        }
        else {
            print();
        }
    }
    return;
}



void CEditText(TConnection *Connection,TReadBuffer *Buffer)

{
    bool bVar1;
    RESULT r;
    ulong uVar2;
    TPlayer *pTVar3;
    TPlayer *pl;
    uint uVar4;
    uint uVar5;
    uint *puVar6;
    uint *puVar7;
    RESULT r_00;
    uint local_103c;
    char Text [4096];
    Object local_2c;
    Object Obj;
    
    if (Connection == (TConnection *)0x0) {
                    // try { // try from 080da177 to 080da17b has its CatchHandler @ 080da1c6
        error("CEditText: Connection ist NULL.\n");
        return;
    }
                    // try { // try from 080d9fd8 to 080da136 has its CatchHandler @ 080da1c6
    local_2c.ObjectID = (*(Buffer->super_TReadStream)._vptr_TReadStream[3])(Buffer);
    bVar1 = Object::exists(&local_2c);
    if (bVar1) {
        Object::getObjectType((Object *)(Text + 0xffc));
        bVar1 = ObjectType::getFlag((ObjectType *)(Text + 0xffc),WRITE);
        if (!bVar1) {
            Object::getObjectType((Object *)(Text + 0xffc));
            bVar1 = ObjectType::getFlag((ObjectType *)(Text + 0xffc),WRITEONCE);
            if ((!bVar1) || (uVar2 = Object::getAttribute(&local_2c,TEXTSTRING), uVar2 != 0))
            goto LAB_080da050;
        }
        (*(Buffer->super_TReadStream)._vptr_TReadStream[4])(Buffer,&local_103c,0x1000);
        puVar7 = &local_103c;
        do {
            puVar6 = puVar7;
            uVar4 = *puVar6 + 0xfefefeff & ~*puVar6;
            uVar5 = uVar4 & 0x80808080;
            puVar7 = puVar6 + 1;
        } while (uVar5 == 0);
        bVar1 = (uVar4 & 0x8080) == 0;
        if (bVar1) {
            uVar5 = uVar5 >> 0x10;
        }
        if (bVar1) {
            puVar7 = (uint *)((int)puVar6 + 6);
        }
        Object::getObjectType((Object *)(Text + 0xffc));
        bVar1 = ObjectType::getFlag((ObjectType *)(Text + 0xffc),WRITE);
        Object::getObjectType((Object *)(Text + 0xffc));
        uVar2 = ObjectType::getAttribute((ObjectType *)(Text + 0xffc),!bVar1 + MAXLENGTH);
        if ((int)puVar7 + ((-3 - (uint)CARRY1((byte)uVar5,(byte)uVar5)) - (int)&local_103c) < uVar2)
        {
            pTVar3 = TConnection::GetPlayer(Connection);
            if (pTVar3 == (TPlayer *)0x0) {
                return;
            }
            Text[0xffc] = (undefined1)local_2c.ObjectID;
            Text[0xffd] = local_2c.ObjectID._1_1_;
            Text[0xffe] = local_2c.ObjectID._2_1_;
            Text[0xfff] = local_2c.ObjectID._3_1_;
                    // try { // try from 080da161 to 080da165 has its CatchHandler @ 080da181
            EditText((pTVar3->super_TCreature).ID,(Object *)(Text + 0xffc),(char *)&local_103c);
            return;
        }
        r_00 = NOROOM;
    }
    else {
LAB_080da050:
        r_00 = NOTACCESSIBLE;
    }
    SendResult(Connection,r_00);
    return;
}



void CEditList(TConnection *Connection,TReadBuffer *Buffer)

{
    bool bVar1;
    RESULT r;
    uint uVar2;
    ulong uVar3;
    TPlayer *pl;
    uint uVar4;
    ulong ID;
    Object OStack_104c;
    uchar Type;
    ulong local_103c;
    Object local_102c;
    Object Door;
    char local_101c [4];
    char Text [4096];
    
    if (Connection == (TConnection *)0x0) {
                    // try { // try from 080da3a7 to 080da3ab has its CatchHandler @ 080da3f6
        error("CEditList: Connection ist NULL.\n");
    }
    else {
                    // try { // try from 080da205 to 080da241 has its CatchHandler @ 080da3f6
        uVar2 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
        uVar3 = (*(Buffer->super_TReadStream)._vptr_TReadStream[3])(Buffer);
        (*(Buffer->super_TReadStream)._vptr_TReadStream[4])(Buffer,local_101c,0x1000);
        local_102c.ObjectID = 0;
        pl = TConnection::GetPlayer(Connection);
        if (pl != (TPlayer *)0x0) {
            uVar4 = uVar2 & 0xff;
            if (uVar4 == 2) {
                ChangeSubowners((ushort)uVar3,pl,local_101c);
            }
            else {
                if (uVar4 < 3) {
                    if (uVar4 == 1) {
                        ChangeGuests((ushort)uVar3,pl,local_101c);
                        return;
                    }
                }
                else if (uVar4 == 3) {
                    OStack_104c.ObjectID = uVar3;
                    local_103c = uVar3;
                    local_102c.ObjectID = uVar3;
                    bVar1 = Object::exists(&local_102c);
                    if (bVar1) {
                        Object::getObjectType(&stack0xffffefb4);
                        bVar1 = ObjectType::getFlag((ObjectType *)&stack0xffffefb4,NAMEDOOR);
                        if (bVar1) {
                            Object::getObjectType(&stack0xffffefb4);
                            bVar1 = ObjectType::getFlag((ObjectType *)&stack0xffffefb4,TEXT);
                            if (bVar1) {
                                OStack_104c.ObjectID = local_102c.ObjectID;
                                ChangeNameDoor(&stack0xffffefb4,pl,local_101c);
                                return;
                            }
                        }
                    }
                    SendResult(Connection,NOTACCESSIBLE);
                    return;
                }
                    // try { // try from 080da272 to 080da398 has its CatchHandler @ 080da3b1
                error("CEditList: Unbekannter Typ %d.\n",uVar2 & 0xff);
            }
        }
    }
    return;
}



// WARNING: Variable defined which should be unmapped: ChaseMode

void CSetTactics(TConnection *Connection,TReadBuffer *Buffer)

{
    TCombat *this;
    bool bVar1;
    uint uVar2;
    uint uVar3;
    uint uVar4;
    TPlayer *pTVar5;
    TPlayer *pl;
    int AttackMode;
    int ChaseMode;
    
    if (Connection == (TConnection *)0x0) {
        error("CSetTactics: Connection ist NULL.\n");
    }
    else {
                    // try { // try from 080da432 to 080da51b has its CatchHandler @ 080da521
        uVar2 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
        uVar3 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
        uVar4 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
        bVar1 = false;
        if (((uVar2 & 0xff) != 0) && ((uVar2 & 0xff) < 4)) {
            bVar1 = true;
        }
        if (((bVar1) && ((uVar3 & 0xff) < 2)) && ((uVar4 & 0xff) < 2)) {
            pTVar5 = TConnection::GetPlayer(Connection);
            if (pTVar5 != (TPlayer *)0x0) {
                this = &(pTVar5->super_TCreature).Combat;
                TCombat::SetAttackMode(this,(uchar)uVar2);
                TCombat::SetChaseMode(this,(uchar)uVar3);
                TCombat::SetSecureMode(this,(uchar)uVar4);
            }
        }
        else {
            print();
        }
    }
    return;
}



// WARNING: Variable defined which should be unmapped: pl

void CAttack(TConnection *Connection,TReadBuffer *Buffer,bool Follow)

{
    ulong CreatureID;
    TPlayer *this;
    ulong dfd;
    TPlayer *pl;
    
    if (Connection == (TConnection *)0x0) {
                    // try { // try from 080da5c7 to 080da5cb has its CatchHandler @ 080da620
        error("CAttack: Connection ist NULL.\n");
    }
    else {
                    // try { // try from 080da560 to 080da573 has its CatchHandler @ 080da620
        this = TConnection::GetPlayer(Connection);
        if (this != (TPlayer *)0x0) {
            dfd = (*(Buffer->super_TReadStream)._vptr_TReadStream[3])(Buffer);
                    // try { // try from 080da58a to 080da5a4 has its CatchHandler @ 080da5d0
            TCombat::SetAttackDest(&(this->super_TCreature).Combat,dfd,Follow);
            TCreature::ToDoAttack(&this->super_TCreature);
            TCreature::ToDoStart(&this->super_TCreature);
        }
    }
    return;
}



// WARNING: Variable defined which should be unmapped: posz

void CInviteToParty(TConnection *Connection,TReadBuffer *Buffer)

{
    bool bVar1;
    TCreature *guest;
    TPlayer *pTVar2;
    ulong id;
    TCreature *pTVar3;
    TPlayer *pl;
    int local_1c;
    int posx;
    int posy;
    int posz;
    
    if (Connection == (TConnection *)0x0) {
        error("CInviteToParty: Connection ist NULL.\n");
    }
    else {
                    // try { // try from 080da650 to 080da74b has its CatchHandler @ 080da751
        pTVar2 = TConnection::GetPlayer(Connection);
        if (pTVar2 != (TPlayer *)0x0) {
            id = (*(Buffer->super_TReadStream)._vptr_TReadStream[3])(Buffer);
            pTVar3 = GetCreature(id);
            if (pTVar3 != (TCreature *)0x0) {
                bVar1 = TConnection::IsVisible(Connection,pTVar3->posx,pTVar3->posy,pTVar3->posz);
                if (bVar1) {
                    InviteToParty((pTVar2->super_TCreature).ID,id);
                }
                else {
                    TConnection::GetPosition(Connection,&local_1c,&posx,&posy);
                    print();
                }
            }
        }
    }
    return;
}



void CJoinParty(TConnection *Connection,TReadBuffer *Buffer)

{
    TPlayer *pTVar1;
    ulong Host;
    TPlayer *pl;
    
    if (Connection == (TConnection *)0x0) {
        error("CJoinParty: Connection ist NULL.\n");
    }
    else {
                    // try { // try from 080da789 to 080da7c3 has its CatchHandler @ 080da7c6
        pTVar1 = TConnection::GetPlayer(Connection);
        if (pTVar1 != (TPlayer *)0x0) {
            Host = (*(Buffer->super_TReadStream)._vptr_TReadStream[3])(Buffer);
            JoinParty((pTVar1->super_TCreature).ID,Host);
        }
    }
    return;
}



void CRevokeInvitation(TConnection *Connection,TReadBuffer *Buffer)

{
    TPlayer *this;
    ulong Guest;
    ulong uVar1;
    TPlayer *pl;
    
    if (Connection == (TConnection *)0x0) {
        error("CRevokeInvitation: Connection ist NULL.\n");
    }
    else {
                    // try { // try from 080da7f9 to 080da86b has its CatchHandler @ 080da870
        this = TConnection::GetPlayer(Connection);
        if (this != (TPlayer *)0x0) {
            Guest = (*(Buffer->super_TReadStream)._vptr_TReadStream[3])(Buffer);
            uVar1 = TPlayer::GetPartyLeader(this,false);
            if (uVar1 == 0) {
                print();
            }
            else {
                RevokeInvitation((this->super_TCreature).ID,Guest);
            }
        }
    }
    return;
}



void CPassLeadership(TConnection *Connection,TReadBuffer *Buffer)

{
    TPlayer *this;
    ulong NewLeader;
    ulong uVar1;
    TPlayer *pl;
    
    if (Connection == (TConnection *)0x0) {
        error("CPassLeadership: Connection ist NULL.\n");
    }
    else {
                    // try { // try from 080da8a9 to 080da91b has its CatchHandler @ 080da920
        this = TConnection::GetPlayer(Connection);
        if (this != (TPlayer *)0x0) {
            NewLeader = (*(Buffer->super_TReadStream)._vptr_TReadStream[3])(Buffer);
            uVar1 = TPlayer::GetPartyLeader(this,false);
            if (uVar1 == 0) {
                print();
            }
            else {
                PassLeadership((this->super_TCreature).ID,NewLeader);
            }
        }
    }
    return;
}



void CLeaveParty(TConnection *Connection)

{
    TPlayer *this;
    ulong uVar1;
    TPlayer *pl;
    
    if (Connection != (TConnection *)0x0) {
        this = TConnection::GetPlayer(Connection);
        if (this != (TPlayer *)0x0) {
            uVar1 = TPlayer::GetPartyLeader(this,false);
            if (uVar1 == 0) {
                print();
            }
            else {
                LeaveParty((this->super_TCreature).ID,false);
            }
        }
        return;
    }
    error("CLeaveParty: Connection ist NULL.\n");
    return;
}



void COpenChannel(TConnection *Connection)

{
    TPlayer *pl;
    TPlayer *pTVar1;
    
    if (Connection != (TConnection *)0x0) {
        pTVar1 = TConnection::GetPlayer(Connection);
        if (pTVar1 != (TPlayer *)0x0) {
                    // try { // try from 080da9e8 to 080da9ec has its CatchHandler @ 080daa10
            OpenChannel((pTVar1->super_TCreature).ID);
        }
        return;
    }
    error("COpenChannel: Connection ist NULL.\n");
    return;
}



void CInviteToChannel(TConnection *Connection,TReadBuffer *Buffer)

{
    RESULT r;
    TPlayer *pTVar1;
    TPlayer *pl;
    char local_3c [4];
    char PlayerName [30];
    
    if (Connection == (TConnection *)0x0) {
                    // try { // try from 080daadb to 080daadf has its CatchHandler @ 080dab20
        error("CInviteToChannel: Connection ist NULL.\n");
    }
    else {
                    // try { // try from 080daa6c to 080daaa7 has its CatchHandler @ 080dab20
        pTVar1 = TConnection::GetPlayer(Connection);
        if (pTVar1 != (TPlayer *)0x0) {
            (*(Buffer->super_TReadStream)._vptr_TReadStream[4])(Buffer,local_3c,0x1e);
            if (local_3c[0] == '\0') {
                print();
            }
            else {
                    // try { // try from 080daacd to 080daad1 has its CatchHandler @ 080daae2
                InviteToChannel((pTVar1->super_TCreature).ID,local_3c);
            }
        }
    }
    return;
}



void CExcludeFromChannel(TConnection *Connection,TReadBuffer *Buffer)

{
    RESULT r;
    TPlayer *pTVar1;
    TPlayer *pl;
    char local_3c [4];
    char PlayerName [30];
    
    if (Connection == (TConnection *)0x0) {
                    // try { // try from 080dab97 to 080dab9b has its CatchHandler @ 080dabe0
        error("CExcludeFromChannel: Connection ist NULL.\n");
    }
    else {
                    // try { // try from 080dab49 to 080dab6d has its CatchHandler @ 080dabe0
        pTVar1 = TConnection::GetPlayer(Connection);
        if (pTVar1 != (TPlayer *)0x0) {
            (*(Buffer->super_TReadStream)._vptr_TReadStream[4])(Buffer,local_3c,0x1e);
                    // try { // try from 080dab7b to 080dab7f has its CatchHandler @ 080dab9e
            ExcludeFromChannel((pTVar1->super_TCreature).ID,local_3c);
        }
    }
    return;
}



void CCancel(TConnection *Connection)

{
    bool bVar1;
    TPlayer *this;
    TPlayer *pl;
    
    if (Connection == (TConnection *)0x0) {
        error("CCancel: Connection ist NULL.\n");
        return;
    }
    this = TConnection::GetPlayer(Connection);
    if (this != (TPlayer *)0x0) {
                    // try { // try from 080dac22 to 080dac2e has its CatchHandler @ 080dac75
        TCombat::StopAttack(&(this->super_TCreature).Combat,0);
        bVar1 = TCreature::ToDoClear(&this->super_TCreature);
        if (bVar1) {
                    // try { // try from 080dac47 to 080dac4b has its CatchHandler @ 080dac75
            SendSnapback(Connection);
        }
        TCreature::ToDoYield(&this->super_TCreature);
        return;
    }
    return;
}



// WARNING: Variable defined which should be unmapped: Name

void CAddBuddy(TConnection *Connection,TReadBuffer *Buffer)

{
    TPlayer *pl;
    TPlayer *this;
    char local_2c [4];
    char Name [30];
    
    if (Connection == (TConnection *)0x0) {
        error("CAddBuddy: Connection ist NULL.\n");
    }
    else {
                    // try { // try from 080dacba to 080dacfb has its CatchHandler @ 080dad00
        (*(Buffer->super_TReadStream)._vptr_TReadStream[4])(Buffer,local_2c,0x1e);
        if (local_2c[0] != '\0') {
            this = TConnection::GetPlayer(Connection);
            if (this != (TPlayer *)0x0) {
                TPlayer::AddBuddy(this,local_2c);
            }
        }
    }
    return;
}



void CRemoveBuddy(TConnection *Connection,TReadBuffer *Buffer)

{
    TPlayer *pl;
    ulong CharacterID_00;
    TPlayer *this;
    ulong CharacterID;
    
    if (Connection == (TConnection *)0x0) {
        error("CRemoveBuddy: Connection ist NULL.\n");
    }
    else {
                    // try { // try from 080dad3b to 080dad6d has its CatchHandler @ 080dad70
        CharacterID_00 = (*(Buffer->super_TReadStream)._vptr_TReadStream[3])(Buffer);
        this = TConnection::GetPlayer(Connection);
        if (this != (TPlayer *)0x0) {
            TPlayer::RemoveBuddy(this,CharacterID_00);
        }
    }
    return;
}



void CRuleViolation(TConnection *Connection,TReadBuffer *Buffer)

{
    bool bVar1;
    ulong CriminalID;
    TPlayer *cr;
    uint uVar2;
    uint uVar3;
    ulong StatementID_00;
    int iVar4;
    ulong uVar5;
    TPlayer *Gamemaster;
    bool IPBanishment;
    char *pcVar6;
    char *local_128;
    char *IPAddress;
    ulong StatementID;
    int Action;
    int Reason;
    int NumberOfStatements;
    vector<> *ReportedStatements;
    TPlayer *Criminal;
    char Comment [200];
    char local_3c [4];
    char Name [30];
    
    if (Connection == (TConnection *)0x0) {
        error("CRuleViolation: Connection ist NULL.\n");
        return;
    }
                    // try { // try from 080dadb3 to 080db14e has its CatchHandler @ 080db154
    cr = TConnection::GetPlayer(Connection);
    if (cr == (TPlayer *)0x0) {
        return;
    }
    (*(Buffer->super_TReadStream)._vptr_TReadStream[4])(Buffer,local_3c,0x1e);
    Trim(local_3c);
    uVar2 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
    uVar2 = uVar2 & 0xff;
    uVar3 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
    uVar3 = uVar3 & 0xff;
    (*(Buffer->super_TReadStream)._vptr_TReadStream[4])(Buffer,&Criminal,200);
    StatementID_00 = (*(Buffer->super_TReadStream)._vptr_TReadStream[3])(Buffer);
    iVar4 = (*(Buffer->super_TReadStream)._vptr_TReadStream[1])(Buffer);
    IPBanishment = (char)iVar4 != '\0';
    bVar1 = CheckBanishmentRight((cr->super_TCreature).ID,uVar2,uVar3);
    if ((!bVar1) ||
       ((IPBanishment && (bVar1 = CheckRight((cr->super_TCreature).ID,IP_BANISHMENT), !bVar1)))) {
        pcVar6 = "You have no authorization for this action.";
        goto LAB_080daf27;
    }
    if ((char)Criminal == '\0') {
        pcVar6 = "Please provide a comment for this report.";
        goto LAB_080daf27;
    }
    if ((uVar3 == 6) && (StatementID_00 == 0)) {
        pcVar6 = "Please provide a statement for this rule violation.";
        goto LAB_080daf27;
    }
    local_128 = (char *)0x0;
    ReportedStatements = (vector<> *)0x0;
    bVar1 = CheckRight((cr->super_TCreature).ID,READ_GAMEMASTER_CHANNEL);
    iVar4 = IdentifyPlayer(local_3c,false,!bVar1,(TPlayer **)&ReportedStatements);
    if (iVar4 == 0) {
        bVar1 = CheckRight(*(ulong *)(ReportedStatements[1].init.Text + 0xac),NO_BANISHMENT);
        if (!bVar1) {
            strcpy(local_3c,ReportedStatements[1].init.Text + 0xb8);
            local_128 = ReportedStatements[2].init.Text + 0xf1;
            goto LAB_080daf8c;
        }
        if (((uVar3 == 1) || (uVar3 == 3)) || (uVar3 == 5)) {
            pcVar6 = "This name has already been approved.";
            goto LAB_080daf27;
        }
        if (uVar3 != 6) {
            pcVar6 = "You may not report a god or gamemaster.";
            goto LAB_080daf27;
        }
    }
    else {
        uVar5 = GetCharacterID(local_3c);
        if (uVar5 == 0) {
            SendResult(Connection,PLAYERNOTEXISTING);
            return;
        }
        pcVar6 = GetCharacterName(local_3c);
        strcpy(local_3c,pcVar6);
        if (IPBanishment) {
            SendMessage(Connection,0x17,"Player is not online. No IP address was banished.");
            IPBanishment = false;
        }
LAB_080daf8c:
        Reason = 0;
        bVar1 = false;
        NumberOfStatements = 0;
        if ((0x1a < uVar2 + 0x12) && (uVar2 + 0x12 < 0x2e)) {
            bVar1 = true;
        }
        if (((!bVar1) && (uVar2 != 0x1d)) || (StatementID_00 == 0)) {
LAB_080dafc4:
            PunishmentOrder(&cr->super_TCreature,local_3c,local_128,uVar2,uVar3,(char *)&Criminal,
                            Reason,(vector<> *)NumberOfStatements,StatementID_00,IPBanishment);
            return;
        }
        uVar5 = 0;
        if (uVar3 != 6) {
            uVar5 = (cr->super_TCreature).ID;
        }
        iVar4 = GetCommunicationContext
                          (uVar5,StatementID_00,&Reason,(vector<> **)&NumberOfStatements);
        if (iVar4 == 1) {
            pcVar6 = "Statement is unknown. Perhaps it is too old?";
            goto LAB_080daf27;
        }
        if (iVar4 != 2) goto LAB_080dafc4;
    }
    pcVar6 = "Statement has already been reported.";
LAB_080daf27:
    SendMessage(Connection,0x17,pcVar6);
    return;
}



void CQuitGame(TConnection *Connection)

{
    TPlayer *this;
    int iVar1;
    TPlayer *pl;
    char *Text;
    
    this = TConnection::GetPlayer(Connection);
    if (this == (TPlayer *)0x0) goto LAB_080db1b8;
    iVar1 = TCreature::LogoutPossible(&this->super_TCreature);
    if (iVar1 == 1) {
        Text = "You may not logout during or immediately after a fight!";
LAB_080db1e2:
        SendMessage(Connection,0x17,Text);
        return;
    }
    if (iVar1 < 2) {
        if (iVar1 != 0) goto LAB_080db1a4;
    }
    else {
        if (iVar1 == 2) {
            Text = "You may not logout here!";
            goto LAB_080db1e2;
        }
LAB_080db1a4:
        error(&DAT_0810b2e0);
    }
    TCreature::ToDoClear(&this->super_TCreature);
LAB_080db1b8:
    TConnection::Logout(Connection,0,true);
    return;
}



void ReceiveData(TConnection *Connection)

{
    byte bVar1;
    bool bVar2;
    int Length;
    int iVar3;
    ulong uVar4;
    TPlayer *pTVar5;
    TPlayer *pl;
    int Command;
    uint uVar6;
    char *pcVar7;
    int dx;
    undefined1 local_2c [4];
    TReadBuffer Buffer;
    
    if (Connection == (TConnection *)0x0) {
        pcVar7 = "ReceiveData: Connection ist NULL.\n";
LAB_080db8fa:
        error(pcVar7);
        return;
    }
    uVar6 = Connection->InDataSize;
    if ((int)uVar6 < 1) {
        pcVar7 = "ReceiveData: Keine Daten vorhanden.\n";
        goto LAB_080db8fa;
    }
    if (0x7fe < (int)uVar6) {
        pcVar7 = &DAT_0810b360;
LAB_080db24a:
        error(pcVar7,uVar6);
        return;
    }
    TReadBuffer::TReadBuffer((TReadBuffer *)local_2c,Connection->InData + 2,uVar6);
                    // try { // try from 080db279 to 080db27d has its CatchHandler @ 080db910
    bVar1 = TReadBuffer::readByte((TReadBuffer *)local_2c);
    uVar6 = (uint)bVar1;
    if (Connection->State == CONNECTION_LOGIN) {
        if (uVar6 == 0xb) {
            bVar2 = TConnection::JoinGame(Connection,(TReadBuffer *)local_2c);
            if (bVar2) {
                return;
            }
            Log("game","Einloggen gescheitert.\n");
            SendResult(Connection,LOGINERROR);
            pTVar5 = TConnection::GetPlayer(Connection);
            if (pTVar5 == (TPlayer *)0x0) {
                error("ReceiveData: Einloggen gescheitert und keine Kreatur bekannt.\n");
            }
            else {
                DecrementIsOnlineOrder((pTVar5->super_TCreature).ID);
            }
            TConnection::Disconnect(Connection);
            return;
        }
        pcVar7 = "ReceiveData: Falsches Login-Kommando %d.\n";
        goto LAB_080db24a;
    }
    bVar2 = CommandAllowed(Connection,(ushort)bVar1);
    if (!bVar2) {
        return;
    }
    TConnection::ResetTimer(Connection,uVar6);
    switch(uVar6) {
    case 0x14:
        pTVar5 = TConnection::GetPlayer(Connection);
        if (pTVar5 != (TPlayer *)0x0) {
            iVar3 = TCreature::LogoutPossible(&pTVar5->super_TCreature);
            if (iVar3 == 1) {
                pcVar7 = "You may not logout during or immediately after a fight!";
LAB_080db32b:
                SendMessage(Connection,0x17,pcVar7);
                return;
            }
            if (iVar3 < 2) {
                if (iVar3 != 0) goto LAB_080db2f2;
            }
            else {
                if (iVar3 == 2) {
                    pcVar7 = "You may not logout here!";
                    goto LAB_080db32b;
                }
LAB_080db2f2:
                error(&DAT_0810b2e0);
            }
            TCreature::ToDoClear(&pTVar5->super_TCreature);
        }
        TConnection::Logout(Connection,0,true);
        break;
    default:
                    // try { // try from 080db834 to 080db86b has its CatchHandler @ 080db982
        print();
        break;
    case 0x1e:
        break;
    case 100:
                    // try { // try from 080db2c6 to 080db587 has its CatchHandler @ 080db982
        CGoPath(Connection,(TReadBuffer *)local_2c);
        break;
    case 0x65:
        iVar3 = -1;
        goto LAB_080db358;
    case 0x66:
        iVar3 = 0;
        goto LAB_080db375;
    case 0x67:
        iVar3 = 1;
LAB_080db358:
        dx = 0;
        goto LAB_080db360;
    case 0x68:
        iVar3 = 0;
        goto LAB_080db391;
    case 0x69:
        if (Connection != (TConnection *)0x0) {
            pTVar5 = TConnection::GetPlayer(Connection);
            if (pTVar5 == (TPlayer *)0x0) {
                return;
            }
            TCreature::ToDoStop(&pTVar5->super_TCreature);
            return;
        }
        pcVar7 = "CGoStop: Connection ist NULL.\n";
        goto LAB_080db3c3;
    case 0x6a:
        iVar3 = -1;
        goto LAB_080db375;
    case 0x6b:
        iVar3 = 1;
LAB_080db375:
        dx = 1;
LAB_080db360:
        CGoDirection(Connection,dx,iVar3);
        break;
    case 0x6c:
        iVar3 = 1;
        goto LAB_080db391;
    case 0x6d:
        iVar3 = -1;
LAB_080db391:
        dx = -1;
        goto LAB_080db360;
    case 0x6f:
        iVar3 = 0;
        goto LAB_080db3fd;
    case 0x70:
        iVar3 = 1;
        goto LAB_080db3fd;
    case 0x71:
        iVar3 = 2;
        goto LAB_080db3fd;
    case 0x72:
        iVar3 = 3;
LAB_080db3fd:
        CRotate(Connection,iVar3);
        break;
    case 0x78:
        CMoveObject(Connection,(TReadBuffer *)local_2c);
        break;
    case 0x7d:
        CTradeObject(Connection,(TReadBuffer *)local_2c);
        break;
    case 0x7e:
        CInspectTrade(Connection,(TReadBuffer *)local_2c);
        break;
    case 0x7f:
        if (Connection != (TConnection *)0x0) {
            pTVar5 = TConnection::GetPlayer(Connection);
            if (pTVar5 == (TPlayer *)0x0) {
                return;
            }
            TPlayer::AcceptTrade(pTVar5);
            return;
        }
        pcVar7 = "CAcceptTrade: Connection ist NULL.\n";
        goto LAB_080db3c3;
    case 0x80:
        if (Connection != (TConnection *)0x0) {
            pTVar5 = TConnection::GetPlayer(Connection);
            if (pTVar5 == (TPlayer *)0x0) {
                return;
            }
            TPlayer::RejectTrade(pTVar5);
            return;
        }
        pcVar7 = "CRejectTrade: Connection ist NULL.\n";
        goto LAB_080db3c3;
    case 0x82:
        CUseObject(Connection,(TReadBuffer *)local_2c);
        break;
    case 0x83:
        CUseTwoObjects(Connection,(TReadBuffer *)local_2c);
        break;
    case 0x84:
        CUseOnCreature(Connection,(TReadBuffer *)local_2c);
        break;
    case 0x85:
        CTurnObject(Connection,(TReadBuffer *)local_2c);
        break;
    case 0x87:
        CCloseContainer(Connection,(TReadBuffer *)local_2c);
        break;
    case 0x88:
        CUpContainer(Connection,(TReadBuffer *)local_2c);
        break;
    case 0x89:
        CEditText(Connection,(TReadBuffer *)local_2c);
        break;
    case 0x8a:
        CEditList(Connection,(TReadBuffer *)local_2c);
        break;
    case 0x8c:
        CLookAtPoint(Connection,(TReadBuffer *)local_2c);
        break;
    case 0x96:
        CTalk(Connection,(TReadBuffer *)local_2c);
        break;
    case 0x97:
        if (Connection != (TConnection *)0x0) {
            SendChannels(Connection);
            return;
        }
        pcVar7 = "CGetChannels: Connection ist NULL.\n";
        goto LAB_080db3c3;
    case 0x98:
        CJoinChannel(Connection,(TReadBuffer *)local_2c);
        break;
    case 0x99:
        if (Connection == (TConnection *)0x0) {
            error("CLeaveChannel: Connection ist NULL.\n");
        }
        else {
                    // try { // try from 080db597 to 080db5eb has its CatchHandler @ 080db946
            uVar6 = (**(_func_int_varargs **)((int)local_2c + 8))((TReadBuffer *)local_2c);
            iVar3 = GetNumberOfChannels();
            if (((int)(uVar6 & 0xffff) < iVar3) &&
               (pTVar5 = TConnection::GetPlayer(Connection), pTVar5 != (TPlayer *)0x0)) {
                LeaveChannel(uVar6 & 0xffff,(pTVar5->super_TCreature).ID,true);
            }
        }
        break;
    case 0x9a:
                    // try { // try from 080db5f8 to 080db670 has its CatchHandler @ 080db982
        CPrivateChannel(Connection,(TReadBuffer *)local_2c);
        break;
    case 0x9b:
        CProcessRequest(Connection,(TReadBuffer *)local_2c);
        break;
    case 0x9c:
        CRemoveRequest(Connection,(TReadBuffer *)local_2c);
        break;
    case 0x9d:
        CCancelRequest(Connection);
        break;
    case 0xa0:
        CSetTactics(Connection,(TReadBuffer *)local_2c);
        break;
    case 0xa1:
        bVar2 = false;
        goto LAB_080db64a;
    case 0xa2:
        bVar2 = true;
LAB_080db64a:
        CAttack(Connection,(TReadBuffer *)local_2c,bVar2);
        break;
    case 0xa3:
        CInviteToParty(Connection,(TReadBuffer *)local_2c);
        break;
    case 0xa4:
        if (Connection == (TConnection *)0x0) {
            error("CJoinParty: Connection ist NULL.\n");
        }
        else {
                    // try { // try from 080db67d to 080db6bb has its CatchHandler @ 080db980
            pTVar5 = TConnection::GetPlayer(Connection);
            if (pTVar5 != (TPlayer *)0x0) {
                uVar4 = (**(_func_int_varargs **)((int)local_2c + 0xc))((TReadBuffer *)local_2c);
                JoinParty((pTVar5->super_TCreature).ID,uVar4);
            }
        }
        break;
    case 0xa5:
                    // try { // try from 080db6c8 to 080db7d4 has its CatchHandler @ 080db982
        CRevokeInvitation(Connection,(TReadBuffer *)local_2c);
        break;
    case 0xa6:
        CPassLeadership(Connection,(TReadBuffer *)local_2c);
        break;
    case 0xa7:
        if (Connection != (TConnection *)0x0) {
            pTVar5 = TConnection::GetPlayer(Connection);
            if (pTVar5 == (TPlayer *)0x0) {
                return;
            }
            uVar4 = TPlayer::GetPartyLeader(pTVar5,false);
            if (uVar4 == 0) {
                print();
                return;
            }
            LeaveParty((pTVar5->super_TCreature).ID,false);
            return;
        }
        pcVar7 = "CLeaveParty: Connection ist NULL.\n";
LAB_080db3c3:
        error(pcVar7);
        break;
    case 0xaa:
        COpenChannel(Connection);
        break;
    case 0xab:
        CInviteToChannel(Connection,(TReadBuffer *)local_2c);
        break;
    case 0xac:
        CExcludeFromChannel(Connection,(TReadBuffer *)local_2c);
        break;
    case 0xbe:
        CCancel(Connection);
        break;
    case 0xc9:
        CRefreshField(Connection,(TReadBuffer *)local_2c);
        break;
    case 0xca:
        CRefreshContainer(Connection,(TReadBuffer *)local_2c);
        break;
    case 0xd2:
        CGetOutfit(Connection);
        break;
    case 0xd3:
        CSetOutfit(Connection,(TReadBuffer *)local_2c);
        break;
    case 0xdc:
        CAddBuddy(Connection,(TReadBuffer *)local_2c);
        break;
    case 0xdd:
        if (Connection == (TConnection *)0x0) {
            error("CRemoveBuddy: Connection ist NULL.\n");
        }
        else {
                    // try { // try from 080db7e4 to 080db81b has its CatchHandler @ 080db946
            uVar4 = (**(_func_int_varargs **)((int)local_2c + 0xc))((TReadBuffer *)local_2c);
            pTVar5 = TConnection::GetPlayer(Connection);
            if (pTVar5 != (TPlayer *)0x0) {
                TPlayer::RemoveBuddy(pTVar5,uVar4);
            }
        }
        break;
    case 0xe6:
        CBugReport(Connection,(TReadBuffer *)local_2c);
        break;
    case 0xe7:
        CRuleViolation(Connection,(TReadBuffer *)local_2c);
        break;
    case 0xe8:
        CErrorFileEntry(Connection,(TReadBuffer *)local_2c);
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ReceiveData(void)

{
    TConnection *Connection_00;
    pid_t __pid;
    TConnection *Connection;
    
    Connection_00 = GetFirstConnection();
    while (Connection_00 != (TConnection *)0x0) {
        if ((Connection_00->State - CONNECTION_LOGIN < 4) && (Connection_00->WaitingForACK != false)
           ) {
            ReceiveData(Connection_00);
            Connection_00->WaitingForACK = false;
            if (Connection_00->State - CONNECTION_LOGIN < 4) {
                __pid = TConnection::GetPID(Connection_00);
                kill(__pid,10);
            }
        }
        Connection_00 = GetNextConnection();
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__I__Z14CommandAllowedP11TConnectiont(void)

{
    __static_initialization_and_destruction_0(1,0xffff);
    return;
}



void __static_initialization_and_destruction_0(int __initialize_p,int __priority)

{
    if ((__priority == 0xffff) && (__initialize_p == 1)) {
        NONE.ObjectID = 0;
        vlong::vlong(&RSA_EXPONENT,0x10001);
        __cxa_atexit(__tcf_0,0,&__dso_handle);
        Semaphore::Semaphore(&CommunicationThreadMutex,1);
        __cxa_atexit(__tcf_1,0,&__dso_handle);
        TRSAPrivateKey::TRSAPrivateKey(&PrivateKey);
        __cxa_atexit(__tcf_2,0,&__dso_handle);
        Semaphore::Semaphore(&RSAMutex,1);
        __cxa_atexit(__tcf_3,0,&__dso_handle);
        TQueryManagerConnectionPool::TQueryManagerConnectionPool(&QueryManagerConnectionPool,10);
        __cxa_atexit(__tcf_4,0,&__dso_handle);
        Waitinglist.Units = (list<> *)operator_new(8);
        (Waitinglist.Units)->firstNode = (listnode<> *)0x0;
        (Waitinglist.Units)->lastNode = (listnode<> *)0x0;
        Waitinglist.firstFreeItem = (storeitem<> *)0x0;
        __cxa_atexit(__tcf_5,0,&__dso_handle);
    }
    return;
}

bool SendData(TConnection *Connection)

{
    int iVar1;
    undefined1 *puVar2;
    bool bVar3;
    uint uVar4;
    int Offset;
    int iVar5;
    int DataSize;
    uint uVar6;
    undefined4 uStackY_50;
    uint auStack_48 [2];
    undefined1 auStack_40 [8];
    undefined1 *local_38;
    uchar_0_ *Buffer;
    int local_30;
    int PacketSize;
    TWriteBuffer WriteBuffer;
    
    Buffer = &stack0xffffffb4;
    if (Connection == (TConnection *)0x0) {
        uStackY_50 = 0x80dc573;
        error("SendData: Verbindung ist NULL.\n");
    }
    else {
        uVar6 = Connection->NextToCommit - Connection->NextToSend;
        uVar4 = uVar6 + 0xe;
        if (-1 < (int)(uVar6 + 7)) {
            uVar4 = uVar6 + 7;
        }
        uVar4 = uVar4 & 0xfffffff8;
        local_30 = uVar4 + 2;
        iVar1 = -(uVar4 + 0x13 & 0xfffffff0);
        local_38 = auStack_40 + iVar1;
        *(uint *)((int)auStack_48 + iVar1 + 4) = uVar4 + 4;
        *(undefined1 **)((int)auStack_48 + iVar1) = auStack_40 + iVar1;
        *(int **)(&stack0xffffffb4 + iVar1) = &PacketSize;
        *(undefined4 *)((int)&uStackY_50 + iVar1) = 0x80dc48e;
        TWriteBuffer::TWriteBuffer
                  (*(TWriteBuffer **)(&stack0xffffffb4 + iVar1),*(uchar **)((int)auStack_48 + iVar1)
                   ,*(int *)((int)auStack_48 + iVar1 + 4));
        *(undefined4 *)((int)auStack_48 + iVar1) = 0;
        *(int **)(&stack0xffffffb4 + iVar1) = &PacketSize;
        *(undefined4 *)((int)&uStackY_50 + iVar1) = 0x80dc4a1;
        TWriteBuffer::writeWord
                  (*(TWriteBuffer **)(&stack0xffffffb4 + iVar1),*(ushort *)((int)auStack_48 + iVar1)
                  );
        *(uint *)((int)auStack_48 + iVar1) = uVar6 & 0xffff;
        *(int **)(&stack0xffffffb4 + iVar1) = &PacketSize;
        *(undefined4 *)((int)&uStackY_50 + iVar1) = 0x80dc4b3;
        TWriteBuffer::writeWord
                  (*(TWriteBuffer **)(&stack0xffffffb4 + iVar1),*(ushort *)((int)auStack_48 + iVar1)
                  );
        iVar5 = Connection->NextToSend % 0x4000;
        if ((int)(uVar6 + iVar5) < 0x4001) {
            *(uint *)((int)auStack_48 + iVar1 + 4) = uVar6;
            *(uchar **)((int)auStack_48 + iVar1) = Connection->OutData + iVar5;
            *(int **)(&stack0xffffffb4 + iVar1) = &PacketSize;
        }
        else {
            *(uchar **)((int)auStack_48 + iVar1) = Connection->OutData + iVar5;
            *(int **)(&stack0xffffffb4 + iVar1) = &PacketSize;
            *(int *)((int)auStack_48 + iVar1 + 4) = 0x4000 - iVar5;
            *(undefined4 *)((int)&uStackY_50 + iVar1) = 0x80dc4f9;
            TWriteBuffer::writeBytes
                      (*(TWriteBuffer **)(&stack0xffffffb4 + iVar1),
                       *(uchar **)((int)auStack_48 + iVar1),*(int *)((int)auStack_48 + iVar1 + 4));
            *(uint *)((int)auStack_48 + iVar1 + 4) = uVar6 + iVar5 + -0x4000;
            *(uchar **)((int)auStack_48 + iVar1) = Connection->OutData;
            *(int **)(&stack0xffffffb4 + iVar1) = &PacketSize;
        }
        *(undefined4 *)((int)&uStackY_50 + iVar1) = 0x80dc518;
        TWriteBuffer::writeBytes
                  (*(TWriteBuffer **)(&stack0xffffffb4 + iVar1),*(uchar **)((int)auStack_48 + iVar1)
                   ,*(int *)((int)auStack_48 + iVar1 + 4));
        *(int *)((int)auStack_48 + iVar1 + 4) = local_30;
        puVar2 = local_38;
        *(TConnection **)(&stack0xffffffb4 + iVar1) = Connection;
        *(undefined1 **)((int)auStack_48 + iVar1) = puVar2;
        *(undefined4 *)((int)&uStackY_50 + iVar1) = 0x80dc52e;
        bVar3 = WriteToSocket(*(TConnection **)(&stack0xffffffb4 + iVar1),
                              *(uchar **)((int)auStack_48 + iVar1),
                              *(int *)((int)auStack_48 + iVar1 + 4));
        if (bVar3) {
            Connection->NextToSend = Connection->NextToSend + uVar6;
            return true;
        }
    }
    return false;
}



bool SendData(TConnection *Connection,char *Data,int Size)

{
    bool bVar1;
    
    if (Connection == (TConnection *)0x0) {
        error("SendData: Connection ist NULL.\n");
        bVar1 = false;
    }
    else if (Data == (char *)0x0) {
        error("SendData: Data ist NULL.\n");
        bVar1 = true;
    }
    else {
        memcpy(Connection->OutData + 2,Data,Size);
        Connection->NextToSend = 0;
        Connection->NextToCommit = Size + 2;
        bVar1 = SendData(Connection);
    }
    return bVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

bool GetWaitinglistEntry(void)

{
    TWaitinglistEntry *pTVar1;
    int iVar2;
    TWaitinglistEntry *Search;
    char *in_stack_00000004;
    ulong *in_stack_00000008;
    undefined1 *in_stack_0000000c;
    undefined1 *in_stack_00000010;
    
    Semaphore::down(&CommunicationThreadMutex);
    pTVar1 = WaitinglistHead;
    while( true ) {
        if (pTVar1 == (TWaitinglistEntry *)0x0) {
            Semaphore::up(&CommunicationThreadMutex);
            return false;
        }
        iVar2 = stricmp(in_stack_00000004,pTVar1->Name,-1);
        if (iVar2 == 0) break;
        pTVar1 = pTVar1->Next;
    }
    *in_stack_00000008 = pTVar1->NextTry;
    *in_stack_0000000c = pTVar1->FreeAccount;
    *in_stack_00000010 = pTVar1->Newbie;
    Semaphore::up(&CommunicationThreadMutex);
    return true;
}



// WARNING: Variable defined which should be unmapped: NextTry_local

void InsertWaitinglistEntry(char *Name,ulong NextTry,bool FreeAccount,bool Newbie)

{
    TWaitinglistEntry *pTVar1;
    int iVar2;
    TWaitinglistEntry *pTVar3;
    TWaitinglistEntry *Entry;
    TWaitinglistEntry *Last;
    bool Newbie_local;
    bool FreeAccount_local;
    ulong NextTry_local;
    
    Semaphore::down(&CommunicationThreadMutex);
    pTVar1 = (TWaitinglistEntry *)0x0;
    pTVar3 = WaitinglistHead;
    while( true ) {
        if (pTVar3 == (TWaitinglistEntry *)0x0) {
            pTVar3 = store<>::getFreeItem(&Waitinglist);
            strcpy(pTVar3->Name,Name);
            pTVar3->NextTry = NextTry;
            pTVar3->FreeAccount = FreeAccount;
            pTVar3->Next = (TWaitinglistEntry *)0x0;
            pTVar3->Sleeping = false;
            pTVar3->Newbie = Newbie;
            if (pTVar1 != (TWaitinglistEntry *)0x0) {
                pTVar1->Next = pTVar3;
                pTVar3 = WaitinglistHead;
            }
            WaitinglistHead = pTVar3;
            Semaphore::up(&CommunicationThreadMutex);
            Log("queue",&DAT_0810bc80);
            return;
        }
        iVar2 = stricmp(Name,pTVar3->Name,-1);
        if (iVar2 == 0) break;
        pTVar1 = pTVar3;
        pTVar3 = pTVar3->Next;
    }
    pTVar3->NextTry = NextTry;
    pTVar3->FreeAccount = FreeAccount;
    pTVar3->Newbie = Newbie;
    Semaphore::up(&CommunicationThreadMutex);
    return;
}



void DeleteWaitinglistEntry(char *Name)

{
    TWaitinglistEntry *pTVar1;
    TWaitinglistEntry *pTVar2;
    int iVar3;
    TWaitinglistEntry *Search;
    TWaitinglistEntry *Entry;
    storeitem<> *psVar4;
    
    psVar4 = (storeitem<> *)0x0;
    Semaphore::down(&CommunicationThreadMutex);
    if (WaitinglistHead != (TWaitinglistEntry *)0x0) {
        iVar3 = stricmp(Name,WaitinglistHead->Name,-1);
        if (iVar3 == 0) {
            psVar4 = (storeitem<> *)WaitinglistHead;
            WaitinglistHead = WaitinglistHead->Next;
        }
        else if (WaitinglistHead != (TWaitinglistEntry *)0x0) {
            pTVar1 = WaitinglistHead->Next;
            pTVar2 = WaitinglistHead;
            while (pTVar1 != (TWaitinglistEntry *)0x0) {
                iVar3 = stricmp(Name,pTVar2->Next->Name,-1);
                if (iVar3 == 0) {
                    psVar4 = (storeitem<> *)pTVar2->Next;
                    pTVar2->Next = (TWaitinglistEntry *)psVar4->next;
                    break;
                }
                pTVar2 = pTVar2->Next;
                pTVar1 = pTVar2->Next;
            }
        }
    }
    if (psVar4 != (storeitem<> *)0x0) {
        psVar4->next = Waitinglist.firstFreeItem;
        Waitinglist.firstFreeItem = psVar4;
    }
    Semaphore::up(&CommunicationThreadMutex);
    return;
}



// WARNING: Variable defined which should be unmapped: Newbie_local

int GetWaitinglistPosition(char *Name,bool FreeAccount,bool Newbie)

{
    int iVar1;
    int iVar2;
    storeitem<> *psVar3;
    TWaitinglistEntry *Search;
    storeitem<> *psVar4;
    int PremiumVeterans;
    int iVar5;
    int PremiumNewbies;
    int iVar6;
    int local_1c;
    int FreeVeterans;
    int FreeNewbies;
    bool Newbie_local;
    bool FreeAccount_local;
    
    iVar6 = 0;
    iVar5 = 0;
    local_1c = 0;
    FreeVeterans = 0;
    Semaphore::down(&CommunicationThreadMutex);
    psVar3 = (storeitem<> *)WaitinglistHead;
    if ((WaitinglistHead != (TWaitinglistEntry *)0x0) && (WaitinglistHead->NextTry + 0x3c < RoundNr)
       ) {
        do {
            psVar4 = psVar3;
            Log("queue",&DAT_0810bcc0,(psVar4->data).Name);
            psVar3 = (storeitem<> *)WaitinglistHead->Next;
            WaitinglistHead = (TWaitinglistEntry *)psVar3;
            psVar4->next = Waitinglist.firstFreeItem;
            Waitinglist.firstFreeItem = psVar4;
            if (psVar3 == (storeitem<> *)0x0) break;
        } while ((psVar3->data).NextTry + 0x3c < RoundNr);
    }
    if (psVar3 != (storeitem<> *)0x0) {
        iVar5 = 0;
        do {
            iVar1 = stricmp(Name,(psVar3->data).Name,-1);
            if (iVar1 == 0) break;
            iVar1 = local_1c;
            if ((psVar3->data).Sleeping == false) {
                if ((psVar3->data).NextTry + 5 < RoundNr) {
                    (psVar3->data).Sleeping = true;
                }
                else if ((psVar3->data).FreeAccount == false) {
                    if ((psVar3->data).Newbie != false) {
                        iVar6 = iVar6 + 1;
                    }
                    if ((psVar3->data).Newbie == false) {
                        iVar5 = iVar5 + 1;
                    }
                }
                else {
                    iVar2 = FreeVeterans + 1;
                    if ((psVar3->data).Newbie == false) {
                        iVar2 = FreeVeterans;
                    }
                    iVar1 = local_1c + 1;
                    FreeVeterans = iVar2;
                    if ((psVar3->data).Newbie != false) {
                        iVar1 = local_1c;
                    }
                }
            }
            local_1c = iVar1;
            psVar3 = psVar3->next;
        } while (psVar3 != (storeitem<> *)0x0);
    }
    Semaphore::up(&CommunicationThreadMutex);
    if (FreeAccount) {
        if (Newbie) {
            local_1c = iVar5 + 1 + FreeVeterans + local_1c + iVar6;
        }
        else {
            local_1c = iVar5 + 1 + local_1c;
            iVar5 = GetNewbiesOnline();
            if (iVar5 < MaxNewbies - PremiumNewbieBuffer) {
                local_1c = FreeVeterans + local_1c;
            }
        }
    }
    else {
        local_1c = iVar5 + 1 + iVar6;
        if (!Newbie) {
            iVar1 = GetNewbiesOnline();
            local_1c = iVar5 + 1;
            if (iVar1 < MaxNewbies) {
                local_1c = iVar6 + iVar5 + 1;
            }
        }
    }
    return local_1c;
}



int CheckWaitingTime(char *Name,TConnection *Connection,bool FreeAccount,bool Newbie)

{
    int iVar1;
    int iVar2;
    int iVar3;
    int iVar4;
    int PlayersOnline;
    int Position;
    int WaitingTime;
    int WaitingTime_00;
    int NewbiesOnline;
    char *Reason;
    char local_11c [2];
    bool Newbie_local;
    bool FreeAccount_local;
    char Message [250];
    
    WaitingTime_00 = 0;
    NewbiesOnline = 0;
    iVar1 = GetWaitinglistPosition(Name,FreeAccount,Newbie);
    iVar2 = GetPlayersOnline();
    iVar3 = GetNewbiesOnline();
    iVar4 = GetOrderBufferSpace();
    if (iVar4 - iVar1 < iVar2) {
        print();
        NewbiesOnline = (int)s_The_server_is_overloaded__0810d5ea;
        WaitingTime_00 = iVar1 / 2 + 10;
        goto LAB_080dcb50;
    }
    if (FreeAccount) {
        if (RoundNr < EarliestFreeAccountAdmissionRound) {
            print();
            NewbiesOnline = (int)s_The_server_is_overloaded__Only_p_0810bf60;
            WaitingTime_00 = iVar1 / 2 + (EarliestFreeAccountAdmissionRound - RoundNr);
            goto LAB_080dcb50;
        }
        if (iVar2 <= (MaxPlayers - PremiumPlayerBuffer) - iVar1) goto LAB_080dcaff;
        print();
        NewbiesOnline = (int)s_Too_many_players_online__Only_pl_0810bec0;
LAB_080dcbd5:
        WaitingTime_00 = iVar1 / 2 + 5;
    }
    else {
        if (MaxPlayers - iVar1 < iVar2) {
            print();
            NewbiesOnline = (int)s_There_are_too_many_players_onlin_0810bfc0;
        }
        else {
LAB_080dcaff:
            if (!Newbie) goto LAB_080dcb50;
            if ((FreeAccount) || (iVar3 <= MaxNewbies - iVar1)) {
                if ((!Newbie) ||
                   ((!FreeAccount || (iVar3 <= (MaxNewbies - PremiumNewbieBuffer) - iVar1))))
                goto LAB_080dcb50;
                print();
                NewbiesOnline = (int)s_There_are_too_many_players_onlin_0810bd80;
                goto LAB_080dcbd5;
            }
            print();
            NewbiesOnline = (int)s_There_are_too_many_players_onlin_0810be20;
        }
        WaitingTime_00 = iVar1 / 2 + 3;
    }
LAB_080dcb50:
    if (0xf0 < WaitingTime_00) {
        WaitingTime_00 = 0xf0;
    }
    if (0 < WaitingTime_00) {
        snprintf(local_11c,0xfa,"%s\n\nYou are at place %d on the waiting list.",NewbiesOnline,iVar1
                );
        SendLoginMessage(Connection,0x16,local_11c,WaitingTime_00);
    }
    return WaitingTime_00;
}



// WARNING: Variable defined which should be unmapped: Chances

int ReadFromSocket(TConnection *Connection,uchar *Buffer,int Size)

{
    int __fd;
    ssize_t sVar1;
    int *piVar2;
    int nread;
    int nleft;
    size_t __nbytes;
    int local_14;
    int Chances;
    
    local_14 = 0x32;
    __nbytes = Size;
    if (0 < Size) {
        do {
            __fd = TConnection::GetSocket(Connection);
            sVar1 = read(__fd,Buffer,__nbytes);
            if (sVar1 == 0) break;
            if (sVar1 < 0) {
                piVar2 = __errno_location();
                if (*piVar2 != 4) {
                    if (*piVar2 != 0xb) {
                        return sVar1;
                    }
                    if (__nbytes == Size) {
                        return sVar1;
                    }
                    if (local_14 == 0) {
                        return sVar1;
                    }
                    local_14 = local_14 + -1;
                    usleep(100000);
                }
            }
            else {
                __nbytes = __nbytes - sVar1;
                Buffer = Buffer + sVar1;
            }
        } while (0 < (int)__nbytes);
    }
    return Size - __nbytes;
}



bool CallGameThread(TConnection *Connection)

{
    bool bVar1;
    pid_t pVar2;
    int iVar3;
    
    bVar1 = GameRunning();
    if (bVar1) {
        Connection->WaitingForACK = true;
        pVar2 = GetGameThreadPID();
        iVar3 = kill(pVar2,10);
        if (iVar3 != 0) {
            pVar2 = GetGameThreadPID();
            error("CallGameThread: Can\'t send SIGUSR1 to pid %d\n",pVar2);
            SendLoginMessage(Connection,0x14,"The server is not online.\nPlease try again later.",-1
                            );
            return false;
        }
    }
    return true;
}



bool CheckConnection(TConnection *Connection)

{
    int iVar1;
    bool bVar2;
    undefined1 local_14 [4];
    pollfd Status;
    
    bVar2 = false;
    local_14 = (undefined1  [4])TConnection::GetSocket(Connection);
    Status.fd._0_2_ = 1;
    iVar1 = poll((pollfd *)local_14,1,0);
    if ((-1 < iVar1) && ((Status.fd._2_2_ & 1) == 0)) {
        bVar2 = true;
    }
    return bVar2;
}



TPlayerData *
PerformRegistration(TConnection *Connection,char *PlayerName,ulong AccountID,char *PlayerPassword,
                   bool GamemasterClient)

{
    int iVar1;
    char *pcVar2;
    TPlayerData *pTVar3;
    __pid_t _Var4;
    TPlayerData *PlayerData;
    char (*__dest) [30];
    bool bVar5;
    int iVar6;
    int local_e18;
    int local_e14;
    int i;
    undefined1 auStack_e0c [2];
    bool ReadOnly;
    bool GamemasterClient_local;
    pollfd Status_1;
    ulong CharacterID;
    int Sex;
    int NumberOfBuddies;
    undefined1 auStack_df4 [3];
    bool PremiumAccountActivated;
    pollfd Status;
    char BuddyNames [100] [30];
    char local_22c [4];
    char Title [31];
    char Rank [31];
    char Guild [31];
    ulong BuddyIDs [100];
    uchar Rights [12];
    undefined1 local_2c [4];
    TQueryManagerPoolConnection QueryManagerConnection;
    
    TQueryManagerPoolConnection::TQueryManagerPoolConnection
              ((TQueryManagerPoolConnection *)local_2c,&QueryManagerConnectionPool);
    if (QueryManagerConnection.QueryManagerConnectionPool == (TQueryManagerConnectionPool *)0x0) {
        pcVar2 = "PerformRegistration: Kann Verbindung zum Query-Manager nicht herstellen.\n";
LAB_080dd3a0:
        error(pcVar2);
switchD_080dcfed_caseD_0:
        pcVar2 = "Internal error, closing connection.";
        goto LAB_080dd020;
    }
                    // try { // try from 080dceb0 to 080dd02f has its CatchHandler @ 080dd590
    _auStack_df4 = TConnection::GetSocket(Connection);
    bVar5 = false;
    Status.fd._0_2_ = 1;
    iVar6 = 1;
    iVar1 = poll((pollfd *)auStack_df4,1,0);
    if ((-1 < iVar1) && ((Status.fd._2_2_ & 1) == 0)) {
        bVar5 = true;
    }
    if (!bVar5) goto LAB_080dd030;
    print();
    BuddyIDs[99] = 0;
    pcVar2 = TConnection::GetIPAddress(Connection);
    iVar6 = TQueryManagerConnection::loginGame
                      ((TQueryManagerConnection *)QueryManagerConnection.QueryManagerConnectionPool,
                       AccountID,PlayerName,PlayerPassword,pcVar2,PrivateWorld,false,
                       GamemasterClient,(ulong *)&Status_1.events,(int *)&CharacterID,Rank + 0x1c,
                       Title + 0x1c,local_22c,&Sex,(ulong *)(Guild + 0x1c),
                       (char (*) [30])&Status.events,(uchar *)(BuddyIDs + 99),
                       (bool *)((int)&NumberOfBuddies + 3));
    switch(iVar6) {
    case 0:
                    // try { // try from 080dd05c to 080dd11d has its CatchHandler @ 080dd590
        _auStack_e0c = TConnection::GetSocket(Connection);
        bVar5 = false;
        Status_1.fd._0_2_ = 1;
        iVar6 = poll((pollfd *)auStack_e0c,1,0);
        if ((-1 < iVar6) && ((Status_1.fd._2_2_ & 1) == 0)) {
            bVar5 = true;
        }
        if (!bVar5) {
            TQueryManagerConnection::decrementIsOnline
                      ((TQueryManagerConnection *)QueryManagerConnection.QueryManagerConnectionPool,
                       Status_1._4_4_);
            iVar6 = Status_1._4_4_;
            goto LAB_080dd030;
        }
        if (AccountID == 0) {
            error("PerformRegistration: Spieler %s wurde noch keinem Account zugewiesen.\n",
                  PlayerName);
            pcVar2 = 
            "Character is not assigned to an account.\nPerform this on the Tibia website\nat \"www.tibia.com\"."
            ;
        }
        else {
            PlayerName[0x1d] = '\0';
            if (NumberOfBuddies._3_1_ != '\0') {
                SendLoginMessage(Connection,0x15,
                                 "Your Premium Account is now activated.\nHave a lot of fun in Tibia."
                                 ,-1);
            }
            pcVar2 = TConnection::GetIPAddress(Connection);
            iVar6 = TConnection::GetSocket(Connection);
            Log("game","Spieler %s loggt ein an Socket %d von %s.\n",PlayerName,iVar6,pcVar2);
            pcVar2 = (char *)0x1;
            pTVar3 = AssignPlayerPoolSlot(Status_1._4_4_,true);
            if (pTVar3 != (TPlayerData *)0x0) {
                _Var4 = getpid();
                bVar5 = pTVar3->Locked == _Var4;
                if ((bVar5) || (pTVar3->AccountID == 0)) {
                    pTVar3->Sex = CharacterID;
                    pTVar3->AccountID = AccountID;
                    strcpy(pTVar3->Name,PlayerName);
                    *(ulong *)pTVar3->Rights = BuddyIDs[99];
                    pTVar3->Rights[4] = '\0';
                    pTVar3->Rights[5] = '\0';
                    pTVar3->Rights[6] = '\0';
                    pTVar3->Rights[7] = '\0';
                    pTVar3->Rights[8] = '\0';
                    pTVar3->Rights[9] = '\0';
                    pTVar3->Rights[10] = '\0';
                    pTVar3->Rights[0xb] = '\0';
                    strcpy(pTVar3->Guild,Rank + 0x1c);
                    strcpy(pTVar3->Rank,Title + 0x1c);
                    pcVar2 = local_22c;
                    strcpy(pTVar3->Title,pcVar2);
                }
                if ((bVar5) && (pTVar3->Buddies == 0)) {
                    pTVar3->Buddies = Sex;
                    local_e14 = 0;
                    if (0 < Sex) {
                        local_e18 = 0;
                        __dest = pTVar3->BuddyName;
                        do {
                            pTVar3->Buddy[local_e14] = *(ulong *)(Guild + local_e14 * 4 + 0x1c);
                            pcVar2 = BuddyNames[-1] + local_e18 + 0x1a;
                            strcpy(*__dest,pcVar2);
                            local_e14 = local_e14 + 1;
                            local_e18 = local_e18 + 0x1e;
                            __dest = __dest + 1;
                        } while (local_e14 < Sex);
                    }
                }
                TQueryManagerPoolConnection::~TQueryManagerPoolConnection
                          ((TQueryManagerPoolConnection *)local_2c,(int)pcVar2);
                return pTVar3;
            }
                    // try { // try from 080dd27e to 080dd569 has its CatchHandler @ 080dd590
            error(&DAT_0810c160);
            TQueryManagerConnection::decrementIsOnline
                      ((TQueryManagerConnection *)QueryManagerConnection.QueryManagerConnectionPool,
                       Status_1._4_4_);
            pcVar2 = "There are too many players online.\nPlease try again later.";
        }
        break;
    case 1:
        print();
        pcVar2 = 
        "Character doesn\'t exist.\nCreate a new character on the Tibia website\nat \"www.tibia.com\"."
        ;
        break;
    case 2:
        print();
        pcVar2 = "Character doesn\'t exist.\nCreate a new character on the Tibia website.";
        break;
    case 3:
        print();
        pcVar2 = "Character doesn\'t live on this world.\nPlease login on the right world.";
        break;
    case 4:
        print();
        pcVar2 = "This world is private and you have not been invited to play on it.";
        break;
    default:
        pcVar2 = &DAT_0810c4a0;
        goto LAB_080dd3a0;
    case 6:
        pcVar2 = TConnection::GetIPAddress(Connection);
        Log("game",&DAT_0810c500,PlayerName,pcVar2);
        goto LAB_080dd3d1;
    case 7:
        pcVar2 = TConnection::GetIPAddress(Connection);
        Log("game","Spieler %s blockiert; Login von %s.\n",PlayerName,pcVar2);
        pcVar2 = "Account disabled for five minutes. Please wait.";
        break;
    case 8:
        Log("game",&DAT_0810c600,PlayerName);
LAB_080dd3d1:
        pcVar2 = "Accountnumber or password is not correct.";
        break;
    case 9:
        pcVar2 = TConnection::GetIPAddress(Connection);
        Log("game",&DAT_0810c640,pcVar2,PlayerName);
        pcVar2 = "IP address blocked for 30 minutes. Please wait.";
        break;
    case 10:
        print();
        pcVar2 = "Your account is banished.";
        break;
    case 0xb:
        print();
        pcVar2 = "Your character is banished because of his/her name.";
        break;
    case 0xc:
        print();
        pcVar2 = "Your IP address is banished.";
        break;
    case 0xd:
        print();
        pcVar2 = "You may only login with one character\nof your account at the same time.";
        break;
    case 0xe:
        print();
        pcVar2 = "You may only login with a Gamemaster account.";
        break;
    case 0xf:
        Log("game",&DAT_0810c860,AccountID,PlayerName);
        pcVar2 = "Login failed due to corrupt data.";
        break;
    case -1:
        goto switchD_080dcfed_caseD_0;
    }
LAB_080dd020:
    iVar6 = 0x14;
    SendLoginMessage(Connection,0x14,pcVar2,-1);
LAB_080dd030:
    TQueryManagerPoolConnection::~TQueryManagerPoolConnection
              ((TQueryManagerPoolConnection *)local_2c,iVar6);
    return (TPlayerData *)0x0;
}



bool HandleLogin(TConnection *Connection)

{
    TReadBuffer *this;
    int *ctx;
    TWaitinglistEntry *pTVar1;
    uchar Command;
    uchar uVar2;
    bool bVar3;
    bool bVar4;
    ushort w;
    ushort w_00;
    ulong AccountID_00;
    int iVar5;
    TPlayerData *Slot;
    __pid_t _Var6;
    pid_t pVar7;
    bool FreeAccount_00;
    bool Newbie_00;
    int WaitingTime;
    TPlayerData *PlayerData;
    int Type;
    TQueryManagerConnectionPool *CharacterID;
    uchar *out;
    char *pcVar8;
    size_t *in_stack_fffffed0;
    uchar *in_stack_fffffed4;
    size_t in_stack_fffffed8;
    bool ReadOnly;
    ulong AccountID;
    bool GamemasterClient;
    ushort TerminalVersion;
    ushort TerminalType;
    bool local_102;
    bool local_101;
    bool Newbie;
    ulong uStack_100;
    bool FreeAccount;
    ulong NextTry;
    TWriteBuffer WriteBuffer;
    uchar AssymmetricData [128];
    char PlayerPassword [31];
    char PlayerName [31];
    TReadBuffer Buffer;
    
    this = (TReadBuffer *)(PlayerName + 0x1c);
    TReadBuffer::TReadBuffer(this,Connection->InData + 2,0x7fe);
                    // try { // try from 080dd5e8 to 080dd5ec has its CatchHandler @ 080ddd00
    uVar2 = TReadBuffer::readByte(this);
    if (uVar2 == '\n') {
        out = (uchar *)0x80;
        ctx = &WriteBuffer.Position;
                    // try { // try from 080dd635 to 080dd645 has its CatchHandler @ 080ddde8
        TReadBuffer::readBytes(this,(uchar *)ctx,0x80);
        Semaphore::down(&RSAMutex);
                    // try { // try from 080dd651 to 080dd655 has its CatchHandler @ 080ddd3f
        TRSAPrivateKey::decrypt
                  (&PrivateKey,(EVP_PKEY_CTX *)ctx,out,in_stack_fffffed0,in_stack_fffffed4,
                   in_stack_fffffed8);
                    // try { // try from 080dd65d to 080dd74c has its CatchHandler @ 080ddde8
        Semaphore::up(&RSAMutex);
        TReadBuffer::TReadBuffer((TReadBuffer *)&NextTry,(uchar *)ctx,0x80);
        TReadBuffer::readByte((TReadBuffer *)&NextTry);
        TXTEASymmetricKey::init
                  (&Connection->SymmetricKey,(EVP_PKEY_CTX *)((int)ctx + WriteBuffer.Size));
        TReadBuffer::skip((TReadBuffer *)&NextTry,0x10);
        w = TReadBuffer::readWord((TReadBuffer *)&NextTry);
        w_00 = TReadBuffer::readWord((TReadBuffer *)&NextTry);
        uVar2 = TReadBuffer::readByte((TReadBuffer *)&NextTry);
        AccountID_00 = TReadBuffer::readQuad((TReadBuffer *)&NextTry);
        pcVar8 = PlayerPassword + 0x1c;
        TReadStream::readString((TReadStream *)&NextTry,pcVar8,0x1e);
        TReadStream::readString((TReadStream *)&NextTry,(char *)(AssymmetricData + 0x7c),0x1e);
        if (PlayerPassword[0x1c] == '\0') {
            pcVar8 = "You must enter a character name.";
        }
        else if ((w < 3) && (TERMINALVERSION[w] <= (int)(uint)w_00)) {
            bVar3 = GameRunning();
            if (bVar3) {
                bVar3 = GameStarting();
                if (bVar3) {
                    pcVar8 = "The game is just starting.\nPlease try again later.";
                }
                else {
                    bVar3 = GameEnding();
                    if (!bVar3) {
                        do {
                            Semaphore::down(&CommunicationThreadMutex);
                            for (pTVar1 = WaitinglistHead; pTVar1 != (TWaitinglistEntry *)0x0;
                                pTVar1 = pTVar1->Next) {
                                iVar5 = stricmp(pcVar8,pTVar1->Name,-1);
                                if (iVar5 == 0) {
                                    uStack_100 = pTVar1->NextTry;
                                    local_101 = pTVar1->FreeAccount;
                                    local_102 = pTVar1->Newbie;
                                    Semaphore::up(&CommunicationThreadMutex);
                                    bVar3 = true;
                                    goto LAB_080dd827;
                                }
                            }
                            Semaphore::up(&CommunicationThreadMutex);
                            bVar3 = false;
LAB_080dd827:
                            if (!bVar3) {
                                print();
                                Slot = PerformRegistration(Connection,pcVar8,AccountID_00,
                                                           (char *)(AssymmetricData + 0x7c),
                                                           uVar2 != '\0');
                                if (Slot == (TPlayerData *)0x0) {
                                    return false;
                                }
                                _Var6 = getpid();
                                bVar3 = Slot->Locked != _Var6;
                                FreeAccount_00 = (bool)((Slot->Rights[0] ^ 1) & 1);
                                Newbie_00 = false;
                                if ((Slot->Profession == 0) && ((Slot->Rights[8] & 0x40) == 0)) {
                                    Newbie_00 = true;
                                }
                                if ((FreeAccount_00 == false) ||
                                   ((MaxPlayers != PremiumPlayerBuffer &&
                                    ((Newbie_00 == false || (MaxNewbies != PremiumNewbieBuffer))))))
                                {
                                    bVar4 = IsPlayerOnline(pcVar8);
                                    if ((bVar4) ||
                                       (iVar5 = CheckWaitingTime(pcVar8,Connection,FreeAccount_00,
                                                                 Newbie_00), iVar5 < 1))
                                    goto LAB_080dd929;
                                    InsertWaitinglistEntry
                                              (pcVar8,iVar5 + RoundNr,FreeAccount_00,Newbie_00);
                                    CharacterID = &QueryManagerConnectionPool;
                                    TQueryManagerPoolConnection::TQueryManagerPoolConnection
                                              ((TQueryManagerPoolConnection *)&NextTry,
                                               &QueryManagerConnectionPool);
                                    if (WriteBuffer.super_TWriteStream._vptr_TWriteStream ==
                                        (_func_int_varargs **)0x0) {
                                        error(
                                             "HandleLogin: Kann Verbindung zum Query-Manager nicht herstellen.\n"
                                             );
                                    }
                                    else {
                                        CharacterID = (TQueryManagerConnectionPool *)
                                                      Slot->CharacterID;
                    // try { // try from 080ddbdb to 080ddbf0 has its CatchHandler @ 080dde0a
                                        TQueryManagerConnection::decrementIsOnline
                                                  ((TQueryManagerConnection *)
                                                   WriteBuffer.super_TWriteStream._vptr_TWriteStream
                                                   ,(ulong)CharacterID);
                                    }
                                    if (bVar3) {
                                        DecreasePlayerPoolSlotSticky(Slot);
                                    }
                                    else {
                    // try { // try from 080ddc07 to 080ddc19 has its CatchHandler @ 080dde0a
                                        ReleasePlayerPoolSlot(Slot);
                                    }
                                }
                                else {
                                    SendLoginMessage(Connection,0x14,
                                                                                                          
                                                  "Only players with premium accounts\nare allowed to enter this world."
                                                  ,-1);
                                    CharacterID = &QueryManagerConnectionPool;
                                    TQueryManagerPoolConnection::TQueryManagerPoolConnection
                                              ((TQueryManagerPoolConnection *)&NextTry,
                                               &QueryManagerConnectionPool);
                                    if (WriteBuffer.super_TWriteStream._vptr_TWriteStream ==
                                        (_func_int_varargs **)0x0) {
                                        error(
                                             "HandleLogin: Kann Verbindung zum Query-Manager nicht herstellen.\n"
                                             );
                                    }
                                    else {
                                        CharacterID = (TQueryManagerConnectionPool *)
                                                      Slot->CharacterID;
                    // try { // try from 080ddc65 to 080ddc9e has its CatchHandler @ 080dddf5
                                        TQueryManagerConnection::decrementIsOnline
                                                  ((TQueryManagerConnection *)
                                                   WriteBuffer.super_TWriteStream._vptr_TWriteStream
                                                   ,(ulong)CharacterID);
                                    }
                                    if (bVar3) {
                                        DecreasePlayerPoolSlotSticky(Slot);
                                    }
                                    else {
                                        ReleasePlayerPoolSlot(Slot);
                                    }
                                }
                                TQueryManagerPoolConnection::~TQueryManagerPoolConnection
                                          ((TQueryManagerPoolConnection *)&NextTry,(int)CharacterID)
                                ;
                                return false;
                            }
                            print();
                            iVar5 = uStack_100 - RoundNr;
                            if (0 < iVar5) {
                                Log("queue",&DAT_0810ca20,pcVar8,iVar5);
                                pcVar8 = "It\'s not your turn yet.";
                                Type = 0x16;
                                goto LAB_080dd78e;
                            }
                            if (-0x3d < iVar5) {
                                iVar5 = CheckWaitingTime(pcVar8,Connection,local_101,local_102);
                                if (0 < iVar5) {
                                    InsertWaitinglistEntry
                                              (pcVar8,iVar5 + RoundNr,local_101,local_102);
                                    return false;
                                }
                                DeleteWaitinglistEntry(pcVar8);
                                Slot = PerformRegistration(Connection,pcVar8,AccountID_00,
                                                           (char *)(AssymmetricData + 0x7c),
                                                           uVar2 != '\0');
                                if (Slot == (TPlayerData *)0x0) {
                                    return false;
                                }
                                _Var6 = getpid();
                                bVar3 = Slot->Locked != _Var6;
LAB_080dd929:
                                if (!bVar3) {
                                    IncreasePlayerPoolSlotSticky(Slot);
                                    ReleasePlayerPoolSlot(Slot);
                                }
                                TWriteBuffer::TWriteBuffer
                                          ((TWriteBuffer *)&NextTry,Connection->InData + 2,0x7fe);
                    // try { // try from 080dd967 to 080dd9af has its CatchHandler @ 080dde17
                                TWriteBuffer::writeByte((TWriteBuffer *)&NextTry,'\v');
                                TWriteBuffer::writeWord((TWriteBuffer *)&NextTry,w);
                                TWriteBuffer::writeWord((TWriteBuffer *)&NextTry,w_00);
                                TWriteBuffer::writeQuad((TWriteBuffer *)&NextTry,Slot->CharacterID);
                                Connection->NextToSend = 0;
                                Connection->NextToCommit = 0;
                                Connection->InDataSize = WriteBuffer.Size;
                                Connection->NextToWrite = 0;
                                TConnection::Login(Connection);
                                bVar3 = GameRunning();
                                if (bVar3) {
                                    Connection->WaitingForACK = true;
                                    pVar7 = GetGameThreadPID();
                                    iVar5 = kill(pVar7,10);
                                    if (iVar5 != 0) {
                                        pVar7 = GetGameThreadPID();
                                        error("CallGameThread: Can\'t send SIGUSR1 to pid %d\n",
                                              pVar7);
                                        SendLoginMessage(Connection,0x14,
                                                                                                                  
                                                  "The server is not online.\nPlease try again later."
                                                  ,-1);
                                        return false;
                                    }
                                }
                                return true;
                            }
                            Log("queue",&DAT_0810c9e0,pcVar8,-iVar5);
                            DeleteWaitinglistEntry(pcVar8);
                        } while( true );
                    }
                    pcVar8 = "The game is just going down.\nPlease try again later.";
                }
            }
            else {
                pcVar8 = "The server is not online.\nPlease try again later.";
            }
        }
        else {
            pcVar8 = 
            "Your terminal version is too old.\nPlease get a new version at\nhttp://www.tibia.com.";
        }
        iVar5 = -1;
        Type = 0x14;
LAB_080dd78e:
        SendLoginMessage(Connection,Type,pcVar8,iVar5);
    }
    else {
        print();
    }
    return false;
}



// WARNING: Variable defined which should be unmapped: Help

bool ReceiveCommand(TConnection *Connection)

{
    uint uVar1;
    bool bVar2;
    int n;
    int iVar3;
    uchar *puVar4;
    EVP_PKEY_CTX *ctx;
    pid_t pVar5;
    ssize_t sVar6;
    int Offset;
    int Count;
    uchar *Size;
    uchar *out;
    size_t *in_stack_ffffffe0;
    uchar *in_stack_ffffffe4;
    size_t in_stack_ffffffe8;
    byte local_12;
    byte local_11;
    uchar Help [2];
    
    if (Connection == (TConnection *)0x0) {
        error("ReceiveCommand: Connection ist NULL.\n");
LAB_080de0d3:
        bVar2 = false;
    }
    else {
        do {
            do {
                while( true ) {
                    iVar3 = ReadFromSocket(Connection,&local_12,2);
                    if (iVar3 == 0) {
                        return false;
                    }
                    if (iVar3 < 0) {
                        return true;
                    }
                    if (iVar3 < 2) {
                        Semaphore::down(&CommunicationThreadMutex);
                        TotalRecv = TotalRecv + 0x31;
                        Semaphore::up(&CommunicationThreadMutex);
                        TConnection::GetSocket(Connection);
                        print();
                        goto LAB_080de003;
                    }
                    Size = (uchar *)((uint)local_11 * 0x100 + (uint)local_12);
                    Connection->InDataSize = (int)Size;
                    if (((uchar *)0x7fd < Size) || (Size == (uchar *)0x0)) {
                        TConnection::GetSocket(Connection);
                        print();
                        if (Size != (uchar *)0x0) {
                            do {
                                Size = Size + -0x800;
                                iVar3 = TConnection::GetSocket(Connection);
                                sVar6 = read(iVar3,Connection,0x800);
                                Semaphore::down(&CommunicationThreadMutex);
                                TotalRecv = TotalRecv + sVar6 + 0x30;
                                Semaphore::up(&CommunicationThreadMutex);
                            } while (0 < (int)Size);
                        }
                        goto LAB_080de003;
                    }
                    if (Connection->State == CONNECTION_CONNECTED) break;
                    out = Size;
                    puVar4 = (uchar *)ReadFromSocket(Connection,Connection->InData,(int)Size);
                    if ((int)puVar4 < 0) {
LAB_080de0b0:
                        SendLoginMessage(Connection,0x14,"Internal error, closing connection.",-1);
                        goto LAB_080de0d3;
                    }
                    Semaphore::down(&CommunicationThreadMutex);
                    TotalRecv = (int)puVar4 + TotalRecv + 0x30;
                    Semaphore::up(&CommunicationThreadMutex);
                    if (puVar4 == Size) {
                        if (((uint)Size & 7) == 0) {
                            iVar3 = 0;
                            if (Size != (uchar *)0x0) {
                                do {
                                    ctx = (EVP_PKEY_CTX *)(Connection->InData + iVar3);
                                    iVar3 = iVar3 + 8;
                                    TXTEASymmetricKey::decrypt
                                              (&Connection->SymmetricKey,ctx,out,in_stack_ffffffe0,
                                               in_stack_ffffffe4,in_stack_ffffffe8);
                                } while (iVar3 < (int)Size);
                            }
                            uVar1 = (uint)Connection->InData[1] * 0x100 +
                                    (uint)Connection->InData[0];
                            Connection->InDataSize = uVar1;
                            if ((uVar1 < 0x7fe) && (uVar1 != 0)) goto LAB_080ddfc8;
                            in_stack_ffffffe0 = (size_t *)TConnection::GetSocket(Connection);
                        }
                        else {
                            in_stack_ffffffe0 = (size_t *)TConnection::GetName(Connection);
                        }
                        print();
                    }
                }
                iVar3 = ReadFromSocket(Connection,Connection->InData + 2,(int)Size);
                if (iVar3 < 0) goto LAB_080de0b0;
                Semaphore::down(&CommunicationThreadMutex);
                TotalRecv = TotalRecv + iVar3 + 0x30;
                Semaphore::up(&CommunicationThreadMutex);
            } while (iVar3 != Connection->InDataSize);
LAB_080ddfc8:
            if (Connection->State == CONNECTION_CONNECTED) {
                alarm(0);
                bVar2 = HandleLogin(Connection);
            }
            else {
                bVar2 = GameRunning();
                if (bVar2) {
                    Connection->WaitingForACK = true;
                    pVar5 = GetGameThreadPID();
                    iVar3 = kill(pVar5,10);
                    if (iVar3 != 0) {
                        pVar5 = GetGameThreadPID();
                        error("CallGameThread: Can\'t send SIGUSR1 to pid %d\n",pVar5);
                        in_stack_ffffffe0 = (size_t *)0xffffffff;
                        SendLoginMessage(Connection,0x14,
                                         "The server is not online.\nPlease try again later.",-1);
                        bVar2 = false;
                        goto LAB_080ddfe6;
                    }
                }
                bVar2 = true;
            }
LAB_080ddfe6:
            if (bVar2 == false) {
                return false;
            }
        } while (Connection->WaitingForACK == false);
        Connection->SigIOPending = true;
LAB_080de003:
        bVar2 = true;
    }
    return bVar2;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void IncrementActiveConnections(void)

{
    Semaphore::down(&CommunicationThreadMutex);
    ActiveConnections = ActiveConnections + 1;
    Semaphore::up(&CommunicationThreadMutex);
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void DecrementActiveConnections(void)

{
    Semaphore::down(&CommunicationThreadMutex);
    ActiveConnections = ActiveConnections + -1;
    Semaphore::up(&CommunicationThreadMutex);
    return;
}



void CommunicationThread(int Socket)

{
    CONNECTIONSTATE CVar1;
    bool bVar2;
    TConnection *this;
    __pid_t _Var3;
    int iVar4;
    int *piVar5;
    TConnection *Connection;
    char *Text;
    int local_a0;
    int Signal;
    sigset_t SignalSet;
    
    this = AssignFreeConnection();
    if (this == (TConnection *)0x0) {
        print();
        iVar4 = close(Socket);
        if (-1 < iVar4) {
            return;
        }
        piVar5 = __errno_location();
        error(&DAT_0810cf20,*piVar5);
        return;
    }
    TConnection::Connect(this,Socket);
    this->WaitingForACK = false;
    _Var3 = getpid();
    iVar4 = fcntl(Socket,8,_Var3);
    if (iVar4 < 0) {
        error(&DAT_0810cea0,Socket);
        iVar4 = close(Socket);
        if (-1 < iVar4) goto LAB_080de426;
        piVar5 = __errno_location();
        iVar4 = *piVar5;
        Text = &DAT_0810cee0;
    }
    else {
        iVar4 = fcntl(Socket,4,0x2800);
        if (-1 < iVar4) {
            sigfillset((sigset_t *)&Signal);
            sigprocmask(2,(sigset_t *)&Signal,(sigset_t *)0x0);
            alarm(5);
            bVar2 = ReceiveCommand(this);
            if (!bVar2) {
                TConnection::Close(this,true);
            }
            this->SigIOPending = false;
switchD_080de377_caseD_0:
            bVar2 = GameRunning();
            if ((!bVar2) || (this->ConnectionIsOk == false)) goto LAB_080de403;
            sigwait((sigset_t *)&Signal,&local_a0);
            switch(local_a0) {
            default:
                goto switchD_080de377_caseD_0;
            case 1:
            case 0xd:
                break;
            case 10:
                if (this->SigIOPending != false) goto switchD_080de377_caseD_1d;
                goto switchD_080de377_caseD_0;
            case 0xc:
                bVar2 = SendData(this);
                if (bVar2) goto switchD_080de377_caseD_0;
                break;
            case 0xe:
                if (this->State != CONNECTION_CONNECTED) goto switchD_080de377_caseD_0;
                print();
                break;
            case 0x1d:
switchD_080de377_caseD_1d:
                if (this->WaitingForACK == false) {
                    this->SigIOPending = false;
                    bVar2 = ReceiveCommand(this);
                    if (!bVar2) {
                        bVar2 = true;
                        goto LAB_080de3ab;
                    }
                }
                else {
                    this->SigIOPending = true;
                }
                goto switchD_080de377_caseD_0;
            }
            bVar2 = false;
LAB_080de3ab:
            TConnection::Close(this,bVar2);
            goto switchD_080de377_caseD_0;
        }
        error(&DAT_0810ce20,Socket);
        iVar4 = close(Socket);
        if (-1 < iVar4) goto LAB_080de426;
        piVar5 = __errno_location();
        iVar4 = *piVar5;
        Text = &DAT_0810ce60;
    }
LAB_080de44b:
    error(Text,iVar4);
LAB_080de426:
    TConnection::Free(this);
    return;
LAB_080de403:
    CVar1 = this->State;
    while (CVar1 - CONNECTION_LOGIN < 4) {
        DelayThread(1,0);
        CVar1 = this->State;
    }
    if (this->ClosingIsDelayed != false) {
        DelayThread(2,0);
    }
    iVar4 = close(Socket);
    if (-1 < iVar4) goto LAB_080de426;
    piVar5 = __errno_location();
    iVar4 = *piVar5;
    Text = &DAT_0810cde0;
    goto LAB_080de44b;
}



int HandleConnection(void *Data)

{
    __pid_t _Var1;
    int Socket;
    int iVar2;
    void *pvVar3;
    
    pvVar3 = Data;
    if ((void *)0x7fffffff < Data) {
        pvVar3 = (void *)((int)Data + 0xffff);
    }
    iVar2 = (int)pvVar3 >> 0x10;
    if (UseOwnStacks) {
        _Var1 = getpid();
        LastUsingCommunicationThread[iVar2] = _Var1;
    }
                    // try { // try from 080de581 to 080de585 has its CatchHandler @ 080de5f0
    CommunicationThread((int)((int)Data + iVar2 * -0x10000));
    Semaphore::down(&CommunicationThreadMutex);
    ActiveConnections = ActiveConnections + -1;
    Semaphore::up(&CommunicationThreadMutex);
    if (UseOwnStacks != false) {
        Semaphore::down(&CommunicationThreadMutex);
        FreeCommunicationThreadStacks[NumberOfFreeCommunicationThreadStacks] = iVar2;
        NumberOfFreeCommunicationThreadStacks = NumberOfFreeCommunicationThreadStacks + 1;
        Semaphore::up(&CommunicationThreadMutex);
    }
    return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

bool OpenSocket(void)

{
    ushort __x;
    int iVar1;
    int *piVar2;
    char *pcVar3;
    undefined4 uVar4;
    undefined4 uVar5;
    undefined4 *__optval;
    undefined4 local_2c;
    linger l;
    undefined1 local_1c [4];
    sockaddr_in ServerAddress;
    
    print();
    getpid();
    __optval = (undefined4 *)GamePort;
    print();
    uVar5 = 0;
    uVar4 = 1;
    TCPSocket = socket(2,1,0);
    if (TCPSocket < 0) {
        pcVar3 = &DAT_0810d1c0;
    }
    else {
        local_2c = 0;
        __optval = &local_2c;
        l.l_onoff = 0;
        uVar5 = 0xd;
        uVar4 = 1;
        iVar1 = setsockopt(TCPSocket,1,0xd,__optval,8);
        if (-1 < iVar1) {
            local_1c._0_2_ = 0;
            local_1c[2] = '\0';
            local_1c[3] = '\0';
            ServerAddress.sin_family = 0;
            ServerAddress.sin_port = 0;
            ServerAddress.sin_addr.s_addr = 0;
            ServerAddress.sin_zero[0] = '\0';
            ServerAddress.sin_zero[1] = '\0';
            ServerAddress.sin_zero[2] = '\0';
            ServerAddress.sin_zero[3] = '\0';
            ServerAddress._0_4_ = inet_addr(GameAddress);
            local_1c._2_2_ = (ushort)GamePort >> 8 | (ushort)GamePort << 8;
            local_1c._0_2_ = 2;
            iVar1 = setsockopt(TCPSocket,1,2,(sockaddr *)local_1c,0x10);
            if (iVar1 == 0) {
                iVar1 = bind(TCPSocket,(sockaddr *)local_1c,0x10);
                if (iVar1 < 0) {
                    piVar2 = __errno_location();
                    error("LaunchServer: Fehler %d bei bind.\n",*piVar2);
                    print();
                    while (iVar1 = bind(TCPSocket,(sockaddr *)local_1c,0x10), iVar1 < 0) {
                        sleep(1);
                    }
                }
                piVar2 = __errno_location();
                *piVar2 = 0;
                iVar1 = listen(TCPSocket,0x200);
                if (-1 < iVar1) {
                    return true;
                }
                iVar1 = *piVar2;
                pcVar3 = "LaunchServer: Fehler %d bei listen.\n";
            }
            else {
                piVar2 = __errno_location();
                iVar1 = *piVar2;
                pcVar3 = "LaunchServer: Fehler %d bei setsockopt.\n";
            }
            error(pcVar3,iVar1);
            return false;
        }
        pcVar3 = "LaunchServer: Socket wurde nicht auf LINGER=0 gesetzt.\n";
    }
    error(pcVar3,uVar4,uVar5,__optval);
    return false;
}



// WARNING: Variable defined which should be unmapped: cli_addr

int AcceptorThreadLoop(void *param_1)

{
    bool bVar1;
    RESULT r;
    int *piVar2;
    void *Argument;
    Thread TVar3;
    int iVar4;
    int NewSocket;
    char *Text;
    int local_28;
    int StackNumber;
    void *Stack;
    socklen_t clilen;
    sockaddr_in cli_addr;
    
    AcceptorThreadPID = getpid();
    print();
LAB_080de8d6:
    do {
        while( true ) {
            bVar1 = GameRunning();
            if (!bVar1) {
                AcceptorThreadPID = 0;
                if (0 < ActiveConnections) {
                    print();
                    while (0 < ActiveConnections) {
                        sleep(1);
                    }
                }
                return 0;
            }
            Stack = (void *)0x10;
            piVar2 = __errno_location();
            *piVar2 = 0;
            Argument = (void *)accept(TCPSocket,(sockaddr *)&clilen,(socklen_t *)&Stack);
            if ((int)Argument < 0) goto LAB_080deb36;
            if (UseOwnStacks != false) break;
            if (ActiveConnections < 0x44c) {
                    // try { // try from 080de940 to 080deb3a has its CatchHandler @ 080deba5
                Semaphore::down(&CommunicationThreadMutex);
                ActiveConnections = ActiveConnections + 1;
                Semaphore::up(&CommunicationThreadMutex);
                TVar3 = StartThread(HandleConnection,Argument,0x10000,true);
                if (TVar3 == 0) {
                    print();
                    iVar4 = close((int)Argument);
                    if (iVar4 < 0) {
                        error(&DAT_0810d240,*piVar2);
                    }
                    Semaphore::down(&CommunicationThreadMutex);
                    ActiveConnections = ActiveConnections + -1;
LAB_080de9b1:
                    Semaphore::up(&CommunicationThreadMutex);
                }
            }
            else {
                print();
                iVar4 = close((int)Argument);
                if (iVar4 < 0) {
                    iVar4 = *piVar2;
                    Text = &DAT_0810d280;
                    goto LAB_080dea07;
                }
            }
        }
        GetCommunicationThreadStack(&local_28,(void **)&StackNumber);
        if (StackNumber != 0) {
            Semaphore::down(&CommunicationThreadMutex);
            ActiveConnections = ActiveConnections + 1;
            Semaphore::up(&CommunicationThreadMutex);
            TVar3 = StartThread(HandleConnection,(void *)(local_28 * 0x10000 + (int)Argument),
                                (void *)StackNumber,0x10000,true);
            if (TVar3 == 0) {
                print();
                iVar4 = close((int)Argument);
                if (iVar4 < 0) {
                    error(&DAT_0810d2c0,*piVar2);
                }
                Semaphore::down(&CommunicationThreadMutex);
                ActiveConnections = ActiveConnections + -1;
                Semaphore::up(&CommunicationThreadMutex);
                iVar4 = local_28;
                Semaphore::down(&CommunicationThreadMutex);
                FreeCommunicationThreadStacks[NumberOfFreeCommunicationThreadStacks] = iVar4;
                NumberOfFreeCommunicationThreadStacks = NumberOfFreeCommunicationThreadStacks + 1;
                goto LAB_080de9b1;
            }
            goto LAB_080de8d6;
        }
        print();
        iVar4 = close((int)Argument);
        if (iVar4 < 0) {
            iVar4 = *piVar2;
            Text = &DAT_0810d320;
            goto LAB_080dea07;
        }
    } while( true );
LAB_080deb36:
    bVar1 = GameRunning();
    if (bVar1) {
        iVar4 = *piVar2;
        Text = "AcceptorThreadLoop: Fehler %d beim Accept.\n";
LAB_080dea07:
        error(Text,iVar4);
    }
    goto LAB_080de8d6;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void CheckThreadlibVersion(void)

{
    bool bVar1;
    
    bVar1 = FileExists("/etc/image-release");
    UseOwnStacks = !bVar1;
    print();
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void InitCommunication(void)

{
    bool bVar1;
    int i;
    int iVar2;
    undefined4 *puVar3;
    char *ctx;
    
                    // try { // try from 080dec6d to 080ded9e has its CatchHandler @ 080dee0e
    bVar1 = FileExists("/etc/image-release");
    UseOwnStacks = !bVar1;
    if (UseOwnStacks) {
        ctx = "Verwende eigene Stacks.\n";
    }
    else {
        ctx = "Verwende verkleinerte Bibliotheks-Stacks.\n";
    }
    print();
    if (UseOwnStacks != false) {
        ctx = (char *)0xaa;
        memset(CommunicationThreadStacks,0xaa,0x44c0000);
        iVar2 = 0;
        do {
            LastUsingCommunicationThread[iVar2] = 0;
            FreeCommunicationThreadStacks[iVar2] = iVar2;
            iVar2 = iVar2 + 1;
        } while (iVar2 < 0x44c);
        NumberOfFreeCommunicationThreadStacks = 0x44c;
    }
    TQueryManagerConnectionPool::init(&QueryManagerConnectionPool,(EVP_PKEY_CTX *)ctx);
    ActiveConnections = 0;
    TCPSocket = -1;
    OpenSocket();
    if (TCPSocket == -1) {
        puVar3 = (undefined4 *)__cxa_allocate_exception(4);
        *puVar3 = "cannot open socket";
    }
    else {
        iVar2 = 0;
        do {
            LoadHistory[iVar2] = 0;
            iVar2 = iVar2 + 1;
        } while (iVar2 < 0x168);
        LoadHistoryPointer = 0;
        TotalSend = 0;
        TotalRecv = 0;
        TotalLoad = 0;
        LagEnd = 0;
        EarliestFreeAccountAdmissionRound = 0;
        InitLog("netload");
        WaitinglistHead = (TWaitinglistEntry *)0x0;
        TRSAPrivateKey::init
                  (&PrivateKey,
                   (EVP_PKEY_CTX *)
                   "12017580013707233233987537782574702577133548287527131234152948150506251412291888866940292054989907714155267326586216043845592229084368540020196135619327879"
                  );
        AcceptorThread = StartThread(AcceptorThreadLoop,(void *)0x0,false);
        if (AcceptorThread != 0) {
            return;
        }
        puVar3 = (undefined4 *)__cxa_allocate_exception(4);
        *puVar3 = "cannot start acceptor thread";
    }
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar3,char_const*::typeinfo,0);
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ExitCommunication(void)

{
    TConnection *Connection;
    TConnection *this;
    pid_t __pid;
    int iVar1;
    int *piVar2;
    char *__status;
    
    print();
    this = GetFirstConnection();
    while (this != (TConnection *)0x0) {
        __pid = TConnection::GetPID(this);
        kill(__pid,1);
        this = GetNextConnection();
    }
    ProcessConnections();
    __status = "Alle Verbindungen beendet.\n";
    print();
    if ((TCPSocket != -1) && (iVar1 = close(TCPSocket), iVar1 < 0)) {
        piVar2 = __errno_location();
        __status = (char *)*piVar2;
        error(&DAT_0810d500);
    }
    if (AcceptorThread != 0) {
        if (AcceptorThreadPID != 0) {
            __status = (char *)0x1;
            kill(AcceptorThreadPID,1);
        }
        JoinThread(AcceptorThread);
        AcceptorThread = 0;
    }
    TQueryManagerConnectionPool::exit(&QueryManagerConnectionPool,(int)__status);
    ExitCommunicationThreadStacks();
    return;
}



void __tcf_0(void *param_1)

{
    int in_stack_00000008;
    
    vlong::~vlong(&RSA_EXPONENT,in_stack_00000008);
    return;
}



void __tcf_1(void *param_1)

{
    int in_stack_00000008;
    
    Semaphore::~Semaphore(&CommunicationThreadMutex,in_stack_00000008);
    return;
}



void __tcf_2(void *param_1)

{
    int in_stack_00000008;
    
    TRSAPrivateKey::~TRSAPrivateKey(&PrivateKey,in_stack_00000008);
    return;
}



void __tcf_3(void *param_1)

{
    int in_stack_00000008;
    
    Semaphore::~Semaphore(&RSAMutex,in_stack_00000008);
    return;
}



void __tcf_4(void *param_1)

{
    int in_stack_00000008;
    int in_stack_fffffff8;
    
    Semaphore::~Semaphore(&QueryManagerConnectionPool.QueryManagerConnectionMutex,in_stack_fffffff8)
    ;
    Semaphore::~Semaphore(&QueryManagerConnectionPool.FreeQueryManagerConnections,in_stack_00000008)
    ;
    return;
}



void __tcf_5(void *param_1)

{
    listnode<> *plVar1;
    list<> *plVar2;
    listnode<> *plVar3;
    
    plVar2 = Waitinglist.Units;
    if (Waitinglist.Units != (list<> *)0x0) {
        plVar1 = (Waitinglist.Units)->firstNode;
        while (plVar1 != (listnode<> *)0x0) {
            plVar3 = plVar1->prev;
            if (plVar3 == (listnode<> *)0x0) {
                plVar2->firstNode = plVar1->next;
                plVar3 = plVar1->prev;
            }
            else {
                plVar3->next = plVar1->next;
            }
            if (plVar1->next == (listnode<> *)0x0) {
                plVar2->lastNode = plVar3;
            }
            else {
                plVar1->next->prev = plVar3;
            }
            operator_delete(plVar1);
            plVar1 = plVar2->firstNode;
        }
        operator_delete(plVar2);
        return;
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__I_TCPSocket(void)

{
    __static_initialization_and_destruction_0(1,0xffff);
    return;
}

void __static_initialization_and_destruction_0(int __initialize_p,int __priority)

{
    if ((__priority == 0xffff) && (__initialize_p == 1)) {
        NONE.ObjectID = 0;
        Semaphore::Semaphore(&OrderBufferEmpty,200);
        __cxa_atexit(__tcf_0,0,&__dso_handle);
        Semaphore::Semaphore(&OrderBufferFull,0);
        __cxa_atexit(__tcf_1,0,&__dso_handle);
        TDynamicWriteBuffer::TDynamicWriteBuffer(&HelpBuffer,0x10000);
        __cxa_atexit(__tcf_2,0,&__dso_handle);
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void InitReaderBuffers(void)

{
    ReplyPointerWrite = 0;
    OrderPointerWrite = 0;
    OrderPointerRead = 0;
    ReplyPointerRead = 0;
    return;
}



void InsertOrder(TReaderThreadOrderType OrderType,int SectorX,int SectorY,int SectorZ,
                ulong CharacterID)

{
    int iVar1;
    ulong CharacterID_local;
    int SectorZ_local;
    
    if (199 < OrderPointerWrite - OrderPointerRead) {
        error(&DAT_0810da40);
    }
    Semaphore::down(&OrderBufferEmpty);
    iVar1 = OrderPointerWrite % 200;
    OrderBuffer[iVar1].SectorY = SectorY;
    OrderPointerWrite = OrderPointerWrite + 1;
    OrderBuffer[iVar1].OrderType = OrderType;
    OrderBuffer[iVar1].SectorX = SectorX;
    OrderBuffer[iVar1].SectorZ = SectorZ;
    OrderBuffer[iVar1].CharacterID = CharacterID;
    Semaphore::up(&OrderBufferFull);
    return;
}



void GetOrder(TReaderThreadOrderType *OrderType,int *SectorX,int *SectorY,int *SectorZ,
             ulong *CharacterID)

{
    int iVar1;
    ulong *CharacterID_local;
    int *SectorZ_local;
    int *SectorY_local;
    
    Semaphore::down(&OrderBufferFull);
    iVar1 = OrderPointerRead % 200;
    *OrderType = OrderBuffer[iVar1].OrderType;
    *SectorX = OrderBuffer[iVar1].SectorX;
    *SectorY = OrderBuffer[OrderPointerRead % 200].SectorY;
    *SectorZ = OrderBuffer[OrderPointerRead % 200].SectorZ;
    iVar1 = OrderPointerRead % 200;
    OrderPointerRead = OrderPointerRead + 1;
    *CharacterID = OrderBuffer[iVar1].CharacterID;
    Semaphore::up(&OrderBufferEmpty);
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void InsertReply(void)

{
    int iVar1;
    TReaderThreadReplyType in_stack_00000004;
    int in_stack_00000008;
    int in_stack_0000000c;
    int in_stack_00000010;
    uchar *in_stack_00000014;
    int in_stack_00000018;
    
    iVar1 = ReplyPointerWrite - ReplyPointerRead;
    while (199 < iVar1) {
        error("InsertReply (Reader): Puffer ist voll; warte...\n");
        DelayThread(5,0);
        iVar1 = ReplyPointerWrite - ReplyPointerRead;
    }
    iVar1 = ReplyPointerWrite % 200;
    ReplyPointerWrite = ReplyPointerWrite + 1;
    ReplyBuffer[iVar1].ReplyType = in_stack_00000004;
    ReplyBuffer[iVar1].SectorX = in_stack_00000008;
    ReplyBuffer[iVar1].SectorY = in_stack_0000000c;
    ReplyBuffer[iVar1].SectorZ = in_stack_00000010;
    ReplyBuffer[iVar1].Data = in_stack_00000014;
    ReplyBuffer[iVar1].Size = in_stack_00000018;
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

bool GetReply(void)

{
    int iVar1;
    bool bVar2;
    TReaderThreadReplyType *in_stack_00000004;
    int *in_stack_00000008;
    int *in_stack_0000000c;
    int *in_stack_00000010;
    undefined4 *in_stack_00000014;
    int *in_stack_00000018;
    
    bVar2 = ReplyPointerRead != ReplyPointerWrite;
    if (bVar2) {
        iVar1 = ReplyPointerRead % 200;
        *in_stack_00000004 = ReplyBuffer[iVar1].ReplyType;
        *in_stack_00000008 = ReplyBuffer[iVar1].SectorX;
        *in_stack_0000000c = ReplyBuffer[ReplyPointerRead % 200].SectorY;
        *in_stack_00000010 = ReplyBuffer[ReplyPointerRead % 200].SectorZ;
        iVar1 = ReplyPointerRead % 200;
        *in_stack_00000014 = ReplyBuffer[iVar1].Data;
        *in_stack_00000018 = ReplyBuffer[iVar1].Size;
        ReplyPointerRead = ReplyPointerRead + 1;
    }
    return bVar2;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void TerminateReaderOrder(void)

{
    int iVar1;
    
    if (199 < OrderPointerWrite - OrderPointerRead) {
        error(&DAT_0810da40);
    }
    Semaphore::down(&OrderBufferEmpty);
    iVar1 = OrderPointerWrite % 200;
    OrderBuffer[iVar1].SectorX = 0;
    OrderPointerWrite = OrderPointerWrite + 1;
    OrderBuffer[iVar1].OrderType = ORDER_TERMINATE;
    OrderBuffer[iVar1].SectorY = 0;
    OrderBuffer[iVar1].SectorZ = 0;
    OrderBuffer[iVar1].CharacterID = 0;
    Semaphore::up(&OrderBufferFull);
    return;
}



void LoadSectorOrder(int SectorX,int SectorY,int SectorZ)

{
    int iVar1;
    
    if (199 < OrderPointerWrite - OrderPointerRead) {
        error(&DAT_0810da40);
    }
    Semaphore::down(&OrderBufferEmpty);
    iVar1 = OrderPointerWrite % 200;
    OrderBuffer[iVar1].SectorX = SectorX;
    OrderPointerWrite = OrderPointerWrite + 1;
    OrderBuffer[iVar1].OrderType = ORDER_LOADSECTOR;
    OrderBuffer[iVar1].SectorY = SectorY;
    OrderBuffer[iVar1].SectorZ = SectorZ;
    OrderBuffer[iVar1].CharacterID = 0;
    Semaphore::up(&OrderBufferFull);
    return;
}



void LoadCharacterOrder(ulong CharacterID)

{
    int iVar1;
    
    if (199 < OrderPointerWrite - OrderPointerRead) {
        error(&DAT_0810da40);
    }
    Semaphore::down(&OrderBufferEmpty);
    iVar1 = OrderPointerWrite % 200;
    OrderPointerWrite = OrderPointerWrite + 1;
    OrderBuffer[iVar1].OrderType = ORDER_LOADCHARACTER;
    OrderBuffer[iVar1].SectorX = 0;
    OrderBuffer[iVar1].SectorY = 0;
    OrderBuffer[iVar1].CharacterID = CharacterID;
    OrderBuffer[iVar1].SectorZ = 0;
    Semaphore::up(&OrderBufferFull);
    return;
}



void ProcessLoadSectorOrder(int SectorX,int SectorY,int SectorZ)

{
    byte b;
    bool bVar1;
    char cVar2;
    uchar *Help;
    byte *pbVar3;
    uchar *__dest;
    int iVar4;
    int iVar5;
    int DataSize;
    char *pcVar6;
    undefined1 uVar7;
    TDynamicWriteBuffer *__s;
    char *pcVar8;
    uchar *Data;
    bool Refreshable;
    int yy;
    int xx;
    TReadScriptFile Script;
    undefined1 local_101c [4];
    char FileName [4096];
    
    __s = (TDynamicWriteBuffer *)local_101c;
    pcVar8 = ORIGMAPPATH;
    sprintf((char *)__s,"%s/%04u-%04u-%02u.sec",ORIGMAPPATH,SectorX,SectorY,SectorZ);
    bVar1 = FileExists((char *)__s);
    if (bVar1) {
                    // try { // try from 080df909 to 080df90d has its CatchHandler @ 080dfbf7
        TReadScriptFile::TReadScriptFile((TReadScriptFile *)&xx);
                    // try { // try from 080df915 to 080dfb32 has its CatchHandler @ 080dfbc0
        TReadScriptFile::open((TReadScriptFile *)&xx,(char *)__s,(int)pcVar8);
        Data._3_1_ = 0;
        yy = -1;
        b = 0xff;
        HelpBuffer.super_TWriteBuffer.Position = 0;
        while (TReadScriptFile::nextToken((TReadScriptFile *)&xx), xx != 0) {
            if ((xx != 6) ||
               (cVar2 = TReadScriptFile::getSpecial((TReadScriptFile *)&xx), cVar2 != ',')) {
                if (xx == 4) {
                    pbVar3 = TReadScriptFile::getBytesequence((TReadScriptFile *)&xx);
                    yy = (int)*pbVar3;
                    b = pbVar3[1];
                    __s = (TDynamicWriteBuffer *)0x3a;
                    TReadScriptFile::readSymbol((TReadScriptFile *)&xx,':');
                    Data._3_1_ = 0;
                }
                else if (xx == 1) {
                    uVar7 = yy == -1;
                    if ((bool)uVar7) {
                        pcVar8 = "coordinate expected";
                        TReadScriptFile::error((TReadScriptFile *)&xx,"coordinate expected");
                        __s = (TDynamicWriteBuffer *)pcVar8;
                    }
                    pcVar8 = TReadScriptFile::getIdentifier((TReadScriptFile *)&xx);
                    iVar4 = 8;
                    pcVar6 = "refresh";
                    do {
                        if (iVar4 == 0) break;
                        iVar4 = iVar4 + -1;
                        uVar7 = *pcVar8 == *pcVar6;
                        pcVar8 = pcVar8 + 1;
                        pcVar6 = pcVar6 + 1;
                    } while ((bool)uVar7);
                    if ((bool)uVar7) {
                        Data._3_1_ = 1;
                    }
                    pcVar8 = TReadScriptFile::getIdentifier((TReadScriptFile *)&xx);
                    iVar4 = 8;
                    pcVar6 = "content";
                    do {
                        if (iVar4 == 0) break;
                        iVar4 = iVar4 + -1;
                        uVar7 = *pcVar8 == *pcVar6;
                        pcVar8 = pcVar8 + 1;
                        pcVar6 = pcVar6 + 1;
                    } while ((bool)uVar7);
                    if ((bool)uVar7) {
                        TReadScriptFile::readSymbol((TReadScriptFile *)&xx,'=');
                        if (Data._3_1_ != 0) {
                            TDynamicWriteBuffer::writeByte(&HelpBuffer,(uchar)yy);
                            TDynamicWriteBuffer::writeByte(&HelpBuffer,b);
                        }
                        __s = &HelpBuffer;
                        LoadObjects((TReadScriptFile *)&xx,(TWriteStream *)&HelpBuffer,
                                    (bool)(Data._3_1_ ^ 1));
                    }
                }
            }
        }
        TReadScriptFile::close((TReadScriptFile *)&xx,(int)__s);
        iVar4 = HelpBuffer.super_TWriteBuffer.Position;
        if (HelpBuffer.super_TWriteBuffer.Position != 0) {
            __dest = (uchar *)operator_new__(HelpBuffer.super_TWriteBuffer.Position);
            __s = (TDynamicWriteBuffer *)HelpBuffer.super_TWriteBuffer.Data;
            memcpy(__dest,HelpBuffer.super_TWriteBuffer.Data,iVar4);
            iVar5 = ReplyPointerWrite - ReplyPointerRead;
            while (199 < iVar5) {
                error("InsertReply (Reader): Puffer ist voll; warte...\n");
                __s = (TDynamicWriteBuffer *)0x0;
                DelayThread(5,0);
                iVar5 = ReplyPointerWrite - ReplyPointerRead;
            }
            iVar5 = ReplyPointerWrite % 200;
            ReplyBuffer[iVar5].ReplyType = REPLY_SECTORDATA;
            ReplyPointerWrite = ReplyPointerWrite + 1;
            ReplyBuffer[iVar5].SectorX = SectorX;
            ReplyBuffer[iVar5].SectorY = SectorY;
            ReplyBuffer[iVar5].SectorZ = SectorZ;
            ReplyBuffer[iVar5].Data = __dest;
            ReplyBuffer[iVar5].Size = iVar4;
        }
                    // try { // try from 080dfbb6 to 080dfbba has its CatchHandler @ 080dfbf7
        TReadScriptFile::~TReadScriptFile((TReadScriptFile *)&xx,(int)__s);
    }
    return;
}



void ProcessLoadCharacterOrder(ulong CharacterID)

{
    TPlayerData *Slot;
    __pid_t _Var1;
    pid_t pVar2;
    TPlayerData *PlayerData;
    int iVar3;
    
    while( true ) {
        Slot = AssignPlayerPoolSlot(CharacterID,true);
        if (Slot == (TPlayerData *)0x0) {
            error(&DAT_0810db00);
            return;
        }
        _Var1 = getpid();
        if (Slot->Locked == _Var1) break;
        pVar2 = GetGameThreadPID();
        if (Slot->Locked == pVar2) {
            return;
        }
        DecreasePlayerPoolSlotSticky(Slot);
        DelayThread(1,0);
    }
    IncreasePlayerPoolSlotSticky(Slot);
    ReleasePlayerPoolSlot(Slot);
    iVar3 = ReplyPointerWrite - ReplyPointerRead;
    while (199 < iVar3) {
        error("InsertReply (Reader): Puffer ist voll; warte...\n");
        DelayThread(5,0);
        iVar3 = ReplyPointerWrite - ReplyPointerRead;
    }
    iVar3 = ReplyPointerWrite % 200;
    ReplyBuffer[iVar3].ReplyType = REPLY_CHARACTERDATA;
    ReplyBuffer[iVar3].SectorX = 0;
    ReplyBuffer[iVar3].SectorY = 0;
    ReplyBuffer[iVar3].SectorZ = 0;
    ReplyBuffer[iVar3].Data = (uchar *)0x0;
    ReplyBuffer[iVar3].Size = CharacterID;
    ReplyPointerWrite = ReplyPointerWrite + 1;
    return;
}



int ReaderThreadLoop(void *param_1)

{
    int SectorX;
    TReaderThreadOrderType TVar1;
    int SectorY;
    int SectorZ;
    ulong CharacterID;
    int iVar2;
    
LAB_080dfd60:
    do {
        while( true ) {
            Semaphore::down(&OrderBufferFull);
            iVar2 = OrderPointerRead % 200;
            SectorX = OrderBuffer[iVar2].SectorX;
            TVar1 = OrderBuffer[iVar2].OrderType;
            OrderPointerRead = OrderPointerRead + 1;
            SectorY = OrderBuffer[iVar2].SectorY;
            SectorZ = OrderBuffer[iVar2].SectorZ;
            CharacterID = OrderBuffer[iVar2].CharacterID;
            Semaphore::up(&OrderBufferEmpty);
            if (TVar1 != ORDER_LOADSECTOR) break;
            ProcessLoadSectorOrder(SectorX,SectorY,SectorZ);
        }
        if ((int)TVar1 < 2) {
            if (TVar1 == ORDER_TERMINATE) {
                return 0;
            }
        }
        else if (TVar1 == ORDER_LOADCHARACTER) {
            ProcessLoadCharacterOrder(CharacterID);
            goto LAB_080dfd60;
        }
        error("ReaderThreadLoop: Unbekanntes Kommando %d.\n",TVar1);
    } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ProcessSectorReply(void)

{
    code *in_stack_00000004;
    void *in_stack_00000014;
    
    (*in_stack_00000004)();
    if (in_stack_00000014 != (void *)0x0) {
        operator_delete__(in_stack_00000014);
        return;
    }
    return;
}



void ProcessCharacterReply(TSendMailsFunction *SendMails,ulong CharacterID)

{
    TPlayerData *Slot;
    TPlayerData *PlayerData;
    
    Slot = AttachPlayerPoolSlot(CharacterID,true);
    if (Slot != (TPlayerData *)0x0) {
        (*SendMails)(Slot);
        DecreasePlayerPoolSlotSticky(Slot);
        ReleasePlayerPoolSlot(Slot);
        return;
    }
    DecreasePlayerPoolSlotSticky(CharacterID);
    return;
}



// WARNING: Variable defined which should be unmapped: SectorX

void ProcessReaderThreadReplies(TRefreshSectorFunction *RefreshSector,TSendMailsFunction *SendMails)

{
    TReaderThreadReplyType TVar1;
    ulong CharacterID;
    uchar *puVar2;
    TPlayerData *Slot;
    uchar *Data;
    int Size;
    int iVar3;
    TReaderThreadReplyType ReplyType;
    TPlayerData *PlayerData;
    int SectorZ;
    int SectorY;
    int SectorX;
    
    while (ReplyPointerRead != ReplyPointerWrite) {
        iVar3 = ReplyPointerRead % 200;
        ReplyPointerRead = ReplyPointerRead + 1;
        TVar1 = ReplyBuffer[iVar3].ReplyType;
        CharacterID = ReplyBuffer[iVar3].Size;
        puVar2 = ReplyBuffer[iVar3].Data;
        if (TVar1 == REPLY_SECTORDATA) {
            (*RefreshSector)(ReplyBuffer[iVar3].SectorX,ReplyBuffer[iVar3].SectorY,
                             ReplyBuffer[iVar3].SectorZ,puVar2,CharacterID);
            if (puVar2 != (uchar *)0x0) {
                operator_delete__(puVar2);
            }
        }
        else if (TVar1 == REPLY_CHARACTERDATA) {
            Slot = AttachPlayerPoolSlot(CharacterID,true);
            if (Slot == (TPlayerData *)0x0) {
                DecreasePlayerPoolSlotSticky(CharacterID);
            }
            else {
                (*SendMails)(Slot);
                DecreasePlayerPoolSlotSticky(Slot);
                ReleasePlayerPoolSlot(Slot);
            }
        }
        else {
            error(&DAT_0810dba0,TVar1);
        }
    }
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void InitReader(void)

{
    undefined4 *puVar1;
    
    ReplyPointerRead = 0;
    OrderPointerWrite = 0;
    OrderPointerRead = 0;
    ReplyPointerWrite = 0;
                    // try { // try from 080e006c to 080e00a7 has its CatchHandler @ 080e00a8
    ReaderThread = StartThread(ReaderThreadLoop,(void *)0x0,false);
    if (ReaderThread != 0) {
        return;
    }
    puVar1 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar1 = "cannot start reader thread";
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar1,char_const*::typeinfo,0);
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void ExitReader(void)

{
    int iVar1;
    
    if (ReaderThread != 0) {
        if (199 < OrderPointerWrite - OrderPointerRead) {
            error(&DAT_0810da40);
        }
        Semaphore::down(&OrderBufferEmpty);
        iVar1 = OrderPointerWrite % 200;
        OrderBuffer[iVar1].OrderType = ORDER_TERMINATE;
        OrderBuffer[iVar1].SectorX = 0;
        OrderPointerWrite = OrderPointerWrite + 1;
        OrderBuffer[iVar1].SectorY = 0;
        OrderBuffer[iVar1].SectorZ = 0;
        OrderBuffer[iVar1].CharacterID = 0;
        Semaphore::up(&OrderBufferFull);
        JoinThread(ReaderThread);
        ReaderThread = 0;
    }
    return;
}



void __tcf_0(void *param_1)

{
    int in_stack_00000008;
    
    Semaphore::~Semaphore(&OrderBufferEmpty,in_stack_00000008);
    return;
}



void __tcf_1(void *param_1)

{
    int in_stack_00000008;
    
    Semaphore::~Semaphore(&OrderBufferFull,in_stack_00000008);
    return;
}



void __tcf_2(void *param_1)

{
    int in_stack_00000008;
    
    TDynamicWriteBuffer::~TDynamicWriteBuffer(&HelpBuffer,in_stack_00000008);
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__I__Z17InitReaderBuffersv(void)

{
    __static_initialization_and_destruction_0(1,0xffff);
    return;
}



void __static_initialization_and_destruction_0(int __initialize_p,int __priority)

{
    if ((__priority == 0xffff) && (__initialize_p == 1)) {
        NONE.ObjectID = 0;
    }
    return;
}



void SetQueryManagerLoginData(int Type,char *Data)

{
    ApplicationType = Type;
    if (Data == (char *)0x0) {
        LoginData[0] = '\0';
    }
    else {
        strncpy(LoginData,Data,0x1e);
    }
    return;
}



// DWARF original prototype: void TQueryManagerConnection(TQueryManagerConnection * this, int
// QueryBufferSize)

void __thiscall
TQueryManagerConnection::TQueryManagerConnection(TQueryManagerConnection *this,int QueryBufferSize)

{
    uint uVar1;
    uchar *puVar2;
    uint *puVar3;
    sockaddr *__addr;
    socklen_t in_stack_ffffffe0;
    uint local_1c [4];
    
    local_1c[3] = 0x4000;
    puVar3 = local_1c + 3;
    if (0x3fff < QueryBufferSize) {
        puVar3 = (uint *)&QueryBufferSize;
    }
    puVar2 = (uchar *)operator_new__(*puVar3);
    this->Buffer = puVar2;
    local_1c[2] = 0x4000;
    puVar3 = local_1c + 2;
    if (0x3fff < QueryBufferSize) {
        puVar3 = (uint *)&QueryBufferSize;
    }
    TReadBuffer::TReadBuffer(&this->ReadBuffer,this->Buffer,*puVar3);
    local_1c[1] = 0x4000;
    puVar3 = local_1c + 1;
    if (0x3fff < QueryBufferSize) {
        puVar3 = (uint *)&QueryBufferSize;
    }
    __addr = (sockaddr *)*puVar3;
    puVar2 = this->Buffer;
    TWriteBuffer::TWriteBuffer(&this->WriteBuffer,puVar2,(int)__addr);
    local_1c[0] = 0x4000;
    puVar3 = local_1c;
    if (0x3fff < QueryBufferSize) {
        puVar3 = (uint *)&QueryBufferSize;
    }
    uVar1 = *puVar3;
    this->Socket = -1;
    this->QueryOk = false;
    this->BufferSize = uVar1;
    connect(this,(int)puVar2,__addr,in_stack_ffffffe0);
    return;
}



// DWARF original prototype: void TQueryManagerConnection(TQueryManagerConnection * this, int
// QueryBufferSize)

void __thiscall
TQueryManagerConnection::TQueryManagerConnection(TQueryManagerConnection *this,int QueryBufferSize)

{
    uint uVar1;
    uchar *puVar2;
    uint *puVar3;
    sockaddr *__addr;
    socklen_t in_stack_ffffffe0;
    uint local_1c [4];
    
    local_1c[3] = 0x4000;
    puVar3 = local_1c + 3;
    if (0x3fff < QueryBufferSize) {
        puVar3 = (uint *)&QueryBufferSize;
    }
    puVar2 = (uchar *)operator_new__(*puVar3);
    this->Buffer = puVar2;
    local_1c[2] = 0x4000;
    puVar3 = local_1c + 2;
    if (0x3fff < QueryBufferSize) {
        puVar3 = (uint *)&QueryBufferSize;
    }
    TReadBuffer::TReadBuffer(&this->ReadBuffer,this->Buffer,*puVar3);
    local_1c[1] = 0x4000;
    puVar3 = local_1c + 1;
    if (0x3fff < QueryBufferSize) {
        puVar3 = (uint *)&QueryBufferSize;
    }
    __addr = (sockaddr *)*puVar3;
    puVar2 = this->Buffer;
    TWriteBuffer::TWriteBuffer(&this->WriteBuffer,puVar2,(int)__addr);
    local_1c[0] = 0x4000;
    puVar3 = local_1c;
    if (0x3fff < QueryBufferSize) {
        puVar3 = (uint *)&QueryBufferSize;
    }
    uVar1 = *puVar3;
    this->Socket = -1;
    this->QueryOk = false;
    this->BufferSize = uVar1;
    connect(this,(int)puVar2,__addr,in_stack_ffffffe0);
    return;
}



// DWARF original prototype: void ~TQueryManagerConnection(TQueryManagerConnection * this, int
// __in_chrg)

void __thiscall
TQueryManagerConnection::~TQueryManagerConnection(TQueryManagerConnection *this,int __in_chrg)

{
    int iVar1;
    int *piVar2;
    
    if (-1 < this->Socket) {
        iVar1 = close(this->Socket);
        if (iVar1 < 0) {
            piVar2 = __errno_location();
            error(&DAT_0810dc00,*piVar2);
        }
        this->Socket = -1;
    }
    if (this->Buffer == (uchar *)0x0) {
        return;
    }
    operator_delete__(this->Buffer);
    return;
}



// DWARF original prototype: void ~TQueryManagerConnection(TQueryManagerConnection * this, int
// __in_chrg)

void __thiscall
TQueryManagerConnection::~TQueryManagerConnection(TQueryManagerConnection *this,int __in_chrg)

{
    int iVar1;
    int *piVar2;
    
    if (-1 < this->Socket) {
        iVar1 = close(this->Socket);
        if (iVar1 < 0) {
            piVar2 = __errno_location();
            error(&DAT_0810dc00,*piVar2);
        }
        this->Socket = -1;
    }
    if (this->Buffer == (uchar *)0x0) {
        return;
    }
    operator_delete__(this->Buffer);
    return;
}



// DWARF original prototype: void connect(TQueryManagerConnection * this)

int __thiscall
TQueryManagerConnection::connect
          (TQueryManagerConnection *this,int __fd,sockaddr *__addr,socklen_t __len)

{
    ushort uVar1;
    int Result;
    int iVar2;
    int *piVar3;
    char *__cp;
    TWriteBuffer *this_00;
    int Try;
    int iVar4;
    int iVar5;
    hostent *local_858;
    hostent *HostEntAddr;
    int ErrorCode;
    char local_84c [4];
    char Buffer [2048];
    hostent HostEnt;
    undefined1 local_2c [4];
    sockaddr_in QueryManagerAddress;
    
    iVar4 = 0;
    if (0 < NumberOfQueryManagers) {
        do {
            local_2c._0_2_ = 0;
            local_2c[2] = '\0';
            local_2c[3] = '\0';
            QueryManagerAddress.sin_family = 0;
            QueryManagerAddress.sin_port = 0;
            QueryManagerAddress.sin_addr.s_addr = 0;
            QueryManagerAddress.sin_zero[0] = '\0';
            QueryManagerAddress.sin_zero[1] = '\0';
            QueryManagerAddress.sin_zero[2] = '\0';
            QueryManagerAddress.sin_zero[3] = '\0';
            QueryManagerAddress._0_4_ = inet_addr(QUERY_MANAGER[iVar4].Host);
            if (QueryManagerAddress._0_4_ == 0xffffffff) {
                HostEntAddr = (hostent *)0x0;
                iVar2 = gethostbyname_r(QUERY_MANAGER[iVar4].Host,(hostent *)(Buffer + 0x7fc),
                                        local_84c,0x800,&local_858,(int *)&HostEntAddr);
                if ((iVar2 == 0) && (local_858 != (hostent *)0x0)) {
                    __cp = inet_ntoa((in_addr)*(in_addr_t *)*local_858->h_addr_list);
                    QueryManagerAddress._0_4_ = inet_addr(__cp);
                    goto LAB_080e0505;
                }
LAB_080e06c8:
                print();
            }
            else {
LAB_080e0505:
                iVar2 = socket(2,1,0);
                this->Socket = iVar2;
                if (iVar2 < 0) goto LAB_080e06c8;
                uVar1 = (ushort)QUERY_MANAGER[iVar4].Port;
                iVar5 = 0x10;
                ErrorCode._2_2_ = uVar1 >> 8 | uVar1 << 8;
                local_2c._2_2_ = ErrorCode._2_2_;
                local_2c._0_2_ = 2;
                iVar2 = ::connect(this->Socket,(sockaddr *)local_2c,0x10);
                if (iVar2 < 0) {
                    print();
                }
                else {
                    this_00 = &this->WriteBuffer;
                    this->QueryOk = true;
                    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e0595 to 080e05a9 has its CatchHandler @ 080e0754
                    TWriteBuffer::writeWord(this_00,0);
                    TWriteBuffer::writeByte(this_00,'\0');
                    // try { // try from 080e05b8 to 080e05bc has its CatchHandler @ 080e0791
                    TWriteBuffer::writeByte(this_00,(uchar)ApplicationType);
                    // try { // try from 080e05d1 to 080e05d5 has its CatchHandler @ 080e07c1
                    TWriteStream::writeString
                              (&this_00->super_TWriteStream,QUERY_MANAGER[iVar4].Password);
                    if (ApplicationType == 1) {
                    // try { // try from 080e069d to 080e06a1 has its CatchHandler @ 080e07f1
                        TWriteStream::writeString(&this_00->super_TWriteStream,LoginData);
                    }
                    iVar5 = executeQuery(this,0x1e,false);
                    if (iVar5 == 0) {
                        return 0;
                    }
                    print();
                }
                if (-1 < this->Socket) {
                    iVar2 = close(this->Socket);
                    if (iVar2 < 0) {
                        piVar3 = __errno_location();
                        error(&DAT_0810dc00,*piVar3,iVar5);
                    }
                    this->Socket = -1;
                }
            }
            iVar4 = iVar4 + 1;
        } while (iVar4 < NumberOfQueryManagers);
    }
    print();
    this->Socket = -1;
    return (int)this;
}



// DWARF original prototype: void disconnect(TQueryManagerConnection * this)

void __thiscall TQueryManagerConnection::disconnect(TQueryManagerConnection *this)

{
    int iVar1;
    int *piVar2;
    
    if (-1 < this->Socket) {
        iVar1 = close(this->Socket);
        if (iVar1 < 0) {
            piVar2 = __errno_location();
            error(&DAT_0810dc00,*piVar2);
        }
        this->Socket = -1;
    }
    return;
}



// WARNING: Variable defined which should be unmapped: Chances
// DWARF original prototype: int write(TQueryManagerConnection * this, uchar * Buffer, int Size)

ssize_t __thiscall
TQueryManagerConnection::write(TQueryManagerConnection *this,int __fd,void *__buf,size_t __n)

{
    ssize_t sVar1;
    int *piVar2;
    int nwritten;
    int nleft;
    void *__n_00;
    int local_14;
    int Chances;
    
    local_14 = 0x32;
    __n_00 = __buf;
    if (0 < (int)__buf) {
        do {
            sVar1 = ::write(this->Socket,(void *)__fd,(size_t)__n_00);
            if (((sVar1 == -1) && (piVar2 = __errno_location(), *piVar2 == 0xb)) && (0 < local_14))
            {
                DelayThread(0,100000);
                local_14 = local_14 + -1;
            }
            else {
                if (sVar1 < 1) {
                    return sVar1;
                }
                __n_00 = (void *)((int)__n_00 - sVar1);
                __fd = __fd + sVar1;
            }
        } while (0 < (int)__n_00);
    }
    return (int)__buf - (int)__n_00;
}



// DWARF original prototype: int read(TQueryManagerConnection * this, uchar * Buffer, int Size, int
// Timeout)

ssize_t __thiscall
TQueryManagerConnection::read(TQueryManagerConnection *this,int __fd,void *__buf,size_t __nbytes)

{
    int iVar1;
    ssize_t sVar2;
    int *piVar3;
    int nread;
    int nleft;
    void *__nbytes_00;
    int local_20;
    int Chances;
    pollfd ufds;
    
    local_20 = 0x32;
    __nbytes_00 = __buf;
    if (0 < (int)__buf) {
        do {
            Chances = this->Socket;
            ufds.fd._0_2_ = 1;
            ufds.fd._2_2_ = 0;
            iVar1 = poll((pollfd *)&Chances,1,__nbytes * 1000);
            if (iVar1 < 1) {
                return -2;
            }
            sVar2 = ::read(this->Socket,(void *)__fd,(size_t)__nbytes_00);
            if (sVar2 == 0) break;
            if (sVar2 < 0) {
                piVar3 = __errno_location();
                if (*piVar3 != 4) {
                    if (*piVar3 != 0xb) {
                        return sVar2;
                    }
                    if (__nbytes_00 == __buf) {
                        return sVar2;
                    }
                    if (local_20 == 0) {
                        return sVar2;
                    }
                    local_20 = local_20 + -1;
                    DelayThread(0,100000);
                }
            }
            else {
                __nbytes_00 = (void *)((int)__nbytes_00 - sVar2);
                __fd = __fd + sVar2;
            }
        } while (0 < (int)__nbytes_00);
    }
    return (int)__buf - (int)__nbytes_00;
}



// DWARF original prototype: void prepareQuery(TQueryManagerConnection * this, int QueryType)

void __thiscall TQueryManagerConnection::prepareQuery(TQueryManagerConnection *this,int QueryType)

{
    this->QueryOk = true;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e0a08 to 080e0a1c has its CatchHandler @ 080e0a27
    TWriteBuffer::writeWord(&this->WriteBuffer,0);
    TWriteBuffer::writeByte(&this->WriteBuffer,(uchar)QueryType);
    return;
}



// DWARF original prototype: void sendFlag(TQueryManagerConnection * this, bool f)

void __thiscall TQueryManagerConnection::sendFlag(TQueryManagerConnection *this,bool f)

{
    TWriteBuffer::writeByte(&this->WriteBuffer,f);
    return;
}



// DWARF original prototype: void sendByte(TQueryManagerConnection * this, uchar b)

void __thiscall TQueryManagerConnection::sendByte(TQueryManagerConnection *this,uchar b)

{
                    // try { // try from 080e0a9d to 080e0aa1 has its CatchHandler @ 080e0ab0
    TWriteBuffer::writeByte(&this->WriteBuffer,b);
    return;
}



// DWARF original prototype: void sendWord(TQueryManagerConnection * this, ushort w)

void __thiscall TQueryManagerConnection::sendWord(TQueryManagerConnection *this,ushort w)

{
                    // try { // try from 080e0b0d to 080e0b11 has its CatchHandler @ 080e0b20
    TWriteBuffer::writeWord(&this->WriteBuffer,w);
    return;
}



// DWARF original prototype: void sendQuad(TQueryManagerConnection * this, ulong q)

void __thiscall TQueryManagerConnection::sendQuad(TQueryManagerConnection *this,ulong q)

{
                    // try { // try from 080e0b7c to 080e0b80 has its CatchHandler @ 080e0b90
    TWriteBuffer::writeQuad(&this->WriteBuffer,q);
    return;
}



// DWARF original prototype: void sendString(TQueryManagerConnection * this, char * s)

void __thiscall TQueryManagerConnection::sendString(TQueryManagerConnection *this,char *s)

{
                    // try { // try from 080e0bec to 080e0bf0 has its CatchHandler @ 080e0c00
    TWriteStream::writeString(&(this->WriteBuffer).super_TWriteStream,s);
    return;
}



// DWARF original prototype: void sendBytes(TQueryManagerConnection * this, uchar * Buffer, int
// Count)

void __thiscall TQueryManagerConnection::sendBytes(TQueryManagerConnection *this)

{
    uchar *in_stack_00000008;
    int in_stack_0000000c;
    
                    // try { // try from 080e0c63 to 080e0c67 has its CatchHandler @ 080e0c72
    TWriteBuffer::writeBytes(&this->WriteBuffer,in_stack_00000008,in_stack_0000000c);
    return;
}



// DWARF original prototype: bool getFlag(TQueryManagerConnection * this)

bool __thiscall TQueryManagerConnection::getFlag(TQueryManagerConnection *this)

{
    uchar uVar1;
    
                    // try { // try from 080e0cc2 to 080e0cc6 has its CatchHandler @ 080e0cd8
    uVar1 = TReadBuffer::readByte(&this->ReadBuffer);
    return uVar1 != '\0';
}



// DWARF original prototype: uchar getByte(TQueryManagerConnection * this)

uchar __thiscall TQueryManagerConnection::getByte(TQueryManagerConnection *this)

{
    uchar uVar1;
    
                    // try { // try from 080e0d22 to 080e0d26 has its CatchHandler @ 080e0d31
    uVar1 = TReadBuffer::readByte(&this->ReadBuffer);
    return uVar1;
}



// DWARF original prototype: ushort getWord(TQueryManagerConnection * this)

ushort __thiscall TQueryManagerConnection::getWord(TQueryManagerConnection *this)

{
    ushort uVar1;
    
                    // try { // try from 080e0d82 to 080e0d86 has its CatchHandler @ 080e0d91
    uVar1 = TReadBuffer::readWord(&this->ReadBuffer);
    return uVar1;
}



// DWARF original prototype: ulong getQuad(TQueryManagerConnection * this)

ulong __thiscall TQueryManagerConnection::getQuad(TQueryManagerConnection *this)

{
    ulong uVar1;
    
                    // try { // try from 080e0de2 to 080e0de6 has its CatchHandler @ 080e0df0
    uVar1 = TReadBuffer::readQuad(&this->ReadBuffer);
    return uVar1;
}



// DWARF original prototype: void getString(TQueryManagerConnection * this, char * Buffer, int
// MaxLength)

void __thiscall
TQueryManagerConnection::getString(TQueryManagerConnection *this,char *Buffer,int MaxLength)

{
                    // try { // try from 080e0e53 to 080e0e57 has its CatchHandler @ 080e0e62
    TReadStream::readString(&(this->ReadBuffer).super_TReadStream,Buffer,MaxLength);
    return;
}



// DWARF original prototype: void getBytes(TQueryManagerConnection * this, uchar * Buffer, int
// Count)

void __thiscall TQueryManagerConnection::getBytes(TQueryManagerConnection *this)

{
    uchar *in_stack_00000008;
    int in_stack_0000000c;
    
                    // try { // try from 080e0ec0 to 080e0ec4 has its CatchHandler @ 080e0ed0
    TReadBuffer::readBytes(&this->ReadBuffer,in_stack_00000008,in_stack_0000000c);
    return;
}



// WARNING: Variable defined which should be unmapped: Help
// DWARF original prototype: int executeQuery(TQueryManagerConnection * this, int Timeout, bool
// AutoReconnect)

int __thiscall
TQueryManagerConnection::executeQuery(TQueryManagerConnection *this,int Timeout,bool AutoReconnect)

{
    byte bVar1;
    void *pvVar2;
    sockaddr *psVar3;
    ssize_t sVar4;
    int iVar5;
    void *pvVar6;
    int Result;
    TWriteBuffer *this_00;
    int Size;
    int DataSize;
    sockaddr *__buf;
    undefined4 uStackY_40;
    char *Text;
    uchar *puVar7;
    socklen_t in_stack_ffffffd0;
    undefined1 auStack_2c [11];
    char local_21;
    char *pcStack_20;
    bool SecondChance;
    char local_19;
    byte local_18;
    undefined1 local_17 [2];
    bool AutoReconnect_local;
    uchar Help2 [4];
    uchar Help [2];
    
    this_00 = &this->WriteBuffer;
    local_19 = AutoReconnect;
    __buf = (sockaddr *)(this->WriteBuffer).Position;
    (this->WriteBuffer).Position = 0;
    if ((int)__buf < 0xffff) {
                    // try { // try from 080e1376 to 080e137a has its CatchHandler @ 080e13ed
        uStackY_40 = 0x80e137b;
        TWriteBuffer::writeWord(this_00,(short)__buf - 2);
    }
    else {
        if (this->BufferSize < (int)(__buf->sa_data + 2)) {
            Text = "TQueryManagerConnection::executeQuery: Puffer zu klein.\n";
            goto LAB_080e0f4d;
        }
        pcStack_20 = __buf[-1].sa_data + 0xc;
        uStackY_40 = 0x80e0f86;
        memmove(this->Buffer + 6,this->Buffer + 2,(size_t)pcStack_20);
                    // try { // try from 080e0f91 to 080e0f95 has its CatchHandler @ 080e1380
        uStackY_40 = 0x80e0f96;
        TWriteBuffer::writeWord(this_00,0xffff);
                    // try { // try from 080e0fa0 to 080e0fa4 has its CatchHandler @ 080e13bd
        uStackY_40 = 0x80e0fa5;
        TWriteBuffer::writeQuad(this_00,(ulong)pcStack_20);
        __buf = (sockaddr *)(__buf->sa_data + 2);
    }
    local_21 = '\x01';
    if (this->QueryOk != false) {
        do {
            if (this->Socket < 0) {
                if (local_19 == '\0') {
                    return 3;
                }
                if ((int)__buf < 0x4000) {
                    iVar5 = -((uint)(__buf->sa_data + 0xd) & 0xfffffff0);
                    puVar7 = this->Buffer;
                    *(sockaddr **)(Help2 + iVar5 + -0x20) = __buf;
                    *(uchar **)(&stack0xffffffc8 + iVar5) = puVar7;
                    *(undefined1 **)(&stack0xffffffc4 + iVar5) = auStack_2c + iVar5;
                    *(undefined4 *)((int)&uStackY_40 + iVar5) = 0x80e1335;
                    memcpy(*(void **)(&stack0xffffffc4 + iVar5),*(void **)(&stack0xffffffc8 + iVar5)
                           ,*(size_t *)(Help2 + iVar5 + -0x20));
                    *(TQueryManagerConnection **)(&stack0xffffffc4 + iVar5) = this;
                    *(undefined4 *)((int)&uStackY_40 + iVar5) = 0x80e1340;
                    connect(*(TQueryManagerConnection **)(&stack0xffffffc4 + iVar5),
                            *(int *)(&stack0xffffffc8 + iVar5),*(sockaddr **)(Help2 + iVar5 + -0x20)
                            ,*(socklen_t *)(&stack0xffffffd0 + iVar5));
                    puVar7 = this->Buffer;
                    *(undefined1 **)(&stack0xffffffc8 + iVar5) = auStack_2c + iVar5;
                    *(sockaddr **)(Help2 + iVar5 + -0x20) = __buf;
                    *(uchar **)(&stack0xffffffc4 + iVar5) = puVar7;
                    *(undefined4 *)((int)&uStackY_40 + iVar5) = 0x80e1356;
                    memcpy(*(void **)(&stack0xffffffc4 + iVar5),*(void **)(&stack0xffffffc8 + iVar5)
                           ,*(size_t *)(Help2 + iVar5 + -0x20));
                }
                else {
                    uStackY_40 = 0x80e0ff6;
                    pvVar2 = operator_new__((uint)__buf);
                    puVar7 = this->Buffer;
                    uStackY_40 = 0x80e100e;
                    psVar3 = __buf;
                    memcpy(pvVar2,puVar7,(size_t)__buf);
                    uStackY_40 = 0x80e1019;
                    connect(this,(int)puVar7,psVar3,in_stack_ffffffd0);
                    uStackY_40 = 0x80e102f;
                    memcpy(this->Buffer,pvVar2,(size_t)__buf);
                    if (pvVar2 != (void *)0x0) {
                        uStackY_40 = 0x80e103b;
                        operator_delete__(pvVar2);
                    }
                }
                if (this->Socket < 0) {
                    return 3;
                }
            }
            uStackY_40 = 0x80e1069;
            psVar3 = (sockaddr *)write(this,(int)this->Buffer,__buf,in_stack_ffffffd0);
            if (psVar3 == __buf) {
                uStackY_40 = 0x80e1092;
                in_stack_ffffffd0 = Timeout;
                sVar4 = read(this,(int)(Help2 + 2),(void *)0x2,Timeout);
                if (sVar4 == 2) {
                    pvVar2 = (void *)((uint)Help2[3] * 0x100 + (uint)Help2[2]);
                    if (pvVar2 == (void *)0xffff) {
                        uStackY_40 = 0x80e1241;
                        sVar4 = read(this,(int)&local_18,(void *)0x4,Timeout);
                        if (sVar4 != 4) {
                            if (this->Socket < 0) {
                                return 3;
                            }
                            uStackY_40 = 0x80e1263;
                            iVar5 = close(this->Socket);
                            if (iVar5 < 0) {
                                uStackY_40 = 0x80e127b;
                                __errno_location();
                                uStackY_40 = 0x80e128d;
                                error(&DAT_0810dc00);
                            }
                            this->Socket = -1;
                            return 3;
                        }
                        pvVar2 = (void *)((uint)local_18 + (uint)_local_17 * 0x100);
                    }
                    if ((pvVar2 == (void *)0x0) || (this->BufferSize < (int)pvVar2)) {
                        if (-1 < this->Socket) {
                            uStackY_40 = 0x80e114a;
                            iVar5 = close(this->Socket);
                            if (iVar5 < 0) {
                                uStackY_40 = 0x80e115f;
                                __errno_location();
                                uStackY_40 = 0x80e1171;
                                error(&DAT_0810dc00);
                            }
                            this->Socket = -1;
                        }
                        uStackY_40 = 0x80e113d;
                        error(&DAT_0810e120);
                        return 3;
                    }
                    uStackY_40 = 0x80e1190;
                    pvVar6 = (void *)read(this,(int)this->Buffer,pvVar2,Timeout);
                    if (pvVar6 == pvVar2) {
                        (this->ReadBuffer).Size = (int)pvVar6;
                        (this->ReadBuffer).Position = 0;
                    // try { // try from 080e11f7 to 080e11fb has its CatchHandler @ 080e1415
                        uStackY_40 = 0x80e11fc;
                        bVar1 = TReadBuffer::readByte(&this->ReadBuffer);
                        if (bVar1 == 3) {
                            uStackY_40 = 0x80e121a;
                            error("TQueryManagerConnection::executeQuery: Anfrage fehlgeschlagen.\n"
                                 );
                            return 3;
                        }
                        return (uint)bVar1;
                    }
                    if (-1 < this->Socket) {
                        uStackY_40 = 0x80e11bb;
                        iVar5 = close(this->Socket);
                        if (iVar5 < 0) {
                            uStackY_40 = 0x80e11d0;
                            __errno_location();
                            uStackY_40 = 0x80e11e2;
                            error(&DAT_0810dc00);
                        }
                        this->Socket = -1;
                    }
                    Text = 
                    "TQueryManagerConnection::executeQuery: Fehler beim Auslesen der Daten.\n";
                    goto LAB_080e0f4d;
                }
                if (-1 < this->Socket) {
                    uStackY_40 = 0x80e10ce;
                    iVar5 = close(this->Socket);
                    if (iVar5 < 0) {
                        uStackY_40 = 0x80e10e3;
                        __errno_location();
                        uStackY_40 = 0x80e10f5;
                        error(&DAT_0810dc00);
                    }
                    this->Socket = -1;
                }
                if (sVar4 == -2) {
                    return 3;
                }
                if (local_21 == '\0') {
                    return 3;
                }
            }
            else {
                if (-1 < this->Socket) {
                    uStackY_40 = 0x80e12e8;
                    iVar5 = close(this->Socket);
                    if (iVar5 < 0) {
                        uStackY_40 = 0x80e12fd;
                        __errno_location();
                        uStackY_40 = 0x80e130f;
                        error(&DAT_0810dc00);
                    }
                    this->Socket = -1;
                }
                if (local_21 == '\0') {
                    Text = 
                    "TQueryManagerConnection::executeQuery: Fehler beim Abschicken der Anfrage.\n";
                    goto LAB_080e0f4d;
                }
            }
            local_21 = '\0';
        } while( true );
    }
    Text = "TQueryManagerConnection::executeQuery: Fehler beim Zusammenbauen der Anfrage.\n";
LAB_080e0f4d:
    uStackY_40 = 0x80e0f52;
    error(Text);
    return 3;
}



// DWARF original prototype: int checkAccountPassword(TQueryManagerConnection * this, ulong
// AccountID, char * Password, char * IPAddress)

int __thiscall TQueryManagerConnection::checkAccountPassword(TQueryManagerConnection *this)

{
    TWriteBuffer *this_00;
    bool bVar1;
    byte bVar2;
    int iVar3;
    int FailureCode;
    int iVar4;
    uint uVar5;
    ulong in_stack_00000008;
    char *in_stack_0000000c;
    char *in_stack_00000010;
    
    this->QueryOk = true;
    this_00 = &this->WriteBuffer;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e1465 to 080e1479 has its CatchHandler @ 080e1510
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,'\n');
                    // try { // try from 080e1484 to 080e1488 has its CatchHandler @ 080e1550
    TWriteBuffer::writeQuad(this_00,in_stack_00000008);
                    // try { // try from 080e1493 to 080e1497 has its CatchHandler @ 080e1582
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_0000000c);
                    // try { // try from 080e14a2 to 080e14a6 has its CatchHandler @ 080e15b2
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000010);
    iVar3 = executeQuery(this,0x1e,true);
    iVar4 = 0;
    if (iVar3 != 0) {
        if (iVar3 == 1) {
                    // try { // try from 080e14dd to 080e14e1 has its CatchHandler @ 080e15e2
            bVar2 = TReadBuffer::readByte(&this->ReadBuffer);
            uVar5 = (uint)bVar2;
            bVar1 = false;
            if ((uVar5 != 0) && (uVar5 < 5)) {
                bVar1 = true;
            }
            if (bVar1) {
                return uVar5;
            }
            error(&DAT_0810e2e0,uVar5);
        }
        iVar4 = -1;
    }
    return iVar4;
}



// WARNING: Variable defined which should be unmapped: PrivateWorld_local
// DWARF original prototype: int loginAdmin(TQueryManagerConnection * this, ulong AccountID, bool
// PrivateWorld, int * NumberOfCharacters, char[30] * Characters, char[30] * Worlds, uchar[4] *
// IPAddresses, ushort * Ports, ushort * PremiumDaysLeft)

int __thiscall
TQueryManagerConnection::loginAdmin
          (TQueryManagerConnection *this,ulong AccountID,bool PrivateWorld,int *NumberOfCharacters,
          char (*Characters) [30],char (*Worlds) [30],uchar (*IPAddresses) [4],ushort *Ports,
          ushort *PremiumDaysLeft)

{
    TWriteBuffer *this_00;
    TReadBuffer *this_01;
    byte bVar1;
    ushort uVar2;
    int iVar3;
    bool PrivateWorld_local;
    
    this_00 = &this->WriteBuffer;
    this->QueryOk = true;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e163c to 080e1650 has its CatchHandler @ 080e1782
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,'\f');
                    // try { // try from 080e165b to 080e165f has its CatchHandler @ 080e17c0
    TWriteBuffer::writeQuad(this_00,AccountID);
    TWriteBuffer::writeByte(this_00,PrivateWorld);
    iVar3 = executeQuery(this,0x1e,true);
    if (iVar3 == 0) {
        this_01 = &this->ReadBuffer;
                    // try { // try from 080e16d6 to 080e16da has its CatchHandler @ 080e17f2
        bVar1 = TReadBuffer::readByte(this_01);
        iVar3 = 0;
        *NumberOfCharacters = (uint)bVar1;
        if (bVar1 != 0) {
            do {
                    // try { // try from 080e1720 to 080e1724 has its CatchHandler @ 080e181d
                TReadStream::readString(&this_01->super_TReadStream,Characters[iVar3],0x1e);
                    // try { // try from 080e1744 to 080e1748 has its CatchHandler @ 080e184f
                TReadStream::readString(&this_01->super_TReadStream,Worlds[iVar3],0x1e);
                    // try { // try from 080e175e to 080e1762 has its CatchHandler @ 080e1885
                TReadBuffer::readBytes(this_01,IPAddresses[iVar3],4);
                    // try { // try from 080e1766 to 080e176a has its CatchHandler @ 080e18b5
                uVar2 = TReadBuffer::readWord(this_01);
                Ports[iVar3] = uVar2;
                iVar3 = iVar3 + 1;
            } while (iVar3 < *NumberOfCharacters);
        }
                    // try { // try from 080e16ef to 080e16f3 has its CatchHandler @ 080e18e7
        uVar2 = TReadBuffer::readWord(this_01);
        *PremiumDaysLeft = uVar2;
        iVar3 = 0;
    }
    else {
        if (iVar3 == 1) {
                    // try { // try from 080e16a7 to 080e16ab has its CatchHandler @ 080e1919
            bVar1 = TReadBuffer::readByte(&this->ReadBuffer);
            if (bVar1 == 1) {
                return 1;
            }
            error(&DAT_0810e340,(uint)bVar1);
        }
        iVar3 = -1;
    }
    return iVar3;
}



// DWARF original prototype: int loadWorldConfig(TQueryManagerConnection * this, int * WorldType,
// int * RebootTime, int * IPAddress, int * Port, int * MaxPlayers, int * PremiumPlayerBuffer, int *
// MaxNewbies, int * PremiumNewbieBuffer)

int __thiscall TQueryManagerConnection::loadWorldConfig(TQueryManagerConnection *this)

{
    TReadBuffer *this_00;
    byte bVar1;
    ushort uVar2;
    int iVar3;
    uint *in_stack_00000008;
    int *in_stack_0000000c;
    int in_stack_00000010;
    uint *in_stack_00000014;
    uint *in_stack_00000018;
    uint *in_stack_0000001c;
    uint *in_stack_00000020;
    uint *in_stack_00000024;
    
    this->QueryOk = true;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e1975 to 080e1989 has its CatchHandler @ 080e1a56
    TWriteBuffer::writeWord(&this->WriteBuffer,0);
    TWriteBuffer::writeByte(&this->WriteBuffer,'5');
    iVar3 = executeQuery(this,0x1e,true);
    if (iVar3 == 0) {
        this_00 = &this->ReadBuffer;
                    // try { // try from 080e19b9 to 080e19bd has its CatchHandler @ 080e1a90
        bVar1 = TReadBuffer::readByte(this_00);
        *in_stack_00000008 = (uint)bVar1;
                    // try { // try from 080e19cc to 080e19d0 has its CatchHandler @ 080e1abb
        bVar1 = TReadBuffer::readByte(this_00);
        iVar3 = 0;
        *in_stack_0000000c = (uint)bVar1 * 0x3c;
        do {
                    // try { // try from 080e19e8 to 080e19ec has its CatchHandler @ 080e1ae6
            bVar1 = TReadBuffer::readByte(this_00);
            *(uint *)(in_stack_00000010 + iVar3 * 4) = (uint)bVar1;
            iVar3 = iVar3 + 1;
        } while (iVar3 < 4);
                    // try { // try from 080e1a02 to 080e1a06 has its CatchHandler @ 080e1b14
        uVar2 = TReadBuffer::readWord(this_00);
        *in_stack_00000014 = (uint)uVar2;
                    // try { // try from 080e1a12 to 080e1a16 has its CatchHandler @ 080e1b46
        uVar2 = TReadBuffer::readWord(this_00);
        *in_stack_00000018 = (uint)uVar2;
                    // try { // try from 080e1a22 to 080e1a26 has its CatchHandler @ 080e1b78
        uVar2 = TReadBuffer::readWord(this_00);
        *in_stack_0000001c = (uint)uVar2;
                    // try { // try from 080e1a32 to 080e1a36 has its CatchHandler @ 080e1baa
        uVar2 = TReadBuffer::readWord(this_00);
        *in_stack_00000020 = (uint)uVar2;
                    // try { // try from 080e1a42 to 080e1a46 has its CatchHandler @ 080e1bdc
        uVar2 = TReadBuffer::readWord(this_00);
        *in_stack_00000024 = (uint)uVar2;
        iVar3 = 0;
    }
    else {
        iVar3 = -1;
    }
    return iVar3;
}



// DWARF original prototype: int loginGame(TQueryManagerConnection * this, ulong AccountID, char *
// PlayerName, char * Password, char * IPAddress, bool PrivateWorld, bool PremiumAccountRequired,
// bool GamemasterRequired, ulong * CharacterID, int * Sex, char * Guild, char * Rank, char * Title,
// int * NumberOfBuddies, ulong * BuddyIDs, char[30] * BuddyNames, uchar * Rights, bool *
// PremiumAccountActivated)

int __thiscall
TQueryManagerConnection::loginGame
          (TQueryManagerConnection *this,ulong AccountID,char *PlayerName,char *Password,
          char *IPAddress,bool PrivateWorld,bool PremiumAccountRequired,bool GamemasterRequired,
          ulong *CharacterID,int *Sex,char *Guild,char *Rank,char *Title,int *NumberOfBuddies,
          ulong *BuddyIDs,char (*BuddyNames) [30],uchar *Rights,bool *PremiumAccountActivated)

{
    TWriteBuffer *this_00;
    byte bVar1;
    uchar uVar2;
    int iVar3;
    ulong uVar4;
    int iVar5;
    int iVar6;
    int FailureCode;
    uint uVar7;
    int *piVar8;
    int i_1;
    byte *pbVar9;
    TReadBuffer *this_01;
    byte *pbVar10;
    undefined1 uVar11;
    bool bVar12;
    undefined1 uVar13;
    bool bVar14;
    byte local_60;
    int Right;
    uint local_50;
    int i_2;
    int NumberOfRights;
    bool GamemasterRequired_local;
    bool PremiumAccountRequired_local;
    int iStack_40;
    bool PrivateWorld_local;
    byte local_3c [4];
    char RightName [30];
    
    this_00 = &this->WriteBuffer;
    this->QueryOk = true;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e1c4a to 080e1c5e has its CatchHandler @ 080e2c00
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,'\x14');
                    // try { // try from 080e1c69 to 080e1c6d has its CatchHandler @ 080e2c40
    TWriteBuffer::writeQuad(this_00,AccountID);
                    // try { // try from 080e1c78 to 080e1c7c has its CatchHandler @ 080e2c72
    TWriteStream::writeString(&this_00->super_TWriteStream,PlayerName);
                    // try { // try from 080e1c87 to 080e1c8b has its CatchHandler @ 080e2ca2
    TWriteStream::writeString(&this_00->super_TWriteStream,Password);
                    // try { // try from 080e1c96 to 080e1c9a has its CatchHandler @ 080e2cd2
    TWriteStream::writeString(&this_00->super_TWriteStream,IPAddress);
    TWriteBuffer::writeByte(this_00,PrivateWorld);
    TWriteBuffer::writeByte(this_00,PremiumAccountRequired);
    TWriteBuffer::writeByte(this_00,GamemasterRequired);
    iVar3 = executeQuery(this,0x78,true);
    if (iVar3 == 0) {
        this_01 = &this->ReadBuffer;
                    // try { // try from 080e1d4c to 080e1d50 has its CatchHandler @ 080e2d06
        uVar4 = TReadBuffer::readQuad(this_01);
        *CharacterID = uVar4;
                    // try { // try from 080e1d6d to 080e1d71 has its CatchHandler @ 080e2d38
        TReadStream::readString(&this_01->super_TReadStream,PlayerName,0x1e);
                    // try { // try from 080e1d78 to 080e1d7c has its CatchHandler @ 080e2d6e
        bVar1 = TReadBuffer::readByte(this_01);
        *Sex = (uint)bVar1;
                    // try { // try from 080e1d9d to 080e1da1 has its CatchHandler @ 080e2da0
        TReadStream::readString(&this_01->super_TReadStream,Guild,0x1e);
                    // try { // try from 080e1db7 to 080e1dbb has its CatchHandler @ 080e2dd6
        TReadStream::readString(&this_01->super_TReadStream,Rank,0x1e);
                    // try { // try from 080e1dd1 to 080e1dd5 has its CatchHandler @ 080e2e0c
        TReadStream::readString(&this_01->super_TReadStream,Title,0x1e);
                    // try { // try from 080e1ddc to 080e1de0 has its CatchHandler @ 080e2e42
        bVar1 = TReadBuffer::readByte(this_01);
        *NumberOfBuddies = (uint)bVar1;
        if (100 < bVar1) {
            error(&DAT_0810e400,*NumberOfBuddies,PlayerName);
        }
        iVar3 = 0;
        while( true ) {
            iStack_40 = 100;
            piVar8 = &stack0xffffffc0;
            if (*NumberOfBuddies < 0x65) {
                piVar8 = NumberOfBuddies;
            }
            if (*piVar8 <= iVar3) break;
                    // try { // try from 080e1e16 to 080e1e1a has its CatchHandler @ 080e2e74
            uVar4 = TReadBuffer::readQuad(this_01);
            BuddyIDs[iVar3] = uVar4;
                    // try { // try from 080e1e42 to 080e1e46 has its CatchHandler @ 080e2ea6
            TReadStream::readString(&this_01->super_TReadStream,BuddyNames[iVar3],0x1e);
            iVar3 = iVar3 + 1;
        }
        iVar3 = 100;
        if (100 < *NumberOfBuddies) {
            do {
                    // try { // try from 080e2bad to 080e2bb1 has its CatchHandler @ 080e2ed9
                TReadBuffer::readQuad(this_01);
                    // try { // try from 080e2bc7 to 080e2bcb has its CatchHandler @ 080e2f09
                TReadStream::readString(&this_01->super_TReadStream,(char *)local_3c,0x1e);
                iVar3 = iVar3 + 1;
            } while (iVar3 < *NumberOfBuddies);
        }
                    // try { // try from 080e1e5d to 080e1e61 has its CatchHandler @ 080e2f3c
        bVar1 = TReadBuffer::readByte(this_01);
        uVar7 = (uint)bVar1;
        local_50 = 0;
        uVar11 = uVar7 != 0;
        uVar13 = uVar7 == 0;
        if (uVar7 != 0) {
            do {
                    // try { // try from 080e1e97 to 080e1e9b has its CatchHandler @ 080e2f6e
                TReadStream::readString(&this_01->super_TReadStream,(char *)local_3c,0x1e);
                iVar3 = 0x10;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"PREMIUM_ACCOUNT";
                do {
                    if (iVar3 == 0) break;
                    iVar3 = iVar3 + -1;
                    uVar11 = *pbVar9 < *pbVar10;
                    uVar13 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while ((bool)uVar13);
                iVar3 = 0;
                if (!(bool)uVar13) {
                    iVar3 = -1;
                }
                iVar5 = 9;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"NOTATION";
                do {
                    if (iVar5 == 0) break;
                    iVar5 = iVar5 + -1;
                    uVar11 = *pbVar9 < *pbVar10;
                    uVar13 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while ((bool)uVar13);
                iVar6 = 9;
                iVar5 = 1;
                if (!(bool)uVar13) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"NAMELOCK";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    uVar11 = *pbVar9 < *pbVar10;
                    uVar13 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while ((bool)uVar13);
                iVar6 = 0x11;
                iVar3 = 2;
                if (!(bool)uVar13) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"STATEMENT_REPORT";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    uVar11 = *pbVar9 < *pbVar10;
                    uVar13 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while ((bool)uVar13);
                iVar6 = 0xb;
                iVar5 = 3;
                if (!(bool)uVar13) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)0x810fcf3;
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    uVar11 = *pbVar9 < *pbVar10;
                    uVar13 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while ((bool)uVar13);
                iVar6 = 0xe;
                iVar3 = 4;
                if (!(bool)uVar13) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"FINAL_WARNING";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    uVar11 = *pbVar9 < *pbVar10;
                    uVar13 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while ((bool)uVar13);
                iVar6 = 0xe;
                iVar5 = 5;
                if (!(bool)uVar13) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"IP_BANISHMENT";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    uVar11 = *pbVar9 < *pbVar10;
                    uVar13 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while ((bool)uVar13);
                iVar6 = 5;
                iVar3 = 6;
                if (!(bool)uVar13) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = &DAT_0810fb59;
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    uVar11 = *pbVar9 < *pbVar10;
                    uVar13 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while ((bool)uVar13);
                iVar6 = 0xe;
                iVar5 = 7;
                if (!(bool)uVar13) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"HOME_TELEPORT";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    uVar11 = *pbVar9 < *pbVar10;
                    uVar13 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while ((bool)uVar13);
                iVar6 = 0x15;
                iVar3 = 8;
                if (!(bool)uVar13) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"CLEAR_CHARACTER_INFO";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    uVar11 = *pbVar9 < *pbVar10;
                    uVar13 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while ((bool)uVar13);
                bVar12 = (!(bool)uVar11 && !(bool)uVar13) < (byte)uVar11;
                bVar14 = (!(bool)uVar11 && !(bool)uVar13) == (bool)uVar11;
                if (bVar14) {
                    iVar3 = -2;
                }
                iVar5 = 0xd;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"CLEAR_GUILDS";
                do {
                    if (iVar5 == 0) break;
                    iVar5 = iVar5 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                if (bVar14) {
                    iVar3 = -2;
                }
                iVar5 = 0xe;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"DELETE_GUILDS";
                do {
                    if (iVar5 == 0) break;
                    iVar5 = iVar5 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                if (bVar14) {
                    iVar3 = -2;
                }
                iVar5 = 0xd;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"BOARD_REPORT";
                do {
                    if (iVar5 == 0) break;
                    iVar5 = iVar5 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                if (bVar14) {
                    iVar3 = -2;
                }
                iVar5 = 0x11;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"BOARD_MODERATION";
                do {
                    if (iVar5 == 0) break;
                    iVar5 = iVar5 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                if (bVar14) {
                    iVar3 = -2;
                }
                iVar5 = 0x15;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"BOARD_ANONYMOUS_EDIT";
                do {
                    if (iVar5 == 0) break;
                    iVar5 = iVar5 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                if (bVar14) {
                    iVar3 = -2;
                }
                iVar5 = 0x13;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"BOARD_PRECONFIRMED";
                do {
                    if (iVar5 == 0) break;
                    iVar5 = iVar5 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                if (bVar14) {
                    iVar3 = -2;
                }
                iVar5 = 0xd;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"KEEP_ACCOUNT";
                do {
                    if (iVar5 == 0) break;
                    iVar5 = iVar5 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                if (bVar14) {
                    iVar3 = -2;
                }
                iVar5 = 0x15;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"GAMEMASTER_BROADCAST";
                do {
                    if (iVar5 == 0) break;
                    iVar5 = iVar5 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar5 = 9;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                iVar3 = 0x14;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"ANONYMOUS_BROADCAST";
                do {
                    if (iVar3 == 0) break;
                    iVar3 = iVar3 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar3 = 10;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                iVar5 = 8;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"INVITED";
                do {
                    if (iVar5 == 0) break;
                    iVar5 = iVar5 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                if (bVar14) {
                    iVar3 = -2;
                }
                iVar5 = 0xe;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"NO_BANISHMENT";
                do {
                    if (iVar5 == 0) break;
                    iVar5 = iVar5 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar5 = 0xb;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                iVar3 = 0x12;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"ALLOW_MULTICLIENT";
                do {
                    if (iVar3 == 0) break;
                    iVar3 = iVar3 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                if (bVar14) {
                    iVar5 = -2;
                }
                iVar3 = 0xf;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"CIPWATCH_ADMIN";
                do {
                    if (iVar3 == 0) break;
                    iVar3 = iVar3 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                if (bVar14) {
                    iVar5 = -2;
                }
                iVar3 = 0xe;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"CIPWATCH_USER";
                do {
                    if (iVar3 == 0) break;
                    iVar3 = iVar3 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                if (bVar14) {
                    iVar5 = -2;
                }
                iVar3 = 0x16;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"CREATECHAR_GAMEMASTER";
                do {
                    if (iVar3 == 0) break;
                    iVar3 = iVar3 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                if (bVar14) {
                    iVar5 = -2;
                }
                iVar3 = 0xf;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"CREATECHAR_GOD";
                do {
                    if (iVar3 == 0) break;
                    iVar3 = iVar3 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                if (bVar14) {
                    iVar5 = -2;
                }
                iVar3 = 0x10;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"CREATECHAR_TEST";
                do {
                    if (iVar3 == 0) break;
                    iVar3 = iVar3 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                if (bVar14) {
                    iVar5 = -2;
                }
                iVar3 = 0xd;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"VIEW_ACCOUNT";
                do {
                    if (iVar3 == 0) break;
                    iVar3 = iVar3 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                if (bVar14) {
                    iVar5 = -2;
                }
                iVar3 = 0x17;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"VIEW_GAMEMASTER_RECORD";
                do {
                    if (iVar3 == 0) break;
                    iVar3 = iVar3 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                if (bVar14) {
                    iVar5 = -2;
                }
                iVar3 = 0x15;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"VIEW_CRIMINAL_RECORD";
                do {
                    if (iVar3 == 0) break;
                    iVar3 = iVar3 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                if (bVar14) {
                    iVar5 = -2;
                }
                iVar3 = 0xf;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"VIEW_LOG_FILES";
                do {
                    if (iVar3 == 0) break;
                    iVar3 = iVar3 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                if (bVar14) {
                    iVar5 = -2;
                }
                iVar3 = 0x12;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"LOG_COMMUNICATION";
                do {
                    if (iVar3 == 0) break;
                    iVar3 = iVar3 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar3 = 0xd;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                iVar5 = 0x12;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"MODIFY_BANISHMENT";
                do {
                    if (iVar5 == 0) break;
                    iVar5 = iVar5 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                if (bVar14) {
                    iVar3 = -2;
                }
                iVar5 = 0x18;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"READ_GAMEMASTER_CHANNEL";
                do {
                    if (iVar5 == 0) break;
                    iVar5 = iVar5 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar5 = 0xe;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                iVar3 = 0x13;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"READ_TUTOR_CHANNEL";
                do {
                    if (iVar3 == 0) break;
                    iVar3 = iVar3 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar3 = 0xf;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                iVar5 = 0x17;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"HIGHLIGHT_HELP_CHANNEL";
                do {
                    if (iVar5 == 0) break;
                    iVar5 = iVar5 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar5 = 0x10;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                iVar3 = 0x10;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"SEND_BUGREPORTS";
                do {
                    if (iVar3 == 0) break;
                    iVar3 = iVar3 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar3 = 0x11;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                iVar5 = 0xc;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"APPOINT_CIP";
                do {
                    if (iVar5 == 0) break;
                    iVar5 = iVar5 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                if (bVar14) {
                    iVar3 = -2;
                }
                iVar5 = 0xc;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"APPOINT_SGM";
                do {
                    if (iVar5 == 0) break;
                    iVar5 = iVar5 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                if (bVar14) {
                    iVar3 = -2;
                }
                iVar5 = 0xc;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"APPOINT_JGM";
                do {
                    if (iVar5 == 0) break;
                    iVar5 = iVar5 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                if (bVar14) {
                    iVar3 = -2;
                }
                iVar5 = 0x10;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"APPOINT_SENATOR";
                do {
                    if (iVar5 == 0) break;
                    iVar5 = iVar5 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                if (bVar14) {
                    iVar3 = -2;
                }
                iVar5 = 0x13;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"SET_ACCOUNT_RIGHTS";
                do {
                    if (iVar5 == 0) break;
                    iVar5 = iVar5 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                if (bVar14) {
                    iVar3 = -2;
                }
                iVar5 = 0x15;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"SET_CHARACTER_RIGHTS";
                do {
                    if (iVar5 == 0) break;
                    iVar5 = iVar5 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                if (bVar14) {
                    iVar3 = -2;
                }
                iVar5 = 0x18;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"SET_ACCOUNTGROUP_RIGHTS";
                do {
                    if (iVar5 == 0) break;
                    iVar5 = iVar5 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                if (bVar14) {
                    iVar3 = -2;
                }
                iVar5 = 0x1a;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"SET_CHARACTERGROUP_RIGHTS";
                do {
                    if (iVar5 == 0) break;
                    iVar5 = iVar5 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0xf;
                iVar5 = -2;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"NAME_INSULTING";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0xe;
                iVar3 = 0x12;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"NAME_SENTENCE";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x19;
                iVar5 = 0x13;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"NAME_NONSENSICAL_LETTERS";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x15;
                iVar3 = 0x14;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"NAME_BADLY_FORMATTED";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0xf;
                iVar5 = 0x15;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"NAME_NO_PERSON";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0xf;
                iVar3 = 0x16;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"NAME_CELEBRITY";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0xd;
                iVar5 = 0x17;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"NAME_COUNTRY";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x13;
                iVar3 = 0x18;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"NAME_FAKE_IDENTITY";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x13;
                iVar5 = 0x19;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"NAME_FAKE_POSITION";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x14;
                iVar3 = 0x1a;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"STATEMENT_INSULTING";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar5 = 0x1b;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                iVar3 = 0x13;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"STATEMENT_SPAMMING";
                do {
                    if (iVar3 == 0) break;
                    iVar3 = iVar3 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x1a;
                iVar3 = 0x1c;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"STATEMENT_ADVERT_OFFTOPIC";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x17;
                iVar5 = 0x1d;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"STATEMENT_ADVERT_MONEY";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x16;
                iVar3 = 0x1e;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"STATEMENT_NON_ENGLISH";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x1b;
                iVar5 = 0x1f;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"STATEMENT_CHANNEL_OFFTOPIC";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x1d;
                iVar3 = 0x20;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"STATEMENT_VIOLATION_INCITING";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x13;
                iVar5 = 0x21;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"CHEATING_BUG_ABUSE";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x17;
                iVar3 = 0x22;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"CHEATING_GAME_WEAKNESS";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x13;
                iVar5 = 0x23;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"CHEATING_MACRO_USE";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar3 = 0x24;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                iVar5 = 0x19;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"CHEATING_MODIFIED_CLIENT";
                do {
                    if (iVar5 == 0) break;
                    iVar5 = iVar5 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x11;
                iVar5 = 0x25;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"CHEATING_HACKING";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x16;
                iVar3 = 0x26;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"CHEATING_MULTI_CLIENT";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x19;
                iVar5 = 0x27;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"CHEATING_ACCOUNT_TRADING";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x19;
                iVar3 = 0x28;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"CHEATING_ACCOUNT_SHARING";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x17;
                iVar5 = 0x29;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"GAMEMASTER_THREATENING";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x16;
                iVar3 = 0x2a;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"GAMEMASTER_PRETENDING";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x15;
                iVar5 = 0x2b;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"GAMEMASTER_INFLUENCE";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x19;
                iVar3 = 0x2c;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"GAMEMASTER_FALSE_REPORTS";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar5 = 0x2d;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                iVar3 = 0x1e;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"KILLING_EXCESSIVE_UNJUSTIFIED";
                do {
                    if (iVar3 == 0) break;
                    iVar3 = iVar3 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x16;
                iVar3 = 0x2e;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"DESTRUCTIVE_BEHAVIOUR";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x11;
                iVar5 = 0x2f;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"SPOILING_AUCTION";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x10;
                iVar3 = 0x30;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"INVALID_PAYMENT";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x16;
                iVar5 = 0x31;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"TELEPORT_TO_CHARACTER";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x11;
                iVar3 = 0x32;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"TELEPORT_TO_MARK";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x12;
                iVar5 = 0x33;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"TELEPORT_VERTICAL";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x17;
                iVar3 = 0x34;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"TELEPORT_TO_COORDINATE";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 9;
                iVar5 = 0x35;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"LEVITATE";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar3 = 0x36;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                iVar5 = 0x10;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"SPECIAL_MOVEUSE";
                do {
                    if (iVar5 == 0) break;
                    iVar5 = iVar5 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x12;
                iVar5 = 0x37;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"MODIFY_GOSTRENGTH";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x10;
                iVar3 = 0x38;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"SHOW_COORDINATE";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 9;
                iVar5 = 0x39;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"RETRIEVE";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0xd;
                iVar3 = 0x3a;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"INVULNERABLE";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0xf;
                iVar5 = 0x3d;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"UNLIMITED_MANA";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0xf;
                iVar3 = 0x3e;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"KEEP_INVENTORY";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0xb;
                iVar5 = 0x3f;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"ALL_SPELLS";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x13;
                iVar3 = 0x40;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"UNLIMITED_CAPACITY";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar5 = 0x41;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                iVar3 = 0xe;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"ZERO_CAPACITY";
                do {
                    if (iVar3 == 0) break;
                    iVar3 = iVar3 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x12;
                iVar3 = 0x42;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"ATTACK_EVERYWHERE";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 10;
                iVar5 = 0x43;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"NO_ATTACK";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 9;
                iVar3 = 0x44;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"NO_RUNES";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x10;
                iVar5 = 0x45;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"NO_LOGOUT_BLOCK";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x12;
                iVar3 = 0x46;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"GAMEMASTER_OUTFIT";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0xb;
                iVar5 = 0x47;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"ILLUMINATE";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x12;
                iVar3 = 0x48;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"CHANGE_PROFESSION";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x14;
                iVar5 = 0x49;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"IGNORED_BY_MONSTERS";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar3 = 0x4a;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                iVar5 = 0x15;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"SHOW_KEYHOLE_NUMBERS";
                do {
                    if (iVar5 == 0) break;
                    iVar5 = iVar5 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0xf;
                iVar5 = 0x4b;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"CREATE_OBJECTS";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0xd;
                iVar3 = 0x4c;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"CREATE_MONEY";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0x10;
                iVar5 = 0x4d;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"CREATE_MONSTERS";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0xe;
                iVar3 = 0x4e;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"CHANGE_SKILLS";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0xf;
                iVar5 = 0x4f;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"CLEANUP_FIELDS";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0xe;
                iVar3 = 0x50;
                if (!bVar14) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"NO_STATISTICS";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                iVar6 = 0xf;
                iVar5 = 0x51;
                if (!bVar14) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"KEEP_CHARACTER";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 < *pbVar10;
                    bVar14 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar14);
                bVar12 = (!bVar12 && !bVar14) == bVar12;
                if (bVar12) {
                    iVar5 = -2;
                }
                iVar3 = 0x10;
                pbVar9 = local_3c;
                pbVar10 = (byte *)"EXTRA_CHARACTER";
                do {
                    if (iVar3 == 0) break;
                    iVar3 = iVar3 + -1;
                    bVar12 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar12);
                iVar6 = 0xd;
                iVar3 = -2;
                if (!bVar12) {
                    iVar3 = iVar5;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"ENTER_HOUSES";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar12);
                iVar6 = 0x10;
                iVar5 = 0x3b;
                if (!bVar12) {
                    iVar5 = iVar3;
                }
                pbVar9 = local_3c;
                pbVar10 = (byte *)"OPEN_NAMEDDOORS";
                do {
                    if (iVar6 == 0) break;
                    iVar6 = iVar6 + -1;
                    bVar12 = *pbVar9 == *pbVar10;
                    pbVar9 = pbVar9 + 1;
                    pbVar10 = pbVar10 + 1;
                } while (bVar12);
                iVar3 = 0x3c;
                if (!bVar12) {
                    iVar3 = iVar5;
                }
                if (iVar3 != -2) {
                    if (iVar3 == -1) {
                        error("TQueryManagerConnection::loginGame: Unbekanntes Recht %s.\n",local_3c
                             );
                    }
                    else {
                        iVar5 = iVar3 + 7;
                        if (-1 < iVar3) {
                            iVar5 = iVar3;
                        }
                        local_60 = (char)iVar3 + (char)(iVar5 >> 3) * -8;
                        Rights[iVar5 >> 3] = Rights[iVar5 >> 3] | (byte)(1 << (local_60 & 0x1f));
                    }
                }
                local_50 = local_50 + 1;
                uVar11 = local_50 < uVar7;
                uVar13 = local_50 == uVar7;
            } while ((int)local_50 < (int)uVar7);
        }
                    // try { // try from 080e2b7b to 080e2b7f has its CatchHandler @ 080e2fa2
        uVar2 = TReadBuffer::readByte(this_01);
        *PremiumAccountActivated = uVar2 != '\0';
        iVar3 = 0;
    }
    else {
        if (iVar3 == 1) {
                    // try { // try from 080e1d0c to 080e1d10 has its CatchHandler @ 080e2fd4
            bVar1 = TReadBuffer::readByte(&this->ReadBuffer);
            uVar7 = (uint)bVar1;
            bVar12 = false;
            if ((uVar7 != 0) && (uVar7 < 0x10)) {
                bVar12 = true;
            }
            if (bVar12) {
                return uVar7;
            }
            error(&DAT_0810e380,uVar7);
        }
        iVar3 = -1;
    }
    return iVar3;
}



// DWARF original prototype: int logoutGame(TQueryManagerConnection * this, ulong CharacterID, int
// Level, char * Profession, char * Residence, time_t LastLoginTime, int TutorActivities)

int __thiscall TQueryManagerConnection::logoutGame(TQueryManagerConnection *this)

{
    TWriteBuffer *this_00;
    int iVar1;
    ulong in_stack_00000008;
    ushort in_stack_0000000c;
    char *in_stack_00000010;
    char *in_stack_00000014;
    ulong in_stack_00000018;
    ushort in_stack_0000001c;
    
    this->QueryOk = true;
    this_00 = &this->WriteBuffer;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e3035 to 080e3049 has its CatchHandler @ 080e30d0
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,'\x15');
                    // try { // try from 080e3054 to 080e3058 has its CatchHandler @ 080e3110
    TWriteBuffer::writeQuad(this_00,in_stack_00000008);
                    // try { // try from 080e3064 to 080e3068 has its CatchHandler @ 080e3142
    TWriteBuffer::writeWord(this_00,in_stack_0000000c);
                    // try { // try from 080e3073 to 080e3077 has its CatchHandler @ 080e3172
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000010);
                    // try { // try from 080e3082 to 080e3086 has its CatchHandler @ 080e31a2
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000014);
                    // try { // try from 080e3091 to 080e3095 has its CatchHandler @ 080e31d6
    TWriteBuffer::writeQuad(this_00,in_stack_00000018);
                    // try { // try from 080e30a1 to 080e30a5 has its CatchHandler @ 080e320a
    TWriteBuffer::writeWord(this_00,in_stack_0000001c);
    iVar1 = executeQuery(this,0x78,true);
    return (iVar1 == 0) - 1;
}



// DWARF original prototype: int setNotation(TQueryManagerConnection * this, ulong GamemasterID,
// char * PlayerName, char * IPAddress, char * Reason, char * Comment, ulong * BanishmentID)

int __thiscall TQueryManagerConnection::setNotation(TQueryManagerConnection *this)

{
    TWriteBuffer *this_00;
    bool bVar1;
    byte bVar2;
    int iVar3;
    ulong uVar4;
    int FailureCode;
    uint uVar5;
    ulong in_stack_00000008;
    char *in_stack_0000000c;
    char *in_stack_00000010;
    char *in_stack_00000014;
    char *in_stack_00000018;
    ulong *in_stack_0000001c;
    
    this->QueryOk = true;
    this_00 = &this->WriteBuffer;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e3265 to 080e3279 has its CatchHandler @ 080e3350
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,'\x1a');
                    // try { // try from 080e3284 to 080e3288 has its CatchHandler @ 080e3390
    TWriteBuffer::writeQuad(this_00,in_stack_00000008);
                    // try { // try from 080e3293 to 080e3297 has its CatchHandler @ 080e33c2
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_0000000c);
                    // try { // try from 080e32a2 to 080e32a6 has its CatchHandler @ 080e33f2
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000010);
                    // try { // try from 080e32b1 to 080e32b5 has its CatchHandler @ 080e3422
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000014);
                    // try { // try from 080e32c0 to 080e32c4 has its CatchHandler @ 080e3456
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000018);
    iVar3 = executeQuery(this,0x1e,true);
    if (iVar3 == 0) {
                    // try { // try from 080e3340 to 080e3344 has its CatchHandler @ 080e348a
        uVar4 = TReadBuffer::readQuad(&this->ReadBuffer);
        *in_stack_0000001c = uVar4;
        iVar3 = 0;
    }
    else {
        if (iVar3 == 1) {
                    // try { // try from 080e3303 to 080e3307 has its CatchHandler @ 080e34bc
            bVar2 = TReadBuffer::readByte(&this->ReadBuffer);
            uVar5 = (uint)bVar2;
            bVar1 = false;
            if ((uVar5 != 0) && (uVar5 < 3)) {
                bVar1 = true;
            }
            if (bVar1) {
                return uVar5;
            }
            error(&DAT_0810e4a0,uVar5);
        }
        else {
            error("TQueryManagerConnection::setNotation: Anfrage fehlgeschlagen.\n");
        }
        iVar3 = -1;
    }
    return iVar3;
}



// DWARF original prototype: int setNamelock(TQueryManagerConnection * this, ulong GamemasterID,
// char * PlayerName, char * IPAddress, char * Reason, char * Comment)

int __thiscall TQueryManagerConnection::setNamelock(TQueryManagerConnection *this)

{
    TWriteBuffer *this_00;
    bool bVar1;
    byte bVar2;
    int iVar3;
    int FailureCode;
    int iVar4;
    uint uVar5;
    ulong in_stack_00000008;
    char *in_stack_0000000c;
    char *in_stack_00000010;
    char *in_stack_00000014;
    char *in_stack_00000018;
    
    this->QueryOk = true;
    this_00 = &this->WriteBuffer;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e3515 to 080e3529 has its CatchHandler @ 080e35f0
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,'\x17');
                    // try { // try from 080e3534 to 080e3538 has its CatchHandler @ 080e3630
    TWriteBuffer::writeQuad(this_00,in_stack_00000008);
                    // try { // try from 080e3543 to 080e3547 has its CatchHandler @ 080e3662
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_0000000c);
                    // try { // try from 080e3552 to 080e3556 has its CatchHandler @ 080e3692
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000010);
                    // try { // try from 080e3561 to 080e3565 has its CatchHandler @ 080e36c2
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000014);
                    // try { // try from 080e3570 to 080e3574 has its CatchHandler @ 080e36f6
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000018);
    iVar3 = executeQuery(this,0x1e,true);
    iVar4 = 0;
    if (iVar3 != 0) {
        if (iVar3 == 1) {
                    // try { // try from 080e35b7 to 080e35bb has its CatchHandler @ 080e372a
            bVar2 = TReadBuffer::readByte(&this->ReadBuffer);
            uVar5 = (uint)bVar2;
            bVar1 = false;
            if ((uVar5 != 0) && (uVar5 < 5)) {
                bVar1 = true;
            }
            if (bVar1) {
                return uVar5;
            }
            error(&DAT_0810e540,uVar5);
        }
        else {
            error("TQueryManagerConnection::setNamelock: Anfrage fehlgeschlagen.\n");
        }
        iVar4 = -1;
    }
    return iVar4;
}



// DWARF original prototype: int banishAccount(TQueryManagerConnection * this, ulong GamemasterID,
// char * PlayerName, char * IPAddress, char * Reason, char * Comment, bool * FinalWarning, int *
// Days, ulong * BanishmentID)

int __thiscall TQueryManagerConnection::banishAccount(TQueryManagerConnection *this)

{
    TWriteBuffer *this_00;
    TReadBuffer *this_01;
    bool bVar1;
    byte bVar2;
    uchar uVar3;
    int iVar4;
    ulong uVar5;
    int FailureCode;
    uint uVar6;
    ulong in_stack_00000008;
    char *in_stack_0000000c;
    char *in_stack_00000010;
    char *in_stack_00000014;
    char *in_stack_00000018;
    char *in_stack_0000001c;
    uint *in_stack_00000020;
    ulong *in_stack_00000024;
    
    this->QueryOk = true;
    this_00 = &this->WriteBuffer;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e3785 to 080e3799 has its CatchHandler @ 080e38c0
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,'\x19');
                    // try { // try from 080e37a4 to 080e37a8 has its CatchHandler @ 080e3900
    TWriteBuffer::writeQuad(this_00,in_stack_00000008);
                    // try { // try from 080e37b3 to 080e37b7 has its CatchHandler @ 080e3932
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_0000000c);
                    // try { // try from 080e37c2 to 080e37c6 has its CatchHandler @ 080e3962
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000010);
                    // try { // try from 080e37d1 to 080e37d5 has its CatchHandler @ 080e3992
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000014);
                    // try { // try from 080e37e0 to 080e37e4 has its CatchHandler @ 080e39c6
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000018);
                    // try { // try from 080e37f8 to 080e37fc has its CatchHandler @ 080e39fa
    TWriteBuffer::writeByte(this_00,*in_stack_0000001c != '\0');
    iVar4 = executeQuery(this,0x1e,true);
    if (iVar4 == 0) {
        this_01 = &this->ReadBuffer;
                    // try { // try from 080e3878 to 080e387c has its CatchHandler @ 080e3a2e
        uVar5 = TReadBuffer::readQuad(this_01);
        *in_stack_00000024 = uVar5;
                    // try { // try from 080e3887 to 080e388b has its CatchHandler @ 080e3a60
        bVar2 = TReadBuffer::readByte(this_01);
        uVar6 = 0xffffffff;
        if (bVar2 != 0xff) {
            uVar6 = (uint)bVar2;
        }
        *in_stack_00000020 = uVar6;
                    // try { // try from 080e38a8 to 080e38ac has its CatchHandler @ 080e3a92
        uVar3 = TReadBuffer::readByte(this_01);
        *in_stack_0000001c = uVar3 != '\0';
        iVar4 = 0;
    }
    else {
        if (iVar4 == 1) {
                    // try { // try from 080e383b to 080e383f has its CatchHandler @ 080e3ac4
            bVar2 = TReadBuffer::readByte(&this->ReadBuffer);
            uVar6 = (uint)bVar2;
            bVar1 = false;
            if ((uVar6 != 0) && (uVar6 < 4)) {
                bVar1 = true;
            }
            if (bVar1) {
                return uVar6;
            }
            error(&DAT_0810e600,uVar6);
        }
        else {
            error("TQueryManagerConnection::banishAccount: Anfrage fehlgeschlagen.\n");
        }
        iVar4 = -1;
    }
    return iVar4;
}



// WARNING: Variable defined which should be unmapped: i_1
// DWARF original prototype: int reportStatement(TQueryManagerConnection * this, ulong ReporterID,
// char * PlayerName, char * Reason, char * Comment, ulong BanishmentID, ulong StatementID, int
// NumberOfStatements, ulong * StatementIDs, ulong * TimeStamps, ulong * CharacterIDs, char[30] *
// Channels, char[256] * Texts)

int __thiscall TQueryManagerConnection::reportStatement(TQueryManagerConnection *this)

{
    TWriteBuffer *this_00;
    int iVar1;
    bool bVar2;
    byte bVar3;
    int iVar4;
    int i;
    int iVar5;
    uint uVar6;
    ulong in_stack_00000008;
    char *in_stack_0000000c;
    char *in_stack_00000010;
    char *in_stack_00000014;
    ulong in_stack_00000018;
    ulong in_stack_0000001c;
    int in_stack_00000020;
    int *in_stack_00000024;
    int in_stack_00000028;
    int in_stack_0000002c;
    int in_stack_00000030;
    int in_stack_00000034;
    int local_14;
    int i_1;
    
    this->QueryOk = true;
    this_00 = &this->WriteBuffer;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e3b25 to 080e3b39 has its CatchHandler @ 080e3ce0
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,'\x1b');
                    // try { // try from 080e3b44 to 080e3b48 has its CatchHandler @ 080e3d20
    TWriteBuffer::writeQuad(this_00,in_stack_00000008);
                    // try { // try from 080e3b53 to 080e3b57 has its CatchHandler @ 080e3d52
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_0000000c);
                    // try { // try from 080e3b62 to 080e3b66 has its CatchHandler @ 080e3d82
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000010);
                    // try { // try from 080e3b71 to 080e3b75 has its CatchHandler @ 080e3db2
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000014);
                    // try { // try from 080e3b80 to 080e3b84 has its CatchHandler @ 080e3de6
    TWriteBuffer::writeQuad(this_00,in_stack_00000018);
                    // try { // try from 080e3b8f to 080e3b93 has its CatchHandler @ 080e3e1a
    TWriteBuffer::writeQuad(this_00,in_stack_0000001c);
    iVar5 = 0;
    iVar4 = in_stack_00000020;
    if (0 < in_stack_00000020) {
        iVar1 = *in_stack_00000024;
        while (iVar1 == 0) {
            iVar5 = iVar5 + 1;
            iVar4 = iVar4 + -1;
            if (in_stack_00000020 <= iVar5) break;
            iVar1 = in_stack_00000024[iVar5];
        }
    }
                    // try { // try from 080e3bcb to 080e3bcf has its CatchHandler @ 080e3e4e
    TWriteBuffer::writeWord(this_00,(ushort)iVar4);
    local_14 = 0;
    if (0 < in_stack_00000020) {
        do {
            if (in_stack_00000024[local_14] != 0) {
                    // try { // try from 080e3c77 to 080e3c7b has its CatchHandler @ 080e3e82
                TWriteBuffer::writeQuad(this_00,in_stack_00000024[local_14]);
                    // try { // try from 080e3c8c to 080e3c90 has its CatchHandler @ 080e3eb6
                TWriteBuffer::writeQuad(this_00,*(ulong *)(in_stack_00000028 + local_14 * 4));
                    // try { // try from 080e3ca1 to 080e3ca5 has its CatchHandler @ 080e3eea
                TWriteBuffer::writeQuad(this_00,*(ulong *)(in_stack_0000002c + local_14 * 4));
                    // try { // try from 080e3cbe to 080e3cc2 has its CatchHandler @ 080e3f1e
                TWriteStream::writeString
                          (&this_00->super_TWriteStream,
                           (char *)(in_stack_00000030 + local_14 * 0x1e));
                    // try { // try from 080e3cd5 to 080e3cd9 has its CatchHandler @ 080e3f52
                TWriteStream::writeString
                          (&this_00->super_TWriteStream,
                           (char *)(local_14 * 0x100 + in_stack_00000034));
            }
            local_14 = local_14 + 1;
        } while (local_14 < in_stack_00000020);
    }
    iVar5 = executeQuery(this,0xb4,true);
    iVar4 = 0;
    if (iVar5 != 0) {
        if (iVar5 == 1) {
                    // try { // try from 080e3c3d to 080e3c41 has its CatchHandler @ 080e3f86
            bVar3 = TReadBuffer::readByte(&this->ReadBuffer);
            uVar6 = (uint)bVar3;
            bVar2 = false;
            if ((uVar6 != 0) && (uVar6 < 3)) {
                bVar2 = true;
            }
            if (bVar2) {
                return uVar6;
            }
            error(&DAT_0810e6c0,uVar6);
        }
        else {
            error("TQueryManagerConnection::reportStatement: Anfrage fehlgeschlagen.\n");
        }
        iVar4 = -1;
    }
    return iVar4;
}



// DWARF original prototype: int banishIPAddress(TQueryManagerConnection * this, ulong GamemasterID,
// char * PlayerName, char * IPAddress, char * Reason, char * Comment)

int __thiscall TQueryManagerConnection::banishIPAddress(TQueryManagerConnection *this)

{
    TWriteBuffer *this_00;
    bool bVar1;
    byte bVar2;
    int iVar3;
    int FailureCode;
    int iVar4;
    uint uVar5;
    ulong in_stack_00000008;
    char *in_stack_0000000c;
    char *in_stack_00000010;
    char *in_stack_00000014;
    char *in_stack_00000018;
    
    this->QueryOk = true;
    this_00 = &this->WriteBuffer;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e3fe5 to 080e3ff9 has its CatchHandler @ 080e40c0
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,'\x1c');
                    // try { // try from 080e4004 to 080e4008 has its CatchHandler @ 080e4100
    TWriteBuffer::writeQuad(this_00,in_stack_00000008);
                    // try { // try from 080e4013 to 080e4017 has its CatchHandler @ 080e4132
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_0000000c);
                    // try { // try from 080e4022 to 080e4026 has its CatchHandler @ 080e4162
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000010);
                    // try { // try from 080e4031 to 080e4035 has its CatchHandler @ 080e4192
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000014);
                    // try { // try from 080e4040 to 080e4044 has its CatchHandler @ 080e41c6
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000018);
    iVar3 = executeQuery(this,0x1e,true);
    iVar4 = 0;
    if (iVar3 != 0) {
        if (iVar3 == 1) {
                    // try { // try from 080e4087 to 080e408b has its CatchHandler @ 080e41fa
            bVar2 = TReadBuffer::readByte(&this->ReadBuffer);
            uVar5 = (uint)bVar2;
            bVar1 = false;
            if ((uVar5 != 0) && (uVar5 < 3)) {
                bVar1 = true;
            }
            if (bVar1) {
                return uVar5;
            }
            error(&DAT_0810e780,uVar5);
        }
        else {
            error("TQueryManagerConnection::banishIPAddress: Anfrage fehlgeschlagen.\n");
        }
        iVar4 = -1;
    }
    return iVar4;
}



// WARNING: Variable defined which should be unmapped: Unjustified_local
// DWARF original prototype: int logCharacterDeath(TQueryManagerConnection * this, ulong
// CharacterID, int Level, ulong Offender, char * Remark, bool Unjustified, time_t Time)

int __thiscall
TQueryManagerConnection::logCharacterDeath
          (TQueryManagerConnection *this,ulong CharacterID,int Level,ulong Offender,char *Remark,
          bool Unjustified,time_t Time)

{
    TWriteBuffer *this_00;
    int iVar1;
    bool Unjustified_local;
    
    this_00 = &this->WriteBuffer;
    this->QueryOk = true;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e425c to 080e4270 has its CatchHandler @ 080e4310
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,'\x1d');
                    // try { // try from 080e427b to 080e427f has its CatchHandler @ 080e4350
    TWriteBuffer::writeQuad(this_00,CharacterID);
                    // try { // try from 080e428b to 080e428f has its CatchHandler @ 080e4382
    TWriteBuffer::writeWord(this_00,(ushort)Level);
                    // try { // try from 080e429a to 080e429e has its CatchHandler @ 080e43b2
    TWriteBuffer::writeQuad(this_00,Offender);
                    // try { // try from 080e42a9 to 080e42ad has its CatchHandler @ 080e43e2
    TWriteStream::writeString(&this_00->super_TWriteStream,Remark);
                    // try { // try from 080e42be to 080e42c2 has its CatchHandler @ 080e4416
    TWriteBuffer::writeByte(this_00,Unjustified);
                    // try { // try from 080e42cd to 080e42d1 has its CatchHandler @ 080e444a
    TWriteBuffer::writeQuad(this_00,Time);
    iVar1 = executeQuery(this,0x5a,true);
    if (iVar1 == 0) {
        iVar1 = 0;
    }
    else {
        error("TQueryManagerConnection::logCharacterDeath: Anfrage fehlgeschlagen.\n");
        iVar1 = -1;
    }
    return iVar1;
}



// DWARF original prototype: int addBuddy(TQueryManagerConnection * this, ulong AccountID, ulong
// Buddy)

int __thiscall TQueryManagerConnection::addBuddy(TQueryManagerConnection *this)

{
    TWriteBuffer *this_00;
    int iVar1;
    ulong in_stack_00000008;
    ulong in_stack_0000000c;
    
    this->QueryOk = true;
    this_00 = &this->WriteBuffer;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e44a5 to 080e44b9 has its CatchHandler @ 080e4513
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,'\x1e');
                    // try { // try from 080e44c4 to 080e44c8 has its CatchHandler @ 080e4550
    TWriteBuffer::writeQuad(this_00,in_stack_00000008);
                    // try { // try from 080e44d3 to 080e44d7 has its CatchHandler @ 080e4582
    TWriteBuffer::writeQuad(this_00,in_stack_0000000c);
    iVar1 = executeQuery(this,0x5a,true);
    if (iVar1 == 0) {
        iVar1 = 0;
    }
    else {
        error("TQueryManagerConnection::addBuddy: Anfrage fehlgeschlagen.\n");
        iVar1 = -1;
    }
    return iVar1;
}



// DWARF original prototype: int removeBuddy(TQueryManagerConnection * this, ulong AccountID, ulong
// Buddy)

int __thiscall TQueryManagerConnection::removeBuddy(TQueryManagerConnection *this)

{
    TWriteBuffer *this_00;
    int iVar1;
    ulong in_stack_00000008;
    ulong in_stack_0000000c;
    
    this->QueryOk = true;
    this_00 = &this->WriteBuffer;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e45d5 to 080e45e9 has its CatchHandler @ 080e4643
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,'\x1f');
                    // try { // try from 080e45f4 to 080e45f8 has its CatchHandler @ 080e4680
    TWriteBuffer::writeQuad(this_00,in_stack_00000008);
                    // try { // try from 080e4603 to 080e4607 has its CatchHandler @ 080e46b2
    TWriteBuffer::writeQuad(this_00,in_stack_0000000c);
    iVar1 = executeQuery(this,0x5a,true);
    if (iVar1 == 0) {
        iVar1 = 0;
    }
    else {
        error("TQueryManagerConnection::removeBuddy: Anfrage fehlgeschlagen.\n");
        iVar1 = -1;
    }
    return iVar1;
}



// DWARF original prototype: int decrementIsOnline(TQueryManagerConnection * this, ulong
// CharacterID)

int __thiscall
TQueryManagerConnection::decrementIsOnline(TQueryManagerConnection *this,ulong CharacterID)

{
    TWriteBuffer *this_00;
    int iVar1;
    
    this_00 = &this->WriteBuffer;
    this->QueryOk = true;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e470b to 080e471f has its CatchHandler @ 080e4773
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,' ');
                    // try { // try from 080e472a to 080e472e has its CatchHandler @ 080e47b0
    TWriteBuffer::writeQuad(this_00,CharacterID);
    iVar1 = executeQuery(this,0x1e,true);
    if (iVar1 == 0) {
        iVar1 = 0;
    }
    else {
        error("TQueryManagerConnection::decrementIsOnline: Anfrage fehlgeschlagen.\n");
        iVar1 = -1;
    }
    return iVar1;
}



// DWARF original prototype: int finishAuctions(TQueryManagerConnection * this, int *
// NumberOfAuctions, ushort * HouseIDs, ulong * CharacterIDs, char[30] * CharacterNames, int * Bids)

int __thiscall
TQueryManagerConnection::finishAuctions
          (TQueryManagerConnection *this,int *NumberOfAuctions,ushort *HouseIDs,ulong *CharacterIDs,
          char (*CharacterNames) [30],int *Bids)

{
    ushort uVar1;
    int iVar2;
    ulong uVar3;
    uint uVar4;
    TReadBuffer *this_00;
    int MaxNumberOfAuctions;
    
    this->QueryOk = true;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e4805 to 080e4819 has its CatchHandler @ 080e4900
    TWriteBuffer::writeWord(&this->WriteBuffer,0);
    TWriteBuffer::writeByte(&this->WriteBuffer,'!');
    iVar2 = executeQuery(this,0x3c,true);
    if (iVar2 == 0) {
        this_00 = &this->ReadBuffer;
        iVar2 = *NumberOfAuctions;
                    // try { // try from 080e485b to 080e485f has its CatchHandler @ 080e4940
        uVar1 = TReadBuffer::readWord(this_00);
        uVar4 = (uint)uVar1;
        *NumberOfAuctions = uVar4;
        if ((int)uVar4 <= iVar2) {
            iVar2 = 0;
            if (uVar4 != 0) {
                do {
                    // try { // try from 080e487c to 080e4880 has its CatchHandler @ 080e496b
                    uVar1 = TReadBuffer::readWord(this_00);
                    HouseIDs[iVar2] = uVar1;
                    // try { // try from 080e488e to 080e4892 has its CatchHandler @ 080e4996
                    uVar3 = TReadBuffer::readQuad(this_00);
                    CharacterIDs[iVar2] = uVar3;
                    // try { // try from 080e48ba to 080e48be has its CatchHandler @ 080e49c4
                    TReadStream::readString(&this_00->super_TReadStream,CharacterNames[iVar2],0x1e);
                    // try { // try from 080e48c2 to 080e48c6 has its CatchHandler @ 080e49fa
                    uVar3 = TReadBuffer::readQuad(this_00);
                    Bids[iVar2] = uVar3;
                    iVar2 = iVar2 + 1;
                } while (iVar2 < *NumberOfAuctions);
            }
            return 0;
        }
        error("TQueryManagerConnection::finishAuctions: zu viele Auktionen (%d>%d).\n",
              *NumberOfAuctions,iVar2);
    }
    else {
        error("TQueryManagerConnection::finishAuctions: Anfrage fehlgeschlagen.\n");
    }
    return -1;
}



// WARNING: Variable defined which should be unmapped: Banish_local
// DWARF original prototype: int excludeFromAuctions(TQueryManagerConnection * this, ulong
// CharacterID, bool Banish)

int __thiscall
TQueryManagerConnection::excludeFromAuctions
          (TQueryManagerConnection *this,ulong CharacterID,bool Banish)

{
    TWriteBuffer *this_00;
    int iVar1;
    bool Banish_local;
    
    this_00 = &this->WriteBuffer;
    this->QueryOk = true;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e4a5c to 080e4a70 has its CatchHandler @ 080e4ad3
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,'3');
                    // try { // try from 080e4a7b to 080e4a7f has its CatchHandler @ 080e4b10
    TWriteBuffer::writeQuad(this_00,CharacterID);
    TWriteBuffer::writeByte(this_00,Banish);
    iVar1 = executeQuery(this,0x1e,true);
    if (iVar1 == 0) {
        iVar1 = 0;
    }
    else {
        error("TQueryManagerConnection::excludeFromAuctions: Anfrage fehlgeschlagen.\n");
        iVar1 = -1;
    }
    return iVar1;
}



// DWARF original prototype: int transferHouses(TQueryManagerConnection * this, int *
// NumberOfTransfers, ushort * HouseIDs, ulong * NewOwnerIDs, char[30] * NewOwnerNames, int *
// Prices)

int __thiscall
TQueryManagerConnection::transferHouses
          (TQueryManagerConnection *this,int *NumberOfTransfers,ushort *HouseIDs,ulong *NewOwnerIDs,
          char (*NewOwnerNames) [30],int *Prices)

{
    ushort uVar1;
    int iVar2;
    ulong uVar3;
    uint uVar4;
    TReadBuffer *this_00;
    int MaxNumberOfTransfers;
    
    this->QueryOk = true;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e4b65 to 080e4b79 has its CatchHandler @ 080e4c60
    TWriteBuffer::writeWord(&this->WriteBuffer,0);
    TWriteBuffer::writeByte(&this->WriteBuffer,'#');
    iVar2 = executeQuery(this,0x3c,true);
    if (iVar2 == 0) {
        this_00 = &this->ReadBuffer;
        iVar2 = *NumberOfTransfers;
                    // try { // try from 080e4bbb to 080e4bbf has its CatchHandler @ 080e4ca0
        uVar1 = TReadBuffer::readWord(this_00);
        uVar4 = (uint)uVar1;
        *NumberOfTransfers = uVar4;
        if ((int)uVar4 <= iVar2) {
            iVar2 = 0;
            if (uVar4 != 0) {
                do {
                    // try { // try from 080e4bdc to 080e4be0 has its CatchHandler @ 080e4ccb
                    uVar1 = TReadBuffer::readWord(this_00);
                    HouseIDs[iVar2] = uVar1;
                    // try { // try from 080e4bee to 080e4bf2 has its CatchHandler @ 080e4cf6
                    uVar3 = TReadBuffer::readQuad(this_00);
                    NewOwnerIDs[iVar2] = uVar3;
                    // try { // try from 080e4c1a to 080e4c1e has its CatchHandler @ 080e4d24
                    TReadStream::readString(&this_00->super_TReadStream,NewOwnerNames[iVar2],0x1e);
                    // try { // try from 080e4c22 to 080e4c26 has its CatchHandler @ 080e4d5a
                    uVar3 = TReadBuffer::readQuad(this_00);
                    Prices[iVar2] = uVar3;
                    iVar2 = iVar2 + 1;
                } while (iVar2 < *NumberOfTransfers);
            }
            return 0;
        }
        error("TQueryManagerConnection::transferHouses: zu viele Transfers (%d>%d).\n",
              *NumberOfTransfers,iVar2);
    }
    else {
        error("TQueryManagerConnection::transferHouses: Anfrage fehlgeschlagen.\n");
    }
    return -1;
}



// WARNING: Variable defined which should be unmapped: HouseID_local
// DWARF original prototype: int cancelHouseTransfer(TQueryManagerConnection * this, ushort HouseID)

int __thiscall
TQueryManagerConnection::cancelHouseTransfer(TQueryManagerConnection *this,ushort HouseID)

{
    TWriteBuffer *this_00;
    int iVar1;
    ushort HouseID_local;
    
    this_00 = &this->WriteBuffer;
    this->QueryOk = true;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e4dc2 to 080e4dd6 has its CatchHandler @ 080e4e24
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,'4');
                    // try { // try from 080e4de1 to 080e4de5 has its CatchHandler @ 080e4e60
    TWriteBuffer::writeWord(this_00,HouseID);
    iVar1 = executeQuery(this,0x1e,true);
    if (iVar1 == 0) {
        iVar1 = 0;
    }
    else {
        error("TQueryManagerConnection::cancelHouseTransfer: Anfrage fehlgeschlagen.\n");
        iVar1 = -1;
    }
    return iVar1;
}



// DWARF original prototype: int evictFreeAccounts(TQueryManagerConnection * this, int *
// NumberOfEvictions, ushort * HouseIDs, ulong * OwnerIDs)

int __thiscall
TQueryManagerConnection::evictFreeAccounts
          (TQueryManagerConnection *this,int *NumberOfEvictions,ushort *HouseIDs,ulong *OwnerIDs)

{
    ushort uVar1;
    int iVar2;
    ulong uVar3;
    uint uVar4;
    TReadBuffer *this_00;
    int MaxNumberOfEvictions;
    
    this->QueryOk = true;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e4eb5 to 080e4ec9 has its CatchHandler @ 080e4f77
    TWriteBuffer::writeWord(&this->WriteBuffer,0);
    TWriteBuffer::writeByte(&this->WriteBuffer,'$');
    iVar2 = executeQuery(this,0x3c,true);
    if (iVar2 == 0) {
        this_00 = &this->ReadBuffer;
        iVar2 = *NumberOfEvictions;
                    // try { // try from 080e4f0b to 080e4f0f has its CatchHandler @ 080e4fb1
        uVar1 = TReadBuffer::readWord(this_00);
        uVar4 = (uint)uVar1;
        *NumberOfEvictions = uVar4;
        if ((int)uVar4 <= iVar2) {
            iVar2 = 0;
            if (uVar4 != 0) {
                do {
                    // try { // try from 080e4f33 to 080e4f37 has its CatchHandler @ 080e4fdc
                    uVar1 = TReadBuffer::readWord(this_00);
                    HouseIDs[iVar2] = uVar1;
                    // try { // try from 080e4f45 to 080e4f49 has its CatchHandler @ 080e5007
                    uVar3 = TReadBuffer::readQuad(this_00);
                    OwnerIDs[iVar2] = uVar3;
                    iVar2 = iVar2 + 1;
                } while (iVar2 < *NumberOfEvictions);
            }
            return 0;
        }
        error(&DAT_0810ebc0,*NumberOfEvictions,iVar2);
    }
    else {
        error("TQueryManagerConnection::evictFreeAccounts: Anfrage fehlgeschlagen.\n");
    }
    return -1;
}



// DWARF original prototype: int evictDeletedCharacters(TQueryManagerConnection * this, int *
// NumberOfEvictions, ushort * HouseIDs)

int __thiscall
TQueryManagerConnection::evictDeletedCharacters
          (TQueryManagerConnection *this,int *NumberOfEvictions,ushort *HouseIDs)

{
    ushort uVar1;
    int iVar2;
    uint uVar3;
    int MaxNumberOfEvictions;
    
    this->QueryOk = true;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e5055 to 080e5069 has its CatchHandler @ 080e5107
    TWriteBuffer::writeWord(&this->WriteBuffer,0);
    TWriteBuffer::writeByte(&this->WriteBuffer,'%');
    iVar2 = executeQuery(this,0x3c,true);
    if (iVar2 == 0) {
        iVar2 = *NumberOfEvictions;
                    // try { // try from 080e50ae to 080e50b2 has its CatchHandler @ 080e5141
        uVar1 = TReadBuffer::readWord(&this->ReadBuffer);
        uVar3 = (uint)uVar1;
        *NumberOfEvictions = uVar3;
        if ((int)uVar3 <= iVar2) {
            iVar2 = 0;
            if (uVar3 != 0) {
                do {
                    // try { // try from 080e50d6 to 080e50da has its CatchHandler @ 080e5170
                    uVar1 = TReadBuffer::readWord(&this->ReadBuffer);
                    HouseIDs[iVar2] = uVar1;
                    iVar2 = iVar2 + 1;
                } while (iVar2 < *NumberOfEvictions);
            }
            return 0;
        }
        error(&DAT_0810ec80,*NumberOfEvictions,iVar2);
    }
    else {
        error("TQueryManagerConnection::evictDeletedCharacters: Anfrage fehlgeschlagen.\n");
    }
    return -1;
}



// WARNING: Variable defined which should be unmapped: i
// DWARF original prototype: int evictExGuildleaders(TQueryManagerConnection * this, int
// NumberOfGuildhouses, int * NumberOfEvictions, ushort * HouseIDs, ulong * Guildleaders)

int __thiscall
TQueryManagerConnection::evictExGuildleaders
          (TQueryManagerConnection *this,int NumberOfGuildhouses,int *NumberOfEvictions,
          ushort *HouseIDs,ulong *Guildleaders)

{
    TWriteBuffer *this_00;
    ushort uVar1;
    int iVar2;
    int i_1;
    int local_14;
    int i;
    
    this->QueryOk = true;
    this_00 = &this->WriteBuffer;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e51c5 to 080e51d9 has its CatchHandler @ 080e52b0
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,'&');
                    // try { // try from 080e51e5 to 080e51e9 has its CatchHandler @ 080e52f0
    TWriteBuffer::writeWord(this_00,(ushort)NumberOfGuildhouses);
    local_14 = 0;
    if (0 < NumberOfGuildhouses) {
        do {
                    // try { // try from 080e5281 to 080e5285 has its CatchHandler @ 080e5322
            TWriteBuffer::writeWord(this_00,HouseIDs[local_14]);
                    // try { // try from 080e5296 to 080e529a has its CatchHandler @ 080e5350
            TWriteBuffer::writeQuad(this_00,Guildleaders[local_14]);
            local_14 = local_14 + 1;
        } while (local_14 < NumberOfGuildhouses);
    }
    iVar2 = executeQuery(this,0x3c,true);
    if (iVar2 == 0) {
                    // try { // try from 080e5236 to 080e523a has its CatchHandler @ 080e5380
        uVar1 = TReadBuffer::readWord(&this->ReadBuffer);
        *NumberOfEvictions = (uint)uVar1;
        iVar2 = 0;
        if (uVar1 != 0) {
            do {
                    // try { // try from 080e5253 to 080e5257 has its CatchHandler @ 080e53b2
                uVar1 = TReadBuffer::readWord(&this->ReadBuffer);
                HouseIDs[iVar2] = uVar1;
                iVar2 = iVar2 + 1;
            } while (iVar2 < *NumberOfEvictions);
        }
        iVar2 = 0;
    }
    else {
        error("TQueryManagerConnection::evictExGuildleaders: Anfrage fehlgeschlagen.\n");
        iVar2 = -1;
    }
    return iVar2;
}



// WARNING: Variable defined which should be unmapped: HouseID_local
// DWARF original prototype: int insertHouseOwner(TQueryManagerConnection * this, ushort HouseID,
// ulong OwnerID, int PaidUntil)

int __thiscall
TQueryManagerConnection::insertHouseOwner
          (TQueryManagerConnection *this,ushort HouseID,ulong OwnerID,int PaidUntil)

{
    TWriteBuffer *this_00;
    int iVar1;
    ushort HouseID_local;
    
    this_00 = &this->WriteBuffer;
    this->QueryOk = true;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e540c to 080e5420 has its CatchHandler @ 080e5487
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,'\'');
                    // try { // try from 080e542b to 080e542f has its CatchHandler @ 080e54c1
    TWriteBuffer::writeWord(this_00,HouseID);
                    // try { // try from 080e543a to 080e543e has its CatchHandler @ 080e54f2
    TWriteBuffer::writeQuad(this_00,OwnerID);
                    // try { // try from 080e5449 to 080e544d has its CatchHandler @ 080e5522
    TWriteBuffer::writeQuad(this_00,PaidUntil);
    iVar1 = executeQuery(this,0x1e,true);
    if (iVar1 == 0) {
        iVar1 = 0;
    }
    else {
        error("TQueryManagerConnection::insertHouseOwner: Anfrage fehlgeschlagen.\n");
        iVar1 = -1;
    }
    return iVar1;
}



// WARNING: Variable defined which should be unmapped: HouseID_local
// DWARF original prototype: int updateHouseOwner(TQueryManagerConnection * this, ushort HouseID,
// ulong OwnerID, int PaidUntil)

int __thiscall
TQueryManagerConnection::updateHouseOwner
          (TQueryManagerConnection *this,ushort HouseID,ulong OwnerID,int PaidUntil)

{
    TWriteBuffer *this_00;
    int iVar1;
    ushort HouseID_local;
    
    this_00 = &this->WriteBuffer;
    this->QueryOk = true;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e557c to 080e5590 has its CatchHandler @ 080e55f7
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,'(');
                    // try { // try from 080e559b to 080e559f has its CatchHandler @ 080e5631
    TWriteBuffer::writeWord(this_00,HouseID);
                    // try { // try from 080e55aa to 080e55ae has its CatchHandler @ 080e5662
    TWriteBuffer::writeQuad(this_00,OwnerID);
                    // try { // try from 080e55b9 to 080e55bd has its CatchHandler @ 080e5692
    TWriteBuffer::writeQuad(this_00,PaidUntil);
    iVar1 = executeQuery(this,0x1e,true);
    if (iVar1 == 0) {
        iVar1 = 0;
    }
    else {
        error("TQueryManagerConnection::updateHouseOwner: Anfrage fehlgeschlagen.\n");
        iVar1 = -1;
    }
    return iVar1;
}



// WARNING: Variable defined which should be unmapped: HouseID_local
// DWARF original prototype: int deleteHouseOwner(TQueryManagerConnection * this, ushort HouseID)

int __thiscall
TQueryManagerConnection::deleteHouseOwner(TQueryManagerConnection *this,ushort HouseID)

{
    TWriteBuffer *this_00;
    int iVar1;
    ushort HouseID_local;
    
    this_00 = &this->WriteBuffer;
    this->QueryOk = true;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e56f2 to 080e5706 has its CatchHandler @ 080e5754
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,')');
                    // try { // try from 080e5711 to 080e5715 has its CatchHandler @ 080e5790
    TWriteBuffer::writeWord(this_00,HouseID);
    iVar1 = executeQuery(this,0x1e,true);
    if (iVar1 == 0) {
        iVar1 = 0;
    }
    else {
        error("TQueryManagerConnection::deleteHouseOwner: Anfrage fehlgeschlagen.\n");
        iVar1 = -1;
    }
    return iVar1;
}



// DWARF original prototype: int getHouseOwners(TQueryManagerConnection * this, int *
// NumberOfHouses, ushort * HouseIDs, ulong * OwnerIDs, char[30] * OwnerNames, int * PaidUntils)

int __thiscall
TQueryManagerConnection::getHouseOwners
          (TQueryManagerConnection *this,int *NumberOfHouses,ushort *HouseIDs,ulong *OwnerIDs,
          char (*OwnerNames) [30],int *PaidUntils)

{
    ushort uVar1;
    int iVar2;
    ulong uVar3;
    uint uVar4;
    TReadBuffer *this_00;
    int MaxNumberOfHouses;
    
    this->QueryOk = true;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e57e5 to 080e57f9 has its CatchHandler @ 080e58e0
    TWriteBuffer::writeWord(&this->WriteBuffer,0);
    TWriteBuffer::writeByte(&this->WriteBuffer,'*');
    iVar2 = executeQuery(this,0x3c,true);
    if (iVar2 == 0) {
        this_00 = &this->ReadBuffer;
        iVar2 = *NumberOfHouses;
                    // try { // try from 080e583b to 080e583f has its CatchHandler @ 080e5920
        uVar1 = TReadBuffer::readWord(this_00);
        uVar4 = (uint)uVar1;
        *NumberOfHouses = uVar4;
        if ((int)uVar4 <= iVar2) {
            iVar2 = 0;
            if (uVar4 != 0) {
                do {
                    // try { // try from 080e585c to 080e5860 has its CatchHandler @ 080e594b
                    uVar1 = TReadBuffer::readWord(this_00);
                    HouseIDs[iVar2] = uVar1;
                    // try { // try from 080e586e to 080e5872 has its CatchHandler @ 080e5976
                    uVar3 = TReadBuffer::readQuad(this_00);
                    OwnerIDs[iVar2] = uVar3;
                    // try { // try from 080e589a to 080e589e has its CatchHandler @ 080e59a4
                    TReadStream::readString(&this_00->super_TReadStream,OwnerNames[iVar2],0x1e);
                    // try { // try from 080e58a2 to 080e58a6 has its CatchHandler @ 080e59da
                    uVar3 = TReadBuffer::readQuad(this_00);
                    PaidUntils[iVar2] = uVar3;
                    iVar2 = iVar2 + 1;
                } while (iVar2 < *NumberOfHouses);
            }
            return 0;
        }
        error(&DAT_0810eec0,*NumberOfHouses,iVar2);
    }
    else {
        error("TQueryManagerConnection::getHouseOwners: Anfrage fehlgeschlagen.\n");
    }
    return -1;
}



// DWARF original prototype: int getAuctions(TQueryManagerConnection * this, int * NumberOfAuctions,
// ushort * HouseIDs)

int __thiscall
TQueryManagerConnection::getAuctions
          (TQueryManagerConnection *this,int *NumberOfAuctions,ushort *HouseIDs)

{
    ushort uVar1;
    int iVar2;
    uint uVar3;
    int MaxNumberOfAuctions;
    
    this->QueryOk = true;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e5a35 to 080e5a49 has its CatchHandler @ 080e5ae7
    TWriteBuffer::writeWord(&this->WriteBuffer,0);
    TWriteBuffer::writeByte(&this->WriteBuffer,'+');
    iVar2 = executeQuery(this,0x78,true);
    if (iVar2 == 0) {
        iVar2 = *NumberOfAuctions;
                    // try { // try from 080e5a8e to 080e5a92 has its CatchHandler @ 080e5b21
        uVar1 = TReadBuffer::readWord(&this->ReadBuffer);
        uVar3 = (uint)uVar1;
        *NumberOfAuctions = uVar3;
        if ((int)uVar3 <= iVar2) {
            iVar2 = 0;
            if (uVar3 != 0) {
                do {
                    // try { // try from 080e5ab6 to 080e5aba has its CatchHandler @ 080e5b50
                    uVar1 = TReadBuffer::readWord(&this->ReadBuffer);
                    HouseIDs[iVar2] = uVar1;
                    iVar2 = iVar2 + 1;
                } while (iVar2 < *NumberOfAuctions);
            }
            return 0;
        }
        error("TQueryManagerConnection::getAuctions: zu viele Auktionen (%d>%d).\n",
              *NumberOfAuctions,iVar2);
    }
    else {
        error("TQueryManagerConnection::getAuctions: Anfrage fehlgeschlagen.\n");
    }
    return -1;
}



// WARNING: Variable defined which should be unmapped: HouseID_local
// DWARF original prototype: int startAuction(TQueryManagerConnection * this, ushort HouseID)

int __thiscall TQueryManagerConnection::startAuction(TQueryManagerConnection *this,ushort HouseID)

{
    TWriteBuffer *this_00;
    int iVar1;
    ushort HouseID_local;
    
    this_00 = &this->WriteBuffer;
    this->QueryOk = true;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e5bb2 to 080e5bc6 has its CatchHandler @ 080e5c14
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,',');
                    // try { // try from 080e5bd1 to 080e5bd5 has its CatchHandler @ 080e5c50
    TWriteBuffer::writeWord(this_00,HouseID);
    iVar1 = executeQuery(this,0x1e,true);
    if (iVar1 == 0) {
        iVar1 = 0;
    }
    else {
        error("TQueryManagerConnection::startAuction: Anfrage fehlgeschlagen.\n");
        iVar1 = -1;
    }
    return iVar1;
}



// WARNING: Variable defined which should be unmapped: i
// DWARF original prototype: int insertHouses(TQueryManagerConnection * this, int NumberOfHouses,
// ushort * HouseIDs, char * * Names, int * Rents, char * * Descriptions, int * Sizes, int *
// PositionsX, int * PositionsY, int * PositionsZ, char[30] * Towns, bool * Guildhouses)

int __thiscall
TQueryManagerConnection::insertHouses
          (TQueryManagerConnection *this,int NumberOfHouses,ushort *HouseIDs,char **Names,int *Rents
          ,char **Descriptions,int *Sizes,int *PositionsX,int *PositionsY,int *PositionsZ,
          char (*Towns) [30],bool *Guildhouses)

{
    TWriteBuffer *this_00;
    int iVar1;
    int local_14;
    int i;
    
    this->QueryOk = true;
    this_00 = &this->WriteBuffer;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e5ca5 to 080e5cb9 has its CatchHandler @ 080e5e10
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,'-');
                    // try { // try from 080e5cc5 to 080e5cc9 has its CatchHandler @ 080e5e50
    TWriteBuffer::writeWord(this_00,(ushort)NumberOfHouses);
    local_14 = 0;
    if (0 < NumberOfHouses) {
        do {
                    // try { // try from 080e5d23 to 080e5d27 has its CatchHandler @ 080e5e82
            TWriteBuffer::writeWord(this_00,HouseIDs[local_14]);
                    // try { // try from 080e5d38 to 080e5d3c has its CatchHandler @ 080e5eaf
            TWriteStream::writeString(&this_00->super_TWriteStream,Names[local_14]);
                    // try { // try from 080e5d4d to 080e5d51 has its CatchHandler @ 080e5edf
            TWriteBuffer::writeQuad(this_00,Rents[local_14]);
                    // try { // try from 080e5d62 to 080e5d66 has its CatchHandler @ 080e5f13
            TWriteStream::writeString(&this_00->super_TWriteStream,Descriptions[local_14]);
                    // try { // try from 080e5d78 to 080e5d7c has its CatchHandler @ 080e5f47
            TWriteBuffer::writeWord(this_00,*(ushort *)(Sizes + local_14));
                    // try { // try from 080e5d8e to 080e5d92 has its CatchHandler @ 080e5f7b
            TWriteBuffer::writeWord(this_00,*(ushort *)(PositionsX + local_14));
                    // try { // try from 080e5da4 to 080e5da8 has its CatchHandler @ 080e5faf
            TWriteBuffer::writeWord(this_00,*(ushort *)(PositionsY + local_14));
                    // try { // try from 080e5dba to 080e5dbe has its CatchHandler @ 080e5fe3
            TWriteBuffer::writeByte(this_00,(uchar)PositionsZ[local_14]);
                    // try { // try from 080e5dd7 to 080e5ddb has its CatchHandler @ 080e6017
            TWriteStream::writeString(&this_00->super_TWriteStream,Towns[local_14]);
                    // try { // try from 080e5df3 to 080e5df7 has its CatchHandler @ 080e604b
            TWriteBuffer::writeByte(this_00,Guildhouses[local_14] != false);
            local_14 = local_14 + 1;
        } while (local_14 < NumberOfHouses);
    }
    iVar1 = executeQuery(this,0x3c,true);
    if (iVar1 == 0) {
        iVar1 = 0;
    }
    else {
        error("TQueryManagerConnection::insertHouses: Anfrage fehlgeschlagen.\n");
        iVar1 = -1;
    }
    return iVar1;
}



// DWARF original prototype: int clearIsOnline(TQueryManagerConnection * this, int *
// NumberOfAffectedPlayers)

int __thiscall
TQueryManagerConnection::clearIsOnline(TQueryManagerConnection *this,int *NumberOfAffectedPlayers)

{
    ushort uVar1;
    int iVar2;
    
    this->QueryOk = true;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e60a8 to 080e60bc has its CatchHandler @ 080e6110
    TWriteBuffer::writeWord(&this->WriteBuffer,0);
    TWriteBuffer::writeByte(&this->WriteBuffer,'.');
    iVar2 = executeQuery(this,0x78,true);
    if (iVar2 == 0) {
                    // try { // try from 080e60fa to 080e60fe has its CatchHandler @ 080e6147
        uVar1 = TReadBuffer::readWord(&this->ReadBuffer);
        *NumberOfAffectedPlayers = (uint)uVar1;
        iVar2 = 0;
    }
    else {
        error("TQueryManagerConnection::clearIsOnline: Anfrage fehlgeschlagen.\n");
        iVar2 = -1;
    }
    return iVar2;
}



// DWARF original prototype: int createPlayerlist(TQueryManagerConnection * this, int
// NumberOfPlayers, char * * Names, int * Levels, char[30] * Professions, bool * NewRecord)

int __thiscall
TQueryManagerConnection::createPlayerlist
          (TQueryManagerConnection *this,int NumberOfPlayers,char **Names,int *Levels,
          char (*Professions) [30],bool *NewRecord)

{
    uchar uVar1;
    ushort w;
    TWriteBuffer *this_00;
    int i;
    int iVar2;
    
    this->QueryOk = true;
    this_00 = &this->WriteBuffer;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e6197 to 080e61ab has its CatchHandler @ 080e6270
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,'/');
    w = 0xffff;
    if (-1 < NumberOfPlayers) {
        w = (ushort)NumberOfPlayers;
    }
                    // try { // try from 080e61c4 to 080e61c8 has its CatchHandler @ 080e62b0
    TWriteBuffer::writeWord(this_00,w);
    iVar2 = 0;
    if (0 < NumberOfPlayers) {
        do {
                    // try { // try from 080e6232 to 080e6236 has its CatchHandler @ 080e62e2
            TWriteStream::writeString(&this_00->super_TWriteStream,Names[iVar2]);
                    // try { // try from 080e6245 to 080e6249 has its CatchHandler @ 080e6312
            TWriteBuffer::writeWord(this_00,*(ushort *)(Levels + iVar2));
                    // try { // try from 080e625e to 080e6262 has its CatchHandler @ 080e6345
            TWriteStream::writeString(&this_00->super_TWriteStream,Professions[iVar2]);
            iVar2 = iVar2 + 1;
        } while (iVar2 < NumberOfPlayers);
    }
    iVar2 = executeQuery(this,0xf0,true);
    if (iVar2 == 0) {
                    // try { // try from 080e6211 to 080e6215 has its CatchHandler @ 080e637c
        uVar1 = TReadBuffer::readByte(&this->ReadBuffer);
        *NewRecord = uVar1 != '\0';
        iVar2 = 0;
    }
    else {
        error("TQueryManagerConnection::createPlayerlist: Anfrage fehlgeschlagen.\n");
        iVar2 = -1;
    }
    return iVar2;
}



// WARNING: Variable defined which should be unmapped: i
// DWARF original prototype: int logKilledCreatures(TQueryManagerConnection * this, int
// NumberOfRaces, char * * Names, int * KilledPlayers, int * KilledCreatures)

int __thiscall
TQueryManagerConnection::logKilledCreatures
          (TQueryManagerConnection *this,int NumberOfRaces,char **Names,int *KilledPlayers,
          int *KilledCreatures)

{
    TWriteBuffer *this_00;
    int iVar1;
    int local_14;
    int i;
    
    this->QueryOk = true;
    this_00 = &this->WriteBuffer;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e63d5 to 080e63e9 has its CatchHandler @ 080e6491
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,'0');
                    // try { // try from 080e63f5 to 080e63f9 has its CatchHandler @ 080e64d0
    TWriteBuffer::writeWord(this_00,(ushort)NumberOfRaces);
    local_14 = 0;
    if (0 < NumberOfRaces) {
        do {
                    // try { // try from 080e6452 to 080e6456 has its CatchHandler @ 080e6502
            TWriteStream::writeString(&this_00->super_TWriteStream,Names[local_14]);
                    // try { // try from 080e6467 to 080e646b has its CatchHandler @ 080e6530
            TWriteBuffer::writeQuad(this_00,KilledPlayers[local_14]);
                    // try { // try from 080e647c to 080e6480 has its CatchHandler @ 080e6560
            TWriteBuffer::writeQuad(this_00,KilledCreatures[local_14]);
            local_14 = local_14 + 1;
        } while (local_14 < NumberOfRaces);
    }
    iVar1 = executeQuery(this,0xf0,true);
    if (iVar1 == 0) {
        iVar1 = 0;
    }
    else {
        error("TQueryManagerConnection::logKilledCreatures: Anfrage fehlgeschlagen.\n");
        iVar1 = -1;
    }
    return iVar1;
}



// DWARF original prototype: int loadPlayers(TQueryManagerConnection * this, ulong
// MinimumCharacterID, int * NumberOfPlayers, char[30] * Names, ulong * CharacterIDs)

int __thiscall
TQueryManagerConnection::loadPlayers
          (TQueryManagerConnection *this,ulong MinimumCharacterID,int *NumberOfPlayers,
          char (*Names) [30],ulong *CharacterIDs)

{
    TWriteBuffer *this_00;
    int iVar1;
    ulong uVar2;
    int i;
    TReadBuffer *this_01;
    
    this->QueryOk = true;
    this_00 = &this->WriteBuffer;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e65b5 to 080e65c9 has its CatchHandler @ 080e6670
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,'2');
                    // try { // try from 080e65d4 to 080e65d8 has its CatchHandler @ 080e66b0
    TWriteBuffer::writeQuad(this_00,MinimumCharacterID);
    iVar1 = executeQuery(this,900,true);
    if (iVar1 == 0) {
        this_01 = &this->ReadBuffer;
                    // try { // try from 080e6616 to 080e661a has its CatchHandler @ 080e66e2
        uVar2 = TReadBuffer::readQuad(this_01);
        iVar1 = 0;
        *NumberOfPlayers = uVar2;
        if (0 < (int)uVar2) {
            do {
                    // try { // try from 080e664f to 080e6653 has its CatchHandler @ 080e670d
                TReadStream::readString(&this_01->super_TReadStream,Names[iVar1],0x1e);
                    // try { // try from 080e6657 to 080e665b has its CatchHandler @ 080e673f
                uVar2 = TReadBuffer::readQuad(this_01);
                CharacterIDs[iVar1] = uVar2;
                iVar1 = iVar1 + 1;
            } while (iVar1 < *NumberOfPlayers);
        }
        iVar1 = 0;
    }
    else {
        error("TQueryManagerConnection::loadPlayers: Anfrage fehlgeschlagen.\n");
        iVar1 = -1;
    }
    return iVar1;
}



// DWARF original prototype: int getKeptCharacters(TQueryManagerConnection * this, ulong
// MinimumCharacterID, int * NumberOfPlayers, ulong * CharacterIDs)

int __thiscall
TQueryManagerConnection::getKeptCharacters
          (TQueryManagerConnection *this,ulong MinimumCharacterID,int *NumberOfPlayers,
          ulong *CharacterIDs)

{
    TWriteBuffer *this_00;
    int iVar1;
    ulong uVar2;
    int i;
    
    this->QueryOk = true;
    this_00 = &this->WriteBuffer;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e6795 to 080e67a9 has its CatchHandler @ 080e6830
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,200);
                    // try { // try from 080e67b4 to 080e67b8 has its CatchHandler @ 080e6870
    TWriteBuffer::writeQuad(this_00,MinimumCharacterID);
    iVar1 = executeQuery(this,0x708,true);
    if (iVar1 == 0) {
                    // try { // try from 080e67f6 to 080e67fa has its CatchHandler @ 080e68a2
        uVar2 = TReadBuffer::readQuad(&this->ReadBuffer);
        iVar1 = 0;
        *NumberOfPlayers = uVar2;
        if (0 < (int)uVar2) {
            do {
                    // try { // try from 080e6813 to 080e6817 has its CatchHandler @ 080e68d0
                uVar2 = TReadBuffer::readQuad(&this->ReadBuffer);
                CharacterIDs[iVar1] = uVar2;
                iVar1 = iVar1 + 1;
            } while (iVar1 < *NumberOfPlayers);
        }
        iVar1 = 0;
    }
    else {
        error("TQueryManagerConnection::getKeptCharacters: Anfrage fehlgeschlagen.\n");
        iVar1 = -1;
    }
    return iVar1;
}



// DWARF original prototype: int getDeletedCharacters(TQueryManagerConnection * this, ulong
// MinimumCharacterID, int * NumberOfPlayers, ulong * CharacterIDs)

int __thiscall
TQueryManagerConnection::getDeletedCharacters
          (TQueryManagerConnection *this,ulong MinimumCharacterID,int *NumberOfPlayers,
          ulong *CharacterIDs)

{
    TWriteBuffer *this_00;
    int iVar1;
    ulong uVar2;
    int i;
    
    this->QueryOk = true;
    this_00 = &this->WriteBuffer;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e6925 to 080e6939 has its CatchHandler @ 080e69c0
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,0xc9);
                    // try { // try from 080e6944 to 080e6948 has its CatchHandler @ 080e6a00
    TWriteBuffer::writeQuad(this_00,MinimumCharacterID);
    iVar1 = executeQuery(this,900,true);
    if (iVar1 == 0) {
                    // try { // try from 080e6986 to 080e698a has its CatchHandler @ 080e6a32
        uVar2 = TReadBuffer::readQuad(&this->ReadBuffer);
        iVar1 = 0;
        *NumberOfPlayers = uVar2;
        if (0 < (int)uVar2) {
            do {
                    // try { // try from 080e69a3 to 080e69a7 has its CatchHandler @ 080e6a60
                uVar2 = TReadBuffer::readQuad(&this->ReadBuffer);
                CharacterIDs[iVar1] = uVar2;
                iVar1 = iVar1 + 1;
            } while (iVar1 < *NumberOfPlayers);
        }
        iVar1 = 0;
    }
    else {
        error("TQueryManagerConnection::getKeptCharacters: Anfrage fehlgeschlagen.\n");
        iVar1 = -1;
    }
    return iVar1;
}



// DWARF original prototype: int deleteOldCharacter(TQueryManagerConnection * this, ulong
// CharacterID)

int __thiscall
TQueryManagerConnection::deleteOldCharacter(TQueryManagerConnection *this,ulong CharacterID)

{
    TWriteBuffer *this_00;
    int iVar1;
    
    this_00 = &this->WriteBuffer;
    this->QueryOk = true;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e6abb to 080e6acf has its CatchHandler @ 080e6b23
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,0xca);
                    // try { // try from 080e6ada to 080e6ade has its CatchHandler @ 080e6b60
    TWriteBuffer::writeQuad(this_00,CharacterID);
    iVar1 = executeQuery(this,0x1e,true);
    if (iVar1 == 0) {
        iVar1 = 0;
    }
    else {
        error("TQueryManagerConnection::deleteOldCharacter: Anfrage fehlgeschlagen.\n");
        iVar1 = -1;
    }
    return iVar1;
}



// DWARF original prototype: int getHiddenCharacters(TQueryManagerConnection * this, ulong
// MinimumCharacterID, int * NumberOfPlayers, ulong * CharacterIDs)

int __thiscall
TQueryManagerConnection::getHiddenCharacters
          (TQueryManagerConnection *this,ulong MinimumCharacterID,int *NumberOfPlayers,
          ulong *CharacterIDs)

{
    TWriteBuffer *this_00;
    int iVar1;
    ulong uVar2;
    int i;
    
    this->QueryOk = true;
    this_00 = &this->WriteBuffer;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e6bb5 to 080e6bc9 has its CatchHandler @ 080e6c50
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,0xcb);
                    // try { // try from 080e6bd4 to 080e6bd8 has its CatchHandler @ 080e6c90
    TWriteBuffer::writeQuad(this_00,MinimumCharacterID);
    iVar1 = executeQuery(this,0x78,true);
    if (iVar1 == 0) {
                    // try { // try from 080e6c16 to 080e6c1a has its CatchHandler @ 080e6cc2
        uVar2 = TReadBuffer::readQuad(&this->ReadBuffer);
        iVar1 = 0;
        *NumberOfPlayers = uVar2;
        if (0 < (int)uVar2) {
            do {
                    // try { // try from 080e6c33 to 080e6c37 has its CatchHandler @ 080e6cf0
                uVar2 = TReadBuffer::readQuad(&this->ReadBuffer);
                CharacterIDs[iVar1] = uVar2;
                iVar1 = iVar1 + 1;
            } while (iVar1 < *NumberOfPlayers);
        }
        iVar1 = 0;
    }
    else {
        error("TQueryManagerConnection::getHiddenCharacters: Anfrage fehlgeschlagen.\n");
        iVar1 = -1;
    }
    return iVar1;
}



// WARNING: Variable defined which should be unmapped: i
// DWARF original prototype: int createHighscores(TQueryManagerConnection * this, int
// NumberOfPlayers, ulong * CharacterIDs, int * ExpPoints, int * ExpLevel, int * Fist, int * Club,
// int * Axe, int * Sword, int * Distance, int * Shielding, int * Magic, int * Fishing)

int __thiscall
TQueryManagerConnection::createHighscores
          (TQueryManagerConnection *this,int NumberOfPlayers,ulong *CharacterIDs,int *ExpPoints,
          int *ExpLevel,int *Fist,int *Club,int *Axe,int *Sword,int *Distance,int *Shielding,
          int *Magic,int *Fishing)

{
    TWriteBuffer *this_00;
    int iVar1;
    int local_14;
    int i;
    
    this->QueryOk = true;
    this_00 = &this->WriteBuffer;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e6d45 to 080e6d59 has its CatchHandler @ 080e6eb5
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,0xcc);
                    // try { // try from 080e6d64 to 080e6d68 has its CatchHandler @ 080e6ef0
    TWriteBuffer::writeQuad(this_00,NumberOfPlayers);
    local_14 = 0;
    if (0 < NumberOfPlayers) {
        do {
                    // try { // try from 080e6dc1 to 080e6dc5 has its CatchHandler @ 080e6f22
            TWriteBuffer::writeQuad(this_00,CharacterIDs[local_14]);
                    // try { // try from 080e6dd6 to 080e6dda has its CatchHandler @ 080e6f4f
            TWriteBuffer::writeQuad(this_00,ExpPoints[local_14]);
                    // try { // try from 080e6dec to 080e6df0 has its CatchHandler @ 080e6f7f
            TWriteBuffer::writeWord(this_00,*(ushort *)(ExpLevel + local_14));
                    // try { // try from 080e6e02 to 080e6e06 has its CatchHandler @ 080e6fb3
            TWriteBuffer::writeWord(this_00,*(ushort *)(Fist + local_14));
                    // try { // try from 080e6e18 to 080e6e1c has its CatchHandler @ 080e6fe7
            TWriteBuffer::writeWord(this_00,*(ushort *)(Club + local_14));
                    // try { // try from 080e6e2e to 080e6e32 has its CatchHandler @ 080e701b
            TWriteBuffer::writeWord(this_00,*(ushort *)(Axe + local_14));
                    // try { // try from 080e6e44 to 080e6e48 has its CatchHandler @ 080e704f
            TWriteBuffer::writeWord(this_00,*(ushort *)(Sword + local_14));
                    // try { // try from 080e6e5a to 080e6e5e has its CatchHandler @ 080e7083
            TWriteBuffer::writeWord(this_00,*(ushort *)(Distance + local_14));
                    // try { // try from 080e6e70 to 080e6e74 has its CatchHandler @ 080e70b7
            TWriteBuffer::writeWord(this_00,*(ushort *)(Shielding + local_14));
                    // try { // try from 080e6e86 to 080e6e8a has its CatchHandler @ 080e70eb
            TWriteBuffer::writeWord(this_00,*(ushort *)(Magic + local_14));
                    // try { // try from 080e6e9c to 080e6ea0 has its CatchHandler @ 080e711f
            TWriteBuffer::writeWord(this_00,*(ushort *)(Fishing + local_14));
            local_14 = local_14 + 1;
        } while (local_14 < NumberOfPlayers);
    }
    iVar1 = executeQuery(this,0x78,true);
    if (iVar1 == 0) {
        iVar1 = 0;
    }
    else {
        error("TQueryManagerConnection::createHighscores: Anfrage fehlgeschlagen.\n");
        iVar1 = -1;
    }
    return iVar1;
}



// DWARF original prototype: int createCensus(TQueryManagerConnection * this)

int __thiscall TQueryManagerConnection::createCensus(TQueryManagerConnection *this)

{
    int iVar1;
    
    this->QueryOk = true;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e7178 to 080e718c has its CatchHandler @ 080e71c8
    TWriteBuffer::writeWord(&this->WriteBuffer,0);
    TWriteBuffer::writeByte(&this->WriteBuffer,0xcd);
    iVar1 = executeQuery(this,600,true);
    if (iVar1 == 0) {
        iVar1 = 0;
    }
    else {
        error("TQueryManagerConnection::createCensus: Anfrage fehlgeschlagen.\n");
        iVar1 = -1;
    }
    return iVar1;
}



// DWARF original prototype: int createKillStatistics(TQueryManagerConnection * this)

int __thiscall TQueryManagerConnection::createKillStatistics(TQueryManagerConnection *this)

{
    int iVar1;
    
    this->QueryOk = true;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e7228 to 080e723c has its CatchHandler @ 080e7278
    TWriteBuffer::writeWord(&this->WriteBuffer,0);
    TWriteBuffer::writeByte(&this->WriteBuffer,0xce);
    iVar1 = executeQuery(this,300,true);
    if (iVar1 == 0) {
        iVar1 = 0;
    }
    else {
        error("TQueryManagerConnection::createKillStatistics: Anfrage fehlgeschlagen.\n");
        iVar1 = -1;
    }
    return iVar1;
}



// DWARF original prototype: int getPlayersOnline(TQueryManagerConnection * this, int *
// NumberOfWorlds, char[30] * Names, ushort * Players)

int __thiscall
TQueryManagerConnection::getPlayersOnline
          (TQueryManagerConnection *this,int *NumberOfWorlds,char (*Names) [30],ushort *Players)

{
    TReadBuffer *this_00;
    byte bVar1;
    ushort uVar2;
    int iVar3;
    
    this->QueryOk = true;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e72d5 to 080e72e9 has its CatchHandler @ 080e7380
    TWriteBuffer::writeWord(&this->WriteBuffer,0);
    TWriteBuffer::writeByte(&this->WriteBuffer,0xcf);
    iVar3 = executeQuery(this,0x78,true);
    if (iVar3 == 0) {
        this_00 = &this->ReadBuffer;
                    // try { // try from 080e7326 to 080e732a has its CatchHandler @ 080e73c0
        bVar1 = TReadBuffer::readByte(this_00);
        iVar3 = 0;
        *NumberOfWorlds = (uint)bVar1;
        if (bVar1 != 0) {
            do {
                    // try { // try from 080e735f to 080e7363 has its CatchHandler @ 080e73eb
                TReadStream::readString(&this_00->super_TReadStream,Names[iVar3],0x1e);
                    // try { // try from 080e7367 to 080e736b has its CatchHandler @ 080e741a
                uVar2 = TReadBuffer::readWord(this_00);
                Players[iVar3] = uVar2;
                iVar3 = iVar3 + 1;
            } while (iVar3 < *NumberOfWorlds);
        }
        iVar3 = 0;
    }
    else {
        error("TQueryManagerConnection::getPlayersOnline: Anfrage fehlgeschlagen.\n");
        iVar3 = -1;
    }
    return iVar3;
}



// DWARF original prototype: int getWorlds(TQueryManagerConnection * this, int * NumberOfWorlds,
// char[30] * Names)

int __thiscall
TQueryManagerConnection::getWorlds
          (TQueryManagerConnection *this,int *NumberOfWorlds,char (*Names) [30])

{
    byte bVar1;
    int iVar2;
    
    this->QueryOk = true;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e7475 to 080e7489 has its CatchHandler @ 080e7511
    TWriteBuffer::writeWord(&this->WriteBuffer,0);
    TWriteBuffer::writeByte(&this->WriteBuffer,0xd0);
    iVar2 = executeQuery(this,0x78,true);
    if (iVar2 == 0) {
                    // try { // try from 080e74c9 to 080e74cd has its CatchHandler @ 080e7550
        bVar1 = TReadBuffer::readByte(&this->ReadBuffer);
        iVar2 = 0;
        *NumberOfWorlds = (uint)bVar1;
        if (bVar1 != 0) {
            do {
                    // try { // try from 080e7502 to 080e7506 has its CatchHandler @ 080e7580
                TReadStream::readString(&(this->ReadBuffer).super_TReadStream,Names[iVar2],0x1e);
                iVar2 = iVar2 + 1;
            } while (iVar2 < *NumberOfWorlds);
        }
        iVar2 = 0;
    }
    else {
        error("TQueryManagerConnection::getWorlds: Anfrage fehlgeschlagen.\n");
        iVar2 = -1;
    }
    return iVar2;
}



// DWARF original prototype: int getServerLoad(TQueryManagerConnection * this, char * World, int
// Period, int * Data)

int __thiscall
TQueryManagerConnection::getServerLoad
          (TQueryManagerConnection *this,char *World,int Period,int *Data)

{
    TWriteBuffer *this_00;
    ushort uVar1;
    int iVar2;
    uint uVar3;
    ushort Value;
    int i;
    
    this->QueryOk = true;
    this_00 = &this->WriteBuffer;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e75d5 to 080e75e9 has its CatchHandler @ 080e7673
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,0xd1);
                    // try { // try from 080e75f4 to 080e75f8 has its CatchHandler @ 080e76b0
    TWriteStream::writeString(&this_00->super_TWriteStream,World);
                    // try { // try from 080e7607 to 080e760b has its CatchHandler @ 080e76e2
    TWriteBuffer::writeByte(this_00,(uchar)Period);
    iVar2 = executeQuery(this,0x168,true);
    if (iVar2 == 0) {
        iVar2 = 0;
        do {
                    // try { // try from 080e7630 to 080e7634 has its CatchHandler @ 080e7712
            uVar1 = TReadBuffer::readWord(&this->ReadBuffer);
            uVar3 = 0xffffffff;
            if (uVar1 != 0xffff) {
                uVar3 = (uint)uVar1;
            }
            Data[iVar2] = uVar3;
            iVar2 = iVar2 + 1;
        } while (iVar2 < 600);
        iVar2 = 0;
    }
    else {
        error("TQueryManagerConnection::getServerLoad: Anfrage fehlgeschlagen.\n");
        iVar2 = -1;
    }
    return iVar2;
}



// DWARF original prototype: int insertPaymentDataOld(TQueryManagerConnection * this, ulong
// PurchaseNr, ulong ReferenceNr, char * FirstName, char * LastName, char * Company, char * Street,
// char * Zip, char * City, char * Country, char * State, char * Phone, char * Fax, char * EMail,
// char * PaymentMethod, ulong ProductID, char * Registrant, ulong AccountID, ulong * PaymentID)

int __thiscall TQueryManagerConnection::insertPaymentDataOld(TQueryManagerConnection *this)

{
    TWriteBuffer *this_00;
    byte bVar1;
    int iVar2;
    ulong uVar3;
    ulong in_stack_00000008;
    ulong in_stack_0000000c;
    char *in_stack_00000010;
    char *in_stack_00000014;
    char *in_stack_00000018;
    char *in_stack_0000001c;
    char *in_stack_00000020;
    char *in_stack_00000024;
    char *in_stack_00000028;
    char *in_stack_0000002c;
    char *in_stack_00000030;
    char *in_stack_00000034;
    char *in_stack_00000038;
    char *in_stack_0000003c;
    ulong in_stack_00000040;
    char *in_stack_00000044;
    ulong in_stack_00000048;
    ulong *in_stack_0000004c;
    
    this->QueryOk = true;
    this_00 = &this->WriteBuffer;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e7765 to 080e7779 has its CatchHandler @ 080e78f6
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,0xd2);
                    // try { // try from 080e7784 to 080e7788 has its CatchHandler @ 080e7930
    TWriteBuffer::writeQuad(this_00,in_stack_00000008);
                    // try { // try from 080e7793 to 080e7797 has its CatchHandler @ 080e7962
    TWriteBuffer::writeQuad(this_00,in_stack_0000000c);
                    // try { // try from 080e77a2 to 080e77a6 has its CatchHandler @ 080e7992
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000010);
                    // try { // try from 080e77b1 to 080e77b5 has its CatchHandler @ 080e79c2
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000014);
                    // try { // try from 080e77c0 to 080e77c4 has its CatchHandler @ 080e79f6
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000018);
                    // try { // try from 080e77cf to 080e77d3 has its CatchHandler @ 080e7a2a
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_0000001c);
                    // try { // try from 080e77de to 080e77e2 has its CatchHandler @ 080e7a5e
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000020);
                    // try { // try from 080e77ed to 080e77f1 has its CatchHandler @ 080e7a92
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000024);
                    // try { // try from 080e77fc to 080e7800 has its CatchHandler @ 080e7ac6
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000028);
                    // try { // try from 080e780b to 080e780f has its CatchHandler @ 080e7afa
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_0000002c);
                    // try { // try from 080e781a to 080e781e has its CatchHandler @ 080e7b2e
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000030);
                    // try { // try from 080e7829 to 080e782d has its CatchHandler @ 080e7b62
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000034);
                    // try { // try from 080e7838 to 080e783c has its CatchHandler @ 080e7b96
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000038);
                    // try { // try from 080e7847 to 080e784b has its CatchHandler @ 080e7bca
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_0000003c);
                    // try { // try from 080e7856 to 080e785a has its CatchHandler @ 080e7bfe
    TWriteBuffer::writeQuad(this_00,in_stack_00000040);
                    // try { // try from 080e7865 to 080e7869 has its CatchHandler @ 080e7c32
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000044);
                    // try { // try from 080e7874 to 080e7878 has its CatchHandler @ 080e7c66
    TWriteBuffer::writeQuad(this_00,in_stack_00000048);
    iVar2 = executeQuery(this,0x168,true);
    if (iVar2 == 0) {
                    // try { // try from 080e78e6 to 080e78ea has its CatchHandler @ 080e7c9a
        uVar3 = TReadBuffer::readQuad(&this->ReadBuffer);
        *in_stack_0000004c = uVar3;
        iVar2 = 0;
    }
    else {
        if (iVar2 == 1) {
                    // try { // try from 080e78b7 to 080e78bb has its CatchHandler @ 080e7ccc
            bVar1 = TReadBuffer::readByte(&this->ReadBuffer);
            if (bVar1 == 1) {
                return 1;
            }
            error(&DAT_0810f520,(uint)bVar1);
        }
        else {
            error("TQueryManagerConnection::insertPaymentDataOld: Anfrage fehlgeschlagen.\n");
        }
        iVar2 = -1;
    }
    return iVar2;
}



// DWARF original prototype: int addPaymentOld(TQueryManagerConnection * this, ulong AccountID, char
// * Description, ulong PaymentID, int Days, int * ActionTaken)

int __thiscall TQueryManagerConnection::addPaymentOld(TQueryManagerConnection *this)

{
    TWriteBuffer *this_00;
    bool bVar1;
    byte bVar2;
    int iVar3;
    int FailureCode;
    uint uVar4;
    ulong in_stack_00000008;
    char *in_stack_0000000c;
    ulong in_stack_00000010;
    ushort in_stack_00000014;
    uint *in_stack_00000018;
    
    this->QueryOk = true;
    this_00 = &this->WriteBuffer;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e7d25 to 080e7d39 has its CatchHandler @ 080e7e06
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,0xd3);
                    // try { // try from 080e7d44 to 080e7d48 has its CatchHandler @ 080e7e40
    TWriteBuffer::writeQuad(this_00,in_stack_00000008);
                    // try { // try from 080e7d53 to 080e7d57 has its CatchHandler @ 080e7e72
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_0000000c);
                    // try { // try from 080e7d62 to 080e7d66 has its CatchHandler @ 080e7ea2
    TWriteBuffer::writeQuad(this_00,in_stack_00000010);
                    // try { // try from 080e7d72 to 080e7d76 has its CatchHandler @ 080e7ed2
    TWriteBuffer::writeWord(this_00,in_stack_00000014);
    iVar3 = executeQuery(this,0x168,true);
    if (iVar3 == 0) {
                    // try { // try from 080e7df2 to 080e7df6 has its CatchHandler @ 080e7f06
        bVar2 = TReadBuffer::readByte(&this->ReadBuffer);
        *in_stack_00000018 = (uint)bVar2;
        iVar3 = 0;
    }
    else {
        if (iVar3 == 1) {
                    // try { // try from 080e7db5 to 080e7db9 has its CatchHandler @ 080e7f38
            bVar2 = TReadBuffer::readByte(&this->ReadBuffer);
            uVar4 = (uint)bVar2;
            bVar1 = false;
            if ((uVar4 != 0) && (uVar4 < 3)) {
                bVar1 = true;
            }
            if (bVar1) {
                return uVar4;
            }
            error(&DAT_0810f5e0,uVar4);
        }
        else {
            error("TQueryManagerConnection::addPaymentOld: Anfrage fehlgeschlagen.\n");
        }
        iVar3 = -1;
    }
    return iVar3;
}



// DWARF original prototype: int cancelPaymentOld(TQueryManagerConnection * this, ulong PurchaseNr,
// ulong ReferenceNr, ulong AccountID, bool * IllegalUse, char * EMailAddress)

int __thiscall TQueryManagerConnection::cancelPaymentOld(TQueryManagerConnection *this)

{
    TWriteBuffer *this_00;
    bool bVar1;
    byte bVar2;
    uchar uVar3;
    int iVar4;
    int FailureCode;
    uint uVar5;
    ulong in_stack_00000008;
    ulong in_stack_0000000c;
    ulong in_stack_00000010;
    undefined4 in_stack_00000014;
    char *in_stack_00000018;
    char *Text;
    
    this->QueryOk = true;
    this_00 = &this->WriteBuffer;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e7f95 to 080e7fa9 has its CatchHandler @ 080e8072
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,0xd4);
                    // try { // try from 080e7fb4 to 080e7fb8 has its CatchHandler @ 080e80b0
    TWriteBuffer::writeQuad(this_00,in_stack_00000008);
                    // try { // try from 080e7fc3 to 080e7fc7 has its CatchHandler @ 080e80e2
    TWriteBuffer::writeQuad(this_00,in_stack_0000000c);
                    // try { // try from 080e7fd2 to 080e7fd6 has its CatchHandler @ 080e8112
    TWriteBuffer::writeQuad(this_00,in_stack_00000010);
    iVar4 = executeQuery(this,0x168,true);
    if (iVar4 == 0) {
                    // try { // try from 080e8047 to 080e804b has its CatchHandler @ 080e8142
        uVar3 = TReadBuffer::readByte(&this->ReadBuffer);
        *(bool *)in_stack_00000014 = uVar3 != '\0';
                    // try { // try from 080e8069 to 080e806d has its CatchHandler @ 080e8174
        TReadStream::readString(&(this->ReadBuffer).super_TReadStream,in_stack_00000018,0x32);
        iVar4 = 0;
    }
    else {
        if (iVar4 == 1) {
                    // try { // try from 080e8015 to 080e8019 has its CatchHandler @ 080e81aa
            bVar2 = TReadBuffer::readByte(&this->ReadBuffer);
            uVar5 = (uint)bVar2;
            bVar1 = false;
            if ((uVar5 != 0) && (uVar5 < 3)) {
                bVar1 = true;
            }
            if (bVar1) {
                return uVar5;
            }
            Text = &DAT_0810f6a0;
        }
        else {
            Text = "TQueryManagerConnection::cancelPaymentOld: Anfrage fehlgeschlagen.\n";
        }
        error(Text);
        iVar4 = -1;
    }
    return iVar4;
}



// DWARF original prototype: int insertPaymentDataNew(TQueryManagerConnection * this, ulong
// PurchaseNr, ulong ReferenceNr, char * FirstName, char * LastName, char * Company, char * Street,
// char * Zip, char * City, char * Country, char * State, char * Phone, char * Fax, char * EMail,
// char * PaymentMethod, ulong ProductID, char * Registrant, char * PaymentKey, ulong * PaymentID)

int __thiscall TQueryManagerConnection::insertPaymentDataNew(TQueryManagerConnection *this)

{
    TWriteBuffer *this_00;
    byte bVar1;
    int iVar2;
    ulong uVar3;
    ulong in_stack_00000008;
    ulong in_stack_0000000c;
    char *in_stack_00000010;
    char *in_stack_00000014;
    char *in_stack_00000018;
    char *in_stack_0000001c;
    char *in_stack_00000020;
    char *in_stack_00000024;
    char *in_stack_00000028;
    char *in_stack_0000002c;
    char *in_stack_00000030;
    char *in_stack_00000034;
    char *in_stack_00000038;
    char *in_stack_0000003c;
    ulong in_stack_00000040;
    char *in_stack_00000044;
    char *in_stack_00000048;
    ulong *in_stack_0000004c;
    
    this->QueryOk = true;
    this_00 = &this->WriteBuffer;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e8205 to 080e8219 has its CatchHandler @ 080e8396
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,0xd5);
                    // try { // try from 080e8224 to 080e8228 has its CatchHandler @ 080e83d0
    TWriteBuffer::writeQuad(this_00,in_stack_00000008);
                    // try { // try from 080e8233 to 080e8237 has its CatchHandler @ 080e8402
    TWriteBuffer::writeQuad(this_00,in_stack_0000000c);
                    // try { // try from 080e8242 to 080e8246 has its CatchHandler @ 080e8432
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000010);
                    // try { // try from 080e8251 to 080e8255 has its CatchHandler @ 080e8462
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000014);
                    // try { // try from 080e8260 to 080e8264 has its CatchHandler @ 080e8496
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000018);
                    // try { // try from 080e826f to 080e8273 has its CatchHandler @ 080e84ca
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_0000001c);
                    // try { // try from 080e827e to 080e8282 has its CatchHandler @ 080e84fe
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000020);
                    // try { // try from 080e828d to 080e8291 has its CatchHandler @ 080e8532
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000024);
                    // try { // try from 080e829c to 080e82a0 has its CatchHandler @ 080e8566
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000028);
                    // try { // try from 080e82ab to 080e82af has its CatchHandler @ 080e859a
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_0000002c);
                    // try { // try from 080e82ba to 080e82be has its CatchHandler @ 080e85ce
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000030);
                    // try { // try from 080e82c9 to 080e82cd has its CatchHandler @ 080e8602
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000034);
                    // try { // try from 080e82d8 to 080e82dc has its CatchHandler @ 080e8636
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000038);
                    // try { // try from 080e82e7 to 080e82eb has its CatchHandler @ 080e866a
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_0000003c);
                    // try { // try from 080e82f6 to 080e82fa has its CatchHandler @ 080e869e
    TWriteBuffer::writeQuad(this_00,in_stack_00000040);
                    // try { // try from 080e8305 to 080e8309 has its CatchHandler @ 080e86d2
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000044);
                    // try { // try from 080e8314 to 080e8318 has its CatchHandler @ 080e8706
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000048);
    iVar2 = executeQuery(this,0x168,true);
    if (iVar2 == 0) {
                    // try { // try from 080e8386 to 080e838a has its CatchHandler @ 080e873a
        uVar3 = TReadBuffer::readQuad(&this->ReadBuffer);
        *in_stack_0000004c = uVar3;
        iVar2 = 0;
    }
    else {
        if (iVar2 == 1) {
                    // try { // try from 080e8357 to 080e835b has its CatchHandler @ 080e876c
            bVar1 = TReadBuffer::readByte(&this->ReadBuffer);
            if (bVar1 == 1) {
                return 1;
            }
            error(&DAT_0810f760,(uint)bVar1);
        }
        else {
            error("TQueryManagerConnection::insertPaymentDataNew: Anfrage fehlgeschlagen.\n");
        }
        iVar2 = -1;
    }
    return iVar2;
}



// DWARF original prototype: int addPaymentNew(TQueryManagerConnection * this, char * PaymentKey,
// ulong PaymentID, int * ActionTaken, char * EMailReceiver)

int __thiscall TQueryManagerConnection::addPaymentNew(TQueryManagerConnection *this)

{
    TWriteBuffer *this_00;
    bool bVar1;
    byte bVar2;
    int iVar3;
    int FailureCode;
    uint uVar4;
    char *in_stack_00000008;
    ulong in_stack_0000000c;
    uint *in_stack_00000010;
    char *in_stack_00000014;
    
    this->QueryOk = true;
    this_00 = &this->WriteBuffer;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e87c5 to 080e87d9 has its CatchHandler @ 080e88a8
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,0xd6);
                    // try { // try from 080e87e4 to 080e87e8 has its CatchHandler @ 080e88e2
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000008);
                    // try { // try from 080e87f3 to 080e87f7 has its CatchHandler @ 080e8912
    TWriteBuffer::writeQuad(this_00,in_stack_0000000c);
    iVar3 = executeQuery(this,0x168,true);
    if (iVar3 == 0) {
                    // try { // try from 080e8876 to 080e887a has its CatchHandler @ 080e8942
        bVar2 = TReadBuffer::readByte(&this->ReadBuffer);
        *in_stack_00000010 = (uint)bVar2;
        if (bVar2 == 5) {
                    // try { // try from 080e88a1 to 080e88a5 has its CatchHandler @ 080e8970
            TReadStream::readString(&(this->ReadBuffer).super_TReadStream,in_stack_00000014,100);
        }
        iVar3 = 0;
    }
    else {
        if (iVar3 == 1) {
                    // try { // try from 080e8836 to 080e883a has its CatchHandler @ 080e89a6
            bVar2 = TReadBuffer::readByte(&this->ReadBuffer);
            uVar4 = (uint)bVar2;
            bVar1 = false;
            if ((uVar4 != 0) && (uVar4 < 4)) {
                bVar1 = true;
            }
            if (bVar1) {
                return uVar4;
            }
            error(&DAT_0810f820,uVar4);
        }
        else {
            error("TQueryManagerConnection::addPaymentNew: Anfrage fehlgeschlagen.\n");
        }
        iVar3 = -1;
    }
    return iVar3;
}



// DWARF original prototype: int cancelPaymentNew(TQueryManagerConnection * this, ulong PurchaseNr,
// ulong ReferenceNr, char * PaymentKey, bool * IllegalUse, bool * Present, char * EMailAddress)

int __thiscall TQueryManagerConnection::cancelPaymentNew(TQueryManagerConnection *this)

{
    TWriteBuffer *this_00;
    TReadBuffer *this_01;
    uchar uVar1;
    int iVar2;
    ulong in_stack_00000008;
    ulong in_stack_0000000c;
    char *in_stack_00000010;
    undefined4 in_stack_00000014;
    undefined4 in_stack_00000018;
    char *in_stack_0000001c;
    char *Text;
    
    this->QueryOk = true;
    this_00 = &this->WriteBuffer;
    (this->WriteBuffer).Position = 0;
                    // try { // try from 080e8a05 to 080e8a19 has its CatchHandler @ 080e8ae4
    TWriteBuffer::writeWord(this_00,0);
    TWriteBuffer::writeByte(this_00,0xd7);
                    // try { // try from 080e8a24 to 080e8a28 has its CatchHandler @ 080e8b20
    TWriteBuffer::writeQuad(this_00,in_stack_00000008);
                    // try { // try from 080e8a33 to 080e8a37 has its CatchHandler @ 080e8b52
    TWriteBuffer::writeQuad(this_00,in_stack_0000000c);
                    // try { // try from 080e8a42 to 080e8a46 has its CatchHandler @ 080e8b82
    TWriteStream::writeString(&this_00->super_TWriteStream,in_stack_00000010);
    iVar2 = executeQuery(this,0x168,true);
    if (iVar2 == 0) {
        this_01 = &this->ReadBuffer;
                    // try { // try from 080e8aa6 to 080e8aaa has its CatchHandler @ 080e8bb2
        uVar1 = TReadBuffer::readByte(this_01);
        *(bool *)in_stack_00000014 = uVar1 != '\0';
                    // try { // try from 080e8ab9 to 080e8abd has its CatchHandler @ 080e8be4
        uVar1 = TReadBuffer::readByte(this_01);
        *(bool *)in_stack_00000018 = uVar1 != '\0';
                    // try { // try from 080e8adb to 080e8adf has its CatchHandler @ 080e8c16
        TReadStream::readString(&this_01->super_TReadStream,in_stack_0000001c,0x32);
        iVar2 = 0;
    }
    else {
        if (iVar2 == 1) {
                    // try { // try from 080e8a85 to 080e8a89 has its CatchHandler @ 080e8c4c
            uVar1 = TReadBuffer::readByte(&this->ReadBuffer);
            if (uVar1 == '\x01') {
                return 1;
            }
            Text = &DAT_0810f8e0;
        }
        else {
            Text = "TQueryManagerConnection::cancelPaymentNew: Anfrage fehlgeschlagen.\n";
        }
        error(Text);
        iVar2 = -1;
    }
    return iVar2;
}



// DWARF original prototype: void TQueryManagerConnectionPool(TQueryManagerConnectionPool * this,
// int Connections)

void __thiscall
TQueryManagerConnectionPool::TQueryManagerConnectionPool
          (TQueryManagerConnectionPool *this,int Connections)

{
    Semaphore::Semaphore(&this->FreeQueryManagerConnections,Connections);
                    // try { // try from 080e8cb5 to 080e8cb9 has its CatchHandler @ 080e8d00
    Semaphore::Semaphore(&this->QueryManagerConnectionMutex,1);
    if (Connections < 1) {
                    // try { // try from 080e8ce6 to 080e8cea has its CatchHandler @ 080e8cf2
        error(&DAT_0810f940,Connections);
        Connections = 1;
    }
    this->NumberOfConnections = Connections;
    this->QueryManagerConnection = (TQueryManagerConnection *)0x0;
    this->QueryManagerConnectionFree = (bool *)0x0;
    return;
}



// DWARF original prototype: void TQueryManagerConnectionPool(TQueryManagerConnectionPool * this,
// int Connections)

void __thiscall
TQueryManagerConnectionPool::TQueryManagerConnectionPool
          (TQueryManagerConnectionPool *this,int Connections)

{
    Semaphore::Semaphore(&this->FreeQueryManagerConnections,Connections);
                    // try { // try from 080e8d55 to 080e8d59 has its CatchHandler @ 080e8da0
    Semaphore::Semaphore(&this->QueryManagerConnectionMutex,1);
    if (Connections < 1) {
                    // try { // try from 080e8d86 to 080e8d8a has its CatchHandler @ 080e8d92
        error(&DAT_0810f940,Connections);
        Connections = 1;
    }
    this->NumberOfConnections = Connections;
    this->QueryManagerConnection = (TQueryManagerConnection *)0x0;
    this->QueryManagerConnectionFree = (bool *)0x0;
    return;
}



// DWARF original prototype: void init(TQueryManagerConnectionPool * this)

int __thiscall
TQueryManagerConnectionPool::init(TQueryManagerConnectionPool *this,EVP_PKEY_CTX *ctx)

{
    int *piVar1;
    bool *pbVar2;
    undefined4 *puVar3;
    int iVar4;
    int i;
    int iVar5;
    TQueryManagerConnection *this_00;
    
    iVar5 = this->NumberOfConnections;
                    // try { // try from 080e8dda to 080e8dde has its CatchHandler @ 080e8f00
    piVar1 = (int *)operator_new__(iVar5 * 0x30 + 4);
    *piVar1 = iVar5;
    this_00 = (TQueryManagerConnection *)(piVar1 + 1);
    while (iVar5 = iVar5 + -1, iVar5 != -1) {
                    // try { // try from 080e8dfc to 080e8e00 has its CatchHandler @ 080e8ea4
        TQueryManagerConnection::TQueryManagerConnection(this_00,0x4000);
        this_00 = this_00 + 1;
    }
    this->QueryManagerConnection = (TQueryManagerConnection *)(piVar1 + 1);
                    // try { // try from 080e8e1e to 080e8ea3 has its CatchHandler @ 080e8f00
    pbVar2 = (bool *)operator_new__(this->NumberOfConnections);
    iVar5 = 0;
    this->QueryManagerConnectionFree = pbVar2;
    if (0 < this->NumberOfConnections) {
        iVar4 = 0;
        do {
            if (*(int *)((int)&this->QueryManagerConnection->Socket + iVar4) < 0) {
                error("TQueryManagerConnectionPool::init: Kann nicht zum Query-Manager verbinden.\n"
                     );
                puVar3 = (undefined4 *)__cxa_allocate_exception(4);
                *puVar3 = "cannot connect to query manager";
                    // WARNING: Subroutine does not return
                __cxa_throw(puVar3,char_const*::typeinfo,0);
            }
            iVar4 = iVar4 + 0x30;
            pbVar2 = this->QueryManagerConnectionFree;
            pbVar2[iVar5] = true;
            iVar5 = iVar5 + 1;
        } while (iVar5 < this->NumberOfConnections);
    }
    return (int)pbVar2;
}



// DWARF original prototype: void exit(TQueryManagerConnectionPool * this)

void __thiscall TQueryManagerConnectionPool::exit(TQueryManagerConnectionPool *this,int __status)

{
    TQueryManagerConnection *pTVar1;
    int i;
    int iVar2;
    TQueryManagerConnection *this_00;
    int in_stack_ffffffe8;
    
    iVar2 = 0;
    if (0 < this->NumberOfConnections) {
        do {
            iVar2 = iVar2 + 1;
            Semaphore::down(&this->FreeQueryManagerConnections);
        } while (iVar2 < this->NumberOfConnections);
    }
    pTVar1 = this->QueryManagerConnection;
    if (pTVar1 != (TQueryManagerConnection *)0x0) {
        this_00 = pTVar1 + *(int *)&pTVar1[-1].QueryOk;
        while (pTVar1 != this_00) {
            this_00 = this_00 + -1;
            TQueryManagerConnection::~TQueryManagerConnection(this_00,in_stack_ffffffe8);
            pTVar1 = this->QueryManagerConnection;
        }
        operator_delete__(&pTVar1[-1].QueryOk);
    }
    if (this->QueryManagerConnectionFree == (bool *)0x0) {
        return;
    }
    operator_delete__(this->QueryManagerConnectionFree);
    return;
}



// DWARF original prototype: TQueryManagerConnection * getConnection(TQueryManagerConnectionPool *
// this)

TQueryManagerConnection * __thiscall
TQueryManagerConnectionPool::getConnection(TQueryManagerConnectionPool *this)

{
    Semaphore *this_00;
    int i;
    int iVar1;
    int iVar2;
    
    this_00 = &this->QueryManagerConnectionMutex;
    Semaphore::down(&this->FreeQueryManagerConnections);
    Semaphore::down(this_00);
    iVar1 = 0;
    if (0 < this->NumberOfConnections) {
        iVar2 = 0;
        do {
            if (this->QueryManagerConnectionFree[iVar1] != false) {
                this->QueryManagerConnectionFree[iVar1] = false;
                Semaphore::up(this_00);
                return (TQueryManagerConnection *)
                       ((int)&this->QueryManagerConnection->BufferSize + iVar2);
            }
            iVar1 = iVar1 + 1;
            iVar2 = iVar2 + 0x30;
        } while (iVar1 < this->NumberOfConnections);
    }
    error("TQueryManagerConnectionPool::getConnection: Keine freie Verbindung gefunden.\n");
    Semaphore::up(this_00);
    return (TQueryManagerConnection *)0x0;
}



// DWARF original prototype: void releaseConnection(TQueryManagerConnectionPool * this,
// TQueryManagerConnection * Connection)

void __thiscall
TQueryManagerConnectionPool::releaseConnection
          (TQueryManagerConnectionPool *this,TQueryManagerConnection *Connection)

{
    TQueryManagerConnection *pTVar1;
    int i;
    int iVar2;
    
    iVar2 = 0;
    if (0 < this->NumberOfConnections) {
        pTVar1 = this->QueryManagerConnection;
        do {
            if (pTVar1 == Connection) {
                this->QueryManagerConnectionFree[iVar2] = true;
                Semaphore::up(&this->FreeQueryManagerConnections);
                return;
            }
            iVar2 = iVar2 + 1;
            pTVar1 = pTVar1 + 1;
        } while (iVar2 < this->NumberOfConnections);
    }
    error("TQueryManagerConnectionPool::releaseConnection: Verbindung nicht gefunden.\n");
    return;
}



// DWARF original prototype: void TQueryManagerPoolConnection(TQueryManagerPoolConnection * this,
// TQueryManagerConnectionPool * Pool)

void __thiscall
TQueryManagerPoolConnection::TQueryManagerPoolConnection
          (TQueryManagerPoolConnection *this,TQueryManagerConnectionPool *Pool)

{
    TQueryManagerConnection *pTVar1;
    int i;
    int iVar2;
    
    if (Pool == (TQueryManagerConnectionPool *)0x0) {
        error("TQueryManagerPoolConnection::TQueryManagerPoolConnection: Pool ist NULL.\n");
        this->QueryManagerConnection = (TQueryManagerConnection *)0x0;
    }
    else {
        this->QueryManagerConnectionPool = Pool;
        iVar2 = 0;
        Semaphore::down(&Pool->FreeQueryManagerConnections);
        Semaphore::down(&Pool->QueryManagerConnectionMutex);
        if (0 < Pool->NumberOfConnections) {
            do {
                if (Pool->QueryManagerConnectionFree[iVar2] != false) {
                    Pool->QueryManagerConnectionFree[iVar2] = false;
                    Semaphore::up(&Pool->QueryManagerConnectionMutex);
                    pTVar1 = Pool->QueryManagerConnection + iVar2;
                    goto LAB_080e90b4;
                }
                iVar2 = iVar2 + 1;
            } while (iVar2 < Pool->NumberOfConnections);
        }
        error("TQueryManagerConnectionPool::getConnection: Keine freie Verbindung gefunden.\n");
        Semaphore::up(&Pool->QueryManagerConnectionMutex);
        pTVar1 = (TQueryManagerConnection *)0x0;
LAB_080e90b4:
        this->QueryManagerConnection = pTVar1;
    }
    return;
}



// DWARF original prototype: void TQueryManagerPoolConnection(TQueryManagerPoolConnection * this,
// TQueryManagerConnectionPool * Pool)

void __thiscall
TQueryManagerPoolConnection::TQueryManagerPoolConnection
          (TQueryManagerPoolConnection *this,TQueryManagerConnectionPool *Pool)

{
    TQueryManagerConnection *pTVar1;
    int i;
    int iVar2;
    
    if (Pool == (TQueryManagerConnectionPool *)0x0) {
        error("TQueryManagerPoolConnection::TQueryManagerPoolConnection: Pool ist NULL.\n");
        this->QueryManagerConnection = (TQueryManagerConnection *)0x0;
    }
    else {
        this->QueryManagerConnectionPool = Pool;
        iVar2 = 0;
        Semaphore::down(&Pool->FreeQueryManagerConnections);
        Semaphore::down(&Pool->QueryManagerConnectionMutex);
        if (0 < Pool->NumberOfConnections) {
            do {
                if (Pool->QueryManagerConnectionFree[iVar2] != false) {
                    Pool->QueryManagerConnectionFree[iVar2] = false;
                    Semaphore::up(&Pool->QueryManagerConnectionMutex);
                    pTVar1 = Pool->QueryManagerConnection + iVar2;
                    goto LAB_080e9154;
                }
                iVar2 = iVar2 + 1;
            } while (iVar2 < Pool->NumberOfConnections);
        }
        error("TQueryManagerConnectionPool::getConnection: Keine freie Verbindung gefunden.\n");
        Semaphore::up(&Pool->QueryManagerConnectionMutex);
        pTVar1 = (TQueryManagerConnection *)0x0;
LAB_080e9154:
        this->QueryManagerConnection = pTVar1;
    }
    return;
}



// DWARF original prototype: void ~TQueryManagerPoolConnection(TQueryManagerPoolConnection * this,
// int __in_chrg)

void __thiscall
TQueryManagerPoolConnection::~TQueryManagerPoolConnection
          (TQueryManagerPoolConnection *this,int __in_chrg)

{
    TQueryManagerConnectionPool *pTVar1;
    TQueryManagerConnection *pTVar2;
    int i;
    int iVar3;
    
    if (this->QueryManagerConnection == (TQueryManagerConnection *)0x0) {
        return;
    }
    pTVar1 = this->QueryManagerConnectionPool;
    iVar3 = 0;
    if (0 < pTVar1->NumberOfConnections) {
        pTVar2 = pTVar1->QueryManagerConnection;
        do {
            if (pTVar2 == this->QueryManagerConnection) {
                pTVar1->QueryManagerConnectionFree[iVar3] = true;
                Semaphore::up(&pTVar1->FreeQueryManagerConnections);
                return;
            }
            iVar3 = iVar3 + 1;
            pTVar2 = pTVar2 + 1;
        } while (iVar3 < pTVar1->NumberOfConnections);
    }
    error("TQueryManagerConnectionPool::releaseConnection: Verbindung nicht gefunden.\n");
    return;
}



// DWARF original prototype: void ~TQueryManagerPoolConnection(TQueryManagerPoolConnection * this,
// int __in_chrg)

void __thiscall
TQueryManagerPoolConnection::~TQueryManagerPoolConnection
          (TQueryManagerPoolConnection *this,int __in_chrg)

{
    TQueryManagerConnectionPool *pTVar1;
    TQueryManagerConnection *pTVar2;
    int i;
    int iVar3;
    
    if (this->QueryManagerConnection == (TQueryManagerConnection *)0x0) {
        return;
    }
    pTVar1 = this->QueryManagerConnectionPool;
    iVar3 = 0;
    if (0 < pTVar1->NumberOfConnections) {
        pTVar2 = pTVar1->QueryManagerConnection;
        do {
            if (pTVar2 == this->QueryManagerConnection) {
                pTVar1->QueryManagerConnectionFree[iVar3] = true;
                Semaphore::up(&pTVar1->FreeQueryManagerConnections);
                return;
            }
            iVar3 = iVar3 + 1;
            pTVar2 = pTVar2 + 1;
        } while (iVar3 < pTVar1->NumberOfConnections);
    }
    error("TQueryManagerConnectionPool::releaseConnection: Verbindung nicht gefunden.\n");
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__I_ApplicationType(void)

{
    __static_initialization_and_destruction_0(1,0xffff);
    return;
}



void __static_initialization_and_destruction_0(int __initialize_p,int __priority)

{
    if ((__priority == 0xffff) && (__initialize_p == 1)) {
        vlong::vlong(&RSA_EXPONENT,0x10001);
        __cxa_atexit(__tcf_0,0,&__dso_handle);
    }
    return;
}



// DWARF original prototype: void TRSAPrivateKey(TRSAPrivateKey * this)

void __thiscall TRSAPrivateKey::TRSAPrivateKey(TRSAPrivateKey *this)

{
    this->_vptr_TRSAPrivateKey = (_func_int_varargs **)&PTR__TRSAPrivateKey_081283e0;
    vlong::vlong(&this->m_PrimeP,0);
                    // try { // try from 080e9359 to 080e935d has its CatchHandler @ 080e93d8
    vlong::vlong(&this->m_PrimeQ,0);
                    // try { // try from 080e936f to 080e9373 has its CatchHandler @ 080e93d4
    vlong::vlong(&this->m_U,0);
                    // try { // try from 080e9385 to 080e9389 has its CatchHandler @ 080e93d0
    vlong::vlong(&this->m_DP,0);
                    // try { // try from 080e9398 to 080e939c has its CatchHandler @ 080e93aa
    vlong::vlong(&this->m_DQ,0);
    return;
}



// DWARF original prototype: void TRSAPrivateKey(TRSAPrivateKey * this)

void __thiscall TRSAPrivateKey::TRSAPrivateKey(TRSAPrivateKey *this)

{
    this->_vptr_TRSAPrivateKey = (_func_int_varargs **)&PTR__TRSAPrivateKey_081283e0;
    vlong::vlong(&this->m_PrimeP,0);
                    // try { // try from 080e9429 to 080e942d has its CatchHandler @ 080e94a8
    vlong::vlong(&this->m_PrimeQ,0);
                    // try { // try from 080e943f to 080e9443 has its CatchHandler @ 080e94a4
    vlong::vlong(&this->m_U,0);
                    // try { // try from 080e9455 to 080e9459 has its CatchHandler @ 080e94a0
    vlong::vlong(&this->m_DP,0);
                    // try { // try from 080e9468 to 080e946c has its CatchHandler @ 080e947a
    vlong::vlong(&this->m_DQ,0);
    return;
}



// DWARF original prototype: void ~TRSAPrivateKey(TRSAPrivateKey * this, int __in_chrg)

void __thiscall TRSAPrivateKey::~TRSAPrivateKey(TRSAPrivateKey *this,int __in_chrg)

{
    int unaff_EBX;
    
    this->_vptr_TRSAPrivateKey = (_func_int_varargs **)&PTR__TRSAPrivateKey_081283e0;
    vlong::~vlong(&this->m_DQ,unaff_EBX);
    vlong::~vlong(&this->m_DP,unaff_EBX);
    vlong::~vlong(&this->m_U,unaff_EBX);
    vlong::~vlong(&this->m_PrimeQ,unaff_EBX);
    vlong::~vlong(&this->m_PrimeP,unaff_EBX);
    return;
}



// DWARF original prototype: void ~TRSAPrivateKey(TRSAPrivateKey * this, int __in_chrg)

void __thiscall TRSAPrivateKey::~TRSAPrivateKey(TRSAPrivateKey *this,int __in_chrg)

{
    int unaff_EBX;
    
    this->_vptr_TRSAPrivateKey = (_func_int_varargs **)&PTR__TRSAPrivateKey_081283e0;
    vlong::~vlong(&this->m_DQ,unaff_EBX);
    vlong::~vlong(&this->m_DP,unaff_EBX);
    vlong::~vlong(&this->m_U,unaff_EBX);
    vlong::~vlong(&this->m_PrimeQ,unaff_EBX);
    vlong::~vlong(&this->m_PrimeP,unaff_EBX);
    return;
}



// DWARF original prototype: void ~TRSAPrivateKey(TRSAPrivateKey * this, int __in_chrg)

void __thiscall TRSAPrivateKey::~TRSAPrivateKey(TRSAPrivateKey *this,int __in_chrg)

{
    int unaff_EBX;
    
    this->_vptr_TRSAPrivateKey = (_func_int_varargs **)&PTR__TRSAPrivateKey_081283e0;
    vlong::~vlong(&this->m_DQ,unaff_EBX);
    vlong::~vlong(&this->m_DP,unaff_EBX);
    vlong::~vlong(&this->m_U,unaff_EBX);
    vlong::~vlong(&this->m_PrimeQ,unaff_EBX);
    vlong::~vlong(&this->m_PrimeP,unaff_EBX);
    operator_delete(this);
    return;
}



// DWARF original prototype: void init(TRSAPrivateKey * this, char * PrimeP, char * PrimeQ)

int __thiscall TRSAPrivateKey::init(TRSAPrivateKey *this,EVP_PKEY_CTX *ctx)

{
    vlong *pvVar1;
    undefined4 *puVar2;
    size_t __len;
    char *in_stack_0000000c;
    vlong *pvVar3;
    vlong *Number;
    vlong local_6c;
    vlong local_5c;
    undefined1 local_4c [4];
    vlong d;
    vlong local_3c;
    string Error;
    
    if (ctx == (EVP_PKEY_CTX *)0x0) {
        puVar2 = (undefined4 *)__cxa_allocate_exception(4);
        *puVar2 = "PrimeP pointer is NULL";
    }
    else {
        if (in_stack_0000000c != (char *)0x0) {
            pvVar1 = &this->m_PrimeP;
                    // try { // try from 080e95ec to 080e95f0 has its CatchHandler @ 080e9850
            vlong::convert((char *)ctx,pvVar1);
            Number = &this->m_PrimeQ;
                    // try { // try from 080e95fe to 080e9602 has its CatchHandler @ 080e9980
            vlong::convert(in_stack_0000000c,Number);
            vlong::vlong(&local_5c,1);
            pvVar3 = Number;
                    // try { // try from 080e9627 to 080e962b has its CatchHandler @ 080e9aa1
            operator-((vlong *)&stack0xffffffd4,Number);
            vlong::~vlong(&local_5c,(int)pvVar3);
                    // try { // try from 080e9648 to 080e964c has its CatchHandler @ 080e9adb
            vlong::vlong(&local_6c,1);
            pvVar3 = pvVar1;
                    // try { // try from 080e965e to 080e9662 has its CatchHandler @ 080e9ab3
            operator-(&local_5c,pvVar1);
                    // try { // try from 080e966c to 080e9670 has its CatchHandler @ 080e9adb
            vlong::~vlong(&local_6c,(int)pvVar3);
                    // try { // try from 080e9685 to 080e9689 has its CatchHandler @ 080e9ad7
            operator*(&local_3c,&local_5c);
            pvVar3 = &RSA_EXPONENT;
                    // try { // try from 080e96a2 to 080e96a6 has its CatchHandler @ 080e9ac5
            vlong::modinv((vlong *)local_4c,&RSA_EXPONENT,&local_3c);
                    // try { // try from 080e96b0 to 080e96b4 has its CatchHandler @ 080e9ad7
            vlong::~vlong(&local_3c,(int)pvVar3);
                    // try { // try from 080e96bb to 080e96bf has its CatchHandler @ 080e9adb
            vlong::~vlong(&local_5c,(int)pvVar3);
            vlong::~vlong((vlong *)&stack0xffffffd4,(int)pvVar3);
                    // try { // try from 080e96d9 to 080e96dd has its CatchHandler @ 080e9b10
            vlong::modinv(&local_6c,pvVar1,Number);
            pvVar3 = &local_6c;
                    // try { // try from 080e96f1 to 080e96f5 has its CatchHandler @ 080e9adf
            vlong::operator=(&this->m_U,pvVar3);
                    // try { // try from 080e96fc to 080e9713 has its CatchHandler @ 080e9b10
            vlong::~vlong(&local_6c,(int)pvVar3);
            vlong::vlong(&local_3c,1);
                    // try { // try from 080e9725 to 080e9729 has its CatchHandler @ 080e9af1
            operator-(&local_5c,pvVar1);
                    // try { // try from 080e9733 to 080e9737 has its CatchHandler @ 080e9b10
            vlong::~vlong(&local_3c,(int)pvVar1);
                    // try { // try from 080e974c to 080e9750 has its CatchHandler @ 080e9b0a
            operator%(&local_6c,(vlong *)local_4c);
            pvVar3 = &local_6c;
                    // try { // try from 080e9764 to 080e9768 has its CatchHandler @ 080e9af8
            vlong::operator=(&this->m_DP,pvVar3);
                    // try { // try from 080e976f to 080e9773 has its CatchHandler @ 080e9b0a
            vlong::~vlong(&local_6c,(int)pvVar3);
                    // try { // try from 080e977a to 080e9791 has its CatchHandler @ 080e9b10
            vlong::~vlong(&local_5c,(int)pvVar3);
            vlong::vlong(&local_3c,1);
                    // try { // try from 080e97a3 to 080e97a7 has its CatchHandler @ 080e9af1
            operator-(&local_5c,Number);
                    // try { // try from 080e97b1 to 080e97b5 has its CatchHandler @ 080e9b10
            vlong::~vlong(&local_3c,(int)Number);
                    // try { // try from 080e97ca to 080e97ce has its CatchHandler @ 080e9b0a
            operator%(&local_6c,(vlong *)local_4c);
            pvVar3 = &local_6c;
                    // try { // try from 080e97e2 to 080e97e6 has its CatchHandler @ 080e9af8
            pvVar1 = vlong::operator=(&this->m_DQ,pvVar3);
                    // try { // try from 080e97ed to 080e97f1 has its CatchHandler @ 080e9b0a
            vlong::~vlong(&local_6c,(int)pvVar3);
                    // try { // try from 080e97f8 to 080e97fc has its CatchHandler @ 080e9b10
            vlong::~vlong(&local_5c,(int)pvVar3);
            vlong::~vlong((vlong *)local_4c,(int)pvVar3);
            return (int)pvVar1;
        }
        puVar2 = (undefined4 *)__cxa_allocate_exception(4);
        *puVar2 = "PrimeQ pointer is NULL";
    }
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar2,char_const*::typeinfo,0);
}



// DWARF original prototype: void decrypt(TRSAPrivateKey * this, uchar * Data)

int __thiscall
TRSAPrivateKey::decrypt
          (TRSAPrivateKey *this,EVP_PKEY_CTX *ctx,uchar *out,size_t *outlen,uchar *in,size_t inlen)

{
    size_t __size;
    int iVar1;
    vlong *pvVar2;
    undefined4 *puVar3;
    size_t __len;
    char *pE;
    char *pE_1;
    undefined1 *puVar4;
    string Error_1;
    vlong local_8c;
    vlong local_7c;
    vlong local_6c;
    undefined1 local_5c [4];
    vlong a;
    undefined1 local_4c [4];
    vlong b;
    undefined1 local_3c [4];
    vlong Plain;
    undefined1 local_2c [4];
    vlong Cipher;
    
    if (ctx == (EVP_PKEY_CTX *)0x0) {
        puVar3 = (undefined4 *)__cxa_allocate_exception(4);
        *puVar3 = "Data pointer is NULL";
    }
    else {
        vlong::vlong((vlong *)local_2c,0);
        pvVar2 = (vlong *)local_2c;
                    // try { // try from 080e9b57 to 080e9b5b has its CatchHandler @ 080e9e62
        iVar1 = vlong::cf(&this->m_PrimeP,(vlong *)local_2c);
        vlong::~vlong((vlong *)local_2c,(int)pvVar2);
        if (iVar1 == 0) {
            puVar3 = (undefined4 *)__cxa_allocate_exception(4);
            *puVar3 = "m_PrimeP is null";
        }
        else {
            vlong::vlong((vlong *)local_2c,0);
            pvVar2 = (vlong *)local_2c;
                    // try { // try from 080e9b9c to 080e9ba0 has its CatchHandler @ 080e9e74
            iVar1 = vlong::cf(&this->m_PrimeQ,(vlong *)local_2c);
            vlong::~vlong((vlong *)local_2c,(int)pvVar2);
            if (iVar1 != 0) {
                vlong::vlong((vlong *)local_2c,0);
                    // try { // try from 080e9bda to 080e9bde has its CatchHandler @ 080e9e76
                vlong::convert((uchar *)ctx,0x80,(vlong *)local_2c);
                    // try { // try from 080e9bed to 080e9bf1 has its CatchHandler @ 080e9e62
                operator%((vlong *)local_4c,(vlong *)local_2c);
                puVar4 = local_4c;
                    // try { // try from 080e9c10 to 080e9c14 has its CatchHandler @ 080e9fa0
                vlong::modexp((vlong *)local_5c);
                    // try { // try from 080e9c1e to 080e9c22 has its CatchHandler @ 080e9e62
                vlong::~vlong((vlong *)local_4c,(int)puVar4);
                    // try { // try from 080e9c37 to 080e9c3b has its CatchHandler @ 080ea17e
                operator%((vlong *)local_3c,(vlong *)local_2c);
                puVar4 = local_3c;
                    // try { // try from 080e9c60 to 080e9c64 has its CatchHandler @ 080e9fb2
                vlong::modexp((vlong *)local_4c);
                    // try { // try from 080e9c6e to 080e9c72 has its CatchHandler @ 080ea17e
                vlong::~vlong((vlong *)local_3c,(int)puVar4);
                    // try { // try from 080e9c80 to 080e9c84 has its CatchHandler @ 080ea177
                vlong::vlong((vlong *)local_3c,(vlong *)local_5c);
                pvVar2 = (vlong *)local_3c;
                    // try { // try from 080e9c92 to 080e9c96 has its CatchHandler @ 080e9fc4
                iVar1 = vlong::cf((vlong *)local_4c,pvVar2);
                    // try { // try from 080e9ca2 to 080e9cca has its CatchHandler @ 080ea177
                vlong::~vlong((vlong *)local_3c,(int)pvVar2);
                if (iVar1 < 0) {
                    // try { // try from 080e9e00 to 080e9e04 has its CatchHandler @ 080ea177
                    vlong::operator+=((vlong *)local_4c,&this->m_PrimeQ);
                }
                operator-((vlong *)&stack0xffffff64,(vlong *)local_4c);
                    // try { // try from 080e9ceb to 080e9cef has its CatchHandler @ 080ea012
                operator*(&local_8c,(vlong *)&stack0xffffff64);
                    // try { // try from 080e9d0d to 080e9d11 has its CatchHandler @ 080ea00e
                operator%(&local_7c,&local_8c);
                    // try { // try from 080e9d26 to 080e9d2a has its CatchHandler @ 080ea00a
                operator*(&local_6c,&this->m_PrimeP);
                pvVar2 = (vlong *)local_5c;
                    // try { // try from 080e9d42 to 080e9d46 has its CatchHandler @ 080e9fd9
                operator+((vlong *)local_3c,pvVar2);
                    // try { // try from 080e9d50 to 080e9d54 has its CatchHandler @ 080ea00a
                vlong::~vlong(&local_6c,(int)pvVar2);
                    // try { // try from 080e9d5b to 080e9d5f has its CatchHandler @ 080ea00e
                vlong::~vlong(&local_7c,(int)pvVar2);
                    // try { // try from 080e9d69 to 080e9d6d has its CatchHandler @ 080ea012
                vlong::~vlong(&local_8c,(int)pvVar2);
                    // try { // try from 080e9d77 to 080e9d7b has its CatchHandler @ 080ea177
                vlong::~vlong((vlong *)&stack0xffffff64,(int)pvVar2);
                    // try { // try from 080e9d8c to 080e9d90 has its CatchHandler @ 080ea11f
                vlong::vlong((vlong *)&stack0xffffff64,(vlong *)local_3c);
                    // try { // try from 080e9da9 to 080e9dad has its CatchHandler @ 080ea016
                vlong::convert((vlong *)&stack0xffffff64,(uchar *)ctx,0x80);
                    // try { // try from 080e9db7 to 080e9dbb has its CatchHandler @ 080ea11f
                vlong::~vlong((vlong *)&stack0xffffff64,(int)ctx);
                pvVar2 = (vlong *)local_3c;
                    // try { // try from 080e9dc2 to 080e9dc6 has its CatchHandler @ 080ea177
                vlong::~vlong(pvVar2,(int)ctx);
                    // try { // try from 080e9dcd to 080e9dd1 has its CatchHandler @ 080ea17e
                vlong::~vlong((vlong *)local_4c,(int)ctx);
                    // try { // try from 080e9dd8 to 080e9ddc has its CatchHandler @ 080e9e62
                vlong::~vlong((vlong *)local_5c,(int)ctx);
                vlong::~vlong((vlong *)local_2c,(int)ctx);
                return (int)pvVar2;
            }
            puVar3 = (undefined4 *)__cxa_allocate_exception(4);
            *puVar3 = "m_PrimeQ is null";
        }
    }
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar3,char_const*::typeinfo,0);
}



void __tcf_0(void *param_1)

{
    int in_stack_00000008;
    
    vlong::~vlong(&RSA_EXPONENT,in_stack_00000008);
    return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__I__ZN14TRSAPrivateKeyC2Ev(void)

{
    __static_initialization_and_destruction_0(1,0xffff);
    return;
}



// DWARF original name: _M_replace_safe<const char*>
// DWARF original prototype: basic_string<char,std::char_traits<char>,std::allocator<char>_> *
// _M_replace_safe<const_char*>(basic_string<char,std::char_traits<char>,std::allocator<char>_> *
// this, 
// __normal_iterator<char*,std::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>
// __i1, 
// __normal_iterator<char*,std::basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_>
// __i2, char * __k1, char * __k2)

basic_string<> * __thiscall
basic_string<>::_M_replace_safe<>
          (basic_string<> *this,__normal_iterator<> __i1,__normal_iterator<> __i2,char *__k1,
          char *__k2)

{
    uint __n;
    uint uVar1;
    
    __n = (int)__k2 - (int)__k1;
    if (std::string::_Rep::_S_max_size <= __n) {
        std::__throw_length_error("basic_string::_M_replace");
    }
    uVar1 = (int)__i1._M_current - (int)(this->_M_dataplus)._M_p;
    std::string::_M_mutate((uint)this,uVar1,(int)__i2._M_current - (int)__i1._M_current);
    if (__n != 0) {
        memcpy((this->_M_dataplus)._M_p + uVar1,__k1,__n);
    }
    return this;
}



// DWARF original prototype: void TXTEASymmetricKey(TXTEASymmetricKey * this)

void __thiscall TXTEASymmetricKey::TXTEASymmetricKey(TXTEASymmetricKey *this)

{
    this->_vptr_TXTEASymmetricKey = (_func_int_varargs **)&PTR__TXTEASymmetricKey_081283f8;
    this->m_SymmetricKey[0] = '\0';
    this->m_SymmetricKey[1] = '\0';
    this->m_SymmetricKey[2] = '\0';
    this->m_SymmetricKey[3] = '\0';
    this->m_SymmetricKey[4] = '\0';
    this->m_SymmetricKey[5] = '\0';
    this->m_SymmetricKey[6] = '\0';
    this->m_SymmetricKey[7] = '\0';
    this->m_SymmetricKey[8] = '\0';
    this->m_SymmetricKey[9] = '\0';
    this->m_SymmetricKey[10] = '\0';
    this->m_SymmetricKey[0xb] = '\0';
    this->m_SymmetricKey[0xc] = '\0';
    this->m_SymmetricKey[0xd] = '\0';
    this->m_SymmetricKey[0xe] = '\0';
    this->m_SymmetricKey[0xf] = '\0';
    return;
}



// DWARF original prototype: void TXTEASymmetricKey(TXTEASymmetricKey * this)

void __thiscall TXTEASymmetricKey::TXTEASymmetricKey(TXTEASymmetricKey *this)

{
    this->_vptr_TXTEASymmetricKey = (_func_int_varargs **)&PTR__TXTEASymmetricKey_081283f8;
    this->m_SymmetricKey[0] = '\0';
    this->m_SymmetricKey[1] = '\0';
    this->m_SymmetricKey[2] = '\0';
    this->m_SymmetricKey[3] = '\0';
    this->m_SymmetricKey[4] = '\0';
    this->m_SymmetricKey[5] = '\0';
    this->m_SymmetricKey[6] = '\0';
    this->m_SymmetricKey[7] = '\0';
    this->m_SymmetricKey[8] = '\0';
    this->m_SymmetricKey[9] = '\0';
    this->m_SymmetricKey[10] = '\0';
    this->m_SymmetricKey[0xb] = '\0';
    this->m_SymmetricKey[0xc] = '\0';
    this->m_SymmetricKey[0xd] = '\0';
    this->m_SymmetricKey[0xe] = '\0';
    this->m_SymmetricKey[0xf] = '\0';
    return;
}



// DWARF original prototype: void ~TXTEASymmetricKey(TXTEASymmetricKey * this, int __in_chrg)

void __thiscall TXTEASymmetricKey::~TXTEASymmetricKey(TXTEASymmetricKey *this,int __in_chrg)

{
    this->_vptr_TXTEASymmetricKey = (_func_int_varargs **)&PTR__TXTEASymmetricKey_081283f8;
    return;
}



// DWARF original prototype: void ~TXTEASymmetricKey(TXTEASymmetricKey * this, int __in_chrg)

void __thiscall TXTEASymmetricKey::~TXTEASymmetricKey(TXTEASymmetricKey *this,int __in_chrg)

{
    this->_vptr_TXTEASymmetricKey = (_func_int_varargs **)&PTR__TXTEASymmetricKey_081283f8;
    return;
}



// DWARF original prototype: void ~TXTEASymmetricKey(TXTEASymmetricKey * this, int __in_chrg)

void __thiscall TXTEASymmetricKey::~TXTEASymmetricKey(TXTEASymmetricKey *this,int __in_chrg)

{
    this->_vptr_TXTEASymmetricKey = (_func_int_varargs **)&PTR__TXTEASymmetricKey_081283f8;
    operator_delete(this);
    return;
}



// DWARF original prototype: void init(TXTEASymmetricKey * this, uchar * SymmetricKey)

int __thiscall TXTEASymmetricKey::init(TXTEASymmetricKey *this,EVP_PKEY_CTX *ctx)

{
    int in_EAX;
    
    if (ctx != (EVP_PKEY_CTX *)0x0) {
        *(undefined4 *)this->m_SymmetricKey = *(undefined4 *)ctx;
        *(undefined4 *)(this->m_SymmetricKey + 4) = *(undefined4 *)(ctx + 4);
        *(undefined4 *)(this->m_SymmetricKey + 8) = *(undefined4 *)(ctx + 8);
        in_EAX = *(int *)(ctx + 0xc);
        *(int *)(this->m_SymmetricKey + 0xc) = in_EAX;
    }
    return in_EAX;
}



// DWARF original prototype: bool isInitialized(TXTEASymmetricKey * this)

bool __thiscall TXTEASymmetricKey::isInitialized(TXTEASymmetricKey *this)

{
    int i;
    int iVar1;
    
    iVar1 = 0;
    do {
        if (this->m_SymmetricKey[iVar1] != '\0') {
            return true;
        }
        iVar1 = iVar1 + 1;
    } while (iVar1 < 0x10);
    return false;
}



// DWARF original prototype: void encrypt(TXTEASymmetricKey * this, uchar * Data)

void __thiscall TXTEASymmetricKey::encrypt(TXTEASymmetricKey *this,char *__block,int __edflag)

{
    uint uVar1;
    ulong v0;
    uint uVar2;
    ulong v1;
    uint uVar3;
    ulong sum;
    uint uVar4;
    ulong i;
    uint uVar5;
    
    if (__block != (char *)0x0) {
        uVar5 = 0;
        uVar2 = *(uint *)__block;
        uVar3 = *(uint *)(__block + 4);
        uVar4 = 0;
        do {
            uVar5 = uVar5 + 1;
            uVar1 = *(int *)(this->m_SymmetricKey + (uVar4 & 3) * 4) + uVar4;
            uVar4 = uVar4 + 0x9e3779b9;
            uVar2 = uVar2 + ((uVar3 << 4 ^ uVar3 >> 5) + uVar3 ^ uVar1);
            uVar3 = uVar3 + ((uVar2 * 0x10 ^ uVar2 >> 5) + uVar2 ^
                            *(int *)(this->m_SymmetricKey + (uVar4 >> 0xb & 3) * 4) + uVar4);
        } while (uVar5 < 0x20);
        *(uint *)__block = uVar2;
        *(uint *)(__block + 4) = uVar3;
    }
    return;
}



// DWARF original prototype: void decrypt(TXTEASymmetricKey * this, uchar * Data)

int __thiscall
TXTEASymmetricKey::decrypt
          (TXTEASymmetricKey *this,EVP_PKEY_CTX *ctx,uchar *out,size_t *outlen,uchar *in,
          size_t inlen)

{
    uint uVar1;
    ulong v0;
    uint uVar2;
    ulong v1;
    uint uVar3;
    ulong sum;
    uint uVar4;
    ulong i;
    uint uVar5;
    
    if (ctx != (EVP_PKEY_CTX *)0x0) {
        uVar5 = 0;
        uVar2 = *(uint *)ctx;
        uVar3 = *(uint *)(ctx + 4);
        uVar4 = 0xc6ef3720;
        do {
            uVar5 = uVar5 + 1;
            uVar1 = *(int *)(this->m_SymmetricKey + (uVar4 >> 0xb & 3) * 4) + uVar4;
            uVar4 = uVar4 + 0x61c88647;
            uVar3 = uVar3 - ((uVar2 << 4 ^ uVar2 >> 5) + uVar2 ^ uVar1);
            uVar2 = uVar2 - ((uVar3 * 0x10 ^ uVar3 >> 5) + uVar3 ^
                            *(int *)(this->m_SymmetricKey + (uVar4 & 3) * 4) + uVar4);
        } while (uVar5 < 0x20);
        *(uint *)ctx = uVar2;
        *(uint *)(ctx + 4) = uVar3;
    }
    return (int)ctx;
}



void TXTEASymmetricKey::encrypt(char *__block,int __edflag)

{
    uint uVar1;
    ulong v0;
    uint uVar2;
    ulong v1;
    uint uVar3;
    ulong sum;
    uint uVar4;
    ulong i;
    uint uVar5;
    
    uVar2 = *(uint *)__block;
    uVar3 = *(uint *)(__block + 4);
    uVar4 = 0;
    uVar5 = 0;
    do {
        uVar5 = uVar5 + 1;
        uVar1 = *(int *)(__edflag + (uVar4 & 3) * 4) + uVar4;
        uVar4 = uVar4 + 0x9e3779b9;
        uVar2 = uVar2 + ((uVar3 << 4 ^ uVar3 >> 5) + uVar3 ^ uVar1);
        uVar3 = uVar3 + ((uVar2 * 0x10 ^ uVar2 >> 5) + uVar2 ^
                        *(int *)(__edflag + (uVar4 >> 0xb & 3) * 4) + uVar4);
    } while (uVar5 < 0x20);
    *(uint *)__block = uVar2;
    *(uint *)(__block + 4) = uVar3;
    return;
}



int TXTEASymmetricKey::decrypt(EVP_PKEY_CTX *ctx,uchar *out,size_t *outlen,uchar *in,size_t inlen)

{
    uint uVar1;
    ulong v0;
    uint uVar2;
    ulong v1;
    uint uVar3;
    ulong sum;
    uint uVar4;
    ulong i;
    uint uVar5;
    
    uVar5 = 0;
    uVar2 = *(uint *)ctx;
    uVar3 = *(uint *)(ctx + 4);
    uVar4 = 0xc6ef3720;
    do {
        uVar5 = uVar5 + 1;
        uVar1 = *(int *)(out + (uVar4 >> 0xb & 3) * 4) + uVar4;
        uVar4 = uVar4 + 0x61c88647;
        uVar3 = uVar3 - ((uVar2 << 4 ^ uVar2 >> 5) + uVar2 ^ uVar1);
        uVar2 = uVar2 - ((uVar3 * 0x10 ^ uVar3 >> 5) + uVar3 ^
                        *(int *)(out + (uVar4 & 3) * 4) + uVar4);
    } while (uVar5 < 0x20);
    *(uint *)ctx = uVar2;
    *(uint *)(ctx + 4) = uVar3;
    return (int)ctx;
}



// DWARF original prototype: void vlong_montgomery(vlong_montgomery * this, vlong * M)

void __thiscall vlong_montgomery::vlong_montgomery(vlong_montgomery *this,vlong *M)

{
    _func_int_varargs **pp_Var1;
    uint *puVar2;
    vlong_value *pvVar3;
    int iVar4;
    uint i;
    int iVar5;
    uint uVar6;
    vlong_montgomery *__in_chrg;
    vlong *a;
    vlong *pvVar7;
    vlong_montgomery *x;
    undefined1 local_3c [4];
    vlong result;
    vlong local_2c [2];
    
    (this->R)._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
    pvVar3 = (vlong_value *)operator_new(0x10);
    (pvVar3->super_vlong_flex_unit).z = 0;
    (pvVar3->super_vlong_flex_unit).a = (uint *)0x0;
    pvVar3->share = 0;
    (this->R).value = pvVar3;
    (this->R).negative = 0;
    (pvVar3->super_vlong_flex_unit).n = 0;
    vlong_flex_unit::set((vlong_flex_unit *)pvVar3,0,0);
    (this->R1)._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
                    // try { // try from 080ea612 to 080ea656 has its CatchHandler @ 080ead98
    pvVar3 = (vlong_value *)operator_new(0x10);
    (pvVar3->super_vlong_flex_unit).z = 0;
    (pvVar3->super_vlong_flex_unit).a = (uint *)0x0;
    pvVar3->share = 0;
    (this->R1).value = pvVar3;
    (this->R1).negative = 0;
    (pvVar3->super_vlong_flex_unit).n = 0;
    vlong_flex_unit::set((vlong_flex_unit *)pvVar3,0,0);
    pvVar7 = &this->m;
    (this->m)._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
                    // try { // try from 080ea66b to 080ea6af has its CatchHandler @ 080ead91
    pvVar3 = (vlong_value *)operator_new(0x10);
    (pvVar3->super_vlong_flex_unit).z = 0;
    (pvVar3->super_vlong_flex_unit).a = (uint *)0x0;
    pvVar3->share = 0;
    (this->m).value = pvVar3;
    (this->m).negative = 0;
    (pvVar3->super_vlong_flex_unit).n = 0;
    vlong_flex_unit::set((vlong_flex_unit *)pvVar3,0,0);
    (this->n1)._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
                    // try { // try from 080ea6c4 to 080ea708 has its CatchHandler @ 080ead8a
    pvVar3 = (vlong_value *)operator_new(0x10);
    (pvVar3->super_vlong_flex_unit).z = 0;
    (pvVar3->super_vlong_flex_unit).a = (uint *)0x0;
    pvVar3->share = 0;
    (this->n1).value = pvVar3;
    (this->n1).negative = 0;
    (pvVar3->super_vlong_flex_unit).n = 0;
    vlong_flex_unit::set((vlong_flex_unit *)pvVar3,0,0);
    (this->T)._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
                    // try { // try from 080ea71d to 080ea761 has its CatchHandler @ 080ead83
    pvVar3 = (vlong_value *)operator_new(0x10);
    (pvVar3->super_vlong_flex_unit).z = 0;
    (pvVar3->super_vlong_flex_unit).a = (uint *)0x0;
    pvVar3->share = 0;
    (this->T).value = pvVar3;
    (this->T).negative = 0;
    (pvVar3->super_vlong_flex_unit).n = 0;
    vlong_flex_unit::set((vlong_flex_unit *)pvVar3,0,0);
    (this->k)._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
                    // try { // try from 080ea776 to 080ea7ba has its CatchHandler @ 080ead7c
    pvVar3 = (vlong_value *)operator_new(0x10);
    (pvVar3->super_vlong_flex_unit).z = 0;
    (pvVar3->super_vlong_flex_unit).a = (uint *)0x0;
    pvVar3->share = 0;
    (this->k).value = pvVar3;
    (this->k).negative = 0;
    (pvVar3->super_vlong_flex_unit).n = 0;
    vlong_flex_unit::set((vlong_flex_unit *)pvVar3,0,0);
    pvVar3 = (this->m).value;
    if (pvVar3->share == 0) {
        if (pvVar3 != (vlong_value *)0x0) {
            uVar6 = (pvVar3->super_vlong_flex_unit).z;
            while (uVar6 != 0) {
                uVar6 = uVar6 - 1;
                (pvVar3->super_vlong_flex_unit).a[uVar6] = 0;
            }
            puVar2 = (pvVar3->super_vlong_flex_unit).a;
            if (puVar2 != (uint *)0x0) {
                operator_delete__(puVar2);
            }
            operator_delete(pvVar3);
        }
    }
    else {
        pvVar3->share = pvVar3->share - 1;
    }
    pvVar3 = M->value;
    (this->m).value = pvVar3;
    puVar2 = &pvVar3->share;
    *puVar2 = *puVar2 + 1;
    (this->m).negative = M->negative;
    this->N = 0;
    local_2c[0]._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
                    // try { // try from 080ea7f7 to 080ea8f5 has its CatchHandler @ 080ead75
    local_2c[0].value = (vlong_value *)operator_new(0x10);
    ((local_2c[0].value)->super_vlong_flex_unit).z = 0;
    ((local_2c[0].value)->super_vlong_flex_unit).a = (uint *)0x0;
    (local_2c[0].value)->share = 0;
    local_2c[0].negative = 0;
    ((local_2c[0].value)->super_vlong_flex_unit).n = 0;
    __in_chrg = (vlong_montgomery *)0x0;
    vlong_flex_unit::set((vlong_flex_unit *)local_2c[0].value,0,1);
    pvVar3 = (this->R).value;
    if (pvVar3->share == 0) {
        if (pvVar3 != (vlong_value *)0x0) {
            uVar6 = (pvVar3->super_vlong_flex_unit).z;
            while (uVar6 != 0) {
                uVar6 = uVar6 - 1;
                (pvVar3->super_vlong_flex_unit).a[uVar6] = 0;
            }
            puVar2 = (pvVar3->super_vlong_flex_unit).a;
            if (puVar2 != (uint *)0x0) {
                operator_delete__(puVar2);
            }
            operator_delete(pvVar3);
        }
    }
    else {
        pvVar3->share = pvVar3->share - 1;
    }
    pvVar3 = local_2c[0].value;
    (this->R).value = local_2c[0].value;
    (local_2c[0].value)->share = (local_2c[0].value)->share + 1;
    local_2c[0]._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
    (this->R).negative = local_2c[0].negative;
    if ((local_2c[0].value)->share == 0) {
        if (local_2c[0].value != (vlong_value *)0x0) {
                    // try { // try from 080eab2d to 080eab31 has its CatchHandler @ 080ead75
            vlong_flex_unit::~vlong_flex_unit
                      (&(local_2c[0].value)->super_vlong_flex_unit,(int)__in_chrg);
            operator_delete(pvVar3);
        }
    }
    else {
        (local_2c[0].value)->share = (local_2c[0].value)->share - 1;
    }
    while( true ) {
        local_2c[0]._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
        local_2c[0].negative = M->negative;
        iVar4 = 0;
        x = (vlong_montgomery *)M->value;
        (x->R1)._vptr_vlong = (_func_int_varargs **)((int)(x->R1)._vptr_vlong + 1);
        if (((this->R).negative != 0) && ((((this->R).value)->super_vlong_flex_unit).n != 0)) {
            iVar4 = 1;
        }
        iVar5 = 0;
        if ((local_2c[0].negative != 0) && ((x->R)._vptr_vlong != (_func_int_varargs **)0x0)) {
            iVar5 = 1;
        }
        local_2c[0].value = (vlong_value *)x;
        if (iVar4 == iVar5) {
                    // try { // try from 080eab18 to 080eab1c has its CatchHandler @ 080eabbc
            iVar4 = vlong_value::cf((this->R).value,(vlong_value *)x);
            __in_chrg = x;
        }
        else {
            iVar4 = (uint)(iVar4 == 0) * 2 + -1;
        }
        vlong::~vlong(local_2c,(int)__in_chrg);
        if (-1 < iVar4) break;
        __in_chrg = this;
        vlong::operator+=(&this->R,&this->R);
        this->N = this->N + 1;
    }
    local_3c = (undefined1  [4])&PTR__vlong_08128410;
    result.value = (vlong_value *)(this->R).negative;
    result._vptr_vlong = (_func_int_varargs **)(this->R).value;
    ((vlong_value *)result._vptr_vlong)->share = ((vlong_value *)result._vptr_vlong)->share + 1;
                    // try { // try from 080ea921 to 080ea925 has its CatchHandler @ 080ead15
    vlong::operator-=((vlong *)local_3c,pvVar7);
    a = (vlong *)local_3c;
                    // try { // try from 080ea93a to 080ea93e has its CatchHandler @ 080ead1f
    vlong::modinv(local_2c,a,pvVar7);
    pvVar3 = (this->R1).value;
    if (pvVar3->share == 0) {
        if (pvVar3 != (vlong_value *)0x0) {
            uVar6 = (pvVar3->super_vlong_flex_unit).z;
            while (uVar6 != 0) {
                uVar6 = uVar6 - 1;
                (pvVar3->super_vlong_flex_unit).a[uVar6] = 0;
            }
            puVar2 = (pvVar3->super_vlong_flex_unit).a;
            if (puVar2 != (uint *)0x0) {
                operator_delete__(puVar2);
            }
            operator_delete(pvVar3);
        }
    }
    else {
        pvVar3->share = pvVar3->share - 1;
    }
    pvVar3 = local_2c[0].value;
    (this->R1).value = local_2c[0].value;
    ((vlong *)&(local_2c[0].value)->share)->_vptr_vlong =
         (_func_int_varargs **)((int)((vlong *)&(local_2c[0].value)->share)->_vptr_vlong + 1);
    local_2c[0]._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
    (this->R1).negative = local_2c[0].negative;
    pp_Var1 = ((vlong *)&(local_2c[0].value)->share)->_vptr_vlong;
    if (pp_Var1 == (_func_int_varargs **)0x0) {
        if ((vlong_montgomery *)local_2c[0].value != (vlong_montgomery *)0x0) {
                    // try { // try from 080eaabd to 080eaac1 has its CatchHandler @ 080ead1f
            vlong_flex_unit::~vlong_flex_unit(&(local_2c[0].value)->super_vlong_flex_unit,(int)a);
            operator_delete(pvVar3);
        }
    }
    else {
        ((vlong *)&(local_2c[0].value)->share)->_vptr_vlong =
             (_func_int_varargs **)((int)pp_Var1 - 1);
    }
    pp_Var1 = result._vptr_vlong;
    local_3c = (undefined1  [4])&PTR__vlong_08128410;
    if (result._vptr_vlong[3] == (_func_int_varargs *)0x0) {
        if (result._vptr_vlong != (_func_int_varargs **)0x0) {
                    // try { // try from 080eaaa0 to 080eaaa4 has its CatchHandler @ 080ead75
            vlong_flex_unit::~vlong_flex_unit((vlong_flex_unit *)result._vptr_vlong,(int)a);
            operator_delete(pp_Var1);
        }
    }
    else {
        result._vptr_vlong[3] = result._vptr_vlong[3] + -1;
    }
                    // try { // try from 080ea9ac to 080ea9b0 has its CatchHandler @ 080ead75
    vlong::modinv(local_2c,pvVar7,&this->R);
    local_3c = (undefined1  [4])&PTR__vlong_08128410;
    result.value = (vlong_value *)(this->R).negative;
    pvVar7 = local_2c;
    result._vptr_vlong = (_func_int_varargs **)(this->R).value;
    ((vlong_value *)result._vptr_vlong)->share = ((vlong_value *)result._vptr_vlong)->share + 1;
                    // try { // try from 080ea9d7 to 080ea9db has its CatchHandler @ 080ead58
    vlong::operator-=((vlong *)local_3c,pvVar7);
    pvVar3 = (this->n1).value;
    if (pvVar3->share == 0) {
        if (pvVar3 != (vlong_value *)0x0) {
            uVar6 = (pvVar3->super_vlong_flex_unit).z;
            while (uVar6 != 0) {
                uVar6 = uVar6 - 1;
                (pvVar3->super_vlong_flex_unit).a[uVar6] = 0;
            }
            puVar2 = (pvVar3->super_vlong_flex_unit).a;
            if (puVar2 != (uint *)0x0) {
                operator_delete__(puVar2);
            }
            operator_delete(pvVar3);
        }
    }
    else {
        pvVar3->share = pvVar3->share - 1;
    }
    pp_Var1 = result._vptr_vlong;
    (this->n1).value = (vlong_value *)result._vptr_vlong;
    result._vptr_vlong[3] = result._vptr_vlong[3] + 1;
    local_3c = (undefined1  [4])&PTR__vlong_08128410;
    (this->n1).negative = (int)result.value;
    if (result._vptr_vlong[3] == (_func_int_varargs *)0x0) {
        if (result._vptr_vlong != (_func_int_varargs **)0x0) {
                    // try { // try from 080eaa4e to 080eaa52 has its CatchHandler @ 080ead71
            vlong_flex_unit::~vlong_flex_unit((vlong_flex_unit *)result._vptr_vlong,(int)pvVar7);
            operator_delete(pp_Var1);
        }
    }
    else {
        result._vptr_vlong[3] = result._vptr_vlong[3] + -1;
    }
    pvVar3 = local_2c[0].value;
    local_2c[0]._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
    pp_Var1 = ((vlong *)&(local_2c[0].value)->share)->_vptr_vlong;
    if (pp_Var1 == (_func_int_varargs **)0x0) {
        if ((vlong_montgomery *)local_2c[0].value != (vlong_montgomery *)0x0) {
                    // try { // try from 080eaa38 to 080eaa3c has its CatchHandler @ 080ead75
            vlong_flex_unit::~vlong_flex_unit
                      (&(local_2c[0].value)->super_vlong_flex_unit,(int)pvVar7);
            operator_delete(pvVar3);
        }
    }
    else {
        ((vlong *)&(local_2c[0].value)->share)->_vptr_vlong =
             (_func_int_varargs **)((int)pp_Var1 - 1);
    }
    return;
}



// DWARF original prototype: void vlong_montgomery(vlong_montgomery * this, vlong * M)

void __thiscall vlong_montgomery::vlong_montgomery(vlong_montgomery *this,vlong *M)

{
    _func_int_varargs **pp_Var1;
    uint *puVar2;
    vlong_value *pvVar3;
    int iVar4;
    uint i;
    int iVar5;
    uint uVar6;
    vlong_montgomery *__in_chrg;
    vlong *a;
    vlong *pvVar7;
    vlong_montgomery *x;
    undefined1 local_3c [4];
    vlong result;
    vlong local_2c [2];
    
    (this->R)._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
    pvVar3 = (vlong_value *)operator_new(0x10);
    (pvVar3->super_vlong_flex_unit).z = 0;
    (pvVar3->super_vlong_flex_unit).a = (uint *)0x0;
    pvVar3->share = 0;
    (this->R).value = pvVar3;
    (this->R).negative = 0;
    (pvVar3->super_vlong_flex_unit).n = 0;
    vlong_flex_unit::set((vlong_flex_unit *)pvVar3,0,0);
    (this->R1)._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
                    // try { // try from 080eae12 to 080eae56 has its CatchHandler @ 080eb598
    pvVar3 = (vlong_value *)operator_new(0x10);
    (pvVar3->super_vlong_flex_unit).z = 0;
    (pvVar3->super_vlong_flex_unit).a = (uint *)0x0;
    pvVar3->share = 0;
    (this->R1).value = pvVar3;
    (this->R1).negative = 0;
    (pvVar3->super_vlong_flex_unit).n = 0;
    vlong_flex_unit::set((vlong_flex_unit *)pvVar3,0,0);
    pvVar7 = &this->m;
    (this->m)._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
                    // try { // try from 080eae6b to 080eaeaf has its CatchHandler @ 080eb591
    pvVar3 = (vlong_value *)operator_new(0x10);
    (pvVar3->super_vlong_flex_unit).z = 0;
    (pvVar3->super_vlong_flex_unit).a = (uint *)0x0;
    pvVar3->share = 0;
    (this->m).value = pvVar3;
    (this->m).negative = 0;
    (pvVar3->super_vlong_flex_unit).n = 0;
    vlong_flex_unit::set((vlong_flex_unit *)pvVar3,0,0);
    (this->n1)._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
                    // try { // try from 080eaec4 to 080eaf08 has its CatchHandler @ 080eb58a
    pvVar3 = (vlong_value *)operator_new(0x10);
    (pvVar3->super_vlong_flex_unit).z = 0;
    (pvVar3->super_vlong_flex_unit).a = (uint *)0x0;
    pvVar3->share = 0;
    (this->n1).value = pvVar3;
    (this->n1).negative = 0;
    (pvVar3->super_vlong_flex_unit).n = 0;
    vlong_flex_unit::set((vlong_flex_unit *)pvVar3,0,0);
    (this->T)._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
                    // try { // try from 080eaf1d to 080eaf61 has its CatchHandler @ 080eb583
    pvVar3 = (vlong_value *)operator_new(0x10);
    (pvVar3->super_vlong_flex_unit).z = 0;
    (pvVar3->super_vlong_flex_unit).a = (uint *)0x0;
    pvVar3->share = 0;
    (this->T).value = pvVar3;
    (this->T).negative = 0;
    (pvVar3->super_vlong_flex_unit).n = 0;
    vlong_flex_unit::set((vlong_flex_unit *)pvVar3,0,0);
    (this->k)._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
                    // try { // try from 080eaf76 to 080eafba has its CatchHandler @ 080eb57c
    pvVar3 = (vlong_value *)operator_new(0x10);
    (pvVar3->super_vlong_flex_unit).z = 0;
    (pvVar3->super_vlong_flex_unit).a = (uint *)0x0;
    pvVar3->share = 0;
    (this->k).value = pvVar3;
    (this->k).negative = 0;
    (pvVar3->super_vlong_flex_unit).n = 0;
    vlong_flex_unit::set((vlong_flex_unit *)pvVar3,0,0);
    pvVar3 = (this->m).value;
    if (pvVar3->share == 0) {
        if (pvVar3 != (vlong_value *)0x0) {
            uVar6 = (pvVar3->super_vlong_flex_unit).z;
            while (uVar6 != 0) {
                uVar6 = uVar6 - 1;
                (pvVar3->super_vlong_flex_unit).a[uVar6] = 0;
            }
            puVar2 = (pvVar3->super_vlong_flex_unit).a;
            if (puVar2 != (uint *)0x0) {
                operator_delete__(puVar2);
            }
            operator_delete(pvVar3);
        }
    }
    else {
        pvVar3->share = pvVar3->share - 1;
    }
    pvVar3 = M->value;
    (this->m).value = pvVar3;
    puVar2 = &pvVar3->share;
    *puVar2 = *puVar2 + 1;
    (this->m).negative = M->negative;
    this->N = 0;
    local_2c[0]._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
                    // try { // try from 080eaff7 to 080eb0f5 has its CatchHandler @ 080eb575
    local_2c[0].value = (vlong_value *)operator_new(0x10);
    ((local_2c[0].value)->super_vlong_flex_unit).z = 0;
    ((local_2c[0].value)->super_vlong_flex_unit).a = (uint *)0x0;
    (local_2c[0].value)->share = 0;
    local_2c[0].negative = 0;
    ((local_2c[0].value)->super_vlong_flex_unit).n = 0;
    __in_chrg = (vlong_montgomery *)0x0;
    vlong_flex_unit::set((vlong_flex_unit *)local_2c[0].value,0,1);
    pvVar3 = (this->R).value;
    if (pvVar3->share == 0) {
        if (pvVar3 != (vlong_value *)0x0) {
            uVar6 = (pvVar3->super_vlong_flex_unit).z;
            while (uVar6 != 0) {
                uVar6 = uVar6 - 1;
                (pvVar3->super_vlong_flex_unit).a[uVar6] = 0;
            }
            puVar2 = (pvVar3->super_vlong_flex_unit).a;
            if (puVar2 != (uint *)0x0) {
                operator_delete__(puVar2);
            }
            operator_delete(pvVar3);
        }
    }
    else {
        pvVar3->share = pvVar3->share - 1;
    }
    pvVar3 = local_2c[0].value;
    (this->R).value = local_2c[0].value;
    (local_2c[0].value)->share = (local_2c[0].value)->share + 1;
    local_2c[0]._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
    (this->R).negative = local_2c[0].negative;
    if ((local_2c[0].value)->share == 0) {
        if (local_2c[0].value != (vlong_value *)0x0) {
                    // try { // try from 080eb32d to 080eb331 has its CatchHandler @ 080eb575
            vlong_flex_unit::~vlong_flex_unit
                      (&(local_2c[0].value)->super_vlong_flex_unit,(int)__in_chrg);
            operator_delete(pvVar3);
        }
    }
    else {
        (local_2c[0].value)->share = (local_2c[0].value)->share - 1;
    }
    while( true ) {
        local_2c[0]._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
        local_2c[0].negative = M->negative;
        iVar4 = 0;
        x = (vlong_montgomery *)M->value;
        (x->R1)._vptr_vlong = (_func_int_varargs **)((int)(x->R1)._vptr_vlong + 1);
        if (((this->R).negative != 0) && ((((this->R).value)->super_vlong_flex_unit).n != 0)) {
            iVar4 = 1;
        }
        iVar5 = 0;
        if ((local_2c[0].negative != 0) && ((x->R)._vptr_vlong != (_func_int_varargs **)0x0)) {
            iVar5 = 1;
        }
        local_2c[0].value = (vlong_value *)x;
        if (iVar4 == iVar5) {
                    // try { // try from 080eb318 to 080eb31c has its CatchHandler @ 080eb3bc
            iVar4 = vlong_value::cf((this->R).value,(vlong_value *)x);
            __in_chrg = x;
        }
        else {
            iVar4 = (uint)(iVar4 == 0) * 2 + -1;
        }
        vlong::~vlong(local_2c,(int)__in_chrg);
        if (-1 < iVar4) break;
        __in_chrg = this;
        vlong::operator+=(&this->R,&this->R);
        this->N = this->N + 1;
    }
    local_3c = (undefined1  [4])&PTR__vlong_08128410;
    result.value = (vlong_value *)(this->R).negative;
    result._vptr_vlong = (_func_int_varargs **)(this->R).value;
    ((vlong_value *)result._vptr_vlong)->share = ((vlong_value *)result._vptr_vlong)->share + 1;
                    // try { // try from 080eb121 to 080eb125 has its CatchHandler @ 080eb515
    vlong::operator-=((vlong *)local_3c,pvVar7);
    a = (vlong *)local_3c;
                    // try { // try from 080eb13a to 080eb13e has its CatchHandler @ 080eb51f
    vlong::modinv(local_2c,a,pvVar7);
    pvVar3 = (this->R1).value;
    if (pvVar3->share == 0) {
        if (pvVar3 != (vlong_value *)0x0) {
            uVar6 = (pvVar3->super_vlong_flex_unit).z;
            while (uVar6 != 0) {
                uVar6 = uVar6 - 1;
                (pvVar3->super_vlong_flex_unit).a[uVar6] = 0;
            }
            puVar2 = (pvVar3->super_vlong_flex_unit).a;
            if (puVar2 != (uint *)0x0) {
                operator_delete__(puVar2);
            }
            operator_delete(pvVar3);
        }
    }
    else {
        pvVar3->share = pvVar3->share - 1;
    }
    pvVar3 = local_2c[0].value;
    (this->R1).value = local_2c[0].value;
    ((vlong *)&(local_2c[0].value)->share)->_vptr_vlong =
         (_func_int_varargs **)((int)((vlong *)&(local_2c[0].value)->share)->_vptr_vlong + 1);
    local_2c[0]._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
    (this->R1).negative = local_2c[0].negative;
    pp_Var1 = ((vlong *)&(local_2c[0].value)->share)->_vptr_vlong;
    if (pp_Var1 == (_func_int_varargs **)0x0) {
        if ((vlong_montgomery *)local_2c[0].value != (vlong_montgomery *)0x0) {
                    // try { // try from 080eb2bd to 080eb2c1 has its CatchHandler @ 080eb51f
            vlong_flex_unit::~vlong_flex_unit(&(local_2c[0].value)->super_vlong_flex_unit,(int)a);
            operator_delete(pvVar3);
        }
    }
    else {
        ((vlong *)&(local_2c[0].value)->share)->_vptr_vlong =
             (_func_int_varargs **)((int)pp_Var1 - 1);
    }
    pp_Var1 = result._vptr_vlong;
    local_3c = (undefined1  [4])&PTR__vlong_08128410;
    if (result._vptr_vlong[3] == (_func_int_varargs *)0x0) {
        if (result._vptr_vlong != (_func_int_varargs **)0x0) {
                    // try { // try from 080eb2a0 to 080eb2a4 has its CatchHandler @ 080eb575
            vlong_flex_unit::~vlong_flex_unit((vlong_flex_unit *)result._vptr_vlong,(int)a);
            operator_delete(pp_Var1);
        }
    }
    else {
        result._vptr_vlong[3] = result._vptr_vlong[3] + -1;
    }
                    // try { // try from 080eb1ac to 080eb1b0 has its CatchHandler @ 080eb575
    vlong::modinv(local_2c,pvVar7,&this->R);
    local_3c = (undefined1  [4])&PTR__vlong_08128410;
    result.value = (vlong_value *)(this->R).negative;
    pvVar7 = local_2c;
    result._vptr_vlong = (_func_int_varargs **)(this->R).value;
    ((vlong_value *)result._vptr_vlong)->share = ((vlong_value *)result._vptr_vlong)->share + 1;
                    // try { // try from 080eb1d7 to 080eb1db has its CatchHandler @ 080eb558
    vlong::operator-=((vlong *)local_3c,pvVar7);
    pvVar3 = (this->n1).value;
    if (pvVar3->share == 0) {
        if (pvVar3 != (vlong_value *)0x0) {
            uVar6 = (pvVar3->super_vlong_flex_unit).z;
            while (uVar6 != 0) {
                uVar6 = uVar6 - 1;
                (pvVar3->super_vlong_flex_unit).a[uVar6] = 0;
            }
            puVar2 = (pvVar3->super_vlong_flex_unit).a;
            if (puVar2 != (uint *)0x0) {
                operator_delete__(puVar2);
            }
            operator_delete(pvVar3);
        }
    }
    else {
        pvVar3->share = pvVar3->share - 1;
    }
    pp_Var1 = result._vptr_vlong;
    (this->n1).value = (vlong_value *)result._vptr_vlong;
    result._vptr_vlong[3] = result._vptr_vlong[3] + 1;
    local_3c = (undefined1  [4])&PTR__vlong_08128410;
    (this->n1).negative = (int)result.value;
    if (result._vptr_vlong[3] == (_func_int_varargs *)0x0) {
        if (result._vptr_vlong != (_func_int_varargs **)0x0) {
                    // try { // try from 080eb24e to 080eb252 has its CatchHandler @ 080eb571
            vlong_flex_unit::~vlong_flex_unit((vlong_flex_unit *)result._vptr_vlong,(int)pvVar7);
            operator_delete(pp_Var1);
        }
    }
    else {
        result._vptr_vlong[3] = result._vptr_vlong[3] + -1;
    }
    pvVar3 = local_2c[0].value;
    local_2c[0]._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
    pp_Var1 = ((vlong *)&(local_2c[0].value)->share)->_vptr_vlong;
    if (pp_Var1 == (_func_int_varargs **)0x0) {
        if ((vlong_montgomery *)local_2c[0].value != (vlong_montgomery *)0x0) {
                    // try { // try from 080eb238 to 080eb23c has its CatchHandler @ 080eb575
            vlong_flex_unit::~vlong_flex_unit
                      (&(local_2c[0].value)->super_vlong_flex_unit,(int)pvVar7);
            operator_delete(pvVar3);
        }
    }
    else {
        ((vlong *)&(local_2c[0].value)->share)->_vptr_vlong =
             (_func_int_varargs **)((int)pp_Var1 - 1);
    }
    return;
}



// DWARF original prototype: void mul(vlong_montgomery * this, vlong * x, vlong * y)

void __thiscall vlong_montgomery::mul(vlong_montgomery *this,vlong *x,vlong *y)

{
    uint uVar1;
    sbyte sVar2;
    vlong_value *pvVar3;
    uint uVar4;
    int iVar5;
    uint u;
    uint x_00;
    int iVar6;
    uint i;
    vlong_value *i_00;
    vlong_value *pvVar7;
    uint uVar8;
    vlong_value *pvVar9;
    vlong_value *pvVar10;
    byte local_34;
    uint delta;
    vlong_value *local_28;
    int local_24;
    
    vlong_flex_unit::fast_mul
              (&((this->T).value)->super_vlong_flex_unit,&x->value->super_vlong_flex_unit,
               &y->value->super_vlong_flex_unit,this->N * 2);
    vlong_flex_unit::fast_mul
              (&((this->k).value)->super_vlong_flex_unit,&((this->T).value)->super_vlong_flex_unit,
               &((this->n1).value)->super_vlong_flex_unit,this->N);
    vlong_flex_unit::fast_mul
              (&x->value->super_vlong_flex_unit,&((this->k).value)->super_vlong_flex_unit,
               &((this->m).value)->super_vlong_flex_unit,this->N * 2);
    pvVar9 = (vlong_value *)&this->T;
    vlong::operator+=(x,(vlong *)pvVar9);
    pvVar10 = x->value;
    uVar1 = this->N;
    pvVar3 = (vlong_value *)(pvVar10->super_vlong_flex_unit).n;
    uVar8 = uVar1 & 0x1f;
    if (pvVar3 != (vlong_value *)0x0) {
        sVar2 = (sbyte)uVar8;
        local_34 = 0x20 - sVar2;
        i_00 = (vlong_value *)0x0;
        do {
            x_00 = 0;
            pvVar9 = (vlong_value *)((int)&(i_00->super_vlong_flex_unit).n + (uVar1 >> 5));
            if (pvVar9 < pvVar3) {
                x_00 = (pvVar10->super_vlong_flex_unit).a[(int)pvVar9];
            }
            if (uVar8 != 0) {
                uVar4 = 0;
                pvVar9 = (vlong_value *)((int)&(pvVar9->super_vlong_flex_unit).n + 1);
                if (pvVar9 < pvVar3) {
                    uVar4 = (pvVar10->super_vlong_flex_unit).a[(int)pvVar9];
                }
                x_00 = (x_00 >> sVar2) + (uVar4 << (local_34 & 0x1f));
            }
            pvVar7 = (vlong_value *)((int)&(i_00->super_vlong_flex_unit).n + 1);
            pvVar9 = i_00;
            vlong_flex_unit::set(&pvVar10->super_vlong_flex_unit,(uint)i_00,x_00);
            pvVar3 = (vlong_value *)(pvVar10->super_vlong_flex_unit).n;
            i_00 = pvVar7;
        } while (pvVar7 < pvVar3);
    }
    delta = (uint)&PTR__vlong_08128410;
    iVar5 = 0;
    local_24 = (this->m).negative;
    pvVar10 = (this->m).value;
    pvVar10->share = pvVar10->share + 1;
    if ((x->negative != 0) && ((x->value->super_vlong_flex_unit).n != 0)) {
        iVar5 = 1;
    }
    iVar6 = 0;
    if ((local_24 != 0) && ((pvVar10->super_vlong_flex_unit).n != 0)) {
        iVar6 = 1;
    }
    local_28 = pvVar10;
    if (iVar5 == iVar6) {
                    // try { // try from 080eb76a to 080eb76e has its CatchHandler @ 080eb771
        iVar5 = vlong_value::cf(x->value,pvVar10);
        pvVar9 = pvVar10;
    }
    else {
        iVar5 = (uint)(iVar5 == 0) * 2 + -1;
    }
    vlong::~vlong((vlong *)&delta,(int)pvVar9);
    if (-1 < iVar5) {
        vlong::operator-=(x,&this->m);
    }
    return;
}



// DWARF original prototype: vlong exp(vlong_montgomery * this, vlong * x, vlong * e)

double __thiscall vlong_montgomery::exp(vlong_montgomery *this,double __x)

{
    vlong_flex_unit *x;
    _func_int_varargs **pp_Var1;
    vlong_value *x_00;
    uint uVar2;
    uint uVar3;
    vlong_value *pvVar4;
    uint x_2;
    uint i;
    uint uVar5;
    longdouble extraout_ST0;
    longdouble lVar6;
    longdouble extraout_ST0_00;
    longdouble extraout_ST0_01;
    longdouble extraout_ST0_02;
    vlong *result_5;
    int in_stack_00000010;
    uint uVar7;
    uint local_84;
    uint *local_80;
    undefined1 local_5c [4];
    vlong_value divide;
    vlong result_2;
    undefined1 local_3c [4];
    vlong t;
    undefined1 local_2c [4];
    vlong result;
    
    local_2c = (undefined1  [4])&PTR__vlong_08128410;
    result.value = (vlong_value *)result_5->negative;
    result._vptr_vlong = (_func_int_varargs **)result_5->value;
    ((vlong_value *)result._vptr_vlong)->share = ((vlong_value *)result._vptr_vlong)->share + 1;
                    // try { // try from 080eb7cb to 080eb7cf has its CatchHandler @ 080ebce1
    vlong::operator-=((vlong *)local_2c,result_5 + 2);
    divide.share = (uint)&PTR__vlong_08128410;
                    // try { // try from 080eb7de to 080eb81f has its CatchHandler @ 080ebdf0
    x_00 = (vlong_value *)operator_new(0x10);
    (x_00->super_vlong_flex_unit).z = 0;
    (x_00->super_vlong_flex_unit).a = (uint *)0x0;
    x_00->share = 0;
    (x_00->super_vlong_flex_unit).n = 0;
    vlong_flex_unit::set((vlong_flex_unit *)x_00,0,0);
    x = *(vlong_flex_unit **)(__x._4_4_ + 4);
    pvVar4 = result_5->value;
    uVar5 = x->n << 5;
    do {
        uVar7 = uVar5;
        if (uVar7 == 0) break;
        uVar5 = uVar7 - 1;
        if (uVar5 >> 5 < x->n) {
            uVar2 = x->a[uVar5 >> 5];
        }
        else {
            uVar2 = 0;
        }
    } while ((1 << ((byte)uVar5 & 0x1f) & uVar2) == 0);
    uVar5 = (pvVar4->super_vlong_flex_unit).n << 5;
    do {
        uVar2 = uVar5;
        if (uVar2 == 0) break;
        uVar5 = uVar2 - 1;
        if (uVar5 >> 5 < (pvVar4->super_vlong_flex_unit).n) {
            uVar3 = (pvVar4->super_vlong_flex_unit).a[uVar5 >> 5];
        }
        else {
            uVar3 = 0;
        }
    } while ((1 << ((byte)uVar5 & 0x1f) & uVar3) == 0);
                    // try { // try from 080eb8c8 to 080eb8cc has its CatchHandler @ 080ebcf0
    vlong_flex_unit::fast_mul
              ((vlong_flex_unit *)x_00,x,&pvVar4->super_vlong_flex_unit,uVar2 + uVar7);
    local_3c = (undefined1  [4])&PTR__vlong_08128410;
    uVar5 = result_5->negative;
    uVar7 = *(uint *)(__x._4_4_ + 8);
                    // try { // try from 080eb8ec to 080eb92d has its CatchHandler @ 080ebd80
    t._vptr_vlong = (_func_int_varargs **)operator_new(0x10);
    ((vlong_flex_unit *)t._vptr_vlong)->z = 0;
    ((vlong_flex_unit *)t._vptr_vlong)->a = (uint *)0x0;
    ((vlong_flex_unit *)((int)t._vptr_vlong + 0xc))->n = 0;
    t.value = (vlong_value *)0x0;
    ((vlong_flex_unit *)t._vptr_vlong)->n = 0;
    vlong_flex_unit::set((vlong_flex_unit *)t._vptr_vlong,0,0);
    divide.super_vlong_flex_unit.a = (uint *)0x0;
    divide.super_vlong_flex_unit.n = 0;
    local_5c = (undefined1  [4])0x0;
    divide.super_vlong_flex_unit.z = 0;
    pvVar4 = x_00;
                    // try { // try from 080eb968 to 080eb96c has its CatchHandler @ 080ebd33
    vlong_value::divide((vlong_value *)local_5c,x_00,result_5[2].value,(vlong_value *)t._vptr_vlong)
    ;
    t.value = (vlong_value *)(uVar5 ^ uVar7);
                    // try { // try from 080eb979 to 080eb97d has its CatchHandler @ 080ebd78
    vlong_flex_unit::~vlong_flex_unit((vlong_flex_unit *)local_5c,(int)pvVar4);
    divide.share = (uint)&PTR__vlong_08128410;
    if (x_00->share == 0) {
        if (x_00 != (vlong_value *)0x0) {
                    // try { // try from 080ebcb3 to 080ebcb7 has its CatchHandler @ 080ebdf0
            vlong_flex_unit::~vlong_flex_unit((vlong_flex_unit *)x_00,(int)pvVar4);
            operator_delete(x_00);
        }
    }
    else {
        x_00->share = x_00->share - 1;
    }
    local_80 = *(uint **)(in_stack_00000010 + 4);
    uVar5 = *local_80 << 5;
    do {
        uVar7 = uVar5;
        if (uVar7 == 0) break;
        uVar5 = uVar7 - 1;
        if (uVar5 >> 5 < *local_80) {
            uVar2 = *(uint *)(local_80[1] + (uVar5 >> 5) * 4);
        }
        else {
            uVar2 = 0;
        }
    } while ((1 << ((byte)uVar5 & 0x1f) & uVar2) == 0);
    uVar5 = 0;
    while( true ) {
        if (uVar5 >> 5 < *local_80) {
            uVar2 = *(uint *)(local_80[1] + (uVar5 >> 5) * 4);
        }
        else {
            uVar2 = 0;
        }
        if ((1 << ((byte)uVar5 & 0x1f) & uVar2) != 0) {
            mul((vlong_montgomery *)result_5,(vlong *)local_2c,(vlong *)local_3c);
        }
        uVar5 = uVar5 + 1;
        if (uVar5 == uVar7) break;
                    // try { // try from 080eba0f to 080eba77 has its CatchHandler @ 080ebde7
        mul((vlong_montgomery *)result_5,(vlong *)local_3c,(vlong *)local_3c);
        local_80 = *(uint **)(in_stack_00000010 + 4);
    }
    local_5c = (undefined1  [4])&PTR__vlong_08128410;
    divide.super_vlong_flex_unit.n = (uint)operator_new(0x10);
    ((vlong_flex_unit *)divide.super_vlong_flex_unit.n)->z = 0;
    ((vlong_flex_unit *)divide.super_vlong_flex_unit.n)->a = (uint *)0x0;
    ((vlong_flex_unit *)(divide.super_vlong_flex_unit.n + 0xc))->n = 0;
    divide.super_vlong_flex_unit.a = (uint *)0x0;
    ((vlong_flex_unit *)divide.super_vlong_flex_unit.n)->n = 0;
    vlong_flex_unit::set((vlong_flex_unit *)divide.super_vlong_flex_unit.n,0,0);
    pvVar4 = result_5[1].value;
    uVar5 = (int)*result._vptr_vlong << 5;
    do {
        uVar7 = uVar5;
        if (uVar7 == 0) break;
        uVar5 = uVar7 - 1;
        if ((_func_int_varargs *)(uVar5 >> 5) < *result._vptr_vlong) {
            uVar2 = *(uint *)(result._vptr_vlong[1] + (int)(uVar5 >> 5) * 4);
        }
        else {
            uVar2 = 0;
        }
    } while ((1 << ((byte)uVar5 & 0x1f) & uVar2) == 0);
    uVar5 = (pvVar4->super_vlong_flex_unit).n << 5;
    do {
        uVar2 = uVar5;
        if (uVar2 == 0) break;
        uVar5 = uVar2 - 1;
        if (uVar5 >> 5 < (pvVar4->super_vlong_flex_unit).n) {
            local_84 = (pvVar4->super_vlong_flex_unit).a[uVar5 >> 5];
        }
        else {
            local_84 = 0;
        }
    } while ((local_84 & 1 << ((byte)uVar5 & 0x1f)) == 0);
                    // try { // try from 080ebb09 to 080ebb0d has its CatchHandler @ 080ebd84
    vlong_flex_unit::fast_mul
              ((vlong_flex_unit *)divide.super_vlong_flex_unit.n,
               (vlong_flex_unit *)result._vptr_vlong,&pvVar4->super_vlong_flex_unit,uVar2 + uVar7);
    divide.super_vlong_flex_unit.a = (uint *)(result_5[1].negative ^ (uint)result.value);
    (this->R)._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
                    // try { // try from 080ebb2c to 080ebb70 has its CatchHandler @ 080ebde3
    pvVar4 = (vlong_value *)operator_new(0x10);
    (pvVar4->super_vlong_flex_unit).z = 0;
    (pvVar4->super_vlong_flex_unit).a = (uint *)0x0;
    pvVar4->share = 0;
    (this->R).value = pvVar4;
    (this->R).negative = 0;
    (pvVar4->super_vlong_flex_unit).n = 0;
    vlong_flex_unit::set((vlong_flex_unit *)pvVar4,0,0);
    divide.share = 0;
    uVar7 = divide.super_vlong_flex_unit.n;
                    // try { // try from 080ebbae to 080ebbb2 has its CatchHandler @ 080ebd9d
    vlong_value::divide((vlong_value *)&divide.share,(vlong_value *)divide.super_vlong_flex_unit.n,
                        result_5[2].value,(this->R).value);
    (this->R).negative = (int)divide.super_vlong_flex_unit.a;
                    // try { // try from 080ebbbf to 080ebbc3 has its CatchHandler @ 080ebddf
    vlong_flex_unit::~vlong_flex_unit((vlong_flex_unit *)&divide.share,uVar7);
    uVar5 = divide.super_vlong_flex_unit.n;
    local_5c = (undefined1  [4])&PTR__vlong_08128410;
    lVar6 = extraout_ST0;
    if (*(int *)(divide.super_vlong_flex_unit.n + 0xc) == 0) {
        if (divide.super_vlong_flex_unit.n != 0) {
                    // try { // try from 080ebc46 to 080ebc89 has its CatchHandler @ 080ebde7
            vlong_flex_unit::~vlong_flex_unit
                      ((vlong_flex_unit *)divide.super_vlong_flex_unit.n,uVar7);
            operator_delete((void *)uVar5);
            lVar6 = extraout_ST0_02;
        }
    }
    else {
        *(int *)(divide.super_vlong_flex_unit.n + 0xc) =
             *(int *)(divide.super_vlong_flex_unit.n + 0xc) + -1;
    }
    pp_Var1 = t._vptr_vlong;
    local_3c = (undefined1  [4])&PTR__vlong_08128410;
    if (t._vptr_vlong[3] == (_func_int_varargs *)0x0) {
        if (t._vptr_vlong != (_func_int_varargs **)0x0) {
                    // try { // try from 080ebc30 to 080ebc34 has its CatchHandler @ 080ebdf0
            vlong_flex_unit::~vlong_flex_unit((vlong_flex_unit *)t._vptr_vlong,uVar7);
            operator_delete(pp_Var1);
            lVar6 = extraout_ST0_01;
        }
    }
    else {
        t._vptr_vlong[3] = t._vptr_vlong[3] + -1;
    }
    pp_Var1 = result._vptr_vlong;
    local_2c = (undefined1  [4])&PTR__vlong_08128410;
    if (result._vptr_vlong[3] == (_func_int_varargs *)0x0) {
        if (result._vptr_vlong != (_func_int_varargs **)0x0) {
            vlong_flex_unit::~vlong_flex_unit((vlong_flex_unit *)result._vptr_vlong,uVar7);
            operator_delete(pp_Var1);
            lVar6 = extraout_ST0_00;
        }
    }
    else {
        result._vptr_vlong[3] = result._vptr_vlong[3] + -1;
    }
    return (double)lVar6;
}



// DWARF original prototype: void vlong_flex_unit(vlong_flex_unit * this)

void __thiscall vlong_flex_unit::vlong_flex_unit(vlong_flex_unit *this)

{
    this->z = 0;
    this->a = (uint *)0x0;
    this->n = 0;
    return;
}



// DWARF original prototype: void vlong_flex_unit(vlong_flex_unit * this)

void __thiscall vlong_flex_unit::vlong_flex_unit(vlong_flex_unit *this)

{
    this->z = 0;
    this->a = (uint *)0x0;
    this->n = 0;
    return;
}



// DWARF original prototype: void ~vlong_flex_unit(vlong_flex_unit * this, int __in_chrg)

void __thiscall vlong_flex_unit::~vlong_flex_unit(vlong_flex_unit *this,int __in_chrg)

{
    uint i;
    uint uVar1;
    
    uVar1 = this->z;
    while (uVar1 != 0) {
        uVar1 = uVar1 - 1;
        this->a[uVar1] = 0;
    }
    if (this->a == (uint *)0x0) {
        return;
    }
    operator_delete__(this->a);
    return;
}



// DWARF original prototype: void ~vlong_flex_unit(vlong_flex_unit * this, int __in_chrg)

void __thiscall vlong_flex_unit::~vlong_flex_unit(vlong_flex_unit *this,int __in_chrg)

{
    uint i;
    uint uVar1;
    
    uVar1 = this->z;
    while (uVar1 != 0) {
        uVar1 = uVar1 - 1;
        this->a[uVar1] = 0;
    }
    if (this->a == (uint *)0x0) {
        return;
    }
    operator_delete__(this->a);
    return;
}



// DWARF original prototype: uint get(vlong_flex_unit * this, uint i)

uint __thiscall vlong_flex_unit::get(vlong_flex_unit *this,uint i)

{
    uint uVar1;
    
    if (i < this->n) {
        uVar1 = this->a[i];
    }
    else {
        uVar1 = 0;
    }
    return uVar1;
}



// DWARF original prototype: void clear(vlong_flex_unit * this)

void __thiscall vlong_flex_unit::clear(vlong_flex_unit *this)

{
    this->n = 0;
    return;
}



// DWARF original prototype: void reserve(vlong_flex_unit * this, uint x)

void __thiscall vlong_flex_unit::reserve(vlong_flex_unit *this,uint x)

{
    uint *puVar1;
    uint i;
    uint uVar2;
    uint *na;
    
    if (this->z < x) {
        puVar1 = (uint *)operator_new__(x * 4);
        uVar2 = 0;
        if (this->n != 0) {
            do {
                puVar1[uVar2] = this->a[uVar2];
                uVar2 = uVar2 + 1;
            } while (uVar2 < this->n);
        }
        if (this->a != (uint *)0x0) {
            operator_delete__(this->a);
        }
        this->a = puVar1;
        this->z = x;
    }
    return;
}



// DWARF original prototype: void set(vlong_flex_unit * this, uint i, uint x)

void __thiscall vlong_flex_unit::set(vlong_flex_unit *this,uint i,uint x)

{
    uint uVar1;
    uint uVar2;
    uint *puVar3;
    uint j;
    uint uVar4;
    uint *na;
    
    uVar4 = this->n;
    if (i < uVar4) {
        this->a[i] = x;
        if ((x == 0) && (uVar4 = this->n, uVar4 != 0)) {
            uVar1 = this->a[uVar4 - 1];
            while (uVar1 == 0) {
                uVar2 = uVar4 - 1;
                this->n = uVar2;
                if (uVar2 == 0) {
                    return;
                }
                uVar1 = this->a[uVar4 - 2];
                uVar4 = uVar2;
            }
        }
    }
    else if (x != 0) {
        uVar1 = i + 1;
        if (this->z < uVar1) {
            puVar3 = (uint *)operator_new__(uVar1 * 4);
            uVar2 = 0;
            uVar4 = this->n;
            if (uVar4 != 0) {
                do {
                    puVar3[uVar2] = this->a[uVar2];
                    uVar2 = uVar2 + 1;
                    uVar4 = this->n;
                } while (uVar2 < uVar4);
            }
            if (this->a != (uint *)0x0) {
                operator_delete__(this->a);
                uVar4 = this->n;
            }
            this->a = puVar3;
            this->z = uVar1;
        }
        for (; uVar4 < i; uVar4 = uVar4 + 1) {
            this->a[uVar4] = 0;
        }
        this->a[i] = x;
        this->n = uVar1;
    }
    return;
}



// WARNING: Variable defined which should be unmapped: i
// DWARF original prototype: void fast_mul(vlong_flex_unit * this, vlong_flex_unit * x,
// vlong_flex_unit * y, uint keep)

void __thiscall
vlong_flex_unit::fast_mul(vlong_flex_unit *this,vlong_flex_unit *x,vlong_flex_unit *y,uint keep)

{
    uint *puVar1;
    uint m;
    uint *puVar2;
    uint p;
    uint v;
    uint uVar3;
    uint uVar4;
    uint uVar5;
    uint *na;
    uint uVar6;
    uint c;
    uint uVar7;
    int iVar8;
    uint w;
    uint uVar9;
    uint uVar10;
    uint uVar11;
    uint local_24;
    uint j;
    uint min_1;
    uint min;
    uint limit;
    uint i;
    
    min = keep + 0x1f >> 5;
    if (this->z < min) {
        puVar2 = (uint *)operator_new__(min << 2);
        uVar5 = 0;
        if (this->n != 0) {
            do {
                puVar2[uVar5] = this->a[uVar5];
                uVar5 = uVar5 + 1;
            } while (uVar5 < this->n);
        }
        if (this->a != (uint *)0x0) {
            operator_delete__(this->a);
        }
        this->a = puVar2;
        this->z = min;
    }
    limit = 0;
    if (min != 0) {
        do {
            this->a[limit] = 0;
            limit = limit + 1;
        } while (limit < min);
    }
    limit = 0;
    uVar5 = min;
    if (x->n <= min) {
        uVar5 = x->n;
    }
    if (uVar5 != 0) {
        do {
            uVar7 = 0;
            uVar9 = limit + y->n;
            uVar3 = min;
            if (uVar9 <= min) {
                uVar3 = uVar9;
            }
            local_24 = limit;
            if (limit < uVar3) {
                uVar10 = x->a[limit] & 0xffff;
                uVar9 = x->a[limit] >> 0x10;
                uVar7 = 0;
                do {
                    uVar4 = this->a[local_24] + uVar7;
                    uVar7 = (uint)(uVar4 < uVar7);
                    uVar6 = y->a[local_24 - limit] & 0xffff;
                    uVar11 = uVar10 * uVar6;
                    uVar4 = uVar4 + uVar11;
                    if (uVar4 < uVar11) {
                        uVar7 = uVar7 + 1;
                    }
                    uVar6 = uVar9 * uVar6;
                    uVar11 = uVar6 * 0x10000;
                    uVar4 = uVar4 + uVar11;
                    iVar8 = uVar7 + (uVar6 >> 0x10);
                    if (uVar4 < uVar11) {
                        iVar8 = iVar8 + 1;
                    }
                    uVar7 = y->a[local_24 - limit] >> 0x10;
                    uVar6 = uVar10 * uVar7;
                    uVar11 = uVar6 * 0x10000;
                    iVar8 = iVar8 + (uVar6 >> 0x10);
                    uVar4 = uVar4 + uVar11;
                    if (uVar4 < uVar11) {
                        iVar8 = iVar8 + 1;
                    }
                    uVar7 = iVar8 + uVar7 * uVar9;
                    this->a[local_24] = uVar4;
                    local_24 = local_24 + 1;
                } while (local_24 < uVar3);
            }
            if ((uVar7 != 0) && (local_24 < min)) {
                puVar2 = this->a;
                do {
                    puVar2[local_24] = puVar2[local_24] + uVar7;
                    puVar2 = this->a;
                    puVar1 = puVar2 + local_24;
                    local_24 = local_24 + 1;
                    uVar7 = (uint)(*puVar1 < uVar7);
                    if (uVar7 == 0) break;
                } while (local_24 < min);
            }
            limit = limit + 1;
        } while (limit < uVar5);
    }
    if ((keep & 0x1f) != 0) {
        this->a[min - 1] = this->a[min - 1] & (1 << (sbyte)(keep & 0x1f)) - 1U;
    }
    if ((min != 0) && (this->a[min - 1] == 0)) {
        puVar2 = this->a + (min - 1);
        do {
            puVar2 = puVar2 + -1;
            min = min - 1;
            if (min == 0) break;
        } while (*puVar2 == 0);
    }
    this->n = min;
    return;
}



// DWARF original name: operator unsigned int
// DWARF original prototype: uint operator_unsigned_int(vlong_value * this)

uint __thiscall vlong_value::operator_unsigned_int(vlong_value *this)

{
    uint uVar1;
    
    if ((this->super_vlong_flex_unit).n == 0) {
        uVar1 = 0;
    }
    else {
        uVar1 = *(this->super_vlong_flex_unit).a;
    }
    return uVar1;
}



// DWARF original prototype: int is_zero(vlong_value * this)

int __thiscall vlong_value::is_zero(vlong_value *this)

{
    return (uint)((this->super_vlong_flex_unit).n == 0);
}



// DWARF original prototype: int test(vlong_value * this, uint i)

int __thiscall vlong_value::test(vlong_value *this,uint i)

{
    uint uVar1;
    
    if (i >> 5 < (this->super_vlong_flex_unit).n) {
        uVar1 = (this->super_vlong_flex_unit).a[i >> 5];
    }
    else {
        uVar1 = 0;
    }
    return (uint)((1 << ((byte)i & 0x1f) & uVar1) != 0);
}



// DWARF original prototype: uint bits(vlong_value * this)

uint __thiscall vlong_value::bits(vlong_value *this)

{
    uint uVar1;
    uint uVar2;
    uint x;
    uint uVar3;
    
    uVar1 = (this->super_vlong_flex_unit).n << 5;
    do {
        uVar3 = uVar1;
        if (uVar3 == 0) {
            return 0;
        }
        uVar1 = uVar3 - 1;
        if (uVar1 >> 5 < (this->super_vlong_flex_unit).n) {
            uVar2 = (this->super_vlong_flex_unit).a[uVar1 >> 5];
        }
        else {
            uVar2 = 0;
        }
    } while ((1 << ((byte)uVar1 & 0x1f) & uVar2) == 0);
    return uVar3;
}



// DWARF original prototype: int cf(vlong_value * this, vlong_value * x)

int __thiscall vlong_value::cf(vlong_value *this,vlong_value *x)

{
    uint uVar1;
    uint uVar2;
    int iVar3;
    uint uVar4;
    uint i;
    uint uVar5;
    uint uVar6;
    
    uVar1 = (this->super_vlong_flex_unit).n;
    uVar2 = (x->super_vlong_flex_unit).n;
    iVar3 = 1;
    if ((uVar1 <= uVar2) && (iVar3 = -1, uVar5 = uVar1, uVar2 <= uVar1)) {
        do {
            if (uVar5 == 0) {
                return 0;
            }
            uVar5 = uVar5 - 1;
            uVar6 = 0;
            if (uVar5 < uVar1) {
                uVar6 = (this->super_vlong_flex_unit).a[uVar5];
            }
            uVar4 = 0;
            if (uVar5 < uVar2) {
                uVar4 = (x->super_vlong_flex_unit).a[uVar5];
            }
            if (uVar4 < uVar6) {
                return 1;
            }
            if (uVar5 < (this->super_vlong_flex_unit).n) {
                uVar6 = (this->super_vlong_flex_unit).a[uVar5];
            }
            else {
                uVar6 = 0;
            }
            if (uVar5 < (x->super_vlong_flex_unit).n) {
                uVar4 = (x->super_vlong_flex_unit).a[uVar5];
            }
            else {
                uVar4 = 0;
            }
            iVar3 = -1;
        } while (uVar4 <= uVar6);
    }
    return iVar3;
}



// WARNING: Variable defined which should be unmapped: N
// DWARF original prototype: void shl(vlong_value * this)

void __thiscall vlong_value::shl(vlong_value *this)

{
    uint uVar1;
    uint uVar2;
    uint carry;
    uint uVar3;
    uint uVar4;
    uint i;
    uint i_00;
    uint N;
    
    uVar3 = 0;
    uVar1 = (this->super_vlong_flex_unit).n;
    uVar2 = uVar1;
    i_00 = 0;
    while( true ) {
        uVar4 = 0;
        if (i_00 < uVar2) {
            uVar4 = (this->super_vlong_flex_unit).a[i_00];
        }
        vlong_flex_unit::set(&this->super_vlong_flex_unit,i_00,uVar3 + uVar4 * 2);
        uVar3 = uVar4 >> 0x1f;
        if (uVar1 < i_00 + 1) break;
        uVar2 = (this->super_vlong_flex_unit).n;
        i_00 = i_00 + 1;
    }
    return;
}



// DWARF original prototype: void shr(vlong_value * this)

void __thiscall vlong_value::shr(vlong_value *this)

{
    uint uVar1;
    uint carry;
    int iVar2;
    uint i;
    uint i_00;
    uint uVar3;
    
    iVar2 = 0;
    uVar1 = (this->super_vlong_flex_unit).n;
    i_00 = uVar1;
    if (uVar1 != 0) {
        while( true ) {
            i_00 = i_00 - 1;
            uVar3 = 0;
            if (i_00 < uVar1) {
                uVar3 = (this->super_vlong_flex_unit).a[i_00];
            }
            vlong_flex_unit::set(&this->super_vlong_flex_unit,i_00,(uVar3 >> 1) + iVar2);
            iVar2 = uVar3 << 0x1f;
            if (i_00 == 0) break;
            uVar1 = (this->super_vlong_flex_unit).n;
        }
    }
    return;
}



// WARNING: Variable defined which should be unmapped: delta
// DWARF original prototype: void shr(vlong_value * this, uint x)

void __thiscall vlong_value::shr(vlong_value *this,uint x)

{
    sbyte sVar1;
    uint uVar2;
    uint uVar3;
    uint uVar4;
    uint u;
    uint x_00;
    uint i;
    uint i_00;
    byte local_18;
    uint delta;
    
    uVar2 = (this->super_vlong_flex_unit).n;
    if (uVar2 != 0) {
        sVar1 = (sbyte)(x & 0x1f);
        local_18 = 0x20 - sVar1;
        i_00 = 0;
        do {
            x_00 = 0;
            uVar4 = (x >> 5) + i_00;
            if (uVar4 < uVar2) {
                x_00 = (this->super_vlong_flex_unit).a[uVar4];
            }
            if ((x & 0x1f) != 0) {
                uVar3 = 0;
                if (uVar4 + 1 < uVar2) {
                    uVar3 = (this->super_vlong_flex_unit).a[uVar4 + 1];
                }
                x_00 = (x_00 >> sVar1) + (uVar3 << (local_18 & 0x1f));
            }
            uVar4 = i_00 + 1;
            vlong_flex_unit::set(&this->super_vlong_flex_unit,i_00,x_00);
            uVar2 = (this->super_vlong_flex_unit).n;
            i_00 = uVar4;
        } while (uVar4 < uVar2);
    }
    return;
}



// DWARF original prototype: void add(vlong_value * this, vlong_value * x)

void __thiscall vlong_value::add(vlong_value *this,vlong_value *x)

{
    uint *puVar1;
    uint uVar2;
    uint *puVar3;
    uint uVar4;
    uint u;
    uint i;
    uint uVar5;
    uint uVar6;
    uint carry;
    uint uVar7;
    uint max;
    uint uVar8;
    
    uVar8 = (this->super_vlong_flex_unit).n;
    uVar5 = (x->super_vlong_flex_unit).n;
    if (uVar8 < uVar5) {
        uVar8 = uVar5;
    }
    if ((this->super_vlong_flex_unit).z < uVar8) {
        puVar3 = (uint *)operator_new__(uVar8 * 4);
        uVar5 = 0;
        if ((this->super_vlong_flex_unit).n != 0) {
            do {
                puVar3[uVar5] = (this->super_vlong_flex_unit).a[uVar5];
                uVar5 = uVar5 + 1;
            } while (uVar5 < (this->super_vlong_flex_unit).n);
        }
        puVar1 = (this->super_vlong_flex_unit).a;
        if (puVar1 != (uint *)0x0) {
            operator_delete__(puVar1);
        }
        (this->super_vlong_flex_unit).a = puVar3;
        (this->super_vlong_flex_unit).z = uVar8;
    }
    uVar7 = 0;
    uVar5 = 0;
    if (uVar8 != 0xffffffff) {
        do {
            if (uVar5 < (this->super_vlong_flex_unit).n) {
                uVar2 = (this->super_vlong_flex_unit).a[uVar5];
            }
            else {
                uVar2 = 0;
            }
            uVar6 = (uint)(uVar7 + uVar2 < uVar7);
            if (uVar5 < (x->super_vlong_flex_unit).n) {
                uVar4 = (x->super_vlong_flex_unit).a[uVar5];
            }
            else {
                uVar4 = 0;
            }
            uVar2 = uVar7 + uVar2 + uVar4;
            uVar7 = uVar6;
            if (uVar2 < uVar4) {
                uVar7 = uVar6 + 1;
            }
            uVar6 = uVar5 + 1;
            vlong_flex_unit::set(&this->super_vlong_flex_unit,uVar5,uVar2);
            uVar5 = uVar6;
        } while (uVar6 < uVar8 + 1);
    }
    return;
}



// WARNING: Variable defined which should be unmapped: N
// DWARF original prototype: void subtract(vlong_value * this, vlong_value * x)

void __thiscall vlong_value::subtract(vlong_value *this,vlong_value *x)

{
    uint uVar1;
    uint uVar2;
    uint uVar3;
    uint ux;
    uint nu;
    uint i;
    uint i_00;
    uint carry;
    uint uVar4;
    uint N;
    
    i_00 = 0;
    uVar1 = (this->super_vlong_flex_unit).n;
    if (uVar1 != 0) {
        uVar4 = 0;
        do {
            if (i_00 < (x->super_vlong_flex_unit).n) {
                uVar2 = (x->super_vlong_flex_unit).a[i_00];
            }
            else {
                uVar2 = 0;
            }
            if (uVar4 <= uVar4 + uVar2) {
                if (i_00 < (this->super_vlong_flex_unit).n) {
                    uVar3 = (this->super_vlong_flex_unit).a[i_00];
                }
                else {
                    uVar3 = 0;
                }
                uVar2 = uVar3 - (uVar4 + uVar2);
                uVar4 = (uint)(uVar3 < uVar2);
                vlong_flex_unit::set(&this->super_vlong_flex_unit,i_00,uVar2);
            }
            i_00 = i_00 + 1;
        } while (i_00 < uVar1);
    }
    return;
}



// DWARF original prototype: void init(vlong_value * this, uint x)

int __thiscall vlong_value::init(vlong_value *this,EVP_PKEY_CTX *ctx)

{
    (this->super_vlong_flex_unit).n = 0;
    vlong_flex_unit::set(&this->super_vlong_flex_unit,0,(uint)ctx);
    return (int)ctx;
}



// DWARF original prototype: void copy(vlong_value * this, vlong_value * x)

int __thiscall vlong_value::copy(vlong_value *this,EVP_PKEY_CTX *dst,EVP_PKEY_CTX *src)

{
    uint in_EAX;
    uint i;
    uint i_00;
    
    (this->super_vlong_flex_unit).n = 0;
    i_00 = *(uint *)dst;
    while (i_00 != 0) {
        i_00 = i_00 - 1;
        if (i_00 < *(uint *)dst) {
            in_EAX = *(uint *)(*(int *)(dst + 4) + i_00 * 4);
        }
        else {
            in_EAX = 0;
        }
        vlong_flex_unit::set(&this->super_vlong_flex_unit,i_00,in_EAX);
    }
    return in_EAX;
}



// DWARF original prototype: void vlong_value(vlong_value * this)

void __thiscall vlong_value::vlong_value(vlong_value *this)

{
    (this->super_vlong_flex_unit).z = 0;
    (this->super_vlong_flex_unit).a = (uint *)0x0;
    (this->super_vlong_flex_unit).n = 0;
    this->share = 0;
    return;
}



// DWARF original prototype: void vlong_value(vlong_value * this)

void __thiscall vlong_value::vlong_value(vlong_value *this)

{
    (this->super_vlong_flex_unit).z = 0;
    (this->super_vlong_flex_unit).a = (uint *)0x0;
    (this->super_vlong_flex_unit).n = 0;
    this->share = 0;
    return;
}



// DWARF original prototype: void mul(vlong_value * this, vlong_value * x, vlong_value * y)

void __thiscall vlong_value::mul(vlong_value *this,vlong_value *x,vlong_value *y)

{
    uint uVar1;
    uint uVar2;
    
    uVar1 = bits(x);
    uVar2 = bits(y);
    vlong_flex_unit::fast_mul
              (&this->super_vlong_flex_unit,&x->super_vlong_flex_unit,&y->super_vlong_flex_unit,
               uVar2 + uVar1);
    return;
}



// DWARF original prototype: void divide(vlong_value * this, vlong_value * x, vlong_value * y,
// vlong_value * rem)

void __thiscall
vlong_value::divide(vlong_value *this,vlong_value *x,vlong_value *y,vlong_value *rem)

{
    uint *this_00;
    uint i_00;
    uint i_01;
    int iVar1;
    uint carry;
    EVP_PKEY_CTX *src;
    uint local_4c;
    uint i_1;
    uint i;
    vlong_value s;
    vlong_value m;
    
    this_00 = &s.share;
    (this->super_vlong_flex_unit).n = 0;
    src = (EVP_PKEY_CTX *)0x0;
    vlong_flex_unit::set(&this->super_vlong_flex_unit,0,0);
    copy(rem,(EVP_PKEY_CTX *)x,src);
    vlong_value((vlong_value *)this_00);
    vlong_value((vlong_value *)&i);
                    // try { // try from 080ec83c to 080ec97b has its CatchHandler @ 080ec9d7
    copy((vlong_value *)this_00,(EVP_PKEY_CTX *)y,src);
    i = 0;
    vlong_flex_unit::set((vlong_flex_unit *)&i,0,1);
    while (iVar1 = cf(rem,(vlong_value *)this_00), 0 < iVar1) {
        shl((vlong_value *)this_00);
        shl((vlong_value *)&i);
    }
    while (iVar1 = cf(rem,y), -1 < iVar1) {
        while (iVar1 = cf(rem,(vlong_value *)this_00), iVar1 < 0) {
            iVar1 = 0;
            i_01 = i;
            i_00 = s.share;
            while (i = i_01, i_00 != 0) {
                i_00 = i_00 - 1;
                if (i_00 < s.share) {
                    i_1 = *(uint *)(m.super_vlong_flex_unit.n + i_00 * 4);
                }
                else {
                    i_1 = 0;
                }
                vlong_flex_unit::set((vlong_flex_unit *)this_00,i_00,(i_1 >> 1) + iVar1);
                iVar1 = i_1 << 0x1f;
                i_01 = i;
            }
            iVar1 = 0;
            while (i_01 != 0) {
                i_01 = i_01 - 1;
                if (i_01 < i) {
                    local_4c = *(uint *)(s.super_vlong_flex_unit.n + i_01 * 4);
                }
                else {
                    local_4c = 0;
                }
                vlong_flex_unit::set((vlong_flex_unit *)&i,i_01,(local_4c >> 1) + iVar1);
                iVar1 = local_4c << 0x1f;
            }
        }
        subtract(rem,(vlong_value *)this_00);
        add(this,(vlong_value *)&i);
    }
    while (s.super_vlong_flex_unit.a != (uint *)0x0) {
        s.super_vlong_flex_unit.a = (uint *)((int)s.super_vlong_flex_unit.a + -1);
        *(undefined4 *)(s.super_vlong_flex_unit.n + (int)s.super_vlong_flex_unit.a * 4) = 0;
    }
    if (s.super_vlong_flex_unit.n != 0) {
        operator_delete__((void *)s.super_vlong_flex_unit.n);
    }
    if (m.super_vlong_flex_unit.a != (uint *)0x0) {
        do {
            m.super_vlong_flex_unit.a = (uint *)((int)m.super_vlong_flex_unit.a + -1);
            *(undefined4 *)(m.super_vlong_flex_unit.n + (int)m.super_vlong_flex_unit.a * 4) = 0;
        } while (m.super_vlong_flex_unit.a != (uint *)0x0);
    }
    if (m.super_vlong_flex_unit.n != 0) {
        operator_delete__((void *)m.super_vlong_flex_unit.n);
    }
    return;
}



// DWARF original prototype: void vlong(vlong * this, uint x)

void __thiscall vlong::vlong(vlong *this,uint x)

{
    vlong_value *this_00;
    
    this->_vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
    this_00 = (vlong_value *)operator_new(0x10);
    vlong_value::vlong_value(this_00);
    this->negative = 0;
    this->value = this_00;
    (this_00->super_vlong_flex_unit).n = 0;
    vlong_flex_unit::set((vlong_flex_unit *)this_00,0,x);
    return;
}



// DWARF original prototype: void vlong(vlong * this, uint x)

void __thiscall vlong::vlong(vlong *this,uint x)

{
    vlong_value *this_00;
    
    this->_vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
    this_00 = (vlong_value *)operator_new(0x10);
    vlong_value::vlong_value(this_00);
    this->negative = 0;
    this->value = this_00;
    (this_00->super_vlong_flex_unit).n = 0;
    vlong_flex_unit::set((vlong_flex_unit *)this_00,0,x);
    return;
}



// DWARF original prototype: void vlong(vlong * this, vlong * x)

void __thiscall vlong::vlong(vlong *this,vlong *x)

{
    uint *puVar1;
    int iVar2;
    vlong_value *pvVar3;
    
    iVar2 = x->negative;
    this->_vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
    this->negative = iVar2;
    pvVar3 = x->value;
    this->value = pvVar3;
    puVar1 = &pvVar3->share;
    *puVar1 = *puVar1 + 1;
    return;
}



// DWARF original prototype: void vlong(vlong * this, vlong * x)

void __thiscall vlong::vlong(vlong *this,vlong *x)

{
    uint *puVar1;
    int iVar2;
    vlong_value *pvVar3;
    
    iVar2 = x->negative;
    this->_vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
    this->negative = iVar2;
    pvVar3 = x->value;
    this->value = pvVar3;
    puVar1 = &pvVar3->share;
    *puVar1 = *puVar1 + 1;
    return;
}



// DWARF original prototype: void ~vlong(vlong * this, int __in_chrg)

void __thiscall vlong::~vlong(vlong *this,int __in_chrg)

{
    vlong_value *pvVar1;
    uint *puVar2;
    uint i;
    uint uVar3;
    
    pvVar1 = this->value;
    this->_vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
    if (pvVar1->share == 0) {
        if (pvVar1 != (vlong_value *)0x0) {
            uVar3 = (pvVar1->super_vlong_flex_unit).z;
            while (uVar3 != 0) {
                uVar3 = uVar3 - 1;
                (pvVar1->super_vlong_flex_unit).a[uVar3] = 0;
            }
            puVar2 = (pvVar1->super_vlong_flex_unit).a;
            if (puVar2 != (uint *)0x0) {
                operator_delete__(puVar2);
            }
            operator_delete(pvVar1);
        }
    }
    else {
        pvVar1->share = pvVar1->share - 1;
    }
    return;
}



// DWARF original prototype: void ~vlong(vlong * this, int __in_chrg)

void __thiscall vlong::~vlong(vlong *this,int __in_chrg)

{
    vlong_value *pvVar1;
    uint *puVar2;
    uint i;
    uint uVar3;
    
    pvVar1 = this->value;
    this->_vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
    if (pvVar1->share == 0) {
        if (pvVar1 != (vlong_value *)0x0) {
            uVar3 = (pvVar1->super_vlong_flex_unit).z;
            while (uVar3 != 0) {
                uVar3 = uVar3 - 1;
                (pvVar1->super_vlong_flex_unit).a[uVar3] = 0;
            }
            puVar2 = (pvVar1->super_vlong_flex_unit).a;
            if (puVar2 != (uint *)0x0) {
                operator_delete__(puVar2);
            }
            operator_delete(pvVar1);
        }
    }
    else {
        pvVar1->share = pvVar1->share - 1;
    }
    return;
}



// DWARF original prototype: void ~vlong(vlong * this, int __in_chrg)

void __thiscall vlong::~vlong(vlong *this,int __in_chrg)

{
    vlong_value *pvVar1;
    uint *puVar2;
    uint i;
    uint uVar3;
    
    pvVar1 = this->value;
    this->_vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
    if (pvVar1->share == 0) {
        if (pvVar1 != (vlong_value *)0x0) {
            uVar3 = (pvVar1->super_vlong_flex_unit).z;
            while (uVar3 != 0) {
                uVar3 = uVar3 - 1;
                (pvVar1->super_vlong_flex_unit).a[uVar3] = 0;
            }
            puVar2 = (pvVar1->super_vlong_flex_unit).a;
            if (puVar2 != (uint *)0x0) {
                operator_delete__(puVar2);
            }
            operator_delete(pvVar1);
        }
    }
    else {
        pvVar1->share = pvVar1->share - 1;
    }
    operator_delete(this);
    return;
}



// DWARF original prototype: void docopy(vlong * this)

void __thiscall vlong::docopy(vlong *this)

{
    uint uVar1;
    vlong_value *this_00;
    EVP_PKEY_CTX *in_stack_ffffffec;
    
    uVar1 = this->value->share;
    if (uVar1 != 0) {
        this->value->share = uVar1 - 1;
        this_00 = (vlong_value *)operator_new(0x10);
        vlong_value::vlong_value(this_00);
        vlong_value::copy(this_00,(EVP_PKEY_CTX *)this->value,in_stack_ffffffec);
        this->value = this_00;
    }
    return;
}



// DWARF original prototype: int cf(vlong * this, vlong * x)

int __thiscall vlong::cf(vlong *this,vlong *x)

{
    int iVar1;
    int iVar2;
    
    iVar2 = 0;
    if ((this->negative != 0) && ((this->value->super_vlong_flex_unit).n != 0)) {
        iVar2 = 1;
    }
    iVar1 = 0;
    if ((x->negative != 0) && ((x->value->super_vlong_flex_unit).n != 0)) {
        iVar1 = 1;
    }
    if (iVar2 != iVar1) {
        return (uint)(iVar2 == 0) * 2 + -1;
    }
    iVar2 = vlong_value::cf(this->value,x->value);
    return iVar2;
}



// DWARF original prototype: vlong * operator=(vlong * this, vlong * x)

vlong * __thiscall vlong::operator=(vlong *this,vlong *x)

{
    vlong_value *pvVar1;
    uint *puVar2;
    uint i;
    uint uVar3;
    
    pvVar1 = this->value;
    if (pvVar1->share == 0) {
        if (pvVar1 != (vlong_value *)0x0) {
            uVar3 = (pvVar1->super_vlong_flex_unit).z;
            while (uVar3 != 0) {
                uVar3 = uVar3 - 1;
                (pvVar1->super_vlong_flex_unit).a[uVar3] = 0;
            }
            puVar2 = (pvVar1->super_vlong_flex_unit).a;
            if (puVar2 != (uint *)0x0) {
                operator_delete__(puVar2);
            }
            operator_delete(pvVar1);
        }
    }
    else {
        pvVar1->share = pvVar1->share - 1;
    }
    pvVar1 = x->value;
    this->value = pvVar1;
    puVar2 = &pvVar1->share;
    *puVar2 = *puVar2 + 1;
    this->negative = x->negative;
    return this;
}



// DWARF original name: operator unsigned int
// DWARF original prototype: uint operator_unsigned_int(vlong * this)

uint __thiscall vlong::operator_unsigned_int(vlong *this)

{
    uint uVar1;
    
    if ((this->value->super_vlong_flex_unit).n == 0) {
        uVar1 = 0;
    }
    else {
        uVar1 = *(this->value->super_vlong_flex_unit).a;
    }
    return uVar1;
}



// DWARF original prototype: vlong * operator+=(vlong * this, vlong * x)

vlong * __thiscall vlong::operator+=(vlong *this,vlong *x)

{
    int iVar1;
    vlong_value *pvVar2;
    vlong *x_00;
    EVP_PKEY_CTX *in_stack_ffffffcc;
    undefined1 local_2c [4];
    vlong tmp;
    
    if (this->negative == x->negative) {
        pvVar2 = this->value;
        if (pvVar2->share != 0) {
            pvVar2->share = pvVar2->share - 1;
            pvVar2 = (vlong_value *)operator_new(0x10);
            vlong_value::vlong_value(pvVar2);
            vlong_value::copy(pvVar2,(EVP_PKEY_CTX *)this->value,in_stack_ffffffcc);
            this->value = pvVar2;
        }
        vlong_value::add(pvVar2,x->value);
    }
    else {
        iVar1 = vlong_value::cf(this->value,x->value);
        if (iVar1 < 0) {
            local_2c = (undefined1  [4])&PTR__vlong_08128410;
            tmp.value = (vlong_value *)this->negative;
            tmp._vptr_vlong = (_func_int_varargs **)this->value;
            ((vlong_value *)tmp._vptr_vlong)->share = ((vlong_value *)tmp._vptr_vlong)->share + 1;
            operator=(this,x);
            x_00 = (vlong *)local_2c;
                    // try { // try from 080ecedc to 080ecee0 has its CatchHandler @ 080ecf40
            operator+=(this,x_00);
            ~vlong((vlong *)local_2c,(int)x_00);
        }
        else {
            pvVar2 = this->value;
            if (pvVar2->share != 0) {
                pvVar2->share = pvVar2->share - 1;
                pvVar2 = (vlong_value *)operator_new(0x10);
                vlong_value::vlong_value(pvVar2);
                vlong_value::copy(pvVar2,(EVP_PKEY_CTX *)this->value,in_stack_ffffffcc);
                this->value = pvVar2;
            }
            vlong_value::subtract(pvVar2,x->value);
        }
    }
    return this;
}



// DWARF original prototype: vlong * operator-=(vlong * this, vlong * x)

vlong * __thiscall vlong::operator-=(vlong *this,vlong *x)

{
    vlong_value *pvVar1;
    int iVar2;
    vlong *x_00;
    EVP_PKEY_CTX *in_stack_ffffffcc;
    undefined1 local_2c [4];
    vlong tmp;
    
    if (this->negative == x->negative) {
        iVar2 = vlong_value::cf(this->value,x->value);
        if (iVar2 < 0) {
            local_2c = (undefined1  [4])&PTR__vlong_08128410;
            tmp.value = (vlong_value *)this->negative;
            tmp._vptr_vlong = (_func_int_varargs **)this->value;
            ((vlong_value *)tmp._vptr_vlong)->share = ((vlong_value *)tmp._vptr_vlong)->share + 1;
            operator=(this,x);
            x_00 = (vlong *)local_2c;
                    // try { // try from 080ed062 to 080ed066 has its CatchHandler @ 080ed084
            operator-=(this,x_00);
            this->negative = 1 - this->negative;
            ~vlong((vlong *)local_2c,(int)x_00);
        }
        else {
            pvVar1 = this->value;
            if (pvVar1->share != 0) {
                pvVar1->share = pvVar1->share - 1;
                pvVar1 = (vlong_value *)operator_new(0x10);
                vlong_value::vlong_value(pvVar1);
                vlong_value::copy(pvVar1,(EVP_PKEY_CTX *)this->value,in_stack_ffffffcc);
                this->value = pvVar1;
            }
            vlong_value::subtract(pvVar1,x->value);
        }
    }
    else {
        pvVar1 = this->value;
        if (pvVar1->share != 0) {
            pvVar1->share = pvVar1->share - 1;
            pvVar1 = (vlong_value *)operator_new(0x10);
            vlong_value::vlong_value(pvVar1);
            vlong_value::copy(pvVar1,(EVP_PKEY_CTX *)this->value,in_stack_ffffffcc);
            this->value = pvVar1;
        }
        vlong_value::add(pvVar1,x->value);
    }
    return this;
}



vlong * operator+(vlong *x,vlong *y)

{
    uint *puVar1;
    int iVar2;
    vlong_value *pvVar3;
    vlong *result;
    vlong *in_stack_0000000c;
    
    iVar2 = y->negative;
    x->_vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
    x->negative = iVar2;
    pvVar3 = y->value;
    x->value = pvVar3;
    puVar1 = &pvVar3->share;
    *puVar1 = *puVar1 + 1;
                    // try { // try from 080ed0d1 to 080ed0d5 has its CatchHandler @ 080ed0e4
    vlong::operator+=(x,in_stack_0000000c);
    return x;
}



vlong * operator-(vlong *x,vlong *y)

{
    uint *puVar1;
    int iVar2;
    vlong_value *pvVar3;
    vlong *result;
    vlong *in_stack_0000000c;
    
    iVar2 = y->negative;
    x->_vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
    x->negative = iVar2;
    pvVar3 = y->value;
    x->value = pvVar3;
    puVar1 = &pvVar3->share;
    *puVar1 = *puVar1 + 1;
                    // try { // try from 080ed131 to 080ed135 has its CatchHandler @ 080ed144
    vlong::operator-=(x,in_stack_0000000c);
    return x;
}



vlong * operator*(vlong *x,vlong *y)

{
    vlong_value *this;
    vlong_value *this_00;
    vlong_value *pvVar1;
    uint uVar2;
    uint uVar3;
    vlong *result;
    int in_stack_0000000c;
    
    x->_vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
    pvVar1 = (vlong_value *)operator_new(0x10);
    vlong_value::vlong_value(pvVar1);
    x->negative = 0;
    x->value = pvVar1;
    (pvVar1->super_vlong_flex_unit).n = 0;
    vlong_flex_unit::set((vlong_flex_unit *)pvVar1,0,0);
    pvVar1 = x->value;
    this = y->value;
    this_00 = *(vlong_value **)(in_stack_0000000c + 4);
    uVar2 = vlong_value::bits(this);
    uVar3 = vlong_value::bits(this_00);
                    // try { // try from 080ed1ef to 080ed1f3 has its CatchHandler @ 080ed211
    vlong_flex_unit::fast_mul
              (&pvVar1->super_vlong_flex_unit,&this->super_vlong_flex_unit,
               &this_00->super_vlong_flex_unit,uVar3 + uVar2);
    x->negative = *(uint *)(in_stack_0000000c + 8) ^ y->negative;
    return x;
}



vlong * operator/(vlong *x,vlong *y)

{
    vlong_value *this;
    uint i;
    vlong *result;
    int in_stack_0000000c;
    undefined1 local_2c [4];
    vlong_value rem;
    
    x->_vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
    this = (vlong_value *)operator_new(0x10);
    vlong_value::vlong_value(this);
    x->negative = 0;
    x->value = this;
    (this->super_vlong_flex_unit).n = 0;
    vlong_flex_unit::set((vlong_flex_unit *)this,0,0);
    vlong_value::vlong_value((vlong_value *)local_2c);
                    // try { // try from 080ed2a9 to 080ed2ad has its CatchHandler @ 080ed300
    vlong_value::divide(x->value,y->value,*(vlong_value **)(in_stack_0000000c + 4),
                        (vlong_value *)local_2c);
    x->negative = *(uint *)(in_stack_0000000c + 8) ^ y->negative;
    while (rem.super_vlong_flex_unit.a != (uint *)0x0) {
        rem.super_vlong_flex_unit.a = (uint *)((int)rem.super_vlong_flex_unit.a + -1);
        *(undefined4 *)(rem.super_vlong_flex_unit.n + (int)rem.super_vlong_flex_unit.a * 4) = 0;
    }
    if (rem.super_vlong_flex_unit.n != 0) {
        operator_delete__((void *)rem.super_vlong_flex_unit.n);
    }
    return x;
}



vlong * operator%(vlong *x,vlong *y)

{
    vlong_value *this;
    uint i;
    vlong *result;
    int in_stack_0000000c;
    undefined1 local_2c [4];
    vlong_value divide;
    
    x->_vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
    this = (vlong_value *)operator_new(0x10);
    vlong_value::vlong_value(this);
    x->negative = 0;
    x->value = this;
    (this->super_vlong_flex_unit).n = 0;
    vlong_flex_unit::set((vlong_flex_unit *)this,0,0);
    vlong_value::vlong_value((vlong_value *)local_2c);
                    // try { // try from 080ed3b9 to 080ed3bd has its CatchHandler @ 080ed400
    vlong_value::divide((vlong_value *)local_2c,y->value,*(vlong_value **)(in_stack_0000000c + 4),
                        x->value);
    x->negative = y->negative;
    while (divide.super_vlong_flex_unit.a != (uint *)0x0) {
        divide.super_vlong_flex_unit.a = (uint *)((int)divide.super_vlong_flex_unit.a + -1);
        *(undefined4 *)(divide.super_vlong_flex_unit.n + (int)divide.super_vlong_flex_unit.a * 4) =
             0;
    }
    if (divide.super_vlong_flex_unit.n != 0) {
        operator_delete__((void *)divide.super_vlong_flex_unit.n);
    }
    return x;
}



vlong * vlong::modexp(vlong *__return_storage_ptr__)

{
    undefined4 in_stack_00000008;
    vlong *in_stack_00000010;
    vlong_montgomery *__in_chrg;
    undefined1 local_5c [4];
    vlong_montgomery me;
    
    vlong_montgomery::vlong_montgomery((vlong_montgomery *)local_5c,in_stack_00000010);
    __in_chrg = (vlong_montgomery *)local_5c;
                    // try { // try from 080ed472 to 080ed476 has its CatchHandler @ 080ed4c4
    vlong_montgomery::exp
              ((vlong_montgomery *)__return_storage_ptr__,
               (double)CONCAT44(in_stack_00000008,(vlong_montgomery *)local_5c));
    ~vlong((vlong *)&me.T.negative,(int)__in_chrg);
    ~vlong((vlong *)&me.n1.negative,(int)__in_chrg);
    ~vlong((vlong *)&me.m.negative,(int)__in_chrg);
    ~vlong((vlong *)&me.R1.negative,(int)__in_chrg);
    ~vlong((vlong *)&me.R.negative,(int)__in_chrg);
    ~vlong((vlong *)local_5c,(int)__in_chrg);
    return __return_storage_ptr__;
}



vlong * __thiscall vlong::gcd(vlong *this,vlong *X,vlong *Y)

{
    vlong_value *pvVar1;
    int iVar2;
    vlong *pvVar3;
    vlong local_4c;
    undefined1 local_3c [4];
    vlong y;
    undefined1 local_2c [4];
    vlong x;
    
    local_2c = (undefined1  [4])&PTR__vlong_08128410;
    x.value = (vlong_value *)X->negative;
    x._vptr_vlong = (_func_int_varargs **)X->value;
    ((vlong_value *)x._vptr_vlong)->share = ((vlong_value *)x._vptr_vlong)->share + 1;
    local_3c = (undefined1  [4])&PTR__vlong_08128410;
    y.value = (vlong_value *)Y->negative;
    y._vptr_vlong = (_func_int_varargs **)Y->value;
    ((vlong_value *)y._vptr_vlong)->share = ((vlong_value *)y._vptr_vlong)->share + 1;
    do {
        local_4c._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
                    // try { // try from 080ed55f to 080ed65f has its CatchHandler @ 080ed6c8
        pvVar1 = (vlong_value *)operator_new(0x10);
        vlong_value::vlong_value(pvVar1);
        local_4c.negative = 0;
        (pvVar1->super_vlong_flex_unit).n = 0;
        local_4c.value = pvVar1;
        vlong_flex_unit::set((vlong_flex_unit *)pvVar1,0,0);
        pvVar3 = &local_4c;
        iVar2 = cf((vlong *)local_3c,&local_4c);
        ~vlong(&local_4c,(int)pvVar3);
        if (iVar2 == 0) {
            this->_vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
            this->negative = (int)x.value;
            pvVar1 = (vlong_value *)x._vptr_vlong;
LAB_080ed68e:
            this->value = pvVar1;
            pvVar1->share = pvVar1->share + 1;
            ~vlong((vlong *)local_3c,(int)pvVar3);
            ~vlong((vlong *)local_2c,(int)pvVar3);
            return this;
        }
        operator%(&local_4c,(vlong *)local_2c);
        pvVar3 = &local_4c;
        operator=((vlong *)local_2c,&local_4c);
        ~vlong(&local_4c,(int)pvVar3);
        local_4c._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
        pvVar1 = (vlong_value *)operator_new(0x10);
        vlong_value::vlong_value(pvVar1);
        local_4c.negative = 0;
        (pvVar1->super_vlong_flex_unit).n = 0;
        local_4c.value = pvVar1;
        vlong_flex_unit::set((vlong_flex_unit *)pvVar1,0,0);
        pvVar3 = &local_4c;
        iVar2 = cf((vlong *)local_2c,&local_4c);
        ~vlong(&local_4c,(int)pvVar3);
        if (iVar2 == 0) {
            this->_vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
            this->negative = (int)y.value;
            pvVar1 = (vlong_value *)y._vptr_vlong;
            goto LAB_080ed68e;
        }
        operator%(&local_4c,(vlong *)local_3c);
        pvVar3 = &local_4c;
        operator=((vlong *)local_3c,&local_4c);
        ~vlong(&local_4c,(int)pvVar3);
    } while( true );
}



vlong * __thiscall vlong::modinv(vlong *this,vlong *a,vlong *m)

{
    vlong_value *pvVar1;
    int iVar2;
    vlong *i;
    vlong *pvVar3;
    undefined1 local_8c [4];
    vlong result_1;
    undefined1 local_7c [4];
    vlong result;
    undefined1 local_6c [4];
    vlong y;
    undefined1 local_5c [4];
    vlong x;
    undefined1 local_4c [4];
    vlong c;
    undefined1 local_3c [4];
    vlong b;
    undefined1 local_2c [4];
    vlong j;
    
    local_2c = (undefined1  [4])&PTR__vlong_08128410;
    pvVar1 = (vlong_value *)operator_new(0x10);
    vlong_value::vlong_value(pvVar1);
    j.value = (vlong_value *)0x0;
    (pvVar1->super_vlong_flex_unit).n = 0;
    j._vptr_vlong = (_func_int_varargs **)pvVar1;
    vlong_flex_unit::set((vlong_flex_unit *)pvVar1,0,1);
    this->_vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
                    // try { // try from 080ed754 to 080ed78a has its CatchHandler @ 080edb77
    pvVar1 = (vlong_value *)operator_new(0x10);
    vlong_value::vlong_value(pvVar1);
    this->negative = 0;
    this->value = pvVar1;
    (pvVar1->super_vlong_flex_unit).n = 0;
    vlong_flex_unit::set((vlong_flex_unit *)pvVar1,0,0);
    local_3c = (undefined1  [4])&PTR__vlong_08128410;
    b.value = (vlong_value *)m->negative;
    b._vptr_vlong = (_func_int_varargs **)m->value;
    ((vlong_value *)b._vptr_vlong)->share = ((vlong_value *)b._vptr_vlong)->share + 1;
    local_4c = (undefined1  [4])&PTR__vlong_08128410;
    c.value = (vlong_value *)a->negative;
    c._vptr_vlong = (_func_int_varargs **)a->value;
    ((vlong_value *)c._vptr_vlong)->share = ((vlong_value *)c._vptr_vlong)->share + 1;
    local_5c = (undefined1  [4])&PTR__vlong_08128410;
                    // try { // try from 080ed7c8 to 080ed7fe has its CatchHandler @ 080edb70
    pvVar1 = (vlong_value *)operator_new(0x10);
    vlong_value::vlong_value(pvVar1);
    x.value = (vlong_value *)0x0;
    (pvVar1->super_vlong_flex_unit).n = 0;
    x._vptr_vlong = (_func_int_varargs **)pvVar1;
    vlong_flex_unit::set((vlong_flex_unit *)pvVar1,0,0);
    local_6c = (undefined1  [4])&PTR__vlong_08128410;
                    // try { // try from 080ed80d to 080ed843 has its CatchHandler @ 080edb64
    pvVar1 = (vlong_value *)operator_new(0x10);
    vlong_value::vlong_value(pvVar1);
    y.value = (vlong_value *)0x0;
    (pvVar1->super_vlong_flex_unit).n = 0;
    y._vptr_vlong = (_func_int_varargs **)pvVar1;
    vlong_flex_unit::set((vlong_flex_unit *)pvVar1,0,0);
    while( true ) {
        local_7c = (undefined1  [4])&PTR__vlong_08128410;
                    // try { // try from 080ed855 to 080ed90c has its CatchHandler @ 080edb60
        pvVar1 = (vlong_value *)operator_new(0x10);
        vlong_value::vlong_value(pvVar1);
        result.value = (vlong_value *)0x0;
        (pvVar1->super_vlong_flex_unit).n = 0;
        result._vptr_vlong = (_func_int_varargs **)pvVar1;
        vlong_flex_unit::set((vlong_flex_unit *)pvVar1,0,0);
        pvVar3 = (vlong *)local_7c;
        iVar2 = cf((vlong *)local_4c,pvVar3);
        ~vlong((vlong *)local_7c,(int)pvVar3);
        if (iVar2 == 0) break;
        operator/((vlong *)local_7c,(vlong *)local_3c);
        pvVar3 = (vlong *)local_7c;
        operator=((vlong *)local_5c,pvVar3);
        ~vlong((vlong *)local_7c,(int)pvVar3);
        operator*((vlong *)local_8c,(vlong *)local_5c);
        local_7c = (undefined1  [4])&PTR__vlong_08128410;
        result.value = b.value;
        result._vptr_vlong = b._vptr_vlong;
        b._vptr_vlong[3] = b._vptr_vlong[3] + 1;
                    // try { // try from 080ed936 to 080ed93a has its CatchHandler @ 080edaf0
        operator-=((vlong *)local_7c,(vlong *)local_8c);
        pvVar3 = (vlong *)local_7c;
        operator=((vlong *)local_6c,pvVar3);
        ~vlong((vlong *)local_7c,(int)pvVar3);
        ~vlong((vlong *)local_8c,(int)pvVar3);
        operator=((vlong *)local_3c,(vlong *)local_4c);
        operator=((vlong *)local_4c,(vlong *)local_6c);
        operator=((vlong *)local_6c,(vlong *)local_2c);
                    // try { // try from 080ed9aa to 080ed9ae has its CatchHandler @ 080edb60
        operator*((vlong *)local_7c,(vlong *)local_2c);
        local_8c = (undefined1  [4])&PTR__vlong_08128410;
        result_1.value = (vlong_value *)this->negative;
        result_1._vptr_vlong = (_func_int_varargs **)this->value;
        ((vlong_value *)result_1._vptr_vlong)->share =
             ((vlong_value *)result_1._vptr_vlong)->share + 1;
                    // try { // try from 080ed9df to 080ed9e3 has its CatchHandler @ 080edb41
        operator-=((vlong *)local_8c,(vlong *)local_7c);
        pvVar3 = (vlong *)local_8c;
        operator=((vlong *)local_2c,pvVar3);
        ~vlong((vlong *)local_8c,(int)pvVar3);
        ~vlong((vlong *)local_7c,(int)pvVar3);
        operator=(this,(vlong *)local_6c);
    }
    local_8c = (undefined1  [4])&PTR__vlong_08128410;
                    // try { // try from 080eda35 to 080edae6 has its CatchHandler @ 080edb60
    pvVar1 = (vlong_value *)operator_new(0x10);
    vlong_value::vlong_value(pvVar1);
    result_1.value = (vlong_value *)0x0;
    (pvVar1->super_vlong_flex_unit).n = 0;
    result_1._vptr_vlong = (_func_int_varargs **)pvVar1;
    vlong_flex_unit::set((vlong_flex_unit *)pvVar1,0,0);
    pvVar3 = (vlong *)local_8c;
    iVar2 = cf(this,pvVar3);
    ~vlong((vlong *)local_8c,(int)pvVar3);
    if (iVar2 < 0) {
        operator+=(this,m);
        pvVar3 = m;
    }
    ~vlong((vlong *)local_6c,(int)pvVar3);
    ~vlong((vlong *)local_5c,(int)pvVar3);
    ~vlong((vlong *)local_4c,(int)pvVar3);
    ~vlong((vlong *)local_3c,(int)pvVar3);
    ~vlong((vlong *)local_2c,(int)pvVar3);
    return this;
}



void vlong::convert(char *pDecimal,vlong *Number)

{
    char cVar1;
    ushort uVar2;
    vlong_value *pvVar3;
    uint x;
    undefined4 *puVar4;
    vlong *pvVar5;
    undefined2 local_4e;
    undefined1 auStack_4c [2];
    char Buffer [2];
    vlong local_3c;
    undefined1 local_2c [4];
    vlong result;
    
    if (pDecimal == (char *)0x0) {
        puVar4 = (undefined4 *)__cxa_allocate_exception(4);
        *puVar4 = "pDecimal pointer is NULL";
    }
    else {
        local_2c = (undefined1  [4])&PTR__vlong_08128410;
        local_4e = 0x100;
        pvVar3 = (vlong_value *)operator_new(0x10);
        vlong_value::vlong_value(pvVar3);
        result.value = (vlong_value *)0x0;
        (pvVar3->super_vlong_flex_unit).n = 0;
        result._vptr_vlong = (_func_int_varargs **)pvVar3;
        vlong_flex_unit::set((vlong_flex_unit *)pvVar3,0,0);
        pvVar5 = (vlong *)local_2c;
        operator=(Number,(vlong *)local_2c);
        ~vlong((vlong *)local_2c,(int)pvVar5);
        cVar1 = *pDecimal;
        while( true ) {
            if (cVar1 == '\0') {
                return;
            }
            uVar2 = (ushort)local_4e >> 8;
            local_4e = CONCAT11((char)uVar2,cVar1);
            x = __strtol_internal(&local_4e,0,10,0);
            if (9 < x) break;
            _auStack_4c = &PTR__vlong_08128410;
            pvVar3 = (vlong_value *)operator_new(0x10);
            vlong_value::vlong_value(pvVar3);
            (pvVar3->super_vlong_flex_unit).n = 0;
            vlong_flex_unit::set((vlong_flex_unit *)pvVar3,0,10);
            pvVar5 = Number;
                    // try { // try from 080edcae to 080edcb2 has its CatchHandler @ 080edda6
            operator*(&local_3c,Number);
            ~vlong((vlong *)auStack_4c,(int)pvVar5);
            _auStack_4c = &PTR__vlong_08128410;
                    // try { // try from 080edccf to 080edd04 has its CatchHandler @ 080edde3
            pvVar3 = (vlong_value *)operator_new(0x10);
            vlong_value::vlong_value(pvVar3);
            (pvVar3->super_vlong_flex_unit).n = 0;
            vlong_flex_unit::set((vlong_flex_unit *)pvVar3,0,x);
            local_2c = (undefined1  [4])&PTR__vlong_08128410;
            pvVar5 = (vlong *)auStack_4c;
            result.value = (vlong_value *)local_3c.negative;
            result._vptr_vlong = (_func_int_varargs **)local_3c.value;
            (local_3c.value)->share = (local_3c.value)->share + 1;
                    // try { // try from 080edd25 to 080edd29 has its CatchHandler @ 080eddad
            operator+=((vlong *)local_2c,pvVar5);
            pDecimal = pDecimal + 1;
            ~vlong((vlong *)auStack_4c,(int)pvVar5);
            pvVar5 = (vlong *)local_2c;
            operator=(Number,(vlong *)local_2c);
            ~vlong((vlong *)local_2c,(int)pvVar5);
            ~vlong(&local_3c,(int)pvVar5);
            cVar1 = *pDecimal;
        }
        puVar4 = (undefined4 *)__cxa_allocate_exception(4);
        *puVar4 = "digit out of range";
    }
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar4,char_const*::typeinfo,0);
}



void vlong::convert(vlong *Number,char *pDecimal,ushort DecimalLength)

{
    char cVar1;
    vlong_value *pvVar2;
    int iVar3;
    undefined4 *puVar4;
    vlong *pvVar5;
    uint local_48;
    int local_44;
    int i;
    undefined1 auStack_3c [2];
    char Buffer [2];
    vlong local_2c [2];
    
    if (pDecimal == (char *)0x0) {
        puVar4 = (undefined4 *)__cxa_allocate_exception(4);
        *puVar4 = "pDecimal pointer is NULL";
    }
    else {
        if (DecimalLength != 0) {
            memset(pDecimal,0,(uint)DecimalLength);
            local_2c[0]._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
            pvVar2 = (vlong_value *)operator_new(0x10);
            vlong_value::vlong_value(pvVar2);
            local_2c[0].negative = 0;
            (pvVar2->super_vlong_flex_unit).n = 0;
            local_2c[0].value = pvVar2;
            vlong_flex_unit::set((vlong_flex_unit *)pvVar2,0,0);
            pvVar5 = local_2c;
            iVar3 = cf(Number,local_2c);
            ~vlong(local_2c,(int)pvVar5);
            if (iVar3 == 0) {
                *pDecimal = '0';
            }
            else {
                local_44 = 0;
                i._2_2_ = 0x100;
                while( true ) {
                    local_2c[0]._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
                    pvVar2 = (vlong_value *)operator_new(0x10);
                    vlong_value::vlong_value(pvVar2);
                    local_2c[0].negative = 0;
                    (pvVar2->super_vlong_flex_unit).n = 0;
                    local_2c[0].value = pvVar2;
                    vlong_flex_unit::set((vlong_flex_unit *)pvVar2,0,0);
                    pvVar5 = local_2c;
                    iVar3 = cf(Number,local_2c);
                    ~vlong(local_2c,(int)pvVar5);
                    if (iVar3 < 1) break;
                    if ((int)(uint)DecimalLength <= local_44) {
                        puVar4 = (undefined4 *)__cxa_allocate_exception(4);
                        *puVar4 = 
                        "large number does not fit in char array (DecimalLength too small)";
                        goto LAB_080ee083;
                    }
                    _auStack_3c = &PTR__vlong_08128410;
                    pvVar2 = (vlong_value *)operator_new(0x10);
                    vlong_value::vlong_value(pvVar2);
                    (pvVar2->super_vlong_flex_unit).n = 0;
                    vlong_flex_unit::set((vlong_flex_unit *)pvVar2,0,10);
                    pvVar5 = Number;
                    // try { // try from 080edf82 to 080edf86 has its CatchHandler @ 080ee0f0
                    operator%(local_2c,Number);
                    ~vlong((vlong *)auStack_3c,(int)pvVar5);
                    if (((local_2c[0].value)->super_vlong_flex_unit).n == 0) {
                        local_48 = 0;
                    }
                    else {
                        local_48 = *((local_2c[0].value)->super_vlong_flex_unit).a;
                    }
                    ~vlong(local_2c,(int)pvVar5);
                    local_2c[0]._vptr_vlong = (_func_int_varargs **)&PTR__vlong_08128410;
                    pvVar2 = (vlong_value *)operator_new(0x10);
                    vlong_value::vlong_value(pvVar2);
                    local_2c[0].negative = 0;
                    (pvVar2->super_vlong_flex_unit).n = 0;
                    local_2c[0].value = pvVar2;
                    vlong_flex_unit::set((vlong_flex_unit *)pvVar2,0,10);
                    pvVar5 = Number;
                    // try { // try from 080ee007 to 080ee00b has its CatchHandler @ 080ee100
                    operator/((vlong *)auStack_3c,Number);
                    ~vlong(local_2c,(int)pvVar5);
                    pvVar5 = (vlong *)auStack_3c;
                    operator=(Number,pvVar5);
                    ~vlong((vlong *)auStack_3c,(int)pvVar5);
                    sprintf((char *)((int)&i + 2),"%d",local_48);
                    pDecimal[local_44] = i._2_1_;
                    local_44 = local_44 + 1;
                }
                local_44 = local_44 + -1;
                while (0 < local_44) {
                    cVar1 = *pDecimal;
                    *pDecimal = pDecimal[local_44];
                    pDecimal[local_44] = cVar1;
                }
            }
            return;
        }
        puVar4 = (undefined4 *)__cxa_allocate_exception(4);
        *puVar4 = "DecimalLength = 0";
    }
LAB_080ee083:
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar4,char_const*::typeinfo,0);
}



void vlong::convert(uchar *pData,ushort DataLength,vlong *Number)

{
    undefined4 *puVar1;
    byte bVar2;
    int j;
    uint uVar3;
    int iVar4;
    int i;
    int iVar5;
    uint x;
    uint x_00;
    ushort DataLength_local;
    
    uVar3 = (uint)DataLength;
    if (pData == (uchar *)0x0) {
        puVar1 = (undefined4 *)__cxa_allocate_exception(4);
        *puVar1 = "pData pointer is NULL";
                    // WARNING: Subroutine does not return
        __cxa_throw(puVar1,char_const*::typeinfo,0);
    }
    iVar5 = 0;
    (Number->value->super_vlong_flex_unit).n = 0;
    if (uVar3 != 0) {
        do {
            x_00 = 0;
            iVar4 = 0;
            bVar2 = 0x18;
            do {
                if (iVar4 + iVar5 < (int)uVar3) {
                    x_00 = x_00 + ((uint)pData[iVar4 + iVar5] << (bVar2 & 0x1f));
                }
                iVar4 = iVar4 + 1;
                bVar2 = bVar2 - 8;
            } while (iVar4 < 4);
            iVar4 = iVar5 + 4;
            vlong_flex_unit::set
                      (&Number->value->super_vlong_flex_unit,((uVar3 + 3) / 4 - iVar5 / 4) - 1,x_00)
            ;
            iVar5 = iVar4;
        } while (iVar4 < (int)uVar3);
    }
    return;
}



void vlong::convert(vlong *Number,uchar *pData,ushort DataLength)

{
    undefined4 *puVar1;
    byte bVar2;
    uint __n;
    uint uVar3;
    int j;
    int iVar4;
    int i;
    int iVar5;
    ushort DataLength_local;
    uint local_1c;
    
    __n = (uint)DataLength;
    if (pData != (uchar *)0x0) {
        memset(pData,0,__n);
        if (__n != 0) {
            iVar5 = 0;
            do {
                uVar3 = ((__n + 3) / 4 - iVar5 / 4) - 1;
                if (uVar3 < (Number->value->super_vlong_flex_unit).n) {
                    local_1c = (Number->value->super_vlong_flex_unit).a[uVar3];
                }
                else {
                    local_1c = 0;
                }
                iVar4 = 0;
                bVar2 = 0x18;
                do {
                    if (iVar4 + iVar5 < (int)__n) {
                        pData[iVar4 + iVar5] = (uchar)(local_1c >> (bVar2 & 0x1f));
                    }
                    iVar4 = iVar4 + 1;
                    bVar2 = bVar2 - 8;
                } while (iVar4 < 4);
                iVar5 = iVar5 + 4;
            } while (iVar5 < (int)__n);
        }
        return;
    }
    puVar1 = (undefined4 *)__cxa_allocate_exception(4);
    *puVar1 = "pData pointer is NULL";
                    // WARNING: Subroutine does not return
    __cxa_throw(puVar1,char_const*::typeinfo,0);
}



// WARNING: Removing unreachable block (ram,0x080ee309)
// WARNING: Removing unreachable block (ram,0x080ee30c)

void __libc_csu_init(void)

{
    _init();
    return;
}



// WARNING: Removing unreachable block (ram,0x080ee340)
// WARNING: Removing unreachable block (ram,0x080ee34e)

void __libc_csu_fini(void)

{
    _fini();
    return;
}



int atexit(__func *__func)

{
    int iVar1;
    
    iVar1 = __cxa_atexit(__func,0,__dso_handle);
    return iVar1;
}



undefined4 __do_global_ctors_aux(void)

{
    code *pcVar1;
    undefined4 in_EDX;
    undefined **ppuVar2;
    
    ppuVar2 = &PTR__GLOBAL__I__ZN14TRSAPrivateKeyC2Ev_0812856c;
    pcVar1 = (code *)PTR__GLOBAL__I__ZN14TRSAPrivateKeyC2Ev_0812856c;
    if (PTR__GLOBAL__I__ZN14TRSAPrivateKeyC2Ev_0812856c != (undefined *)0xffffffff) {
        do {
            ppuVar2 = ppuVar2 + -1;
            (*pcVar1)();
            pcVar1 = (code *)*ppuVar2;
        } while (pcVar1 != (code *)0xffffffff);
    }
    return in_EDX;
}



void _fini(void)

{
    __do_global_dtors_aux();
    return;
}

